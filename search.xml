<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>深入解析单例模式的七种实现</title>
    <url>/2020/10/18/10%E3%80%81%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%83%E7%A7%8D%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="深入解析单例模式的七种实现"><a href="#深入解析单例模式的七种实现" class="headerlink" title="深入解析单例模式的七种实现"></a>深入解析单例模式的七种实现</h1><h3 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h3><p>什么是单例模式呢？ 我们引用一下维基百科：</p>
<blockquote>
<p><strong>单例模式</strong>，也叫<strong>单子模式</strong>，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。还有就是我们经常使用的servlet就是单例多线程的。使用单例能够节省很多内存。</p>
</blockquote>
<h3 id="如何实现单例模式呢？"><a href="#如何实现单例模式呢？" class="headerlink" title="如何实现单例模式呢？"></a>如何实现单例模式呢？</h3><p>我们引用一下维基百科：</p>
<blockquote>
<p>实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。</p>
</blockquote>
<p>好了，我们知道了单例模式的定义和如何使用单例的描述，接下来，就引用Linux Torvalds 的话：</p>
<blockquote>
<p>Talk is cheap. Show me the code</p>
</blockquote>
<p>让我们来看看单例模式的7种实现方式</p>
<h3 id="单例模式的七种实现"><a href="#单例模式的七种实现" class="headerlink" title="单例模式的七种实现"></a>单例模式的七种实现</h3><h4 id="第一种：懒汉式加载"><a href="#第一种：懒汉式加载" class="headerlink" title="第一种：懒汉式加载"></a>第一种：懒汉式加载</h4><blockquote>
<p>懒汉式加载：最简单的单例模式：2步，1.把自己的构造方法设置为私有的，不让别人访问你的实例，2.提供一个static方法给别人获取你的实例.</p>
</blockquote>
<p><img src="http://cdn.tuwenbin.vip/20201019010059.png" alt="img"></p>
<p>懒汉式加载版本单例模式</p>
<p>我们可以看到，这是一个简单的获取单例的一个类，首先我们定义一个静态实例 single,  如何将构造方法变成私有的。并且给外界一个静态获取实例的方法。如果对象不是null，就直接返回实例，从而保证实例。也可以保证不浪费内存。这是我们的第一个实现单例模式的例子。很简单。但是有问题，我们后面再讲。</p>
<h4 id="第二种：饿汉式加载"><a href="#第二种：饿汉式加载" class="headerlink" title="第二种：饿汉式加载"></a>第二种：饿汉式加载</h4><p><img src="http://cdn.tuwenbin.vip/20201019010102.png" alt="img"></p>
<p>饿汉式加载版本单例模式</p>
<p>我们看到第二种单例模式，代码量比第一个少了很多，而为什么叫饿汉式呢？我们看代码，我们定义了一个静态的final的实例，并且直接new了一个对象，这样就会导致Single2  类在加载字节码到虚拟机的时候就会实例化这个实例，当你调用getInstance方法的时候，就会直接返回，不必做任何判断，这样做的好处是代码量明显减少了，坏处是，在你没有使用该单例的时候，该单例却被加载了，如果该单例很大的话，将会浪费很多的内存。</p>
<h4 id="我们停下来思考一下"><a href="#我们停下来思考一下" class="headerlink" title="我们停下来思考一下"></a>我们停下来思考一下</h4><blockquote>
<p>我们如何选择这两种实现方式呢？如果你的项目对性能没有要求，那么请直接使用饿汉式方法实现单例模式，既简单又方便。但是，大部分程序员都是有追求的，岂能不追求性能。那么我们看第一种方式，就是懒汉式，我们刚刚说过，懒汉式既保证了单例，又保证了性能。但是，他真的能保证单例吗？可以确定的是：在单线程模式下，毫无问题，但在复杂的多线程模式下，会怎么样呢？show me code .</p>
</blockquote>
<h4 id="测试用例：我们测试一下-测试用例"><a href="#测试用例：我们测试一下-测试用例" class="headerlink" title="测试用例：我们测试一下   测试用例"></a>测试用例：我们测试一下  <img src="http://cdn.tuwenbin.vip/20201019010106.png" alt="img"> 测试用例</h4><p>我们分析一下上面的代码，首先，我们验证的是什么呢？我们想验证多线程下获取懒汉式单例会不会出现错误。也就是出现一个以上的单例，我们如何做呢？首先我们定义一个Set对实例进行去重，然后创建1000个线程（Windows每个进程最多1000个线程，Linux每个进程最多2000个线程），每个线程都去获取实例，并添加到set中，实际上，我们应该使用Collections.synchronizedSet(set)获取一个线程安全的set，但是，这里为了方便，就直接使用HashSet了，然后main线程等待10秒，让1000个线程尽量都执行完毕。最后循环打印set的内容。在某些情况下，会出现2个实例，注意，是某些情况下，一定要多测试几次。下面是我们测试的结果：</p>
<p><img src="http://cdn.tuwenbin.vip/20201019010109.png" alt="img"></p>
<p>测试结果</p>
<h4 id="我们停下来思考一下："><a href="#我们停下来思考一下：" class="headerlink" title="我们停下来思考一下："></a>我们停下来思考一下：</h4><blockquote>
<p>我们通过测试用例发现：高并发情况下，我们的懒加载确实存在bug。为什么会这样呢？我们假设第一个线程进入getInstance方法，判断实例为null，准备进入if块内执行实例化，这时线程突然让出时间片，第二个线程也进入方法，判断实例也为null，并且进入if块执行实例化，第一个线程唤醒也进入if块进行实例化。这时就会出现2个实例。所以出现了bug。So,  我们想要性能（避免上面说的消耗不需要的内存），又要线程安全。那我们该怎么办呢？有点经验的同学心里肯定有数了。show me code.</p>
</blockquote>
<h4 id="第三种方式：synchronized-同步式"><a href="#第三种方式：synchronized-同步式" class="headerlink" title="第三种方式：synchronized 同步式"></a>第三种方式：synchronized 同步式</h4><p><img src="http://cdn.tuwenbin.vip/20201019010112.png" alt="img"></p>
<p>59{(V}0%M<code>G546FRI</code>F4(_9.png</p>
<p>这是我们的第三种方式，我们分析一下代码，我们可以看到，我们仅仅是在第一种懒汉式中加入了一个关键字，synchronized,  使用synchronized保证线程同步，保证同时只有一个进程进入此方法。从而保证并发安全。但是这样做完美吗？我们思考一下我们的代码：我们使用synchronized关键字，相当于每个想要进入该方法的获取实例的线程都要阻塞排队，我们仔细思考一下：需要吗？当实例已经初始化之后，我们还需要做同步控制吗？这对性能的影响是巨大的。是的，我们只需要在实例第一次初始化的时候同步就足够了。我们继续优化。</p>
<h4 id="第四种方式：双重检验锁："><a href="#第四种方式：双重检验锁：" class="headerlink" title="第四种方式：双重检验锁："></a>第四种方式：双重检验锁：</h4><p><img src="http://cdn.tuwenbin.vip/20201019010115.png" alt="img"></p>
<p>双重检验锁</p>
<p>我们继续分析一下代码：首先看getInstance方法，我们在方法声明上去除了synchronized关键字，多线程进入方法内部，判断是否为null，如果为null，多个线程同时进入if块内，此时，我们是用Single4  Class对象同步一段方法。保证只有一个线程进入该方法。并且判断是否为null，如果为null，就进行初始化。我们想象一下，如果第一个线程进入进入同步块，发现该实例为null，于是进入if块实例化，第二个线程进入同步内则发现实例已经不是null，直接就返回  了，从而保证了并发安全。那么这个和第三种方式又什么区别呢？第三种方式的缺陷是：每个线程每次进入该方法都需要被同步，成本巨大。而第四种方式呢？每个线程最多只有在第一次的时候才会进入同步块，也就是说，只要实例被初始化了，那么之后进入该方法的线程就不必进入同步块了。就解决并发下线程安全和性能的平衡。虽然第一次还是会被阻塞。但相比较于第三种，已经好多了。</p>
<p>我们还对一个东西感兴趣，就是修饰变量的volatile关键字，为什么要用volatile关键字呢？这是个有趣的问题。我们好好分析一下：<br> 首先我们看，Java虚拟机初始化一个对象都干了些什么？总的来说，3件事情：</p>
<ol>
<li>在堆空间分配内存</li>
<li>执行构造方法进行初始化</li>
<li>将对象指向内存中分配的内存空间，也就是地址</li>
</ol>
<p>但是由于当我们编译的时候，编译器在生成汇编代码的时候会对流程进行优化（这里涉及到happen-before原则和Java内存模型和CPU流水线执行的知识，就不展开讲了），优化的结果式有可能式123顺序执行，也有可能式132执行，但是，如果是按照132的顺序执行，走到第三步（还没到第二步）的时候，这时突然另一个线程来访问，走到if(single4 ==  null)块，会发现single4已经不是null了，就直接返回了，但是此时对象还没有完成初始化，如果另一个线程对实例的某些需要初始化的参数进行操作，就有可能报错。使用volatile关键字，能够告诉编译器不要对代码进行重排序的优化。就不会出现这种问题了。</p>
<p>我们看到，小小的单例模式被我们弄得很复杂。但这就是一个程序员的追求，追求最好的性能，追求最好的代码。</p>
<p>那还有没有别的更好的办法呢？这个代码也太多了，代码可读性也不好。而且线程第一次进入还会阻塞，还能更完美吗？</p>
<h4 id="第五种方式：既要懒汉式加载，又要线程安全：静态内部类。"><a href="#第五种方式：既要懒汉式加载，又要线程安全：静态内部类。" class="headerlink" title="第五种方式：既要懒汉式加载，又要线程安全：静态内部类。"></a>第五种方式：既要懒汉式加载，又要线程安全：静态内部类。</h4><p><img src="http://cdn.tuwenbin.vip/20201019010118.png" alt="img"></p>
<p>我们来分析一下代码：相比较饿汉式（也就是第二种），我们增加了一个内部类，内部类中有一个外部类的实例，并且已经初始化了。我们回忆一下饿汉式有什么问题，饿汉式的问题是：<strong>在你没有使用该单例的时候，该单例却被加载了，如果该单例很大的话，将会浪费很多的内存</strong>.但是，我们现在引入了内部类的方式，虚拟机的机制是，如果你没有访问一个类，那么是不会载入该类进入虚拟机的。当我们使用外部类的时候其他属性的时候，是不会浪费内存载入内部类中的单例的。从而也就保证了并发安全和防止内存浪费。<br> 但是，这样就能完美了吗？</p>
<h4 id="第六种方式：反射和反序列化破坏单例"><a href="#第六种方式：反射和反序列化破坏单例" class="headerlink" title="第六种方式：反射和反序列化破坏单例"></a>第六种方式：反射和反序列化破坏单例</h4><p><img src="http://cdn.tuwenbin.vip/20201019010122.png" alt="img"></p>
<p>我们知道Java的反射几乎是什么事情都能做，管你什么私有的公有的。都能破坏。我们是没有还手之力的。精心编写的代码就被破坏了，而反序列化也很厉害，但是稍微还有点办法遏制。什么办法呢？重写readResolve方法。show me code。</p>
<p><img src="http://cdn.tuwenbin.vip/20201019010126.png" alt="img"></p>
<p>我们看到：我们重写了readResolve方法，在该方法中直接返回了我们的内部类实例。重写readResolve()  方法，防止反序列化破坏单例机制，这是因为：反序列化的机制在反序列化的时候，会判断如果实现了serializable或者externalizable接口的类中包含readResolve方法的话，会直接调用readResolve方法来获取实例。这样我们就制止了反序列化破坏我们的单例模式。那反射呢？我们有办法吗？</p>
<h4 id="第七种方式：最后一招，使用枚举"><a href="#第七种方式：最后一招，使用枚举" class="headerlink" title="第七种方式：最后一招，使用枚举"></a>第七种方式：最后一招，使用枚举</h4><p><img src="http://cdn.tuwenbin.vip/20201019010128.png" alt="img"></p>
<p>为什么使用枚举可以呢？枚举类型反编译之后可以看到实际上是一个继承自Enum的类。所以本质还是一个类。 因为枚举的特点，你只会有一个实例。我们看一下反编译的枚举类。</p>
<p><img src="http://cdn.tuwenbin.vip/20201019010130.png" alt="img"></p>
<p>反编译的class字节码</p>
<p>我们看到，我们的hello包下的Single7枚举继承了java.lang.Enum&lt;&gt; 类。事实上就是一个类，但是我们这样就能防止反射破坏我们辛苦写的单例模式了。因为枚举的特点，而他也能保证单例。堪称完美！！！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>回到开始，我们引用了一些维基百科的话，我们再看看维基百科关于并发是怎么说的：</p>
<blockquote>
<p>单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率).</p>
</blockquote>
<p>我们看到维基百科还是靠谱的。告诉了我们可以使用互斥锁来防止并发出现的问题。</p>
<p>而单例模式带来了什么好处呢？</p>
<ol>
<li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li>
<li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>线程创建的三种方式及区别</title>
    <url>/2019/02/12/1%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="线程创建的三种方式及区别"><a href="#线程创建的三种方式及区别" class="headerlink" title="线程创建的三种方式及区别"></a><strong>线程创建的三种方式及区别</strong></h1><h2 id="创建方式"><a href="#创建方式" class="headerlink" title="**创建方式      **"></a>**创建方式      **</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类　"></a><strong>继承Thread类</strong>　</h3><p>（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。　　</p>
<p>（2）创建Thread子类的实例，即创建了线程对象。　　</p>
<p>（3）调用线程对象的start()方法来启动该线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Thread;<br><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread</span> </span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        testExtends();<br>    &#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testExtends</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    Thread t1 = <span class="hljs-keyword">new</span> MyThreadExtends();<br>    Thread t2 = <span class="hljs-keyword">new</span> MyThreadExtends();<br>    t1.start();t2.start();<br>&#125;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreadExtends</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-meta">@Overridepublic</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;通过继承Thread，线程号:&quot;</span> + currentThread().getName());<br>    &#125;&#125;<br></code></pre></td></tr></table></figure>



<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口　"></a><strong>实现Runnable接口</strong>　</h3><p>（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 （2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 （3）调用线程对象的start()方法来启动该线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Thread;<br><span class="hljs-keyword">import</span> java.util.concurrent.*;<span class="hljs-comment">//测试类public class TestThread &#123;public static void main(String[] args) </span><br><span class="hljs-keyword">throws</span> Exception &#123;<br>testImplents();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testImplents</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    MyThreadImplements myThreadImplements = <span class="hljs-keyword">new</span> MyThreadImplements();<br>    Thread t1 = <span class="hljs-keyword">new</span> Thread(myThreadImplements);<br>    Thread t2 = <span class="hljs-keyword">new</span> Thread(myThreadImplements, <span class="hljs-string">&quot;my thread -2&quot;</span>);<br>    t1.start();t2.start();<br>&#125;&#125;<span class="hljs-comment">//线程类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreadImplements</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-meta">@Overridepublic</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;通过实现Runable，线程号:&quot;</span> + Thread.currentThread().getName());<br>    &#125;&#125;<br></code></pre></td></tr></table></figure>



<h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a><strong>实现Callable接口</strong></h3><p>（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</p>
<p>（2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。</p>
<p>（3）使用FutureTask对象作为Thread对象的target创建并启动新线程。</p>
<p>（4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Thread;<br><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThread</span> </span><br><span class="hljs-class"></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span><br><span class="hljs-function"></span>&#123;testCallable();&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCallable</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span><br><span class="hljs-function"></span>&#123;<br>    Callable callable = <span class="hljs-keyword">new</span> MyThreadCallable();<br> 	FutureTask task = <span class="hljs-keyword">new</span> FutureTask(callable);<br>    <span class="hljs-keyword">new</span> Thread(task).start();<br>    System.out.println(task.get());<br>    Thread.sleep(<span class="hljs-number">10</span>);<span class="hljs-comment">//等待线程执行结束</span><br>    <span class="hljs-comment">//task.get() 获取call()的返回值。若调用时call()方法未返回，则阻塞线程等待返回值</span><br>    <span class="hljs-comment">//get的传入参数为等待时间，超时抛出超时异常；传入参数为空时，则不设超时，一直等待</span><br>    System.out.println(task.get(<span class="hljs-number">100L</span>, TimeUnit.MILLISECONDS));<br>&#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreadCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span> </span><br><span class="hljs-class"></span>&#123;<br>	<span class="hljs-meta">@Overridepublic</span> <span class="hljs-function">Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;通过实现Callable，线程号:&quot;</span> + Thread.currentThread().getName());<span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>    &#125;&#125;<br></code></pre></td></tr></table></figure>



<h2 id="三种方式的优缺点"><a href="#三种方式的优缺点" class="headerlink" title="三种方式的优缺点　"></a><strong>三种方式的优缺点</strong>　</h2><h3 id="采用继承Thread类方式："><a href="#采用继承Thread类方式：" class="headerlink" title="采用继承Thread类方式："></a><strong>采用继承Thread类方式：</strong></h3><p>（1）优点：编写简单，如果需要访问当前线程，无需使用Thread.currentThread()方法，直接使用this，即可获得当前线程。　　　</p>
<p>（2）缺点：因为线程类已经继承了Thread类，所以不能再继承其他的父类。</p>
<h3 id="采用实现Runnable接口方式："><a href="#采用实现Runnable接口方式：" class="headerlink" title="采用实现Runnable接口方式：　　　"></a><strong>采用实现Runnable接口方式：</strong>　　　</h3><p>（1）优点：线程类只是实现了Runable接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。　　　</p>
<p>（2）缺点：编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法。</p>
<h3 id="Runnable和Callable的区别："><a href="#Runnable和Callable的区别：" class="headerlink" title="Runnable和Callable的区别：　　"></a><strong>Runnable和Callable的区别：</strong>　　</h3><p>(1)Callable规定的方法是call(),Runnable规定的方法是run().　　　</p>
<p>(2)Callable的任务执行后可返回值，而Runnable的任务是不能返回值得　　　</p>
<p>(3)call方法可以抛出异常，run方法不可以，因为run方法本身没有抛出异常，所以自定义的线程类在重写run的时候也无法抛出异常　　　</p>
<p>(4)运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。 </p>
<h3 id="start（）和run（）的区别"><a href="#start（）和run（）的区别" class="headerlink" title="start（）和run（）的区别"></a><strong>start（）和run（）的区别</strong></h3><p>start()方法用来，开启线程，但是线程开启后并没有立即执行，他需要获取cpu的执行权才可以执行run()方法是由jvm创建完本地操作系统级线程后回调的方法，不可以手动调用（否则就是普通方法）</p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>22</title>
    <url>/2016/10/12/22/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>21</title>
    <url>/2016/10/12/21/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>23</title>
    <url>/2016/10/12/23/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>24</title>
    <url>/2016/10/12/24/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>25</title>
    <url>/2016/10/12/25/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>26</title>
    <url>/2016/10/12/26/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>27</title>
    <url>/2016/10/12/27/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>28</title>
    <url>/2016/10/12/28/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>29</title>
    <url>/2016/10/12/29/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>java中的notify和notifyAll有什么区别？</title>
    <url>/2019/04/22/2java%E4%B8%AD%E7%9A%84notify%E5%92%8CnotifyAll%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<p>java中的notify和notifyAll有什么区别？</p>
<p>先说两个概念：锁池和等待池</p>
<ul>
<li>锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。</li>
<li>等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁后，进入到了该对象的等待池中</li>
</ul>
<blockquote>
<p>Reference：<a href="https://link.zhihu.com/?target=http://blog.csdn.net/emailed/article/details/4689220">java中的锁池和等待池</a></p>
</blockquote>
<p>链接：<a href="https://www.zhihu.com/question/37601861/answer/145545371">https://www.zhihu.com/question/37601861/answer/145545371</a></p>
<p>然后再来说notify和notifyAll的区别</p>
<ul>
<li>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的<strong>等待池</strong>中，等待池中的线程<strong>不会去竞争该对象的锁</strong>。</li>
<li>当有线程调用了对象的 <strong>notifyAll</strong>()方法（唤醒所有 wait 线程）或 <strong>notify</strong>()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争</li>
<li>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它<strong>还会留在锁池中</strong>，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</li>
</ul>
<blockquote>
<p>Reference：<a href="https://link.zhihu.com/?target=http://wiki.jikexueyuan.com/project/java-concurrency/collaboration-between-threads.html">线程间协作：wait、notify、notifyAll</a></p>
</blockquote>
<p>综上，所谓唤醒线程，另一种解释可以说是将线程由等待池移动到锁池，notifyAll调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而notify只会唤醒一个线程。有了这些理论基础，后面的notify可能会导致死锁，而notifyAll则不会的例子也就好解释了</p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>30</title>
    <url>/2016/10/12/30/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>31</title>
    <url>/2016/10/12/31/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>32</title>
    <url>/2016/10/12/32/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>33</title>
    <url>/2016/10/12/33/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>34</title>
    <url>/2016/10/12/34/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>35</title>
    <url>/2016/10/12/35/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>36</title>
    <url>/2016/10/12/36/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>37</title>
    <url>/2016/10/12/37/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>39</title>
    <url>/2016/10/12/39/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>38</title>
    <url>/2016/10/12/38/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP-三次握手和四次挥手简单理解</title>
    <url>/2019/06/05/3TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="TCP-三次握手和四次挥手简单理解"><a href="#TCP-三次握手和四次挥手简单理解" class="headerlink" title="TCP-三次握手和四次挥手简单理解"></a>TCP-三次握手和四次挥手简单理解</h1><p><strong>三次握手（three-way handshaking）</strong></p>
<p>1.背景：TCP位于传输层，作用是提供可靠的字节流服务，为了准确无误地将数据送达目的地，TCP协议采纳三次握手策略。</p>
<p>2.原理：</p>
<p>1）发送端首先发送一个带有SYN（synchronize）标志地数据包给接收方。</p>
<p>2）接收方接收后，回传一个带有SYN/ACK标志的数据包传递确认信息，表示我收到了。</p>
<p>3）最后，发送方再回传一个带有ACK标志的数据包，代表我知道了，表示’握手‘结束。</p>
<p>通俗的说法</p>
<p>1）Client：嘿，李四，是我，听到了吗？</p>
<p>2）Server：我听到了，你能听到我的吗?</p>
<p>3）Client：好的，我们互相都能听到对方的话，我们的通信可以开始了。</p>
<p><img src="http://cdn.tuwenbin.vip/20201019001329.png" alt="img"></p>
<p>​                                                                                                3次握手</p>
<p><strong>四次挥手（Four-Way-Wavehand）</strong></p>
<p><strong>1.意义：</strong>当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭SOCKET,它可能还需要发送一些数据给主动方后，再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。</p>
<p>2.原理：</p>
<p> 1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p>
<p> 2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</p>
<p> 3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p>
<p> 4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手</p>
<p>通俗的说法</p>
<p>1）Client：我所有东西都说完了</p>
<p>2）Server：我已经全部听到了，但是等等我，我还没说完</p>
<p>3）Server：好了，我已经说完了</p>
<p>4）Client：好的，那我们的通信结束l</p>
<p><img src="http://cdn.tuwenbin.vip/20201019001358.png" alt="img"></p>
<p>​                                                                                            四次挥手</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>40</title>
    <url>/2016/10/12/40/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/41/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/42/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/43/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/44/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/45/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/46/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/47/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/48/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/49/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么tcp是三次握手而不是两次握手？</title>
    <url>/2019/10/12/4%E4%B8%BA%E4%BB%80%E4%B9%88tcp%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="为什么tcp是三次握手而不是两次握手？"><a href="#为什么tcp是三次握手而不是两次握手？" class="headerlink" title="为什么tcp是三次握手而不是两次握手？"></a>为什么tcp是三次握手而不是两次握手？</h1><p>   <strong>标准答案：第三次握手时为了防止已失效的连接请求报文段有传送到B，因而产生错误。</strong></p>
<p>下面做出详细解释：</p>
<p>​    所谓“防止已失效的连接请求报文”是这样产生的。考虑一种正常情况。A发出连接请求，但因连接请求报文丢失而未收到确认。于是A再重传一次请求连接。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A共发送了两个连接请求报文段。其中第一个丢失，第二个到达了B。没有“已失效的请求连接报文段”。</p>
<p>   现假定出现一种异常情况，即A发出的第一个请求连接报文段并没有丢失，而是<strong>在某些网络结点长时间滞留了，</strong>以至到连接释放以后的某个时间才到达B。本来这是一个已失效的报文段。但B收到此失效的连接请求报文段后，就<strong>误认为</strong>是A又发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。<strong>假定不采用三次握手，那么只要B发出确认，新的连接就建立了。</strong></p>
<p>   由于现在A并没有发出建立请求的连接，因此<strong>不会理睬B的确认，也不会向B发送数据</strong>，但B却以为新的运输连接已经建立了，并<strong>一直等待A发来的数据。B的许多资源就这样白白浪费了。</strong></p>
<p>   采用三次握手的办法可以防止上述现象发生。例如在刚才的情况下，A不会向B的确认发出确认。<strong>B由于收不到确认，就知道A并没有要求建立连接，所以就不会分配资源给这个连接。</strong></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>50</title>
    <url>/2016/10/12/50/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>51</title>
    <url>/2016/10/12/51/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>52</title>
    <url>/2016/10/12/52/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>54</title>
    <url>/2016/10/12/54/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>53</title>
    <url>/2016/10/12/53/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>55</title>
    <url>/2016/10/12/55/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>56</title>
    <url>/2016/10/12/56/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>57</title>
    <url>/2016/10/12/57/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>58</title>
    <url>/2016/10/12/58/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>B+树特征</title>
    <url>/2020/01/27/5B+%E6%A0%91%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<h3 id="B-树特征"><a href="#B-树特征" class="headerlink" title="B+树特征"></a>B+树特征</h3><p>B+ 树是一种树数据结构，是一个n叉树，每个节点通常有多个孩子，一颗B+树包含根节点、内部节点和叶子节点。B+ 树通常用于数据库和操作系统的文件系统中。 B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。 B+ 树元素自底向上插入。</p>
<p><strong>一个m阶的B树具有如下几个特征：</strong></p>
<p>1.根结点至少有两个子女。</p>
<p>2.每个中间节点都至少包含<code>ceil(m / 2)</code>个孩子，最多有m个孩子。</p>
<p>3.每一个叶子节点都包含k-1个元素，其中 m/2 &lt;= k &lt;= m。</p>
<p>4.所有的叶子结点都位于同一层。</p>
<p>5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7862980-42f0acde88d3c0cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/825" alt="img"></p>
<p>image.png</p>
<p>在本例中每一个父节点都出现在子节点中，是子节点最大或者最小的元素。而下面的例子中存在如果父结点存储的为子节点最小值，那么便不需要存储第一个子节点的内容。【例如子节点5、8—&gt;10、15—&gt;16、17、18意味着我父节点存10与16即可。而同样的例子如果父节点存最大值，那么便需要存8、15、18 】</p>
<p>在这里，根节点中最大的元素是15，也就是整个树中最大的元素。以后无论插入多少元素要始终保持最大元素在根节点当中。</p>
<p>每个叶子节点都有一个指针，指向下一个数据，形成一个有序链表。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7862980-1347d7c27ee3362c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" alt="img"></p>
<p>image.png</p>
<p>而只有叶子节点才会有data，其他都是索引。</p>
<h4 id="B-树与B树的区别"><a href="#B-树与B树的区别" class="headerlink" title="B+树与B树的区别"></a>B+树与B树的区别</h4><ul>
<li>有k个子结点的结点必然有k个关键码；</li>
<li>非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。</li>
<li>树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。</li>
</ul>
<h4 id="B-树的查询操作"><a href="#B-树的查询操作" class="headerlink" title="B+树的查询操作"></a>B+树的查询操作</h4><p>在单元查询的时候，B+树会自定向下逐层查找，最终找到匹配的叶子节点。例如我们查找3 。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7862980-232891d8ab2cd09b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" alt="img"></p>
<p>image.png</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7862980-6e527c79534bd69a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" alt="img"></p>
<p>image.png</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7862980-d47307fc3a169d6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200" alt="img"></p>
<p>image.png</p>
<p>而B+树中间节点没有Data数据，所以同样大小的磁盘页可以容纳更多的节点元素。所以数据量相同的情况下，B+树比B树更加“矮胖“，因此使用的IO查询次数更少。</p>
<p>由于B树的查找并不稳定（最好的情况是查询根节点，最坏查询叶子节点）。而B树每一次查找都是稳定的。</p>
<p>比起B树，B+树 ①IO次数更少 ②查询性能很稳定  ③范围查询更简便</p>
<p>下面我放入一个讲解的很好的博客：<a href="https://links.jianshu.com/go?to=https://blog.csdn.net/Fmuma/article/details/80287924">https://blog.csdn.net/Fmuma/article/details/80287924</a></p>
<h4 id="B-树的插入操作"><a href="#B-树的插入操作" class="headerlink" title="B+树的插入操作"></a>B+树的插入操作</h4><p>①若为空树，那么创建一个节点并将记录插入其中，此时这个叶子结点也是根结点，插入操作结束。</p>
<p>此处的图片中例子的介数为5 。</p>
<p>a）空树中插入5。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7862980-4437cbc344cd8c22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/155" alt="img"></p>
<p>image.png</p>
<p>②针对叶子类型结点：根据key值找到叶子结点，向这个叶子结点插入记录。插入后，若当前结点key的个数小于等于m-1（5-1 = 4），则插入结束。否则将这个叶子结点分裂成左右两个叶子结点，左叶子结点包含前m/2个（2个）记录，右结点包含剩下的记录，将第m/2+1个（3个）记录的key进位到父结点中（父结点一定是索引类型结点），进位到父结点的key左孩子指针向左结点，右孩子指针向右结点。将当前结点的指针指向父结点，然后执行第3步。</p>
<p>b）依次插入8，10，15。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7862980-0d284095ad32c1f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/150" alt="img"></p>
<p>image.png</p>
<p>c）插入16</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7862980-cc59c8f21d94ae22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/184" alt="img"></p>
<p>image.png</p>
<p>插入16后超过了关键字的个数限制，所以要进行分裂。在叶子结点分裂时，分裂出来的左结点2个记录，右边3个记录，中间第三个数成为索引结点中的key（10），分裂后当前结点指向了父结点（根结点）。结果如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7862980-eae0580e070c58f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/404" alt="img"></p>
<p>image.png</p>
<p>③针对索引类型结点：若当前结点key的个数小于等于m-1（4），则插入结束。否则，将这个索引类型结点分裂成两个索引结点，左索引结点包含前(m-1)/2个key（2个），右结点包含m-(m-1)/2个key（3个），将第m/2个key进位到父结点中，进位到父结点的key左孩子指向左结点,，进位到父结点的key右孩子指向右结点。将当前结点的指针指向父结点，然后重复第3步。</p>
<p>d）插入17</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7862980-ae3812c3ee35ecbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/327" alt="img"></p>
<p>image.png</p>
<p>e）插入18，插入后如下图所示</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7862980-658d073331022d62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/404" alt="img"></p>
<p>image.png</p>
<p>当前结点的关键字个数大于5，进行分裂。分裂成两个结点，左结点2个记录，右结点3个记录，关键字16进位到父结点（索引类型）中，将当前结点的指针指向父结点。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7862980-5da77efad2493a4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/520" alt="img"></p>
<p>image.png</p>
<p>f）插入若干数据后</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7862980-65dd732f056b4af2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/761" alt="img"></p>
<p>image.png</p>
<p>g）在上图中插入7，结果如下图所示</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7862980-019534138f87ba32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/762" alt="img"></p>
<p>image.png</p>
<p>当前结点的关键字个数超过4，需要分裂。左结点2个记录，右结点3个记录。分裂后关键字7进入到父结点中，将当前结点的指针指向父结点，结果如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7862980-4e079296c4e76291.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/870" alt="img"></p>
<p>image.png</p>
<p>当前结点的关键字个数超过4，需要继续分裂。左结点2个关键字，右结点2个关键字，关键字16进入到父结点中，将当前结点指向父结点，结果如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7862980-0110b3372a3ff5c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/870" alt="img"></p>
<p>image.png</p>
<p>当前结点的关键字个数满足条件，插入结束。</p>
<p>此处参考了：<a href="https://links.jianshu.com/go?to=https://blog.csdn.net/Fmuma/article/details/80287924">https://blog.csdn.net/Fmuma/article/details/80287924</a></p>
<h4 id="B-树的删除操作"><a href="#B-树的删除操作" class="headerlink" title="B+树的删除操作"></a>B+树的删除操作</h4><blockquote>
<p>下面是一颗5阶B树的删除过程，5阶B数的结点最少2个key，最多4个key。</p>
</blockquote>
<p>如果叶子结点中没有相应的key，则删除失败。否则执行下面的步骤。</p>
<p>①删除叶子结点中对应的key。删除后若结点的key的个数大于等于Math.ceil(m/2) – 1（&gt;=2），删除操作结束，否则执行第2步。</p>
<p>a）初始状态</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7862980-25a7a8fec1b73876.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/870" alt="img"></p>
<p>image.png</p>
<p>b）删除22,删除后结果如下图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7862980-122e25da308f1159.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/870" alt="img"></p>
<p>image.png</p>
<p><strong>删除后叶子结点中key的个数大于等于2，删除结束。</strong></p>
<p>②若结点的key的个数小于Math.ceil(m/2) – 1（&lt;2），且兄弟结点key有富余（大于Math.ceil(m/2)– 1）（&gt;2），向兄弟结点借一个记录，同时用借到的key替换父结（指当前结点和兄弟结点共同的父结点）点中的key，删除结束。否则执行第3步。</p>
<p>c）删除15，删除后的结果如下图所示。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7862980-7456d1acd804afbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/870" alt="img"></p>
<p>image.png</p>
<p><strong>删除后当前结点只有一个key，不满足条件，而兄弟结点有三个key，可以从兄弟结点借一个关键字为9的记录,同时更新将父结点中的关键字由10也变为9，删除结束。</strong></p>
<p>③若结点的key的个数小于Math.ceil(m/2) – 1（&lt;2），且兄弟结点中没有富余的key（小于Math.ceil(m/2)– 1），则当前结点和兄弟结点合并成一个新的叶子结点，并删除父结点中的key，将当前结点指向父结点（必为索引结点），执行第4步（第4步以后的操作和B树就完全一样了，主要是为了更新索引结点）。</p>
<p>d）删除7，删除后的结果如下图所示</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7862980-18575f57d978e9e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1024" alt="img"></p>
<p>image.png</p>
<p><strong>当前结点关键字个数小于2，（左）兄弟结点中的也没有富余的关键字（当前结点还有个右兄弟，不过选择任意一个进行分析就可以了，这里我们选择了左边的），所以当前结点和兄弟结点合并，并删除父结点中的key，当前结点指向父结点。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7862980-ba7e9a66e7c30524.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/870" alt="img"></p>
<p>image.png</p>
<p>④若索引结点的key的个数大于等于Math.ceil(m/2) – 1（&gt;=2），则删除操作结束。否则执行第5步。</p>
<p>⑤若兄弟结点有富余，父结点key下移，兄弟结点key上移，删除结束。否则执行第6步</p>
<p>⑥当前结点和兄弟结点及父结点下移key合并成一个新的结点。将当前结点指向父结点，重复第4步。</p>
<p><strong>此时当前结点的关键字个数小于2，兄弟结点的关键字也没有富余，所以父结点中的关键字下移，和两个孩子结点合并，结果如下图所示。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7862980-0f99822de5407565.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/871" alt="img"></p>
<p>image.png</p>
<p>注意，通过B+树的删除操作后，索引结点中存在的key，不一定在叶子结点中存在对应的记录。</p>
<p>作者：CPinging<br>链接：<a href="https://www.jianshu.com/p/71700a464e97">https://www.jianshu.com/p/71700a464e97</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>59</title>
    <url>/2016/10/12/59/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB与MyISAM的区别</title>
    <url>/2020/03/04/6InnoDB%E4%B8%8EMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB%20%20%20/</url>
    <content><![CDATA[<h1 id="InnoDB与MyISAM的区别"><a href="#InnoDB与MyISAM的区别" class="headerlink" title="InnoDB与MyISAM的区别"></a>InnoDB与MyISAM的区别</h1><h3 id="一、InnoDB的特点"><a href="#一、InnoDB的特点" class="headerlink" title="一、InnoDB的特点"></a>一、InnoDB的特点</h3><ol>
<li><strong>支持行锁</strong>，采用MVCC来支持高并发，有可能死锁</li>
<li><strong>支持事务</strong></li>
<li><strong>支持外键</strong></li>
<li><strong>支持崩溃后的安全恢复</strong></li>
<li><strong>不支持全文索引</strong></li>
<li>其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，<strong>树的叶节点data域保存了完整的数据记录</strong>。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而<strong>其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址</strong>，这也是和MyISAM不同的地方。<strong>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。</strong> 因此，在设计表的时候，不建议使用过长的字段作为主键。</li>
</ol>
<h3 id="二、MyISAM的特点"><a href="#二、MyISAM的特点" class="headerlink" title="二、MyISAM的特点"></a>二、MyISAM的特点</h3><ol>
<li><strong>不支持行锁(MyISAM只有表锁)</strong></li>
<li><strong>不支持事务</strong></li>
<li><strong>不支持外键</strong></li>
<li><strong>不支持崩溃后的安全恢复</strong></li>
<li>支持BLOB和TEXT的前500个字符索引，<strong>支持全文索引</strong></li>
<li>对于不会进行修改的表，<strong>支持压缩表</strong>，极大地减少了磁盘空间的占用</li>
<li><strong>B+Tree叶节点的data域存放的是数据记录的地址</strong>。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</li>
</ol>
<h3 id="三、关于二者的对比和总结"><a href="#三、关于二者的对比和总结" class="headerlink" title="三、关于二者的对比和总结"></a>三、关于二者的对比和总结</h3><blockquote>
<p>MyISAM 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是InnoDB  提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery  capabilities)的事务安全(transaction-safe (ACID compliant))型表。<strong>MyISAM更适合读密集的表，而InnoDB更适合写密集的的表</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>60</title>
    <url>/2016/10/12/60/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP状态码(响应码)</title>
    <url>/2020/04/22/7%20HTTP%E7%8A%B6%E6%80%81%E7%A0%81(%E5%93%8D%E5%BA%94%E7%A0%81)%20/</url>
    <content><![CDATA[<h1 id="HTTP状态码-响应码"><a href="#HTTP状态码-响应码" class="headerlink" title="HTTP状态码(响应码)"></a>HTTP状态码(响应码)</h1><p>HTTP状态码(响应码)用来表明HTTP请求是否已经成功完成.HTTP响应类型一共分五大类:消息响应,成功响应,重定向,客户端错误,服务器端错误.</p>
<p>下表列出了所有HTTP状态码,以及他们各自所代表的含义:</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>原因短语</th>
<th>代表含义</th>
<th>HTTP 版本</th>
</tr>
</thead>
<tbody><tr>
<td>消息响应</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>100</td>
<td>Continue (继续)</td>
<td>客户端应当继续发送请求.这个临时响应是用来通知客户端它的部分请求已经被服务器接收,且仍未被拒绝.客户端应当继续发送请求的剩余部分,或者如果请求已经完成,忽略这个响应.服务器必须在请求完成后向客户端发送一个最终响应.</td>
<td>HTTP/1.1 可用</td>
</tr>
<tr>
<td>101</td>
<td>Switching Protocol (切换协议)</td>
<td>服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到 在Upgrade消息头中定义的那些协议。:  只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特 性的资源。</td>
<td>HTTP/1.1 可用</td>
</tr>
<tr>
<td>成功响应</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>200</td>
<td>OK (成功)</td>
<td>请求成功.成功的意义根据请求所使用的方法不同而不同. GET: 资源已被提取,并作为响应体传回客户端. HEAD: 实体头已作为响应头传回客户端 POST: 经过服务器处理客户端传来的数据,适合的资源作为响应体传回客户端. TRACE: 服务器收到请求消息作为响应体传回客户端.     PUT, DELETE, 和 OPTIONS 方法永远不会返回 200 状态码.</td>
<td>HTTP/0.9 可用</td>
</tr>
<tr>
<td>201</td>
<td>Created (已创建)</td>
<td>请求成功，而且有一个新的资源已经依据请求的需要而建立，通常这是 PUT 方法得到的响应码.</td>
<td>HTTP/0.9 可用</td>
</tr>
<tr>
<td>202</td>
<td>Accepted (已创建)</td>
<td>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。:返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</td>
<td>HTTP/0.9 可用</td>
</tr>
<tr>
<td>203</td>
<td>Non-Authoritative Information (未授权信息)</td>
<td>服务器已成功处理了请求,但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝,如果不是上述情况,使用200状态码才是最合适的.</td>
<td>HTTP/0.9 and 1.1</td>
</tr>
<tr>
<td>204</td>
<td>No Content (无内容)</td>
<td>该响应没有响应内容,只有响应头,响应头也可能是有用的.用户代理可以根据新的响应头来更新对应资源的缓存信息.</td>
<td>HTTP/0.9 可用</td>
</tr>
<tr>
<td>205</td>
<td>Reset Content (重置内容)</td>
<td>告诉用户代理去重置发送该请求的窗口的文档视图.</td>
<td>HTTP/1.1 可用</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content (部分内容)</td>
<td>当客户端通过使用range头字段进行文件分段下载时使用该状态码</td>
<td>HTTP/1.1 可用</td>
</tr>
<tr>
<td>重定向</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>300</td>
<td>Multiple Choice (多种选择)</td>
<td>该请求有多种可能的响应,用户代理或者用户必须选择它们其中的一个.服务器没有任何标准可以遵循去代替用户来进行选择.</td>
<td>HTTP/1.0 and later</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently (永久移动)</td>
<td>该状态码表示所请求的URI资源路径已经改变,新的URL会在响应的<code>Location</code>:头字段里找到.</td>
<td>HTTP/0.9 可用</td>
</tr>
<tr>
<td>302</td>
<td>Found (临时移动)</td>
<td>该状态码表示所请求的URI资源路径临时改变,并且还可能继续改变.因此客户端在以后访问时还得继续使用该URI.新的URL会在响应的<code>Location:</code>头字段里找到.</td>
<td>HTTP/0.9 可用</td>
</tr>
<tr>
<td>303</td>
<td>See Other (查看其他位置)</td>
<td>服务器发送该响应用来引导客户端使用GET方法访问另外一个URI.</td>
<td>HTTP/0.9 and 1.1</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified (未修改)</td>
<td>告诉客户端,所请求的内容距离上次访问并没有变化. 客户端可以直接从浏览器缓存里获取该资源.</td>
<td>HTTP/0.9 可用</td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy (使用代理)</td>
<td>所请求的资源必须统过代理才能访问到.由于安全原因,该状态码并未受到广泛支持.</td>
<td>HTTP/1.1 可用</td>
</tr>
<tr>
<td>306</td>
<td><em>unused</em> (未使用)</td>
<td>这个状态码已经不再被使用,当初它被用在HTTP 1.1规范的旧版本中.</td>
<td>HTTP/1.1 可用</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect (临时重定向)</td>
<td>服务器发送该响应用来引导客户端使用相同的方法访问另外一个URI来获取想要获取的资源.新的URL会在响应的<code>Location:</code>头字段里找到.与302状态码有相同的语义,且前后两次访问必须使用相同的方法(GET POST).</td>
<td>HTTP/1.1 可用</td>
</tr>
<tr>
<td>308</td>
<td>Permanent Redirect (永久重定向)</td>
<td>所请求的资源将永久的位于另外一个URI上.新的URL会在响应的<code>Location:</code>头字段里找到.与301状态码有相同的语义,且前后两次访问必须使用相同的方法(GET POST).</td>
<td>HTTPbis  (试验草案)</td>
</tr>
<tr>
<td>客户端错误</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>400</td>
<td>Bad Request (错误请求)</td>
<td>因发送的请求语法错误,服务器无法正常读取.</td>
<td>HTTP/0.9 可用</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized (未授权)</td>
<td>需要身份验证后才能获取所请求的内容,类似于403错误.不同点是.401错误后,只要正确输入帐号密码,验证即可通过.</td>
<td>HTTP/0.9 可用</td>
</tr>
<tr>
<td>402</td>
<td>Payment Required (需要付款)</td>
<td>该状态码被保留以供将来使用.创建此代码最初的目的是为数字支付系统而用,然而,到现在也没投入使用.</td>
<td>HTTP/0.9 and 1.1</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden (禁止访问)</td>
<td>客户端没有权利访问所请求内容,服务器拒绝本次请求.</td>
<td>HTTP/0.9 可用</td>
</tr>
<tr>
<td>404</td>
<td>Not Found (未找到)</td>
<td>服务器找不到所请求的资源.由于经常发生此种情况,所以该状态码在上网时是非常常见的.</td>
<td>HTTP/0.9 可用</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed (不允许使用该方法)</td>
<td>该请求使用的方法被服务器端禁止使用,RFC2616中规定, <code>GET</code> 和 <code>HEAD</code> 方法不能被禁止.</td>
<td>HTTP/1.1 可用</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable (无法接受)</td>
<td>在进行服务器驱动内容协商后,没有发现合适的内容传回给客户端.</td>
<td>HTTP/1.1 可用</td>
</tr>
<tr>
<td>407</td>
<td>Proxy Authentication Required (要求代理身份验证)</td>
<td>类似于状态码 401,不过需要通过代理才能进行验证.</td>
<td>HTTP/1.1 可用</td>
</tr>
<tr>
<td>408</td>
<td>Request Timeout (请求超时)</td>
<td>客户端没有在服务器预备等待的时间内完成一个请求的发送.这意味着服务器将会切断和客户端的连接. 在其他浏览器中,这种响应更常见一些,  例如Chrome 和 IE9, 目的是为了使用HTTP 预连机制加快浏览速度. 同时注意,一些服务器不发送此种响应就直接切断连接.</td>
<td>HTTP/1.1 可用</td>
</tr>
<tr>
<td>409</td>
<td>Conflict (冲突)</td>
<td>该请求与服务器的当前状态所冲突.</td>
<td>HTTP/1.1 可用</td>
</tr>
<tr>
<td>410</td>
<td>Gone (已失效)</td>
<td>所请求的资源已经被删除.</td>
<td>HTTP/1.1 可用</td>
</tr>
<tr>
<td>411</td>
<td>Length Required (需要内容长度头)</td>
<td>因服务器在本次请求中需要 <code>Content-Length</code> 头字段,而客户端没有发送.所以,服务器拒绝了该请求.</td>
<td>HTTP/1.1 可用</td>
</tr>
<tr>
<td>412</td>
<td>Precondition Failed (预处理失败)</td>
<td>服务器没能满足客户端在获取资源时在请求头字段中设置的先决条件.</td>
<td>HTTP/1.1 可用</td>
</tr>
<tr>
<td>413</td>
<td>Request Entity Too Large (请求实体过长)</td>
<td>请求实体大小超过服务器的设置的最大限制,服务器可能会关闭HTTP链接并返回<code>Retry-After</code> 头字段.</td>
<td>HTTP/1.1 可用</td>
</tr>
<tr>
<td>414</td>
<td>Request-URI Too Long (请求网址过长)</td>
<td>客户端请求所包含的URI地址太长,以至于服务器无法处理.</td>
<td>HTTP/1.1 可用</td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type (媒体类型不支持)</td>
<td>服务器不支持客户端所请求的媒体类型,因此拒绝该请求.</td>
<td>HTTP/1.1 可用</td>
</tr>
<tr>
<td>416</td>
<td>Requested Range Not Satisfiable (请求范围不合要求)</td>
<td>请求中包含的<code>Range</code>头字段无法被满足,通常是因为<code>Range</code>中的数字范围超出所请求资源的大小.</td>
<td>HTTP/1.1 可用</td>
</tr>
<tr>
<td>417</td>
<td>Expectation Failed (预期结果失败)</td>
<td>在请求头<code> Expect</code> 中指定的预期内容无法被服务器满足.</td>
<td>HTTP/1.1 可用</td>
</tr>
<tr>
<td>服务器端错误</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error (内部服务器错误)</td>
<td>服务器遇到未知的无法解决的问题.</td>
<td>HTTP/0.9 可用</td>
</tr>
<tr>
<td>501</td>
<td>Implemented (未实现)</td>
<td>服务器不支持该请求中使用的方法,比如<code>POST</code> 和 <code>PUT.只有``GET</code> 和 <code>HEAD</code> 是RFC2616规范中规定服务器必须实现的方法.</td>
<td>HTTP/0.9 可用</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway (网关错误)</td>
<td>服务器作为网关且从上游服务器获取到了一个无效的HTTP响应.</td>
<td>HTTP/0.9 可用</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable (服务不可用)</td>
<td>由于临时的服务器维护或者过载,服务器当前无法处理请求.这个状况是临时的,并且将在一段时间以后恢复.如果能够预计延迟时间,那么响应中可以包含一个<code>Retry-After:</code>头用以标明这个延迟时间.如果没有给出这个<code>Retry-After:</code>信息，那么客户端应当以处理500响应的方式处理它.同时,这种情况下,一个友好的用于解释服务器出现问题的页面应当被返回,并且,缓存相关的HTTP头信息也应该包含,因为通常这种错误提示网页不应当被客户端缓存.</td>
<td>HTTP/0.9 可用</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Timeout  (网关超时)</td>
<td>服务器作为网关且不能从上游服务器及时的得到响应返回给客户端.</td>
<td>HTTP/1.1 可用</td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version Not Supported (HTTP版本不受支持)</td>
<td>服务器不支持客户端发送的HTTP请求中所使用的HTTP协议版本.</td>
<td>HTTP/1.1 可用</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/09/20/8JVM%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">title: JVM<br>date: 2020-6-22 23:38:45<br>categories: <br>    - JVM<br>tags: <br>    - JVM<br>cover:  https:&#x2F;&#x2F;cdn.tuwenbin.vip&#x2F;72edc31fee5659434017a320e7ac8a5bb2f0aa0b.jpg%401320w_742h.jpg<br></code></pre></td></tr></table></figure>



<h1 id="JVM探究"><a href="#JVM探究" class="headerlink" title="JVM探究"></a>JVM探究</h1><p>请你谈谈你对JVM的理解?java8虚拟机和之前的变化更新?·</p>
<p>什么是OOM,什么是栈溢出 StackOverFlowErr?怎么分析?</p>
<p>JVM的常用调优参数有哪些?</p>
<p>内存快照如何抓取,怎么分析Dump文件?知道吗?</p>
<p>谈谈JVM中,类加载器你的认识?</p>
<h2 id="1-JVM的位置"><a href="#1-JVM的位置" class="headerlink" title="1.JVM的位置"></a>1.JVM的位置</h2><p><img src="http://cdn.tuwenbin.vip/20201019003920.png" alt="ScreenClip"></p>
<h2 id="2JVM的体系结构"><a href="#2JVM的体系结构" class="headerlink" title="2JVM的体系结构"></a>2JVM的体系结构</h2><p><img src="http://cdn.tuwenbin.vip/20201019003929.png" alt="ScreenClip"></p>
<h2 id="3-类加载器-作用：加载Class文件"><a href="#3-类加载器-作用：加载Class文件" class="headerlink" title="3.类加载器  作用：加载Class文件~"></a>3.类加载器  作用：加载Class文件~</h2><p><img src="http://cdn.tuwenbin.vip/20201019003932.png" alt="ScreenClip"></p>
<h3 id="1-虚拟机自带的加载器"><a href="#1-虚拟机自带的加载器" class="headerlink" title="1.虚拟机自带的加载器"></a>1.虚拟机自带的加载器</h3><h3 id="2-启动类（根）的加载器"><a href="#2-启动类（根）的加载器" class="headerlink" title="2.启动类（根）的加载器"></a>2.启动类（根）的加载器</h3><h3 id="3-扩展类加载器"><a href="#3-扩展类加载器" class="headerlink" title="3.扩展类加载器"></a>3.扩展类加载器</h3><h3 id="4-应用程序加载器"><a href="#4-应用程序加载器" class="headerlink" title="4.应用程序加载器"></a>4.应用程序加载器</h3><h2 id="4-双亲委派机制"><a href="#4-双亲委派机制" class="headerlink" title="4.双亲委派机制"></a>4.双亲委派机制<img src="http://cdn.tuwenbin.vip/20201019003936.png" alt="ScreenClip"></h2><h2 id="5-沙箱安全机制"><a href="#5-沙箱安全机制" class="headerlink" title="5.沙箱安全机制"></a>5.沙箱安全机制<img src="http://cdn.tuwenbin.vip/20201019003942.png" alt="ScreenClip"></h2><p><img src="http://cdn.tuwenbin.vip/20201019003956.png" alt="ScreenClip"></p>
<p><img src="http://cdn.tuwenbin.vip/20201019003959.png" alt="ScreenClip"></p>
<p><img src="http://cdn.tuwenbin.vip/20201019004003.png" alt="ScreenClip"></p>
<p><img src="http://cdn.tuwenbin.vip/20201019004007.png" alt="ScreenClip"></p>
<p><img src="http://cdn.tuwenbin.vip/20201019004020.png" alt="ScreenClip"></p>
<h2 id="6-Native"><a href="#6-Native" class="headerlink" title="6, Native."></a>6, Native.<img src="http://cdn.tuwenbin.vip/20201019004023.png" alt="ScreenClip"></h2><h2 id="7-PC寄存器"><a href="#7-PC寄存器" class="headerlink" title="7.PC寄存器"></a>7.PC寄存器<img src="http://cdn.tuwenbin.vip/20201019004028.png" alt="ScreenClip"></h2><h2 id="8-方法区"><a href="#8-方法区" class="headerlink" title="8.方法区"></a>8.方法区<img src="http://cdn.tuwenbin.vip/20201019004034.png" alt="ScreenClip"></h2><h2 id="9-栈"><a href="#9-栈" class="headerlink" title="9.栈"></a>9.栈</h2><p><img src="http://cdn.tuwenbin.vip/20201019004037.png" alt="ScreenClip"></p>
<p><img src="http://cdn.tuwenbin.vip/20201019004051.png" alt="ScreenClip"></p>
<p><img src="http://cdn.tuwenbin.vip/20201019004055.png" alt="ScreenClip"></p>
<h2 id="10-三种VM"><a href="#10-三种VM" class="headerlink" title="10.三种VM"></a>10.三种VM<img src="http://cdn.tuwenbin.vip/20201019004059.png" alt="ScreenClip"></h2><h2 id="11-堆"><a href="#11-堆" class="headerlink" title="11.堆"></a>11.堆<img src="http://cdn.tuwenbin.vip/20201019004102.png" alt="ScreenClip"></h2><p><img src="http://cdn.tuwenbin.vip/20201019004107.png" alt="ScreenClip"></p>
<p><img src="http://cdn.tuwenbin.vip/20201019004112.png" alt="ScreenClip"></p>
<h2 id="12-新生区、老年区"><a href="#12-新生区、老年区" class="headerlink" title="12.新生区、老年区"></a>12.新生区、老年区<img src="http://cdn.tuwenbin.vip/20201019004114.png" alt="ScreenClip"></h2><p> <strong>老年区</strong></p>
<p><img src="http://cdn.tuwenbin.vip/20201019004120.png" alt="ScreenClip"></p>
<p><img src="http://cdn.tuwenbin.vip/20201019004124.png" alt="ScreenClip"></p>
<p><img src="http://cdn.tuwenbin.vip/20201019004128.png" alt="ScreenClip"></p>
<p>元空间：逻辑上存在，物理上不存在</p>
<p><img src="http://cdn.tuwenbin.vip/20201019004132.png" alt="ScreenClip"></p>
<h2 id="13-永久区"><a href="#13-永久区" class="headerlink" title="13.永久区"></a>13.永久区</h2><h2 id="14-堆内存调优"><a href="#14-堆内存调优" class="headerlink" title="14.堆内存调优"></a>14.堆内存调优<img src="http://cdn.tuwenbin.vip/20201019004136.png" alt="ScreenClip"></h2><h2 id="15、GC"><a href="#15、GC" class="headerlink" title="15、GC"></a>15、GC</h2><h3 id=""><a href="#" class="headerlink" title=""></a><img src="http://cdn.tuwenbin.vip/20201019004145.png" alt="ScreenClip"></h3><p><img src="http://cdn.tuwenbin.vip/20201019004148.png" alt="ScreenClip"></p>
<p><img src="http://cdn.tuwenbin.vip/20201019004152.png" alt="ScreenClip"></p>
<p><img src="http://cdn.tuwenbin.vip/20201019004156.png" alt="ScreenClip"></p>
<p><img src="http://cdn.tuwenbin.vip/20201019004203.png" alt="ScreenClip"></p>
<p><img src="http://cdn.tuwenbin.vip/20201019004207.png" alt="ScreenClip"></p>
<p><img src="http://cdn.tuwenbin.vip/20201019004211.png" alt="ScreenClip"></p>
<h2 id="16-JMM"><a href="#16-JMM" class="headerlink" title="16.JMM"></a>16.JMM</h2><h2 id="17-总结"><a href="#17-总结" class="headerlink" title="17.总结"></a>17.总结</h2><p><img src="http://cdn.tuwenbin.vip/20201019004216.png" alt="ScreenClip"></p>
<p><img src="http://cdn.tuwenbin.vip/20201019004221.png" alt="ScreenClip"></p>
]]></content>
  </entry>
  <entry>
    <title>MySQL查询优化</title>
    <url>/2020/08/21/9MySQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="MySQL查询优化"><a href="#MySQL查询优化" class="headerlink" title="MySQL查询优化"></a>MySQL查询优化</h1><h1 id="优化MySQL语句执行效率的方法，从哪些方面入手，SQL语句性能如何分析？"><a href="#优化MySQL语句执行效率的方法，从哪些方面入手，SQL语句性能如何分析？" class="headerlink" title="优化MySQL语句执行效率的方法，从哪些方面入手，SQL语句性能如何分析？"></a>优化MySQL语句执行效率的方法，从哪些方面入手，SQL语句性能如何分析？</h1><h1 id="分析查询速度"><a href="#分析查询速度" class="headerlink" title="分析查询速度"></a>分析查询速度</h1><ul>
<li>记录慢查询日志<br> 分析查询日志，使用<code>pt-query-digest</code>工具进行分析</li>
<li>使用<code>show profile</code><br> set peofiling=1; # 服务器上执行的所有语句会检测消耗的时间、存到临时表中<br> <code>show profiles # 所有的SQL语句执行记录</code><br> <code>show profile for query 临时表ID # 查执行ID的SQL语句</code></li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">mysql&gt; set profiling=<span class="hljs-number">1</span>;<br>Query OK, <span class="hljs-number">0</span> rows affected<br><br>mysql&gt; select * from user;<br>+----+------+-----+<br><span class="hljs-params">| id |</span> name <span class="hljs-params">| age |</span><br>+----+------+-----+<br><span class="hljs-params">|  1 |</span> Jack <span class="hljs-params">|  23 |</span><br>+----+------+-----+<br><span class="hljs-number">1</span> row <span class="hljs-keyword">in</span> set<br><br>mysql&gt; show profiles;<br>+----------+------------+---------------------------------------------------------------------------------------------------------------------------------+<br><span class="hljs-params">| Query_ID |</span> Duration   <span class="hljs-params">| Query                                                                                                                           |</span><br>+----------+------------+---------------------------------------------------------------------------------------------------------------------------------+  <br><span class="hljs-params">|       1 |</span>   <span class="hljs-number">8.675</span>E-<span class="hljs-number">5</span> <span class="hljs-params">| set profiling=1                                                                                                                 |</span><br><span class="hljs-params">|       2|</span>   <span class="hljs-number">0</span>.<span class="hljs-number">0001</span>97 <span class="hljs-params">| select * from user                                                                                                              |</span><br>+----------+------------+---------------------------------------------------------------------------------------------------------------------------------+<br><span class="hljs-number">10</span> rows <span class="hljs-keyword">in</span> set<br><br>mysql&gt; show profile <span class="hljs-keyword">for</span> query <span class="hljs-number">2</span>;<br>+----------------------+----------+<br><span class="hljs-params">| Status               |</span> Duration <span class="hljs-params">|</span><br><span class="hljs-params">+----------------------+----------+</span><br><span class="hljs-params">|</span> starting             <span class="hljs-params">| 4.3E-5   |</span><br><span class="hljs-params">| checking permissions |</span> <span class="hljs-number">7</span>E-<span class="hljs-number">6</span>     <span class="hljs-params">|</span><br><span class="hljs-params">|</span> Opening tables       <span class="hljs-params">| 1.8E-5   |</span><br><span class="hljs-params">| System lock          |</span> <span class="hljs-number">1</span>E-<span class="hljs-number">5</span>     <span class="hljs-params">|</span><br><span class="hljs-params">|</span> init                 <span class="hljs-params">| 1.4E-5   |</span><br><span class="hljs-params">| optimizing           |</span> <span class="hljs-number">4</span>E-<span class="hljs-number">6</span>     <span class="hljs-params">|</span><br><span class="hljs-params">|</span> statistics           <span class="hljs-params">| 3.1E-5   |</span><br><span class="hljs-params">| preparing            |</span> <span class="hljs-number">1</span>E-<span class="hljs-number">5</span>     <span class="hljs-params">|</span><br><span class="hljs-params">|</span> executing            <span class="hljs-params">| 2E-6     |</span><br><span class="hljs-params">| Sending data         |</span> <span class="hljs-number">1</span>E-<span class="hljs-number">5</span>     <span class="hljs-params">|</span><br><span class="hljs-params">|</span> <span class="hljs-keyword">end</span>                  <span class="hljs-params">| 3E-6     |</span><br><span class="hljs-params">| query <span class="hljs-keyword">end</span>            |</span> <span class="hljs-number">2</span>E-<span class="hljs-number">6</span>     <span class="hljs-params">|</span><br><span class="hljs-params">|</span> closing tables       <span class="hljs-params">| 5E-6     |</span><br><span class="hljs-params">| freeing items        |</span> <span class="hljs-number">3.5</span>E-<span class="hljs-number">5</span>   <span class="hljs-params">|</span><br><span class="hljs-params">|</span> logging slow query   <span class="hljs-params">| 3E-6     |</span><br><span class="hljs-params">| cleaning up          |</span> <span class="hljs-number">2</span>E-<span class="hljs-number">6</span>     <span class="hljs-params">|</span><br><span class="hljs-params">+----------------------+----------+</span><br><span class="hljs-params">16 rows <span class="hljs-keyword">in</span> set</span><br></code></pre></td></tr></table></figure>

<ul>
<li>show status<br> <code>show status</code>会返回一些计数器，<code>show global status</code>查看服务器级别的所有计数。</li>
<li>show processlist<br> 观察是否有大量的线程处于不正常的状态或特征。</li>
<li>explain<br> 分析单条的SQL语句</li>
</ul>
<figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">mysql&gt; explain select * from user;<br>+----+-------------+-------+--------+---------------+------+---------+------+------+-------+<br><span class="hljs-params">| id |</span> select_type <span class="hljs-params">| table |</span> type   <span class="hljs-params">| possible_keys |</span> key  <span class="hljs-params">| key_len |</span> ref  <span class="hljs-params">| rows |</span> Extra <span class="hljs-params">|</span><br><span class="hljs-params">+----+-------------+-------+--------+---------------+------+---------+------+------+-------+</span><br><span class="hljs-params">|</span>  <span class="hljs-number">1</span> <span class="hljs-params">| SIMPLE      |</span> user  <span class="hljs-params">| system |</span> NULL          <span class="hljs-params">| NULL |</span> NULL    <span class="hljs-params">| NULL |</span>    <span class="hljs-number">1</span> <span class="hljs-params">|       |</span><br>+----+-------------+-------+--------+---------------+------+---------+------+------+-------+<br><span class="hljs-number">1</span> row <span class="hljs-keyword">in</span> set<br></code></pre></td></tr></table></figure>

<blockquote>
<p>explain它有一个别名<code>desc</code>，所以使用<code>explain select * from user;</code>查询到的结果与上面的一样。</p>
</blockquote>
<h1 id="优化查询过程中的数据访问"><a href="#优化查询过程中的数据访问" class="headerlink" title="优化查询过程中的数据访问"></a>优化查询过程中的数据访问</h1><ul>
<li>数据太多会导致查询性能下降。</li>
<li>确定应用程序是否在检索大量超过需要的数据，可能太多行或列。</li>
<li>确认MySQL服务器是否在分析大量不必要的数据行</li>
</ul>
<p><strong>避免使用以下SQL语句</strong></p>
<ul>
<li>查询不需要的记录，使用<code>limit</code>解决</li>
<li>多表管理返回全部列，需要制定列，如A.id、B.name等</li>
<li>总是取出全部列，<code>select *</code>会让优化器无法完成索引覆盖扫描优化</li>
<li>重复查询相同的数据，可以使用缓存，下次直接读取缓存</li>
</ul>
<p><strong>是否在扫描额外的记录</strong><br> 使用<code>explain</code>来进行分析，如果发现查询需要扫描大量的数据但是只返回少数的行，可以通过如下技巧去优化：</p>
<ul>
<li>使用索引覆盖扫描，把所有的列都放在索引中。</li>
<li>改变数据库和表的结构，修改数据表范式</li>
<li>重写SQL语句，让优化器可以以最优的方式执行查询</li>
</ul>
<h1 id="优化长难的查询语句"><a href="#优化长难的查询语句" class="headerlink" title="优化长难的查询语句"></a>优化长难的查询语句</h1><p>使用尽可能小的查询是好的，但有时将一个大的查询分解成多个小的查询是很有必要的。</p>
<ul>
<li><strong>切分查询</strong><br> 将一个大的查询分为多个小的相同的查询<br> 一次性删除1000万的数据比一次删除1万，暂停一会儿在执行删除1万条数据要较少更多的服务器开销。</li>
<li><strong>分解关联查询</strong><br> 可以将一条关联语句分解成多个SQL语句执行<br> 让缓存的效率更高<br> 执行单个查询可以减少锁的竞争<br> 在应用层做关联可以更容易对数据库进行拆分</li>
</ul>
<h1 id="优化特定类型的查询语句"><a href="#优化特定类型的查询语句" class="headerlink" title="优化特定类型的查询语句"></a>优化特定类型的查询语句</h1><h2 id="优化count-查询"><a href="#优化count-查询" class="headerlink" title="优化count()查询"></a>优化<code>count()</code>查询</h2><ul>
<li><code>count(*)</code>占用的<code>*</code>会忽略所有的列，直接统计所有的列数，因此不要使用<code>count(列名)</code></li>
<li>MyISAM中<code>没有任何where条件的count(* )</code>查询速度非常快</li>
<li><code>有where条件</code>时，MyISAM的count统计不一定比其他表引擎快</li>
</ul>
<p>优化：</p>
<ul>
<li>可以使用<code>explain</code>查询近似值，用近似值代替<code>count(*)</code></li>
<li>增加汇总表</li>
<li>使用缓存</li>
</ul>
<h2 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h2><ul>
<li>确定on或者using子句的列上有索引；</li>
<li>确保<code>group by</code>和<code>order by</code>中只有一个表中的列，这样MySQL才有可能使用索引；</li>
</ul>
<h2 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h2><p>尽量使用关联查询替代</p>
<h2 id="优化group-by和distinct"><a href="#优化group-by和distinct" class="headerlink" title="优化group by和distinct"></a>优化<code>group by</code>和<code>distinct</code></h2><ul>
<li>使用<strong>索引</strong>来优化</li>
<li>关联查询中，使用<strong>标识列</strong>（主键列）进行分组的效率会更高</li>
<li>如果不需要<code>order by</code>，进行<code>group by</code>时使用<code>order by NULL</code>，MySQL不会进行文件排序</li>
<li><code>with rollup</code>超级剧和，可以挪到应用程序处理</li>
</ul>
<h2 id="优化limit子句"><a href="#优化limit子句" class="headerlink" title="优化limit子句"></a>优化<code>limit</code>子句</h2><p><code>limit</code>偏移量大的时候，查询效率较低。</p>
<p>方案：</p>
<ul>
<li>记录上一次查询的最大ID，下次查询时直接根据ID来查询（还是使用limit查询，不过加一个where条件，id &gt; ID）</li>
</ul>
<h2 id="优化union"><a href="#优化union" class="headerlink" title="优化union"></a>优化<code>union</code></h2><p><code>union all</code> 的效率高于<code>union</code>。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>精尽 Spring MVC 面试题</title>
    <url>/2018/10/12/%E7%B2%BE%E5%B0%BD%20Spring%20MVC%20%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="精尽-Spring-MVC-面试题"><a href="#精尽-Spring-MVC-面试题" class="headerlink" title="精尽 Spring MVC 面试题"></a>精尽 Spring MVC 面试题</h1><p>以下面试题，基于网络整理，和自己编辑。具体参考的文章，会在文末给出所有的链接。</p>
<p>如果胖友有自己的疑问，欢迎在星球提问，我们一起整理吊吊的 Spring MVC 面试题的大保健。</p>
<p>而题目的难度，艿艿尽量按照从容易到困难的顺序，逐步下去。</p>
<p>当然，艿艿还是非常推荐胖友去撸一撸 Spring MVC 的源码，特别是如下两篇：</p>
<ul>
<li><a href="http://svip.iocoder.cn/Spring-MVC/Components-intro/">《精尽 Spring MVC 源码分析 —— 组件一览》</a></li>
<li><a href="http://svip.iocoder.cn/Spring-MVC/DispatcherServlet-process-request-intro/">《精尽 Spring MVC 源码分析 —— 请求处理一览》</a></li>
</ul>
<p>考虑到 Spring MVC 和 Rest 关系比较大，所以本文一共分成两大块：</p>
<ul>
<li>Spring MVC</li>
<li>REST</li>
</ul>
<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="Spring-MVC-框架有什么用？"><a href="#Spring-MVC-框架有什么用？" class="headerlink" title="Spring MVC 框架有什么用？"></a>Spring MVC 框架有什么用？</h2><p>Spring Web MVC 框架提供”模型-视图-控制器”( Model-View-Controller )架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。</p>
<p>MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。</p>
<h2 id="介绍下-Spring-MVC-的核心组件？"><a href="#介绍下-Spring-MVC-的核心组件？" class="headerlink" title="介绍下 Spring MVC 的核心组件？"></a>介绍下 Spring MVC 的核心组件？</h2><p>Spring MVC 一共有九大核心组件，分别是：</p>
<ul>
<li>MultipartResolver</li>
<li>LocaleResolver</li>
<li>ThemeResolver</li>
<li>HandlerMapping</li>
<li>HandlerAdapter</li>
<li>HandlerExceptionResolver</li>
<li>RequestToViewNameTranslator</li>
<li>ViewResolver</li>
<li>FlashMapManager</li>
</ul>
<p>虽然很多，但是在前后端分离的架构中，在 <a href="http://svip.iocoder.cn/Spring-MVC/Interview/#">「描述一下 DispatcherServlet 的工作流程？」</a> 问题中，我们会明白，最关键的只有 HandlerMapping + HandlerAdapter + HandlerExceptionResolver 。</p>
<p>关于每个组件的说明，直接看 <a href="http://svip.iocoder.cn/Spring-MVC/Components-intro/">《精尽 Spring MVC 源码分析 —— 组件一览》</a> 。</p>
<h2 id="描述一下-DispatcherServlet-的工作流程？"><a href="#描述一下-DispatcherServlet-的工作流程？" class="headerlink" title="描述一下 DispatcherServlet 的工作流程？"></a>描述一下 DispatcherServlet 的工作流程？</h2><p>DispatcherServlet 的工作流程可以用一幅图来说明：</p>
<p><a href="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15300766829012.jpg"><img src="http://cdn.tuwenbin.vip/15300766829012.jpg" alt="DispatcherServlet 的工作流程"></a>DispatcherServlet 的工作流程</p>
<p>① <strong>发送请求</strong></p>
<p>用户向服务器发送 HTTP 请求，请求被 Spring MVC 的调度控制器  DispatcherServlet 捕获。</p>
<p>② <strong>映射处理器</strong></p>
<p>DispatcherServlet 根据请求 URL ，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 <strong>Handler</strong> 对象以及 Handler 对象对应的<strong>拦截器</strong>），最后以 HandlerExecutionChain 对象的形式返回。</p>
<ul>
<li>即 HandlerExecutionChain 中，包含对应的 <strong>Handler</strong> 对象和<strong>拦截器</strong>们。</li>
</ul>
<blockquote>
<p>此处，对应的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; &#x2F;&#x2F; HandlerMapping.java<br>&gt; <br>&gt; @Nullable<br>&gt; HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;<br>&gt;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>③ <strong>处理器适配</strong></p>
<p>DispatcherServlet 根据获得的 Handler，选择一个合适的HandlerAdapter 。（附注：如果成功获得 HandlerAdapter 后，此时将开始执行拦截器的 <code>#preHandler(...)</code> 方法）。</p>
<p>提取请求 Request 中的模型数据，填充 Handler 入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：</p>
<ul>
<li>HttpMessageConverter ：会将请求消息（如 JSON、XML 等数据）转换成一个对象。</li>
<li>数据转换：对请求消息进行数据转换。如 String 转换成 Integer、Double 等。</li>
<li>数据格式化：对请求消息进行数据格式化。如将字符串转换成格式化数字或格式化日期等。</li>
<li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到 BindingResult 或 Error 中。</li>
</ul>
<p>Handler(Controller) 执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象。</p>
<blockquote>
<p>此处，对应的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; &#x2F;&#x2F; HandlerAdapter.java<br>&gt; <br>&gt; @Nullable<br>&gt; ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;<br>&gt;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>.</p>
<blockquote>
<p>图中没有 ④ 。</p>
</blockquote>
<p>⑤ <strong>解析视图</strong></p>
<p>根据返回的 ModelAndView ，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的 ViewResolver)，解析出 View 对象，然后返回给 DispatcherServlet。</p>
<blockquote>
<p>此处，对应的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; &#x2F;&#x2F; ViewResolver.java<br>&gt; <br>&gt; @Nullable<br>&gt; View resolveViewName(String viewName, Locale locale) throws Exception;<br>&gt;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>⑥ ⑦ <strong>渲染视图</strong> + <strong>响应请求</strong></p>
<p>ViewResolver 结合 Model 和 View，来渲染视图，并写回给用户( 浏览器 )。</p>
<blockquote>
<p>此处，对应的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; &#x2F;&#x2F; View.java<br>&gt; <br>&gt; void render(@Nullable Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception;<br>&gt;<br></code></pre></td></tr></table></figure>
</blockquote>
<hr>
<p>这样一看，胖友可能有点懵逼，所以还是推荐看看：</p>
<ul>
<li><a href="http://svip.iocoder.cn/Spring-MVC/Components-intro/">《精尽 Spring MVC 源码分析 —— 组件一览》</a></li>
<li><a href="http://svip.iocoder.cn/Spring-MVC/DispatcherServlet-process-request-intro/">《精尽 Spring MVC 源码分析 —— 请求处理一览》</a></li>
</ul>
<p><strong>但是 Spring MVC 的流程真的一定是酱紫么</strong>？</p>
<p>既然这么问，答案当然不是。对于目前主流的架构，前后端已经进行分离了，所以 Spring MVC 只负责 <strong>M</strong>odel 和 <strong>C</strong>ontroller 两块，而将 <strong>V</strong>iew 移交给了前端。所以，在上图中的步骤 ⑤ 和 ⑥ 两步，已经不在需要。</p>
<p>那么变成什么样了呢？在步骤 ③ 中，如果 Handler(Controller) 执行完后，如果判断方法有 <code>@ResponseBody</code> 注解，则直接将结果写回给用户( 浏览器 )。</p>
<p>但是 HTTP 是不支持返回 Java POJO 对象的，所以需要将结果使用 <a href="http://svip.iocoder.cn/Spring-MVC/HandlerAdapter-5-HttpMessageConverter/">HttpMessageConverter</a> 进行转换后，才能返回。例如说，大家所熟悉的 <a href="https://github.com/alibaba/fastjson/wiki/%E5%9C%A8-Spring-%E4%B8%AD%E9%9B%86%E6%88%90-Fastjson">FastJsonHttpMessageConverter</a> ，将 POJO 转换成 JSON 字符串返回。</p>
<p>😈 是不是略微有点复杂，还是那句话，撸下源码，捅破这个窗口。当然，如果胖友精力有限，只要看整体流程的几篇即可。 </p>
<hr>
<p>嘻嘻，再来补充两个图，这真的是 Spring MVC 非常关键的问题，所以要用心理解。</p>
<blockquote>
<p>FROM <a href="https://blog.csdn.net/J080624/article/details/77990164">《SpringMVC - 运行流程图及原理分析》</a></p>
<p><strong>流程示意图</strong>：</p>
<p><a href="http://static2.iocoder.cn/images/Spring/2022-02-21/01.png"><img src="http://cdn.tuwenbin.vip/01.png" alt="流程示意图"></a>流程示意图</p>
<p><strong>代码序列图</strong>：</p>
<p><a href="http://static2.iocoder.cn/images/Spring/2022-02-21/02.png"><img src="http://cdn.tuwenbin.vip/02.png" alt="代码序列图"></a>代码序列图</p>
<hr>
<p>FROM <a href="https://item.jd.com/11807414.html">《看透 Spring MVC：源代码分析与实践》</a> P123</p>
<p><strong>流程示意图</strong>：</p>
<p><a href="http://static2.iocoder.cn/images/Spring/2022-02-21/03.png"><img src="http://cdn.tuwenbin.vip/03.png" alt="《流程示意图》"></a>《流程示意图》</p>
</blockquote>
<h2 id="Controller-注解有什么用？"><a href="#Controller-注解有什么用？" class="headerlink" title="@Controller 注解有什么用？"></a>@Controller 注解有什么用？</h2><p><code>@Controller</code> 注解，它将一个类标记为 Spring Web MVC <strong>控制器</strong> Controller 。</p>
<h2 id="RestController-和-Controller-有什么区别？"><a href="#RestController-和-Controller-有什么区别？" class="headerlink" title="@RestController 和 @Controller 有什么区别？"></a>@RestController 和 @Controller 有什么区别？</h2><p><code>@RestController</code> 注解，在 <code>@Controller</code> 基础上，增加了 <code>@ResponseBody</code> 注解，更加适合目前前后端分离的架构下，提供 Restful API ，返回例如 JSON 数据格式。当然，返回什么样的数据格式，根据客户端的 <code>&quot;ACCEPT&quot;</code> 请求头来决定。</p>
<h2 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h2><p><code>@RequestMapping</code> 注解，用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：</p>
<ul>
<li>类级别：映射请求的 URL。</li>
<li>方法级别：映射 URL 以及 HTTP 请求方法。</li>
</ul>
<h2 id="RequestMapping-和-GetMapping-注解的不同之处在哪里？"><a href="#RequestMapping-和-GetMapping-注解的不同之处在哪里？" class="headerlink" title="@RequestMapping 和 @GetMapping 注解的不同之处在哪里？"></a>@RequestMapping 和 @GetMapping 注解的不同之处在哪里？</h2><ul>
<li><code>@RequestMapping</code> 可注解在类和方法上；<code>@GetMapping</code> 仅可注册在方法上。</li>
<li><code>@RequestMapping</code> 可进行 GET、POST、PUT、DELETE 等请求方法；<code>@GetMapping</code> 是 <code>@RequestMapping</code> 的 GET 请求方法的特例，目的是为了提高清晰度。</li>
</ul>
<h2 id="返回-JSON-格式使用什么注解？"><a href="#返回-JSON-格式使用什么注解？" class="headerlink" title="返回 JSON 格式使用什么注解？"></a>返回 JSON 格式使用什么注解？</h2><p>可以使用 <strong><code>@ResponseBody</code></strong> 注解，或者使用包含 <code>@ResponseBody</code> 注解的 <strong><code>@RestController</code></strong> 注解。</p>
<p>当然，还是需要配合相应的支持 JSON 格式化的 HttpMessageConverter 实现类。例如，Spring MVC 默认使用 MappingJackson2HttpMessageConverter 。</p>
<h2 id="介绍一下-WebApplicationContext-？"><a href="#介绍一下-WebApplicationContext-？" class="headerlink" title="介绍一下 WebApplicationContext ？"></a>介绍一下 WebApplicationContext ？</h2><p>WebApplicationContext 是实现ApplicationContext接口的子类，专门为 WEB 应用准备的。</p>
<ul>
<li>它允许从相对于 Web 根目录的路径中<strong>加载配置文件</strong>，<strong>完成初始化 Spring MVC 组件的工作</strong>。</li>
<li>从 WebApplicationContext 中，可以获取 ServletContext 引用，整个 Web 应用上下文对象将作为属性放置在 ServletContext 中，以便 Web 应用环境可以访问 Spring 上下文。</li>
</ul>
<p>关于这一块，如果想要详细了解，可以看看如下两篇文章：</p>
<ul>
<li><a href="http://svip.iocoder.cn/Spring-MVC/context-init-Root-WebApplicationContext/">《精尽 Spring MVC 源码分析 —— 容器的初始化（一）之 Root WebApplicationContext 容器》</a></li>
<li><a href="http://svip.iocoder.cn/Spring-MVC/context-init-Servlet-WebApplicationContext/">《精尽 Spring MVC 源码分析 —— 容器的初始化（二）之 Servlet WebApplicationContext 容器》</a></li>
</ul>
<h2 id="Spring-MVC-的异常处理？"><a href="#Spring-MVC-的异常处理？" class="headerlink" title="Spring MVC 的异常处理？"></a>Spring MVC 的异常处理？</h2><p>Spring MVC 提供了异常解析器 HandlerExceptionResolver 接口，将处理器( <code>handler</code> )执行时发生的异常，解析( 转换 )成对应的 ModelAndView 结果。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; HandlerExceptionResolver.java<br><br>public interface HandlerExceptionResolver &#123;<br><br>    &#x2F;**<br>     * 解析异常，转换成对应的 ModelAndView 结果<br>     *&#x2F;<br>    @Nullable<br>    ModelAndView resolveException(<br>            HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex);<br><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>也就是说，如果异常被解析成功，则会返回 ModelAndView 对象。</li>
<li>详细的源码解析，见 <a href="http://svip.iocoder.cn/Spring-MVC/HandlerExceptionResolver/">《精尽 Spring MVC 源码解析 —— HandlerExceptionResolver 组件》</a> 。</li>
</ul>
<p>一般情况下，我们使用 <code>@ExceptionHandler</code> 注解来实现过异常的处理，可以先看看 <a href="https://www.jianshu.com/p/12e1a752974d">《Spring 异常处理 ExceptionHandler 的使用》</a> 。</p>
<ul>
<li>一般情况下，艿艿喜欢使用<strong>第三种</strong>。</li>
</ul>
<h2 id="Spring-MVC-有什么优点？"><a href="#Spring-MVC-有什么优点？" class="headerlink" title="Spring MVC 有什么优点？"></a>Spring MVC 有什么优点？</h2><ol>
<li>使用真的真的真的非常<strong>方便</strong>，无论是添加 HTTP 请求方法映射的方法，还是不同数据格式的响应。</li>
<li>提供<strong>拦截器机制</strong>，可以方便的对请求进行拦截处理。</li>
<li>提供<strong>异常机制</strong>，可以方便的对异常做统一处理。</li>
<li>可以任意使用各种<strong>视图</strong>技术，而不仅仅局限于 JSP ，例如 Freemarker、Thymeleaf 等等。</li>
<li>不依赖于 Servlet API (目标虽是如此，但是在实现的时候确实是依赖于 Servlet 的，当然仅仅依赖 Servlet ，而不依赖 Filter、Listener )。</li>
</ol>
<h2 id="Spring-MVC-怎样设定重定向和转发-？"><a href="#Spring-MVC-怎样设定重定向和转发-？" class="headerlink" title="Spring MVC 怎样设定重定向和转发 ？"></a>Spring MVC 怎样设定重定向和转发 ？</h2><ul>
<li>结果转发：在返回值的前面加 <code>&quot;forward:/&quot;</code> 。</li>
<li>重定向：在返回值的前面加上 <code>&quot;redirect:/&quot;</code> 。</li>
</ul>
<p>当然，目前前后端分离之后，我们作为后端开发，已经很少有机会用上这个功能了。</p>
<h2 id="Spring-MVC-的-Controller-是不是单例？"><a href="#Spring-MVC-的-Controller-是不是单例？" class="headerlink" title="Spring MVC 的 Controller 是不是单例？"></a>Spring MVC 的 Controller 是不是单例？</h2><p>绝绝绝大多数情况下，Controller 是<strong>单例</strong>。</p>
<p>那么，Controller 里一般不建议存在<strong>共享的变量</strong>。实际场景下，艿艿也没碰到需要使用共享变量的情况。</p>
<h2 id="Spring-MVC-和-Struts2-的异同？"><a href="#Spring-MVC-和-Struts2-的异同？" class="headerlink" title="Spring MVC 和 Struts2 的异同？"></a>Spring MVC 和 Struts2 的异同？</h2><ol>
<li><p>入口</p>
<p>不同</p>
<ul>
<li>Spring MVC 的入门是一个 Servlet <strong>控制器</strong>。</li>
<li>Struts2 入门是一个 Filter <strong>过滤器</strong>。</li>
</ul>
</li>
<li><p>配置映射</p>
<p>不同，</p>
<ul>
<li>Spring MVC 是基于<strong>方法</strong>开发，传递参数是通过<strong>方法形参</strong>，一般设置为<strong>单例</strong>。</li>
<li>Struts2 是基于<strong>类</strong>开发，传递参数是通过<strong>类的属性</strong>，只能设计为<strong>多例</strong>。 </li>
</ul>
</li>
</ol>
<ul>
<li><p>视图</p>
<p>不同</p>
<ul>
<li>Spring MVC 通过参数解析器是将 Request 对象内容进行解析成方法形参，将响应数据和页面封装成 <strong>ModelAndView</strong> 对象，最后又将模型数据通过 <strong>Request</strong> 对象传输到页面。其中，如果视图使用 JSP 时，默认使用 <strong>JSTL</strong> 。</li>
<li>Struts2 采用<strong>值栈</strong>存储请求和响应的数据，通过 <strong>OGNL</strong> 存取数据。</li>
</ul>
</li>
</ul>
<p>当然，更详细的也可以看看 <a href="http://www.voidcn.com/article/p-ylualwcj-c.html">《面试题：Spring MVC 和 Struts2 的区别》</a> 一文。</p>
<h2 id="详细介绍下-Spring-MVC-拦截器？"><a href="#详细介绍下-Spring-MVC-拦截器？" class="headerlink" title="详细介绍下 Spring MVC 拦截器？"></a>详细介绍下 Spring MVC 拦截器？</h2><p><code>org.springframework.web.servlet.HandlerInterceptor</code> ，拦截器接口。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; HandlerInterceptor.java<br><br>&#x2F;**<br> * 拦截处理器，在 &#123;@link HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行之前<br> *&#x2F;<br>default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)<br>		throws Exception &#123;<br>	return true;<br>&#125;<br><br>&#x2F;**<br> * 拦截处理器，在 &#123;@link HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行成功之后<br> *&#x2F;<br>default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,<br>		@Nullable ModelAndView modelAndView) throws Exception &#123;<br>&#125;<br><br>&#x2F;**<br> * 拦截处理器，在 &#123;@link HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行完之后，无论成功还是失败<br> *<br> * 并且，只有该处理器 &#123;@link #preHandle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行成功之后，才会被执行<br> *&#x2F;<br>default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,<br>		@Nullable Exception ex) throws Exception &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>一共有三个方法，分别为：</p>
<ul>
<li><p><code>#preHandle(...)</code> 方法，调用 Controller 方法之<strong>前</strong>执行。 </p>
</li>
<li><p><code>#postHandle(...)</code> 方法，调用 Controller 方法之<strong>后</strong>执行。</p>
</li>
<li><pre><code>#afterCompletion(...)</code></pre>
<p> 方法，处理完 Controller 方法返回结果之</p>
<p>后</p>
<p>执行。</p>
<ul>
<li>例如，页面渲染后。</li>
<li><strong>当然，要注意，无论调用 Controller 方法是否成功，都会执行</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>举个例子：</p>
<ul>
<li>当俩个拦截器都实现放行操作时，执行顺序为 <code>preHandle[1] =&gt;  preHandle[2] =&gt; postHandle[2] =&gt; postHandle[1] =&gt; afterCompletion[2] =&gt; afterCompletion[1]</code> 。</li>
<li>当第一个拦截器 <code>#preHandle(...)</code> 方法返回 <code>false</code> ，也就是对其进行拦截时，第二个拦截器是完全不执行的，第一个拦截器只执行 <code>#preHandle(...)</code> 部分。</li>
<li>当第一个拦截器 <code>#preHandle(...)</code> 方法返回 <code>true</code> ，第二个拦截器 <code>#preHandle(...)</code> 返回 <code>false</code> ，执行顺序为 <code>preHandle[1] =&gt; preHandle[2] =&gt; afterCompletion[1]</code> 。</li>
</ul>
</li>
<li><p>总结来说：</p>
<ul>
<li><code>#preHandle(...)</code> 方法，按拦截器定义<strong>顺序</strong>调用。若任一拦截器返回 <code>false</code> ，则 Controller 方法不再调用。</li>
<li><code>#postHandle(...)</code> 和 <code>#afterCompletion(...)</code> 方法，按拦截器定义<strong>逆序</strong>调用。</li>
<li><code>#postHandler(...)</code> 方法，在调用 Controller 方法之<strong>后</strong>执行。</li>
<li><code>#afterCompletion(...)</code> 方法，只有该拦截器在 <code>#preHandle(...)</code> 方法返回 <code>true</code> 时，才能够被调用，且一定会被调用。为什么“且一定会被调用”呢？即使 <code>#afterCompletion(...)</code> 方法，按拦截器定义<strong>逆序</strong>调用时，前面的拦截器发生异常，后面的拦截器还能够调用，<strong>即无视异常</strong>。</li>
</ul>
</li>
</ul>
<hr>
<p>关于这块，可以看看如下两篇文章：</p>
<ul>
<li><a href="https://blog.csdn.net/amaxiaochen/article/details/77210880">《Spring MVC 多个拦截器执行顺序及拦截器使用方法》</a> 文章，通过<strong>实践</strong>更加理解。</li>
<li><a href="http://svip.iocoder.cn/Spring-MVC/HandlerMapping-2-HandlerInterceptor/">《精尽 Spring MVC 源码分析 —— HandlerMapping 组件（二）之 HandlerInterceptor》</a> 文章，通过<strong>源码</strong>更加理解。</li>
</ul>
<h2 id="Spring-MVC-的拦截器可以做哪些事情？"><a href="#Spring-MVC-的拦截器可以做哪些事情？" class="headerlink" title="Spring MVC 的拦截器可以做哪些事情？"></a>Spring MVC 的拦截器可以做哪些事情？</h2><p>拦截器能做的事情非常非常非常多，例如：</p>
<ul>
<li>记录访问日志。</li>
<li>记录异常日志。</li>
<li>需要登陆的请求操作，拦截未登陆的用户。</li>
<li>…</li>
</ul>
<h2 id="Spring-MVC-的拦截器和-Filter-过滤器有什么差别？"><a href="#Spring-MVC-的拦截器和-Filter-过滤器有什么差别？" class="headerlink" title="Spring MVC 的拦截器和 Filter 过滤器有什么差别？"></a>Spring MVC 的拦截器和 Filter 过滤器有什么差别？</h2><p>看了文章 <a href="https://blog.csdn.net/xiaodanjava/article/details/32125687">《过滤器( Filter )和拦截器( Interceptor )的区别》</a> ，感觉对比的怪怪的。艿艿觉得主要几个点吧：</p>
<ul>
<li><strong>功能相同</strong>：拦截器和 Filter都能实现相应的功能，谁也不比谁强。</li>
<li><strong>容器不同</strong>：拦截器构建在 Spring MVC 体系中；Filter 构建在 Servlet 容器之上。</li>
<li><strong>使用便利性不同</strong>：拦截器提供了三个方法，分别在不同的时机执行；过滤器仅提供一个方法，当然也能实现拦截器的执行时机的效果，就是麻烦一些。</li>
</ul>
<p>另外，😈 再补充一点小知识。我们会发现，拓展性好的框架，都会提供相应的拦截器或过滤器机制，方便的我们做一些拓展。例如：</p>
<ul>
<li>Dubbo 的 Filter 机制。</li>
<li>Spring Cloud Gateway 的 Filter 机制。</li>
<li>Struts2 的拦截器机制。</li>
</ul>
<h1 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h1><p>本小节的内容，基本是基于 <a href="http://www.spring4all.com/article/1445">《排名前 20 的 REST 和 Spring MVC 面试题》</a> 之上，做增补。</p>
<h2 id="REST-代表着什么"><a href="#REST-代表着什么" class="headerlink" title="REST 代表着什么?"></a>REST 代表着什么?</h2><p>REST 代表着抽象状态转移，它是根据 HTTP 协议从客户端发送数据到服务端，例如：服务端的一本书可以以 XML 或 JSON 格式传递到客户端。</p>
<p>然而，假如你不熟悉REST，我建议你先看看 <a href="http://bit.ly/2zIGzWK">REST API design and development</a> 这篇文章来更好的了解它。不过对于大多数胖友的英语，可能不太好，所以也可以阅读知乎上的 <a href="https://www.zhihu.com/question/28557115">《怎样用通俗的语言解释 REST，以及 RESTful？》</a> 讨论。</p>
<h2 id="资源是什么"><a href="#资源是什么" class="headerlink" title="资源是什么?"></a>资源是什么?</h2><p>资源是指数据在 REST 架构中如何显示的。将实体作为资源公开 ，它允许客户端通过 HTTP 方法如：<a href="http://javarevisited.blogspot.sg/2012/03/get-post-method-in-http-and-https.html">GET</a>, <a href="http://www.java67.com/2014/08/difference-between-post-and-get-request.html">POST</a>,<a href="http://www.java67.com/2016/09/when-to-use-put-or-post-in-restful-web-services.html">PUT</a>, DELETE 等读，写，修改和创建资源。</p>
<h2 id="什么是安全的-REST-操作"><a href="#什么是安全的-REST-操作" class="headerlink" title="什么是安全的 REST 操作?"></a>什么是安全的 REST 操作?</h2><p>REST 接口是通过 HTTP 方法完成操作。</p>
<ul>
<li>一些HTTP操作是安全的，如 GET 和 HEAD ，它不能在服务端修改资源</li>
<li>换句话说，PUT,POST 和 DELETE 是不安全的，因为他们能修改服务端的资源。</li>
</ul>
<p>所以，是否安全的界限，在于<strong>是否修改</strong>服务端的资源。</p>
<h2 id="什么是幂等操作-为什么幂等操作如此重要"><a href="#什么是幂等操作-为什么幂等操作如此重要" class="headerlink" title="什么是幂等操作? 为什么幂等操作如此重要?"></a>什么是幂等操作? 为什么幂等操作如此重要?</h2><p>有一些HTTP方法，如：GET，不管你使用多少次它都能产生相同的结果，在没有任何一边影响的情况下，发送多个 GET 请求到相同的<a href="http://www.java67.com/2013/01/difference-between-url-uri-and-urn.html">URI</a> 将会产生相同的响应结果。因此，这就是所谓<strong>幂等</strong>操作。</p>
<p>换句话说，<a href="http://javarevisited.blogspot.sg/2016/05/what-are-idempotent-and-safe-methods-of-HTTP-and-REST.html">POST方法不是幂等操作</a> ，因为如果发送多个 POST 请求，它将在服务端创建不同的资源。但是，假如你用PUT更新资源，它将是幂等操作。</p>
<p>甚至多个 PUT 请求被用来更新服务端资源，将得到相同的结果。你可以通过 Pluralsight 学习 <a href="http://pluralsight.pxf.io/c/1193463/424552/7490?u=https://www.pluralsight.com/courses/xhttp-fund">HTTP Fundamentals</a> 课程来了解 HTTP 协议和一般的 HTTP 的更多幂等操作。</p>
<h2 id="REST-是可扩展的或说是协同的吗"><a href="#REST-是可扩展的或说是协同的吗" class="headerlink" title="REST 是可扩展的或说是协同的吗?"></a>REST 是可扩展的或说是协同的吗?</h2><p>是的，<a href="http://javarevisited.blogspot.sg/2015/08/difference-between-soap-and-restfull-webservice-java.html">REST</a> 是可扩展的和可协作的。它既不托管一种特定的技术选择，也不定在客户端或者服务端。你可以用 <a href="http://javarevisited.blogspot.sg/2017/11/top-5-free-java-courses-for-beginners.html">Java</a>, <a href="http://www.java67.com/2018/02/5-free-cpp-courses-to-learn-programming.html">C++</a>, <a href="http://www.java67.com/2018/02/5-free-python-online-courses-for-beginners.html">Python</a>, 或 <a href="http://www.java67.com/2018/04/top-5-free-javascript-courses-to-learn.html">JavaScript</a> 来创建 RESTful Web 服务，也可以在客户端使用它们。</p>
<p>我建议你读一本关于REST接口的书来了解更多，如：<a href="http://javarevisited.blogspot.sg/2017/02/top-5-books-to-learn-rest-and-restful-web-services-in-java.html">RESTful Web Services</a> 。</p>
<blockquote>
<p>艿艿：所以这里的“可拓展”、“协同”对应到我们平时常说的，“跨语言”、“语言无关”。</p>
</blockquote>
<h2 id="REST-用哪种-HTTP-方法呢"><a href="#REST-用哪种-HTTP-方法呢" class="headerlink" title="REST 用哪种 HTTP 方法呢?"></a>REST 用哪种 HTTP 方法呢?</h2><p>REST 能用任何的 HTTP 方法，但是，最受欢迎的是：</p>
<ul>
<li>用 GET 来检索服务端资源</li>
<li>用 POST 来创建服务端资源</li>
<li><a href="http://javarevisited.blogspot.sg/2016/04/what-is-purpose-of-http-request-types-in-RESTful-web-service.html#axzz56WGunSwy">用 PUT 来更新服务端资源</a> </li>
<li>用 DELETE 来删除服务端资源。</li>
</ul>
<p>恰好，这四个操作，对上我们日常逻辑的 CRUD 操作。</p>
<blockquote>
<p>艿艿：经常能听到胖友抱怨自己做的都是 CRUD 的功能。看了这个面试题，有没觉得原来 CRUD 也能玩的稍微高级一点？！</p>
<p>实际上，每个 CRUD 也是可以通过不断的打磨，玩的很高级。例如说 DDD 领域驱动，完整的单元测试，可扩展的设计。</p>
</blockquote>
<h2 id="删除的-HTTP-状态返回码是什么"><a href="#删除的-HTTP-状态返回码是什么" class="headerlink" title="删除的 HTTP 状态返回码是什么 ?"></a>删除的 HTTP 状态返回码是什么 ?</h2><p>在删除成功之后，您的 REST API 应该返回什么状态代码，并没有严格的规则。它可以返回 200 或 204 没有内容。</p>
<ul>
<li>一般来说，如果删除操作成功，响应主体为空，返回 <a href="http://www.netingcn.com/http-status-204.html">204</a> 。</li>
<li>如果删除请求成功且响应体不是空的，则返回 200 。</li>
</ul>
<h2 id="REST-API-是无状态的吗"><a href="#REST-API-是无状态的吗" class="headerlink" title="REST API 是无状态的吗?"></a>REST API 是无状态的吗?</h2><p><strong>是的</strong>，REST API 应该是无状态的，因为它是基于 HTTP 的，它也是无状态的。</p>
<p>REST API 中的请求应该包含处理它所需的所有细节。它<strong>不应该</strong>依赖于以前或下一个请求或服务器端维护的一些数据，例如会话。</p>
<p><strong>REST 规范为使其无状态设置了一个约束，在设计 REST API 时，您应该记住这一点</strong>。</p>
<h2 id="REST安全吗-你能做什么来保护它"><a href="#REST安全吗-你能做什么来保护它" class="headerlink" title="REST安全吗? 你能做什么来保护它?"></a>REST安全吗? 你能做什么来保护它?</h2><p>安全是一个宽泛的术语。它可能意味着消息的安全性，这是通过认证和授权提供的加密或访问限制提供的。</p>
<p>REST 通常不是安全的，但是您可以通过使用 Spring Security 来保护它。</p>
<ul>
<li>至少，你可以通过在 Spring Security 配置文件中使用 HTTP 来启用 HTTP Basic Auth 基本认证。</li>
<li>类似地，如果底层服务器支持 HTTPS ，你可以使用 HTTPS 公开 REST API 。</li>
</ul>
<h2 id="RestTemplate-的优势是什么"><a href="#RestTemplate-的优势是什么" class="headerlink" title="RestTemplate 的优势是什么?"></a>RestTemplate 的优势是什么?</h2><p>在 Spring Framework 中，RestTemplate 类是 <a href="http://www.java67.com/2012/09/top-10-java-design-pattern-interview-question-answer.html">模板方法模式</a> 的实现。跟其他主流的模板类相似，如 JdbcTemplate 或 JmsTempalte ，它将在客户端简化跟 RESTful Web  服务的集成。正如在 RestTemplate 例子中显示的一样，你能非常容易地用它来调用 RESTful Web 服务。</p>
<blockquote>
<p>艿艿：当然，实际场景我还是更喜欢使用 <a href="http://square.github.io/okhttp/">OkHttp</a> 作为 HTTP 库，因为更好的性能，使用也便捷，并且无需依赖 Spring 库。</p>
</blockquote>
<h2 id="HttpMessageConverter-在-Spring-REST-中代表什么"><a href="#HttpMessageConverter-在-Spring-REST-中代表什么" class="headerlink" title="HttpMessageConverter 在 Spring REST 中代表什么?"></a>HttpMessageConverter 在 Spring REST 中代表什么?</h2><p>HttpMessageConverter 是一种<a href="http://www.java67.com/2014/12/strategy-pattern-in-java-with-example.html">策略接口</a> ，它指定了一个转换器，它可以转换 HTTP 请求和响应。Spring REST 用这个接口转换 HTTP 响应到多种格式，例如：JSON 或 XML 。</p>
<p>每个 HttpMessageConverter 实现都有一种或几种相关联的MIME协议。Spring 使用 <code>&quot;Accept&quot;</code> 的标头来确定客户端所期待的内容类型。</p>
<p>然后，它将尝试找到一个注册的 HTTPMessageConverter ，它能够处理特定的内容类型，并使用它将响应转换成这种格式，然后再将其发送给客户端。</p>
<p>如果胖友对 HttpMessageConverter 不了解，可以看看 <a href="https://leokongwq.github.io/2017/06/14/spring-MessageConverter.html">《Spring 中 HttpMessageConverter 详解》</a> 。</p>
<h2 id="如何创建-HttpMessageConverter-的自定义实现来支持一种新的请求-响应？"><a href="#如何创建-HttpMessageConverter-的自定义实现来支持一种新的请求-响应？" class="headerlink" title="如何创建 HttpMessageConverter 的自定义实现来支持一种新的请求/响应？"></a>如何创建 HttpMessageConverter 的自定义实现来支持一种新的请求/响应？</h2><p>我们仅需要创建自定义的 AbstractHttpMessageConverter 的实现，并使用 WebMvcConfigurerAdapter 的 <code>#extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</code> 方法注中册它，该方法可以生成一种新的请求 / 响应类型。</p>
<p>具体的示例，可以学习 <a href="https://github.com/alibaba/fastjson/wiki/%E5%9C%A8-Spring-%E4%B8%AD%E9%9B%86%E6%88%90-Fastjson">《在 Spring 中集成 Fastjson》</a> 文章。</p>
<h2 id="PathVariable-注解，在-Spring-MVC-做了什么-为什么-REST-在-Spring-中如此有用？"><a href="#PathVariable-注解，在-Spring-MVC-做了什么-为什么-REST-在-Spring-中如此有用？" class="headerlink" title="@PathVariable 注解，在 Spring MVC 做了什么? 为什么 REST 在 Spring 中如此有用？"></a>@PathVariable 注解，在 Spring MVC 做了什么? 为什么 REST 在 Spring 中如此有用？</h2><p><code>@PathVariable</code> 注解，是 Spring MVC 中有用的注解之一，它允许您从 URI 读取值，比如查询参数。它在使用 Spring 创建 RESTful Web 服务时特别有用，因为在 REST 中，资源标识符是 URI 的一部分。</p>
<p>具体的使用示例，胖友如果不熟悉，可以看看 <a href="https://blog.csdn.net/cx361006796/article/details/52829759">《Spring MVC 的 @RequestParam 注解和 @PathVariable 注解的区别》</a> 。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>文末的文末，艿艿还是那句话！！！！还是非常推荐胖友去撸一撸 Spring MVC 的源码，特别是如下两篇：</p>
<ul>
<li><a href="http://svip.iocoder.cn/Spring-MVC/Components-intro/">《精尽 Spring MVC 源码分析 —— 组件一览》</a></li>
<li><a href="http://svip.iocoder.cn/Spring-MVC/DispatcherServlet-process-request-intro/">《精尽 Spring MVC 源码分析 —— 请求处理一览》</a></li>
</ul>
<p>参考和推荐如下文章：</p>
<ul>
<li><a href="http://www.spring4all.com/article/1445">《排名前 20 的 REST 和 Spring MVC 面试题》</a></li>
<li><a href="http://www.iocoder.cn/Fight/Learn-Restful-HTTP-API-design-from-Github/">《跟着 Github 学习 Restful HTTP API 的优雅设计》</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring MVC</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>精尽 Java【基础】面试题</title>
    <url>/2016/10/12/%E7%B2%BE%E5%B0%BD%20Java%E3%80%90%E5%9F%BA%E7%A1%80%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="精尽-Java【基础】面试题"><a href="#精尽-Java【基础】面试题" class="headerlink" title="精尽 Java【基础】面试题"></a>精尽 Java【基础】面试题</h1><p>以下面试题，基于网络整理，和自己编辑。具体参考的文章，会在文末给出所有的链接。</p>
<p>如果胖友有自己的疑问，欢迎在星球提问，我们一起整理吊吊的 Java【基础】面试题的大保健。</p>
<p>而题目的难度，艿艿尽量按照从容易到困难的顺序，逐步下去。</p>
<p>考虑到 Java 涉及的知识点非常非常非常之多，所以我们会分成五大篇来分享，分别是：</p>
<ul>
<li><p>Java【基础】</p>
<blockquote>
<p>本文。😈 分不到其它类别里的，都会放到本文。</p>
</blockquote>
</li>
<li><p>Java【集合】</p>
</li>
<li><p>Java【并发】</p>
</li>
<li><p>Java【网络】</p>
<blockquote>
<p>因为 Java 网络编程大多使用 Netty ，所以面试题统一整理到 <a href="http://svip.iocoder.cn/Netty/Interview">《精尽 Netty 面试题》</a> 中，避免重复。</p>
</blockquote>
</li>
<li><p>Java【虚拟机】</p>
</li>
</ul>
<h2 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h2><p>面向对象是一种思想，世间万物都可以看做一个对象，这里只讨论面向对象编程（OOP），Java 是一个支持并发、基于类和面向对象的计算机编程语言。面向对象软件开发具有以下优点：</p>
<ul>
<li>代码开发模块化，更易维护和修改。</li>
<li>代码复用性强。</li>
<li>增强代码的可靠性和灵活性。</li>
<li>增加代码的可读性。</li>
</ul>
<p>🦅 <strong>请说说面向对象的特征？</strong></p>
<p>四点：<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong>、<strong>抽象</strong>。</p>
<blockquote>
<p>艿艿：这个题目，能说出上述四点就好了。</p>
</blockquote>
<p>1）封装</p>
<p>封装，给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在 Java 当中，有 4 种修饰符： <code>default</code>、<code>public</code>、<code>private</code> 和 <code>protected</code> 。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。</p>
<p>下面列出了使用封装的一些好处：</p>
<ul>
<li>通过隐藏对象的属性来保护对象内部的状态。</li>
<li>提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。</li>
<li>禁止对象之间的不良交互提高模块化。</li>
</ul>
<p>2）继承</p>
<p>继承，给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。</p>
<p>3）多态</p>
<p>多态，是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作，可以应用到其他类型的值上面。</p>
<p>4）抽象</p>
<p>抽象，是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。</p>
<p>Java 支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。</p>
<p>🦅 <strong>面向对象和面向过程的区别？</strong></p>
<ul>
<li>面向过程<ul>
<li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源。比如，单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发，性能是最重要的因素。</li>
<li>缺点：没有面向对象易维护、易复用、易扩展。</li>
</ul>
</li>
<li>面向对象<ul>
<li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。</li>
<li>缺点：性能比面向过程低。</li>
</ul>
</li>
</ul>
<p>🦅 <strong>重载和重写的区别？</strong></p>
<p>1）重写 <code>override</code></p>
<ul>
<li>方法名、参数、返回值相同。</li>
<li>子类方法不能缩小父类方法的访问权限。</li>
<li>子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。</li>
<li>存在于父类和子类之间。</li>
<li>方法被定义为 <code>final</code> 不能被重写。</li>
</ul>
<p>2）重载 <code>overload</code></p>
<ul>
<li>参数类型、个数、顺序至少有一个不相同。</li>
<li>不能重载只有返回值不同的方法名。</li>
<li>存在于父类和子类、同类中。</li>
</ul>
<p>🦅 <strong>对比图</strong></p>
<p><a href="https://user-gold-cdn.xitu.io/2018/5/9/16342c734014a933?imageView2/0/w/1280/h/960/format/jpeg/ignore-error/1">对比图</a></p>
<p>🦅 <strong>Java 中，什么是构造方法？什么是构造方法重载？什么是拷贝构造方法？</strong></p>
<p>1）构造方法</p>
<p>当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java 编译器会为这个类创建一个默认的构造方法。</p>
<p>2）构造方法重载</p>
<p>Java 中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。</p>
<p>3）拷贝构造方法</p>
<p>Java 不支持像 C++ 中那样的<a href="http://www.runoob.com/cplusplus/cpp-copy-constructor.html">拷贝构造方法</a>，这个不同点是因为如果你不自己写构造方法的情况下，Java 不会创建默认的拷贝构造方法。</p>
<h2 id="JDK、JRE、JVM-分别是什么关系？"><a href="#JDK、JRE、JVM-分别是什么关系？" class="headerlink" title="JDK、JRE、JVM 分别是什么关系？"></a>JDK、JRE、JVM 分别是什么关系？</h2><p>🦅 <strong>JDK</strong></p>
<p>JDK 即为 Java 开发工具包，包含编写 Java 程序所必须的编译、运行等开发工具以及 JRE。开发工具如：</p>
<ul>
<li>用于编译 Java 程序的 javac 命令。</li>
<li>用于启动 JVM 运行 Java 程序的 Java 命令。</li>
<li>用于生成文档的 Javadoc 命令。</li>
<li>用于打包的 jar 命令等等。</li>
</ul>
<blockquote>
<p>简单说，就是 JDK 包含 JRE 包含 JVM。</p>
</blockquote>
<p>🦅 <strong>JRE</strong></p>
<p>JRE 即为 Java 运行环境，提供了运行 Java 应用程序所必须的软件环境，包含有 Java 虚拟机（JVM）和丰富的系统类库。系统类库即为 Java 提前封装好的功能类，只需拿来直接使用即可，可以大大的提高开发效率。</p>
<blockquote>
<p>简单说，就是 JRE 包含 JVM。</p>
</blockquote>
<p>🦅 <strong>JVM</strong></p>
<p>JVM 即为 Java 虚拟机，提供了字节码文件(<code>.class</code>)的运行环境支持。</p>
<blockquote>
<p><img src="http://cdn.tuwenbin.vip/57u4a9gq.bmp" alt="57u4a9gq">JDK &gt; JRE &gt; JVM</p>
</blockquote>
<p>🦅 <strong>为什么 Java 被称作是“平台无关的编程语言”？</strong></p>
<p>Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。</p>
<ul>
<li>Java 源文件( <code>.java</code> )被编译成能被 Java 虚拟机执行的字节码文件( <code>.class</code> )。</li>
<li>Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</li>
</ul>
<p>🦅 <strong>JDK 各版本的新特性？</strong></p>
<ul>
<li>JDK5 ~ JDK10 ，看 <a href="https://www.jianshu.com/p/37b52f1ebd4a">https://www.jianshu.com/p/37b52f1ebd4a</a> 。</li>
<li>JDK11 ，看 <a href="https://www.jianshu.com/p/81b65eded96c">https://www.jianshu.com/p/81b65eded96c</a> 。</li>
</ul>
<p>对于大多数面试官，肯定不会问你 JDK 各版本的新特性，更多的会问 JDK8 引入了什么重要的特性？一般上，关键的回答是Lambda 表达式和集合之流式操作，然后说说你在项目中怎么使用的。</p>
<p>🦅 <strong>Java 和 C++ 的区别？</strong></p>
<ul>
<li>都是面向对象的语言，都支持封装、继承和多态。</li>
<li>Java 不提供指针来直接访问内存，程序内存更加安全。</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>
<li>【重要】Java 有自动内存管理机制，不需要程序员手动释放无用内存。</li>
</ul>
<h2 id="什么是字节码？采用字节码的最大好处是什么？"><a href="#什么是字节码？采用字节码的最大好处是什么？" class="headerlink" title="什么是字节码？采用字节码的最大好处是什么？"></a>什么是字节码？采用字节码的最大好处是什么？</h2><p>🦅 <strong>什么是字节码？</strong></p>
<blockquote>
<p>这个问题，面试官可以衍生提问，Java 是编译执行的语言，还是解释执行的语言。</p>
</blockquote>
<p>Java 中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。</p>
<p>编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在 Java 中，这种供虚拟机理解的代码叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。</p>
<p>每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java 源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。<strong>这也就是解释了 Java 的编译与解释并存的特点</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Java 源代码<br>&#x3D;&gt; 编译器 &#x3D;&gt; JVM 可执行的 Java 字节码(即虚拟指令)<br>&#x3D;&gt; JVM &#x3D;&gt; JVM 中解释器 &#x3D;&gt; 机器可执行的二进制机器码 &#x3D;&gt; 程序运行<br></code></pre></td></tr></table></figure>

<p>🦅 <strong>采用字节码的好处？</strong></p>
<p>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p>
<blockquote>
<p>解释型语言：解释型语言，是在运行的时候将程序翻译成机器语言。解释型语言的程序不需要在运行前编译，在运行程序的时候才翻译，专门的解释器负责在每个语句执行的时候解释程序代码。这样解释型语言每执行一次就要翻译一次，效率比较低。——百度百科</p>
<p>例如：Python、PHP 。</p>
</blockquote>
<h2 id="Java-中的几种基本数据类型是什么？各自占用多少字节？"><a href="#Java-中的几种基本数据类型是什么？各自占用多少字节？" class="headerlink" title="Java 中的几种基本数据类型是什么？各自占用多少字节？"></a>Java 中的几种基本数据类型是什么？各自占用多少字节？</h2><p>Java 支持的数据类型包括基本数据类型和引用类型。</p>
<p><strong>基本数据</strong>类型如下：</p>
<ul>
<li>整数值型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>
<li>字符型：<code>char</code></li>
<li>浮点类型：<code>float</code>、<code>double</code></li>
<li>布尔型：<code>boolean</code></li>
<li>整数型：默认 <code>int</code> 型，小数默认是 <code>double</code> 型。Float 和 Long 类型的必须加后缀。比如：<code>float f = 100f</code> 。</li>
</ul>
<p><strong>引用类型</strong>声明的变量是指该变量在内存中实际存储的是一个引用地址，实体在堆中。</p>
<ul>
<li>引用类型包括类、接口、数组等。</li>
<li>特别注意，String 是引用类型不是基本类型。</li>
</ul>
<p>🦅 <strong>什么是值传递和引用传递？</strong></p>
<ul>
<li>值传递，是对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。</li>
<li>引用传递，一般是对于对象型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身。</li>
</ul>
<p>一般认为，Java 内的传递都是值传递，Java 中实例对象的传递是引用传递。</p>
<p>🦅 <strong>是否可以在 static 环境中访问非 static 变量？</strong></p>
<p><code>static</code> 变量在 Java 中是属于类的，它在所有的实例中的值是一样的。当类被 Java 虚拟机载入的时候，会对 <code>static</code> 变量进行初始化。</p>
<p>如果你的代码尝试不用实例来访问非 <code>static</code> 的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p>
<p>🦅 <strong>char 型变量中能不能存贮一个中文汉字？为什么？</strong></p>
<ul>
<li>在 C 语言中，char 类型占 1 个字节，而汉字占 2 个字节，所以不能存储。</li>
<li>在 Java 语言中，char 类型占 2 个字节，而且 Java 默认采用 Unicode 编码，一个 Unicode 码是 16  位，所以一个 Unicode 码占两个字节，Java 中无论汉字还是英文字母，都是用 Unicode 编码来表示的。所以，在 Java  中，char 类型变量可以存储一个中文汉字。</li>
</ul>
<h2 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h2><p>Java 平台提供了两种类型的字符串：String 和 StringBuffer/StringBuilder，它们可以储存和操作字符串。</p>
<ul>
<li><p>String ，是只读字符串，也就意味着 String 引用的字符串内容是不能被改变的。</p>
<blockquote>
<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。</p>
</blockquote>
</li>
<li><p>StringBuffer/StringBuilder 类，表示的字符串对象可以直接进行修改。StringBuilder 是 Java 5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被 <code>synchronized</code> 修饰，因此它的效率也比 StringBuffer 要高。</p>
<blockquote>
<p>StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。</p>
<p>相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
</blockquote>
</li>
</ul>
<p>🦅 <strong>对于三者使用的总结？</strong></p>
<ul>
<li><p>操作少量的数据 = String 。</p>
<blockquote>
<p>这个也是实际编码较为经常使用的方式。</p>
</blockquote>
</li>
<li><p>单线程操作字符串缓冲区下操作大量数据 = StringBuilder 。</p>
<blockquote>
<p>甚至有时，我们为了避免每个线程重复创建 StringBuilder 对象，会通过 ThreadLocal + StringBuilder 的方式，进行对 StringBuilder 的重用。具体可以参考 <a href="http://nathanchen.github.io/14596982516208.html">《StringBuilder 在高性能场景下的正确用法》</a> 文章。</p>
</blockquote>
</li>
<li><p>多线程操作字符串缓冲区下操作大量数据 = StringBuffer</p>
<blockquote>
<p>实际场景下，我们基本不太会出现，多线程操作同一个 StringBuffer 对象。</p>
</blockquote>
</li>
</ul>
<p>🦅 <strong><code>String s = new String(&quot;xyz&quot;)</code> 会创建几个对象？</strong></p>
<ul>
<li>首先，在 String 池内找，找到 <code>&quot;xyz&quot;</code> 字符串，不创建 <code>&quot;xyz&quot;</code> 对应的 String 对象，否则创建一个对象。</li>
<li>然后，遇到 <code>new</code> 关键字，在内存上创建 String 对象，并将其返回给 <code>s</code> ，又一个对象。</li>
</ul>
<p>所以，总共是 1 个或者 2 个对象。</p>
<p>具体的，可以看看 <a href="https://blog.csdn.net/tzs_1041218129/article/details/69367423">《关于String s = new String(“xyz”); 创建几个对象的问题》</a> 文章的测试代码。</p>
<p>🦅 <strong>String 为什么是不可变的？</strong></p>
<p>简单的来说，String 类中使用 <code>final</code> 关键字字符数组保存字符串。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; String.java<br><br>private final char[] value;<br></code></pre></td></tr></table></figure>

<ul>
<li>所以 String 对象是不可变的。</li>
</ul>
<p>而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串 <code>char[] value</code> ，但是没有用 <code>final</code> 关键字修饰。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; AbstractStringBuilder.java<br><br>char[] value;<br></code></pre></td></tr></table></figure>

<ul>
<li>所以这两种对象都是可变的。</li>
</ul>
<p>🦅 <strong>StringTokenizer 是什么？</strong></p>
<p>StringTokenizer ，是一个用来分割字符串的工具类。</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">StringTokenizer st &#x3D; new StringTokenizer(”Hello World”);<br>while (st.hasMoreTokens()) &#123;<br>    System.out.println(st.nextToken());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Hello<br>World<br></code></pre></td></tr></table></figure>

<h2 id="什么是自动拆装箱？"><a href="#什么是自动拆装箱？" class="headerlink" title="什么是自动拆装箱？"></a>什么是自动拆装箱？</h2><p>自动装箱和拆箱，就是基本类型和引用类型之间的转换。</p>
<p>🦅 <strong>为什么要转换？</strong></p>
<p>如果你在 Java5 下进行过编程的话，你一定不会陌生这一点，你不能直接地向集合( Collection )中放入原始类型值，因为集合只接收对象。</p>
<ul>
<li>通常这种情况下你的做法是，将这些原始类型的值转换成对象，然后将这些转换的对象放入集合中。使用 Integer、Double、Boolean 等这些类，我们可以将原始类型值转换成对应的对象，但是从某些程度可能使得代码不是那么简洁精炼。</li>
<li>为了让代码简练，Java5 引入了具有在原始类型和对象类型自动转换的装箱和拆箱机制。</li>
<li>但是自动装箱和拆箱并非完美，在使用时需要有一些注意事项，如果没有搞明白自动装箱和拆箱，可能会引起难以察觉的 Bug 。</li>
</ul>
<p>🦅 <strong>int 和 Integer 有什么区别？</strong></p>
<ul>
<li><code>int</code> 是基本数据类型。</li>
<li>Integer 是其包装类，注意是一个类。</li>
</ul>
<p>当然，要注意下 Integer 的缓存策略，可以看看 <a href="http://www.importnew.com/18884.html">《理解Java Integer 的缓存策略》</a> 文章。</p>
<h2 id="equals-与-的区别？"><a href="#equals-与-的区别？" class="headerlink" title="equals 与 == 的区别？"></a>equals 与 == 的区别？</h2><ul>
<li><p>值类型（<code>int</code>,<code>char</code>,<code>long</code>,<code>boolean</code>等）的话</p>
<ul>
<li>都是用 == 判断相等性。</li>
</ul>
</li>
<li><p>对象引用的话</p>
<ul>
<li><p>== 判断引用所指的对象是否是同一个。</p>
</li>
<li><p>equals 方法，是 Object 的成员函数，有些类会覆盖(<code>override</code>) 这个方法，用于判断对象的等价性。</p>
<blockquote>
<p>例如 String 类，两个引用所指向的 String 都是 <code>&quot;abc&quot;</code> ，但可能出现他们实际对应的对象并不是同一个（和 JVM 实现方式有关），因此用 == 判断他们可能不相等，但用 equals 方法判断一定是相等的。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>🦅 <strong>如何在父类中为子类自动完成所有的 hashCode 和 equals 实现？这么做有何优劣？</strong></p>
<p>父类的 equals ，一般情况下是无法满足子类的 equals 的需求。</p>
<ul>
<li>比如所有的对象都继承 Object ，默认使用的是 Object 的 equals  方法，在比较两个对象的时候，是看他们是否指向同一个地址。但是我们的需求是对象的某个属性相同，就相等了，而默认的 equals  方法满足不了当前的需求，所以我们要重写 equals 方法。</li>
<li>如果重写了 equals 方法，就必须重写 hashCode 方法，否则就会降低 Map 等集合的索引速度。</li>
</ul>
<p>🦅 <strong>说一说你对 <code>java.lang.Object</code> 对象中 hashCode 和 equals 方法的理解。在什么场景下需要重新实现这两个方法?</strong></p>
<p>这个问题，和上个 <a href="http://svip.iocoder.cn/Java/Core/Interview/#">「如何在父类中为子类自动完成所有的 hashCode 和 equals 实现？这么做有何优劣？」</a> 一样的答案。</p>
<p>🦅 <strong>这样的 a.hashCode() 有什么用，与 a.equals(b) 有什么关系?</strong></p>
<blockquote>
<p>这个问题，和上述问题，就是换个姿势，差不了太多。</p>
</blockquote>
<ol>
<li><p>equals 方法，用于比较对象的内容是否相等。</p>
<blockquote>
<p>当覆盖了 equals 方法时，比较对象是否相等将通过覆盖后的 equals 方法进行比较（判断对象的内容是否相等）。</p>
</blockquote>
</li>
<li><p>hashCode 方法，大多在集合中用到。</p>
<blockquote>
<p>将对象放入到集合中时，首先判断要放入对象的 hashCode 值与集合中的任意一个元素的 hashCode 值是否相等，如果不相等直接将该对象放入集合中。</p>
<p>如果 hashCode 值相等，然后再通过 equals 方法判断要放入对象与集合中的任意一个对象是否相等，如果 equals 判断不相等，直接将该元素放入到集合中，否则不放入。</p>
</blockquote>
</li>
</ol>
<p>🦅 <strong>有没有可能 2 个不相等的对象有相同的 hashCode？</strong></p>
<p>可能会发生，这个被称为<strong>哈希碰撞</strong>。当然，相等的对象，即我们重写了 equals 方法，一定也要重写 hashCode 方法，否则将出现我们在 HashMap 中，相等的对象作为 key ，将找不到对应的 value 。</p>
<p>所以说，equals 和 hashCode 的关系会是：</p>
<ul>
<li>equals 不相等，hashCode 可能相等。</li>
<li>equals 相等，请重写 hashCode 方法，保证 hashCode 相等。</li>
</ul>
<p>一般来说，hashCode 方法的重写，可以看看 <a href="https://segmentfault.com/a/1190000010799123">《科普：为什么 String hashCode 方法选择数字31作为乘子》</a> 方法。</p>
<h2 id="final、finally、finalize-的区别？"><a href="#final、finally、finalize-的区别？" class="headerlink" title="final、finally、finalize 的区别？"></a>final、finally、finalize 的区别？</h2><p>1）final</p>
<p><code>final</code> ，是修饰符关键字。</p>
<ul>
<li>如果一个类被声明为 <code>final</code> ，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 <code>abstract</code> 的，又被声明为 <code>final</code> 的。</li>
<li>将变量或方法声明为 <code>final</code> ，可以保证它们在使用中不被改变。被声明为 final 的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为 <code>final</code> 的方法也同样只能使用，不能重写。</li>
</ul>
<blockquote>
<p>另外，在早期的 Java 实现版本中，会将 <code>final</code> 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 <code>final</code> 方法进行这些优化了）。类中所有的<code>private</code> 方法都隐式地指定为 <code>final</code> 。</p>
</blockquote>
<p>2）finally</p>
<p>在异常处理时提供 <code>finally</code> 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 <code>catch</code> 子句就会执行，然后控制就会进入 <code>finally</code> 块（如果有的话）。</p>
<p>在以下 4 种特殊情况下，finally块不会被执行：</p>
<ul>
<li>在 <code>finally</code> 语句块中发生了异常。</li>
<li>在前面的代码中用了 <code>System.exit()</code> 退出程序。</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU 。</li>
</ul>
<p>3）finalize</p>
<p><code>finalize</code> ，是方法名。</p>
<p>Java 允许使用 <code>#finalize()</code> 方法，在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。</p>
<ul>
<li>它是在 Object 类中定义的，因此所有的类都继承了它。</li>
<li>子类覆盖 <code>finalize()</code> 方法，以整理系统资源或者执行其他清理工作。</li>
<li><code>#finalize()</code> 方法，是在垃圾收集器删除对象之前对这个对象调用的。</li>
</ul>
<p>一般情况下，我们在业务中不会自己实现这个方法，更多是在一些框架中使用，例如 <a href="https://github.com/netty/netty/issues/4145">《Netty Using finalize() to release ByteBufs》</a> 。</p>
<p>🦅 <strong>String 类能被继承吗，为什么？</strong></p>
<p>不能，因为 String 是 <code>final</code> 修饰。</p>
<h2 id="抽象类和接口有什么区别？"><a href="#抽象类和接口有什么区别？" class="headerlink" title="抽象类和接口有什么区别？"></a>抽象类和接口有什么区别？</h2><p>从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p>
<ul>
<li>Java 提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：接口中所有的方法隐含的都是抽象的，而抽象类则可以同时包含抽象和非抽象的方法。</li>
<li>类可以实现很多个接口，但是只能继承一个抽象类。类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</li>
<li>抽象类可以在不提供接口方法实现的情况下实现接口。</li>
<li>Java 接口中声明的变量默认都是 <code>final</code> 的。抽象类可以包含非 <code>final</code> 的变量。</li>
<li>Java 接口中的成员函数默认是 <code>public</code> 的。抽象类的成员函数可以是 <code>private</code>，<code>protected</code> 或者是 <code>public</code> 。</li>
<li>接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含 <code>#main(String[] args)</code> 方法的话是可以被调用的。</li>
</ul>
<p>🦅 <strong>继承和组合的区别在哪？</strong></p>
<ul>
<li>继承：指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系。在 Java 中，此类关系通过关键字 <code>extends</code> 明确标识，在设计时一般没有争议性。</li>
<li>组合：组合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即 has-a 的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。<ul>
<li>比如，计算机与 CPU 、公司与员工的关系等。</li>
<li>表现在代码层面，和关联关系是一致的，只能从语义级别来区分。</li>
</ul>
</li>
</ul>
<p>因为组合能带来比继承更好的灵活性，所以有句话叫做“组合优于继承”。感兴趣的胖友，可以看看 <a href="https://www.zhihu.com/question/21862257">《怎样理解“组合优于继承”以及“OO的反模块化”，在这些方面FP具体来说有什么优势？》</a> 文章。</p>
<p>🦅 <strong>请详细讲述一下 RandomAccess 接口有什么作用？</strong></p>
<p>RandomAccess 用来当标记的，是一种<strong>标记</strong>接口，接口的非典型用法。意思是，随机访问任意下标元素都比较快。</p>
<p>用处，当要实现某些算法时，会判断当前类是否实现了 RandomAccess 接口，会根据结果选择不同的算法。</p>
<h2 id="讲讲类的实例化顺序？"><a href="#讲讲类的实例化顺序？" class="headerlink" title="讲讲类的实例化顺序？"></a>讲讲类的实例化顺序？</h2><p>初始化顺序如下：</p>
<ul>
<li>父类静态变量</li>
<li>父类静态代码块</li>
<li>子类静态变量、</li>
<li>子类静态代码块</li>
<li>父类非静态变量（父类实例成员变量）</li>
<li>父类构造函数</li>
<li>子类非静态变量（子类实例成员变量）</li>
<li>子类构造函数</li>
</ul>
<p>感兴趣的胖友，可以详细看看 <a href="https://blog.csdn.net/Vencc__/article/details/52222628">《Java 类的实例化顺序》</a> 文章，提供的示例。</p>
<h2 id="什么是内部类？"><a href="#什么是内部类？" class="headerlink" title="什么是内部类？"></a>什么是内部类？</h2><p>简单的说，就是在一个类、接口或者方法的内部创建另一个类。这样理解的话，创建内部类的方法就很明确了。当然，详细的可以看看 <a href="https://blog.csdn.net/hikvision_java_gyh/article/details/8964155">《Java 内部类总结（吐血之作）》</a> 文章。</p>
<p>🦅 <strong>内部类的作用是什么？</strong></p>
<p>内部类提供了更好的封装，除了该外围类，其他类都不能访问。</p>
<p>🦅 <strong>Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？</strong></p>
<p>可以继承其他类或实现其他接口，在 Java 集合的流式操作中，我们常常这么干。</p>
<p>🦅 <strong>内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</strong></p>
<p>一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</p>
<h2 id="什么是-Java-IO-？"><a href="#什么是-Java-IO-？" class="headerlink" title="什么是 Java IO ？"></a>什么是 Java IO ？</h2><p>Java IO 相关的类，在 <code>java.io</code> 包下，具体操作分成面向字节(Byte)和面向字符(Character)两种方式。如下图所示：</p>
<p><img src="http://cdn.tuwenbin.vip/ne9xds34.bmp" alt="ne9xds34">类图</p>
<h2 id="什么是-Java-序列化？"><a href="#什么是-Java-序列化？" class="headerlink" title="什么是 Java 序列化？"></a>什么是 Java 序列化？</h2><p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。</p>
<ul>
<li>可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。</li>
<li>序列化是为了解决在对对象流进行读写操作时所引发的问题。</li>
</ul>
<p>反序列化的过程，则是和序列化相反的过程。</p>
<blockquote>
<p>另外，我们不能将序列化局限在 Java 对象转换成二进制数组，例如说，我们将一个 Java 对象，转换成 JSON 字符串，或者 XML 字符串，这也可以理解为是序列化。</p>
</blockquote>
<p>🦅 <strong>如何实现 Java 序列化？</strong></p>
<blockquote>
<p>如下的方式，就是 Java 内置的序列化方案，实际场景下，我们可以自定义序列化的方案，例如说 Google Protobuf 。</p>
</blockquote>
<p>将需要被序列化的类，实现 Serializable 接口，该接口没有需要实现的方法，<code>implements Serializable</code> 只是为了标注该对象是可被序列化的。</p>
<ul>
<li>序列化<ul>
<li>然后，使用一个输出流(如：FileOutputStream)来构造一个 ObjectOutputStream(对象流)对象</li>
<li>接着，使用 ObjectOutputStream 对象的 <code>#writeObject(Object obj)</code> 方法，就可以将参数为 <code>obj</code> 的对象写出(即保存其状态)。</li>
</ul>
</li>
<li>反序列化<ul>
<li>要恢复的话则用输入流。</li>
</ul>
</li>
</ul>
<p>🦅 <strong>Java 序列话中，如果有些字段不想进行序列化怎么办？</strong></p>
<p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p>
<ul>
<li>当对象被序列化时，阻止实例中那些用此关键字修饰的的变量序列化。</li>
<li>当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</li>
<li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li>
</ul>
<h2 id="如何实现对象克隆？"><a href="#如何实现对象克隆？" class="headerlink" title="如何实现对象克隆？"></a>如何实现对象克隆？</h2><p>一般来说，有两种方式：</p>
<ul>
<li>1、实现 Cloneable 接口，并重写 Object 类中的 <code>#clone()</code> 方法。可以实现<strong>浅克隆</strong>，也可以实现<strong>深克隆</strong>。</li>
<li>2、实现 Serializable 接口，通过对象的序列化和反序列化实现克隆。可以实现真正的<strong>深克隆</strong>。</li>
</ul>
<blockquote>
<p>艿艿：这个问题，也可以变种来问，什么是<strong>浅克隆</strong>和<strong>深克隆</strong>。</p>
</blockquote>
<p>具体的代码实现，可以看看 <a href="https://blog.csdn.net/caomiao2006/article/details/52590622">《Java 对象的浅克隆和深克隆》</a> 文章。</p>
<p>实际场景下，我们使用的克隆比较少，更多是对象之间的属性克隆。例如说，将 DO 的属性复制到 DTO 中，又或者将 DTO 的属性复制到 VO 中。此时，我们一般使用 BeanUtils 工具类。具体的使用，看看 <a href="https://www.cnblogs.com/tison/p/7840647.html">《浅谈 BeanUtils 的拷贝，深度克隆》</a> 文章。</p>
<h2 id="error-和-exception-有什么区别？CheckedException-和-RuntimeException-有什么区别？"><a href="#error-和-exception-有什么区别？CheckedException-和-RuntimeException-有什么区别？" class="headerlink" title="error 和 exception 有什么区别？CheckedException 和 RuntimeException 有什么区别？"></a>error 和 exception 有什么区别？CheckedException 和 RuntimeException 有什么区别？</h2><p>Java 的异常体系，基于共同的祖先 <code>java.lang.Throwable</code> 类。如下图所示：</p>
<p><img src="http://cdn.tuwenbin.vip/9dx75n14.bmp" alt="9dx75n14">Throwable 类图</p>
<blockquote>
<p>感谢【贾鹤鸣】胖友指出的问题。图有点问题：</p>
<ol>
<li>图中的 ArrithmeticException 异常，多了一个 r ，正确拼写是 ArithmeticException 。</li>
<li>图中 ClassNotFoundException 异常，父类是 <code>ReflectiveOperationException =&gt; Exception</code> ，不属于 RunTimeException 。</li>
</ol>
</blockquote>
<ul>
<li>Error（错误），表示系统级的错误和程序不必处理的异常，是 Java 运行环境中的内部错误或者硬件问题。<ul>
<li>例如：内存资源不足等。</li>
<li>对于这种错误，程序基本无能为力，除了退出运行外别无选择，它是由 Java 虚拟机抛出的。</li>
</ul>
</li>
<li>Exception（异常），表示需要捕捉或者需要程序进行处理的异常，它处理的是因为程序设计的瑕疵而引起的问题或者在外的输入等引起的一般性问题，是程序必须处理的。Exception 又分为运行时异常，受检查异常。<ul>
<li>RuntimeException(运行时异常)，表示无法让程序恢复的异常，导致的原因通常是因为执行了错误的操作，建议终止逻辑，因此，编译器不检查这些异常。</li>
<li>CheckedException(受检查异常)，是表示程序可以处理的异常，也即表示程序可以修复（由程序自己接受异常并且做出处理），所以称之为受检查异常。</li>
</ul>
</li>
</ul>
<p>🦅 <strong>异常的使用的注意地方？</strong></p>
<p>神作《Effective Java》中对异常的使用给出了以下指导原则：</p>
<blockquote>
<p>艿艿：该书，十分推荐去阅读。</p>
</blockquote>
<ul>
<li>不要将异常处理用于正常的控制流（设计良好的 API 不应该强迫它的调用者为了正常的控制流而使用异常）。</li>
<li>对可以恢复的情况使用受检异常，对编程错误使用运行时异常。</li>
<li>避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）。</li>
<li>优先使用标准的异常。</li>
<li>每个方法抛出的异常都要有文档。</li>
<li>保持异常的原子性</li>
<li>不要在 <code>catch</code> 中忽略掉捕获到的异常。</li>
</ul>
<p>🦅 <strong>Throwable 类常用方法？</strong></p>
<ul>
<li><code>#getMessage()</code> 方法：返回异常发生时的详细信息。</li>
<li><code>#getCause()</code> 方法：获得导致当前 Throwable 异常的 Throwable 异常。</li>
<li><code>#getStackTrace()</code>方法：获得 Throwable 对象封装的异常信息。<ul>
<li><code>#printStackTrace()</code> 方法：在控制台上打印。</li>
</ul>
</li>
</ul>
<p>🦅 <strong>请列出 5 个运行时异常？</strong></p>
<ul>
<li>NullPointerException</li>
<li>IndexOutOfBoundsException</li>
<li>ClassCastException</li>
<li>ArrayStoreException</li>
<li>BufferOverflowException</li>
</ul>
<p>🦅 <strong><code>throw</code> 与 <code>throws</code> 的区别 ？</strong></p>
<ul>
<li><code>throw</code> ，用于在程序中显式地抛出一个异常。</li>
<li><code>throws</code> ，用于指出在该方法中没有处理的异常。<strong>每个方法必须显式指明哪些异常没有处理，以便该方法的调用者可以预防可能发生的异常</strong>。最后，多个异常用逗号分隔。</li>
</ul>
<p>🦅 <strong>异常处理中 <code>finally</code> 语句块的重要性?</strong></p>
<p>不管程序是否发生了异常, <code>finally</code> 语句块都会被执行，甚至当没有<code>catch</code> 声明但抛出了一个异常时, <code>finally</code> 语句块也会被执行。</p>
<p><code>finally</code> 语句块通常用于释放资源, 如 I/O 缓冲区, 数据库连接等等。</p>
<p>🦅 <strong>异常被处理后异常对象会发生什么?</strong></p>
<blockquote>
<p>艿艿：这个问题有点奇怪，从网上找来的…</p>
</blockquote>
<p>异常对象会在下次 GC 执行时被回收。</p>
<h2 id="说说反射的用途及实现？"><a href="#说说反射的用途及实现？" class="headerlink" title="说说反射的用途及实现？"></a>说说反射的用途及实现？</h2><p>Java 反射机制主要提供了以下功能：</p>
<ul>
<li>在运行时构造一个类的对象。</li>
<li>判断一个类所具有的成员变量和方法。</li>
<li>调用一个对象的方法。</li>
<li>生成动态代理。</li>
</ul>
<p>反射的应用很多，很多框架都有用到：</p>
<ul>
<li>Spring 框架的 IoC 基于反射创建对象和设置依赖属性。</li>
<li>Spring MVC 的请求调用对应方法，也是通过反射。</li>
<li>JDBC 的 <code>Class#forName(String className)</code> 方法，也是使用反射。</li>
</ul>
<p>不了解 Java 反射的同学，可以看看 <a href="http://www.cnblogs.com/zhaopei/p/reflection.html">《什么是反射、反射可以做些什么》</a> 。</p>
<blockquote>
<p>对于大多数 Java 萌新，包括艿艿在内。不过后来发现，再难的 Java 知识，未来都需要变成我们的基础知识，嘻嘻。</p>
</blockquote>
<p>🦅 <strong>反射中，Class.forName 和 ClassLoader 区别？</strong></p>
<p>这两者，都可用来对类进行加载。差别在于：</p>
<ul>
<li><p><code>Class#forName(...)</code> 方法，除了将类的 <code>.class</code> 文件加载到JVM 中之外，还会对类进行解释，执行类中的 <code>static</code> 块。</p>
</li>
<li><p>ClassLoader 只干一件事情，就是将 <code>.class</code> 文件加载到 JVM 中，不会执行 <code>static</code> 中的内容，只有在 newInstance 才会去执行 <code>static</code> 块。</p>
<blockquote>
<p><code>Class#forName(name, initialize, loader)</code> 方法，带参函数也可控制是否加载 <code>static</code> 块，并且只有调用了newInstance 方法采用调用构造函数，创建类的对象。</p>
</blockquote>
</li>
</ul>
<p>详细的测试，可以看看 <a href="https://blog.csdn.net/qq_27093465/article/details/52262340">《Java 反射中，Class.forName 和ClassLoader 的区别(代码说话)》</a> 文章。</p>
<p>🦅 <strong>UnsupportedOperationException 是什么？</strong></p>
<p>UnsupportedOperationException ，是用于表明操作不支持的异常。</p>
<p>在 JDK 类中已被大量运用，在集合框架<code>java.util.Collections.UnmodifiableCollection</code> 将会在所有 add 和 remove 操作中抛出这个异常。</p>
<h2 id="什么是注解？"><a href="#什么是注解？" class="headerlink" title="什么是注解？"></a>什么是注解？</h2><p>直接看 <a href="https://www.jianshu.com/p/5cac4cb9be54">《深入浅出 Java 注解》</a> 。</p>
<p>如果胖友没有自己实现自定义的注解，千万一定马上去尝试写下。酱紫，我们会对注解，有更好且清晰的认识。</p>
<h2 id="什么时候用断言（assert）？"><a href="#什么时候用断言（assert）？" class="headerlink" title="什么时候用断言（assert）？"></a>什么时候用断言（<code>assert</code>）？</h2><p>断言，在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。</p>
<ul>
<li><p>一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。</p>
</li>
<li><p>断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为<code>true</code>；如果表达式的值为 <code>false</code> ，那么系统会报告一个AssertionError 错误。断言的使用如下面的代码所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">assert(a &gt; 0); &#x2F;&#x2F; throws an AssertionError if a &lt;&#x3D; 0<br></code></pre></td></tr></table></figure>

<ul>
<li>断言可以有两种形式：<ul>
<li><code>assert Expression1;</code> 。</li>
<li><code>assert Expression1 : Expression2;</code> 。</li>
<li>Expression1 应该总是产生一个布尔值。</li>
<li>Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。</li>
</ul>
</li>
</ul>
</li>
<li><p>要在运行时启用断言，可以在启动 JVM 时使用 <code>-enableassertions</code> 或者 <code>-ea</code> 标记。要在运行时选择禁用断言，可以在启动 JVM 时使用 <code>-da</code> 或者 <code>-disableassertions</code> 标记。要在系统类中启用或禁用断言，可使用 <code>-esa</code> 或 <code>-dsa</code> 标记。还可以在包的基础上启用或者禁用断言。</p>
</li>
</ul>
<p>当然，实际场景下，我们会在 Spring 的源码中看到，它自己封装了 Assert 类，实现更方便的断言功能，并且，在生产环境下也启用。</p>
<p>另外，在单元测试中，也会使用自己封装的断言类，判断执行结果的正确与错误。</p>
<h2 id="Java-对象创建的方式？"><a href="#Java-对象创建的方式？" class="headerlink" title="Java 对象创建的方式？"></a>Java 对象创建的方式？</h2><ol>
<li>使用 <code>new</code> 关键字创建对象。</li>
<li>使用 Class 类的 newInstance 方法(反射机制)。</li>
<li>使用 Constructor 类的 newInstance 方法(反射机制)。</li>
<li>使用 clone 方法创建对象。</li>
<li>使用(反)序列化机制创建对象。</li>
</ol>
<h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>一写到 Java 基础，怎么说呢？就觉着概念挺多的，有点无从下手。实际情况下呢，艿艿自己面试的时候，很多问题可能都不太会问。那么，就把本文当成一种复习的文章吧，哈哈哈哈。</p>
<p>参考与推荐如下文章：</p>
<ul>
<li><a href="https://juejin.im/entry/5af2557c6fb9a07aa83eb59c">《2018 年最新 Java 面试题及答案整理》</a></li>
<li><a href="http://www.ituring.com.cn/article/507089">《32 道常见的 Java 基础面试题》</a></li>
<li><a href="http://www.n35n.com/2017/07/JAVA%E6%80%BB%E7%BB%93/">《Java 总结》</a></li>
<li><a href="https://github.com/Snailclimb/JavaGuide/blob/3dc5234d3a77d134e4768b17cc864c4cc1030e41/Java%E7%9B%B8%E5%85%B3/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md">《Java 基础知识》</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/java-interview-bible/basic-concept.html">Java 面试宝典</a></li>
</ul>
]]></content>
      <categories>
        <category>Java【基础】</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java【基础】</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis 面试题</title>
    <url>/2016/10/12/%E7%B2%BE%E5%B0%BD%20MyBatis%20%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="精尽-MyBatis-面试题"><a href="#精尽-MyBatis-面试题" class="headerlink" title="精尽 MyBatis 面试题"></a>精尽 MyBatis 面试题</h1><p>以下面试题，基于网络整理，和自己编辑。具体参考的文章，会在文末给出所有的链接。</p>
<p>如果胖友有自己的疑问，欢迎在星球提问，我们一起整理吊吊的 MyBatis 面试题的大保健。</p>
<p>而题目的难度，艿艿尽量按照从容易到困难的顺序，逐步下去。</p>
<h2 id="MyBatis-编程步骤"><a href="#MyBatis-编程步骤" class="headerlink" title="MyBatis 编程步骤"></a>MyBatis 编程步骤</h2><ol>
<li>创建 SqlSessionFactory 对象。</li>
<li>通过 SqlSessionFactory 获取 SqlSession 对象。</li>
<li>通过 SqlSession 获得 Mapper 代理对象。</li>
<li>通过 Mapper 代理对象，执行数据库操作。</li>
<li>执行成功，则使用 SqlSession 提交事务。</li>
<li>执行失败，则使用 SqlSession 回滚事务。</li>
<li>最终，关闭会话。</li>
</ol>
<h2 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{} 和 ${} 的区别是什么？"></a><code>#&#123;&#125;</code> 和 <code>$&#123;&#125;</code> 的区别是什么？</h2><p><code>$&#123;&#125;</code> 是 Properties 文件中的变量占位符，它可以用于 XML 标签属性值和 SQL 内部，属于<strong>字符串替换</strong>。例如将 <code>$&#123;driver&#125;</code> 会被静态替换为 <code>com.mysql.jdbc.Driver</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dataSource type&#x3D;&quot;UNPOOLED&quot;&gt;<br>    &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;<br>    &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;<br>    &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;<br>&lt;&#x2F;dataSource&gt;<br></code></pre></td></tr></table></figure>

<p><code>$&#123;&#125;</code> 也可以对传递进来的参数<strong>原样拼接</strong>在 SQL 中。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;select id&#x3D;&quot;getSubject3&quot; parameterType&#x3D;&quot;Integer&quot; resultType&#x3D;&quot;Subject&quot;&gt;<br>    SELECT * FROM subject<br>    WHERE id &#x3D; $&#123;id&#125;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>实际场景下，不推荐这么做。因为，可能有 SQL 注入的风险。</li>
</ul>
<hr>
<p><code>#&#123;&#125;</code> 是 SQL 的参数占位符，Mybatis 会将 SQL 中的 <code>#&#123;&#125;</code> 替换为 <code>?</code> 号，在 SQL 执行前会使用 PreparedStatement 的参数设置方法，按序给 SQL 的 <code>?</code> 号占位符设置参数值，比如 <code>ps.setInt(0, parameterValue)</code> 。 所以，<code>#&#123;&#125;</code> 是<strong>预编译处理</strong>，可以有效防止 SQL 注入，提高系统安全性。</p>
<hr>
<p>另外，<code>#&#123;&#125;</code> 和 <code>$&#123;&#125;</code> 的取值方式非常方便。例如：<code>#&#123;item.name&#125;</code> 的取值方式，为使用反射从参数对象中，获取 <code>item</code> 对象的 <code>name</code> 属性值，相当于 <code>param.getItem().getName()</code> 。</p>
<h2 id="当实体类中的属性名和表中的字段名不一样-，怎么办？"><a href="#当实体类中的属性名和表中的字段名不一样-，怎么办？" class="headerlink" title="当实体类中的属性名和表中的字段名不一样 ，怎么办？"></a>当实体类中的属性名和表中的字段名不一样 ，怎么办？</h2><p>第一种， 通过在查询的 SQL 语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;select id&#x3D;&quot;selectOrder&quot; parameterType&#x3D;&quot;Integer&quot; resultType&#x3D;&quot;Order&quot;&gt; <br>    SELECT order_id AS id, order_no AS orderno, order_price AS price <br>    FROM orders <br>    WHERE order_id &#x3D; #&#123;id&#125;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>这里，艿艿还有几点建议：<ul>
<li>1、数据库的关键字，统一使用大写，例如：<code>SELECT</code>、<code>AS</code>、<code>FROM</code>、<code>WHERE</code> 。</li>
<li>2、每 5 个查询字段换一行，保持整齐。</li>
<li>3、<code>,</code> 的后面，和 <code>=</code> 的前后，需要有空格，更加清晰。</li>
<li>4、<code>SELECT</code>、<code>FROM</code>、<code>WHERE</code> 等，单独一行，高端大气。</li>
</ul>
</li>
</ul>
<hr>
<p>第二种，是第一种的特殊情况。大多数场景下，数据库字段名和实体类中的属性名差，主要是前者为<strong>下划线风格</strong>，后者为<strong>驼峰风格</strong>。在这种情况下，可以直接配置如下，实现自动的下划线转驼峰的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;setting name&#x3D;&quot;logImpl&quot; value&#x3D;&quot;LOG4J&quot;&#x2F;&gt;<br>    &lt;setting name&#x3D;&quot;mapUnderscoreToCamelCase&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;<br>&lt;&#x2F;settings&gt;<br></code></pre></td></tr></table></figure>

<p>😈 也就说，约定大于配置。非常推荐！</p>
<hr>
<p>第三种，通过 <code>&lt;resultMap&gt;</code> 来映射字段名和实体类属性名的一一对应的关系。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;resultMap type&#x3D;&quot;me.gacl.domain.Order&quot; id&#x3D;”OrderResultMap”&gt; <br>    &lt;!–- 用 id 属性来映射主键字段 -–&gt; <br>    &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;order_id&quot;&gt; <br>    &lt;!–- 用 result 属性来映射非主键字段，property 为实体类属性名，column 为数据表中的属性 -–&gt; <br>    &lt;result property&#x3D;&quot;orderNo&quot; column &#x3D;&quot;order_no&quot; &#x2F;&gt; <br>    &lt;result property&#x3D;&quot;price&quot; column&#x3D;&quot;order_price&quot; &#x2F;&gt; <br>&lt;&#x2F;resultMap&gt;<br><br>&lt;select id&#x3D;&quot;getOrder&quot; parameterType&#x3D;&quot;Integer&quot; resultMap&#x3D;&quot;OrderResultMap&quot;&gt;<br>    SELECT * <br>    FROM orders <br>    WHERE order_id &#x3D; #&#123;id&#125;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>此处 <code>SELECT *</code> 仅仅作为示例只用，实际场景下，千万千万千万不要这么干。用多少字段，查询多少字段。</li>
<li>相比第一种，第三种的<strong>重用性</strong>会一些。</li>
</ul>
<h2 id="XML-映射文件中，除了常见的-select-insert-update-delete标-签之外，还有哪些标签？"><a href="#XML-映射文件中，除了常见的-select-insert-update-delete标-签之外，还有哪些标签？" class="headerlink" title="XML 映射文件中，除了常见的 select | insert | update | delete标 签之外，还有哪些标签？"></a>XML 映射文件中，除了常见的 select | insert | update | delete标 签之外，还有哪些标签？</h2><p>如下部分，可见 <a href="http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html">《MyBatis 文档 —— Mapper XML 文件》</a> ：</p>
<ul>
<li><p><code>&lt;cache /&gt;</code> 标签，给定命名空间的缓存配置。</p>
<ul>
<li><code>&lt;cache-ref /&gt;</code> 标签，其他命名空间缓存配置的引用。</li>
</ul>
</li>
<li><p><code>&lt;resultMap /&gt;</code> 标签，是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。</p>
</li>
<li><p><del>`` 标签，已废弃！老式风格的参数映射。内联参数是首选,这个元素可能在将来被移除，这里不会记录。</del></p>
</li>
<li><p><code>&lt;sql /&gt;</code>标签，可被其他语句引用的可重用语句块。</p>
<ul>
<li><code>&lt;include /&gt;</code> 标签，引用 <code>&lt;sql /&gt;</code> 标签的语句。</li>
</ul>
</li>
<li><p><code>&lt;selectKey /&gt;</code> 标签，不支持自增的主键生成策略标签。</p>
</li>
</ul>
<p>如下部分，可见 <a href="http://www.mybatis.org/mybatis-3/zh/dynamic-sql.html">《MyBatis 文档 —— 动态 SQL》</a> ：</p>
<ul>
<li><code>&lt;if /&gt;</code></li>
<li><code>&lt;choose /&gt;</code>、<code>&lt;when /&gt;</code>、<code>&lt;otherwise /&gt;</code></li>
<li><code>&lt;trim /&gt;</code>、<code>&lt;where /&gt;</code>、<code>&lt;set /&gt;</code></li>
<li><code>&lt;foreach /&gt;</code></li>
<li><code>&lt;bind /&gt;</code></li>
</ul>
<h2 id="Mybatis-动态-SQL-是做什么的？都有哪些动态-SQL-？能简述一下动态-SQL-的执行原理吗？"><a href="#Mybatis-动态-SQL-是做什么的？都有哪些动态-SQL-？能简述一下动态-SQL-的执行原理吗？" class="headerlink" title="Mybatis 动态 SQL 是做什么的？都有哪些动态 SQL ？能简述一下动态 SQL 的执行原理吗？"></a>Mybatis 动态 SQL 是做什么的？都有哪些动态 SQL ？能简述一下动态 SQL 的执行原理吗？</h2><ul>
<li>Mybatis 动态 SQL ，可以让我们在 XML 映射文件内，以 XML 标签的形式编写动态 SQL ，完成逻辑判断和动态拼接 SQL 的功能。</li>
<li>Mybatis 提供了 9 种动态 SQL 标签：<code>&lt;if /&gt;</code>、<code>&lt;choose /&gt;</code>、<code>&lt;when /&gt;</code>、<code>&lt;otherwise /&gt;</code>、<code>&lt;trim /&gt;</code>、<code>&lt;where /&gt;</code>、<code>&lt;set /&gt;</code>、<code>&lt;foreach /&gt;</code>、<code>&lt;bind /&gt;</code> 。</li>
<li>其执行原理为，使用 <strong>OGNL</strong> 的表达式，从 SQL 参数对象中计算表达式的值，根据表达式的值动态拼接 SQL ，以此来完成动态 SQL 的功能。</li>
</ul>
<p>如上的内容，更加详细的话，请看 <a href="http://www.mybatis.org/mybatis-3/zh/dynamic-sql.html">《MyBatis 文档 —— 动态 SQL》</a> 文档。</p>
<h2 id="最佳实践中，通常一个-XML-映射文件，都会写一个-Mapper-接口与之对应。请问，这个-Mapper-接口的工作原理是什么？Mapper-接口里的方法，参数不同时，方法能重载吗？"><a href="#最佳实践中，通常一个-XML-映射文件，都会写一个-Mapper-接口与之对应。请问，这个-Mapper-接口的工作原理是什么？Mapper-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="最佳实践中，通常一个 XML 映射文件，都会写一个 Mapper 接口与之对应。请问，这个 Mapper 接口的工作原理是什么？Mapper 接口里的方法，参数不同时，方法能重载吗？"></a>最佳实践中，通常一个 XML 映射文件，都会写一个 Mapper 接口与之对应。请问，这个 Mapper 接口的工作原理是什么？Mapper 接口里的方法，参数不同时，方法能重载吗？</h2><p>Mapper 接口，对应的关系如下：</p>
<ul>
<li>接口的全限名，就是映射文件中的 <code>&quot;namespace&quot;</code> 的值。</li>
<li>接口的方法名，就是映射文件中 MappedStatement 的 <code>&quot;id&quot;</code> 值。</li>
<li>接口方法内的参数，就是传递给 SQL 的参数。</li>
</ul>
<p>Mapper 接口是没有实现类的，当调用接口方法时，接口全限名 + 方法名拼接字符串作为 key 值，可唯一定位一个对应的 MappedStatement 。举例：<code>com.mybatis3.mappers.StudentDao.findStudentById</code> ，可以唯一找到 <code>&quot;namespace&quot;</code> 为 <code>com.mybatis3.mappers.StudentDao</code> 下面 <code>&quot;id&quot;</code> 为 <code>findStudentById</code> 的 MappedStatement 。</p>
<p>总结来说，在 Mybatis 中，每一个 <code>&lt;select /&gt;</code>、<code>&lt;insert /&gt;</code>、<code>&lt;update /&gt;</code>、<code>&lt;delete /&gt;</code> 标签，都会被解析为一个 MappedStatement 对象。</p>
<p>另外，Mapper 接口的实现类，通过 MyBatis 使用 <strong>JDK Proxy</strong> 自动生成其代理对象 Proxy ，而代理对象 Proxy 会拦截接口方法，从而“调用”对应的 MappedStatement 方法，最终执行 SQL ，返回执行结果。整体流程如下图：<a href="http://static2.iocoder.cn/images/MyBatis/2020_03_15/02.png"><img src="http://cdn.tuwenbin.vip/02.png" alt="流程"></a>流程</p>
<ul>
<li><p>其中，SqlSession 在调用 Executor 之前，会获得对应的 MappedStatement 方法。例如：<code>DefaultSqlSession#select(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler)</code> 方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; DefaultSqlSession.java<br><br>@Override<br>public void select(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler) &#123;<br>    try &#123;<br>        &#x2F;&#x2F; 获得 MappedStatement 对象<br>        MappedStatement ms &#x3D; configuration.getMappedStatement(statement);<br>        &#x2F;&#x2F; 执行查询<br>        executor.query(ms, wrapCollection(parameter), rowBounds, handler);<br>    &#125; catch (Exception e) &#123;<br>        throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);<br>    &#125; finally &#123;<br>        ErrorContext.instance().reset();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>完整的流程，胖友可以慢慢撸下 MyBatis 的源码。</li>
</ul>
</li>
</ul>
<hr>
<p>Mapper 接口里的方法，是不能重载的，因为是<strong>全限名 + 方法名</strong>的保存和寻找策略。😈 所以有时，想个 Mapper 接口里的方法名，还是蛮闹心的，嘿嘿。</p>
<h2 id="Mapper-接口绑定有几种实现方式-分别是怎么实现的"><a href="#Mapper-接口绑定有几种实现方式-分别是怎么实现的" class="headerlink" title="Mapper 接口绑定有几种实现方式,分别是怎么实现的?"></a>Mapper 接口绑定有几种实现方式,分别是怎么实现的?</h2><p>接口绑定有三种实现方式：</p>
<p>第一种，通过 <strong>XML Mapper</strong> 里面写 SQL 来绑定。在这种情况下，要指定 XML 映射文件里面的 <code>&quot;namespace&quot;</code> 必须为接口的全路径名。</p>
<p>第二种，通过<strong>注解</strong>绑定，就是在接口的方法上面加上 <code>@Select</code>、<code>@Update</code>、<code>@Insert</code>、<code>@Delete</code> 注解，里面包含 SQL 语句来绑定。</p>
<p>第三种，是第二种的特例，也是通过<strong>注解</strong>绑定，在接口的方法上面加上 <code>@SelectProvider</code>、<code>@UpdateProvider</code>、<code>@InsertProvider</code>、<code>@DeleteProvider</code> 注解，通过 Java 代码，生成对应的动态 SQL 。</p>
<hr>
<p>实际场景下，最最最推荐的是<strong>第一种</strong>方式。因为，SQL 通过注解写在 Java 代码中，会非常杂乱。而写在 XML 中，更加有整体性，并且可以更加方便的使用 OGNL 表达式。</p>
<h2 id="Mybatis-的-XML-Mapper文件中，不同的-XML-映射文件，id-是否可以重复？"><a href="#Mybatis-的-XML-Mapper文件中，不同的-XML-映射文件，id-是否可以重复？" class="headerlink" title="Mybatis 的 XML Mapper文件中，不同的 XML 映射文件，id 是否可以重复？"></a>Mybatis 的 XML Mapper文件中，不同的 XML 映射文件，id 是否可以重复？</h2><p>不同的 XML Mapper 文件，如果配置了 <code>&quot;namespace&quot;</code> ，那么 id 可以重复；如果没有配置 <code>&quot;namespace&quot;</code> ，那么 id 不能重复。毕竟<code>&quot;namespace&quot;</code> 不是必须的，只是最佳实践而已。</p>
<p>原因就是，<code>namespace + id</code> 是作为 <code>Map&lt;String, MappedStatement&gt;</code> 的 key 使用的。如果没有 <code>&quot;namespace&quot;</code>，就剩下 id ，那么 id 重复会导致数据互相覆盖。如果有了 <code>&quot;namespace&quot;</code>，自然 id 就可以重复，<code>&quot;namespace&quot;</code>不同，<code>namespace + id</code> 自然也就不同。</p>
<h2 id="如何获取自动生成的-主-键值"><a href="#如何获取自动生成的-主-键值" class="headerlink" title="如何获取自动生成的(主)键值?"></a>如何获取自动生成的(主)键值?</h2><p>不同的数据库，获取自动生成的(主)键值的方式是不同的。</p>
<p>MySQL 有两种方式，但是<strong>自增主键</strong>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 方式一，使用 useGeneratedKeys + keyProperty 属性<br>&lt;insert id&#x3D;&quot;insert&quot; parameterType&#x3D;&quot;Person&quot; useGeneratedKeys&#x3D;&quot;true&quot; keyProperty&#x3D;&quot;id&quot;&gt;<br>    INSERT INTO person(name, pswd)<br>    VALUE (#&#123;name&#125;, #&#123;pswd&#125;)<br>&lt;&#x2F;insert&gt;<br>    <br>&#x2F;&#x2F; 方式二，使用 &#96;&lt;selectKey &#x2F;&gt;&#96; 标签<br>&lt;insert id&#x3D;&quot;insert&quot; parameterType&#x3D;&quot;Person&quot;&gt;<br>    &lt;selectKey keyProperty&#x3D;&quot;id&quot; resultType&#x3D;&quot;long&quot; order&#x3D;&quot;AFTER&quot;&gt;<br>        SELECT LAST_INSERT_ID()<br>    &lt;&#x2F;selectKey&gt;<br>        <br>    INSERT INTO person(name, pswd)<br>    VALUE (#&#123;name&#125;, #&#123;pswd&#125;)<br>&lt;&#x2F;insert&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>其中，<strong>方式一</strong>较为常用。</li>
</ul>
<hr>
<p>Oracle 有两种方式，<strong>序列</strong>和<strong>触发器</strong>。因为艿艿自己不了解 Oracle ，所以问了银行的朋友，他们是使用<strong>序列</strong>。而基于<strong>序列</strong>，根据 <code>&lt;selectKey /&gt;</code> 执行的时机，也有两种方式，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 这个是创建表的自增序列<br>CREATE SEQUENCE student_sequence<br>INCREMENT BY 1<br>NOMAXVALUE<br>NOCYCLE<br>CACHE 10;<br><br>&#x2F;&#x2F; 方式一，使用 &#96;&lt;selectKey &#x2F;&gt;&#96; 标签 + BEFORE<br>&lt;insert id&#x3D;&quot;add&quot; parameterType&#x3D;&quot;Student&quot;&gt;<br>　　&lt;selectKey keyProperty&#x3D;&quot;student_id&quot; resultType&#x3D;&quot;int&quot; order&#x3D;&quot;BEFORE&quot;&gt;<br>      select student_sequence.nextval FROM dual<br>    &lt;&#x2F;selectKey&gt;<br>    <br>     INSERT INTO student(student_id, student_name, student_age)<br>     VALUES (#&#123;student_id&#125;,#&#123;student_name&#125;,#&#123;student_age&#125;)<br>&lt;&#x2F;insert&gt;<br><br>&#x2F;&#x2F; 方式二，使用 &#96;&lt;selectKey &#x2F;&gt;&#96; 标签 + AFTER<br>&lt;insert id&#x3D;&quot;save&quot; parameterType&#x3D;&quot;com.threeti.to.ZoneTO&quot; &gt;<br>    &lt;selectKey resultType&#x3D;&quot;java.lang.Long&quot; keyProperty&#x3D;&quot;id&quot; order&#x3D;&quot;AFTER&quot; &gt;<br>      SELECT SEQ_ZONE.CURRVAL AS id FROM dual<br>    &lt;&#x2F;selectKey&gt;<br>    <br>    INSERT INTO TBL_ZONE (ID, NAME ) <br>    VALUES (SEQ_ZONE.NEXTVAL, #&#123;name,jdbcType&#x3D;VARCHAR&#125;)<br>&lt;&#x2F;insert&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>他们使用第一种方式，没有具体原因，可能就没什么讲究吧。嘿嘿。</li>
</ul>
<p>至于为什么不用<strong>触发器</strong>呢？朋友描述如下：</p>
<blockquote>
<p>朋友：触发器不行啊，我们这边原来也有触发器，一有数据更改就会有问题了呀<br>艿艿：数据更改指的是？<br>朋友：就改线上某几条数据<br>艿艿：噢噢。手动改是吧？<br>朋友：不行~</p>
</blockquote>
<hr>
<p>当然，数据库还有 SQLServer、PostgreSQL、DB2、H2 等等，具体的方式，胖友自己 Google 下噢。</p>
<p>关于如何获取自动生成的(主)键值的<strong>原理</strong>，可以看看 <a href="http://svip.iocoder.cn/MyBatis/executor-3/">《精尽 MyBatis 源码分析 —— SQL 执行（三）之 KeyGenerator》</a> 。</p>
<h2 id="Mybatis-执行批量插入，能返回数据库主键列表吗？"><a href="#Mybatis-执行批量插入，能返回数据库主键列表吗？" class="headerlink" title="Mybatis 执行批量插入，能返回数据库主键列表吗？"></a>Mybatis 执行批量插入，能返回数据库主键列表吗？</h2><p>能，JDBC 都能做，Mybatis 当然也能做。</p>
<h2 id="在-Mapper-中如何传递多个参数"><a href="#在-Mapper-中如何传递多个参数" class="headerlink" title="在 Mapper 中如何传递多个参数?"></a>在 Mapper 中如何传递多个参数?</h2><p>第一种，使用 Map 集合，装载多个参数进行传递。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 调用方法<br>Map&lt;String, Object&gt; map &#x3D; new HashMap();<br>map.put(&quot;start&quot;, start);<br>map.put(&quot;end&quot;, end);<br>return studentMapper.selectStudents(map);<br><br>&#x2F;&#x2F; Mapper 接口<br>List&lt;Student&gt; selectStudents(Map&lt;String, Object&gt; map);<br><br>&#x2F;&#x2F; Mapper XML 代码<br>&lt;select id&#x3D;&quot;selectStudents&quot; parameterType&#x3D;&quot;Map&quot; resultType&#x3D;&quot;Student&quot;&gt;<br>    SELECT * <br>    FROM students <br>    LIMIT #&#123;start&#125;, #&#123;end&#125;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>显然，这不是一种优雅的方式。</li>
</ul>
<hr>
<p>第二种，保持传递多个参数，使用 <code>@Param</code> 注解。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 调用方法<br>return studentMapper.selectStudents(0, 10);<br><br>&#x2F;&#x2F; Mapper 接口<br>List&lt;Student&gt; selectStudents(@Param(&quot;start&quot;) Integer start, @Param(&quot;end&quot;) Integer end);<br><br>&#x2F;&#x2F; Mapper XML 代码<br>&lt;select id&#x3D;&quot;selectStudents&quot; resultType&#x3D;&quot;Student&quot;&gt;<br>    SELECT * <br>    FROM students <br>    LIMIT #&#123;start&#125;, #&#123;end&#125;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>推荐使用这种方式。</li>
</ul>
<hr>
<p>第三种，保持传递多个参数，不使用 <code>@Param</code> 注解。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 调用方法<br>return studentMapper.selectStudents(0, 10);<br><br>&#x2F;&#x2F; Mapper 接口<br>List&lt;Student&gt; selectStudents(Integer start, Integer end);<br><br>&#x2F;&#x2F; Mapper XML 代码<br>&lt;select id&#x3D;&quot;selectStudents&quot; resultType&#x3D;&quot;Student&quot;&gt;<br>    SELECT * <br>    FROM students <br>    LIMIT #&#123;param1&#125;, #&#123;param2&#125;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>其中，按照参数在方法方法中的位置，从 1 开始，逐个为 <code>#&#123;param1&#125;</code>、<code>#&#123;param2&#125;</code>、<code>#&#123;param3&#125;</code> 不断向下。</li>
</ul>
<h2 id="Mybatis-是否可以映射-Enum-枚举类？"><a href="#Mybatis-是否可以映射-Enum-枚举类？" class="headerlink" title="Mybatis 是否可以映射 Enum 枚举类？"></a>Mybatis 是否可以映射 Enum 枚举类？</h2><p>Mybatis 可以映射枚举类，对应的实现类为 EnumTypeHandler 或 EnumOrdinalTypeHandler 。</p>
<ul>
<li>EnumTypeHandler ，基于 <code>Enum.name</code> 属性( String )。<strong>默认</strong>。</li>
<li>EnumOrdinalTypeHandler ，基于 <code>Enum.ordinal</code> 属性( <code>int</code> )。可通过 <code>&lt;setting name=&quot;defaultEnumTypeHandler&quot; value=&quot;EnumOrdinalTypeHandler&quot; /&gt;</code> 来设置。</li>
</ul>
<p>😈 当然，实际开发场景，我们很少使用 Enum 类型，更加的方式是，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class Dog &#123;<br><br>    public static final int STATUS_GOOD &#x3D; 1;<br>    public static final int STATUS_BETTER &#x3D; 2;<br>    public static final int STATUS_BEST &#x3D; 3；<br>    <br>    private int status;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<p>并且，不单可以映射枚举类，Mybatis 可以映射任何对象到表的一列上。映射方式为自定义一个 TypeHandler 类，实现 TypeHandler 的<code>#setParameter(...)</code> 和 <code>#getResult(...)</code> 接口方法。</p>
<p>TypeHandler 有两个作用：</p>
<ul>
<li>一是，完成从 javaType 至 jdbcType 的转换。</li>
<li>二是，完成 jdbcType 至 javaType 的转换。</li>
</ul>
<p>具体体现为 <code>#setParameter(...)</code> 和 <code>#getResult(..)</code> 两个方法，分别代表设置 SQL 问号占位符参数和获取列查询结果。</p>
<p>关于 TypeHandler 的<strong>原理</strong>，可以看看 <a href="http://svip.iocoder.cn/MyBatis/type-package/">《精尽 MyBatis 源码分析 —— 类型模块》</a> 。</p>
<h2 id="Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？"></a>Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h2><p>Mybatis 有四种 Executor 执行器，分别是 SimpleExecutor、ReuseExecutor、BatchExecutor、CachingExecutor 。</p>
<ul>
<li>SimpleExecutor ：每执行一次 update 或 select 操作，就创建一个 Statement 对象，用完立刻关闭 Statement 对象。</li>
<li>ReuseExecutor ：执行 update 或 select 操作，以 SQL 作为key 查找<strong>缓存</strong>的 Statement 对象，存在就使用，不存在就创建；用完后，不关闭 Statement 对象，而是放置于缓存 <code>Map&lt;String, Statement&gt;</code> 内，供下一次使用。简言之，就是重复使用 Statement 对象。</li>
<li>BatchExecutor ：执行 update 操作（没有 select 操作，因为 JDBC 批处理不支持 select  操作），将所有 SQL 都添加到批处理中（通过 addBatch 方法），等待统一执行（使用 executeBatch 方法）。它缓存了多个  Statement 对象，每个 Statement 对象都是调用 addBatch 方法完毕后，等待一次执行 executeBatch 批处理。<strong>实际上，整个过程与 JDBC 批处理是相同</strong>。</li>
<li>CachingExecutor ：在上述的三个执行器之上，增加<strong>二级缓存</strong>的功能。</li>
</ul>
<hr>
<p>通过设置 <code>&lt;setting name=&quot;defaultExecutorType&quot; value=&quot;&quot;&gt;</code> 的 <code>&quot;value&quot;</code> 属性，可传入 SIMPLE、REUSE、BATCH 三个值，分别使用 SimpleExecutor、ReuseExecutor、BatchExecutor 执行器。</p>
<p>通过设置 <code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;&quot;</code> 的 <code>&quot;value&quot;</code> 属性为 <code>true</code> 时，创建 CachingExecutor 执行器。</p>
<hr>
<p>这块的源码解析，可见 <a href="http://svip.iocoder.cn/MyBatis/executor-1">《精尽 MyBatis 源码分析 —— SQL 执行（一）之 Executor》</a> 。</p>
<h2 id="MyBatis-如何执行批量插入"><a href="#MyBatis-如何执行批量插入" class="headerlink" title="MyBatis 如何执行批量插入?"></a>MyBatis 如何执行批量插入?</h2><p>首先，在 Mapper XML 编写一个简单的 Insert 语句。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;insert id&#x3D;&quot;insertUser&quot; parameterType&#x3D;&quot;String&quot;&gt; <br>    INSERT INTO users(name) <br>    VALUES (#&#123;value&#125;) <br>&lt;&#x2F;insert&gt;<br></code></pre></td></tr></table></figure>

<p>然后，然后在对应的 Mapper 接口中，编写映射的方法。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public interface UserMapper &#123;<br>    <br>    void insertUser(@Param(&quot;name&quot;) String name);<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后，调用该 Mapper 接口方法。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">private static SqlSessionFactory sqlSessionFactory;<br><br>@Test<br>public void testBatch() &#123;<br>    &#x2F;&#x2F; 创建要插入的用户的名字的数组<br>    List&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;();<br>    names.add(&quot;占小狼&quot;);<br>    names.add(&quot;朱小厮&quot;);<br>    names.add(&quot;徐妈&quot;);<br>    names.add(&quot;飞哥&quot;);<br><br>    &#x2F;&#x2F; 获得执行器类型为 Batch 的 SqlSession 对象，并且 autoCommit &#x3D; false ，禁止事务自动提交<br>    try (SqlSession session &#x3D; sqlSessionFactory.openSession(ExecutorType.BATCH, false)) &#123;<br>        &#x2F;&#x2F; 获得 Mapper 对象<br>        UserMapper mapper &#x3D; session.getMapper(UserMapper.class);<br>        &#x2F;&#x2F; 循环插入<br>        for (String name : names) &#123;<br>            mapper.insertUser(name);<br>        &#125;<br>        &#x2F;&#x2F; 提交批量操作<br>        session.commit();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>代码比较简单，胖友仔细看看。当然，还有另一种方式，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">INSERT INTO [表名]([列名],[列名]) <br>VALUES<br>([列值],[列值])),<br>([列值],[列值])),<br>([列值],[列值]));<br></code></pre></td></tr></table></figure>

<ul>
<li>对于这种方式，需要保证单条 SQL 不超过语句的最大限制 <code>max_allowed_packet</code> 大小，默认为 1 M 。</li>
</ul>
<p>这两种方式的性能对比，可以看看 [《<a href="https://www.jianshu.com/p/cce617be9f9e">实验]mybatis批量插入方式的比较》</a> 。</p>
<h2 id="介绍-MyBatis-的一级缓存和二级缓存的概念和实现原理？"><a href="#介绍-MyBatis-的一级缓存和二级缓存的概念和实现原理？" class="headerlink" title="介绍 MyBatis 的一级缓存和二级缓存的概念和实现原理？"></a>介绍 MyBatis 的一级缓存和二级缓存的概念和实现原理？</h2><p>内容有些长，直接参见 <a href="https://tech.meituan.com/mybatis_cache.html">《聊聊 MyBatis 缓存机制》</a> 一文。</p>
<hr>
<p>这块的源码解析，可见 <a href="http://svip.iocoder.cn/MyBatis/cache-package">《精尽 MyBatis 源码分析 —— 缓存模块》</a> 。</p>
<h2 id="Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h2><p>Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载。其中，association 指的就是<strong>一对一</strong>，collection 指的就是<strong>一对多查询</strong>。</p>
<p>在 Mybatis 配置文件中，可以配置 <code>&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot; /&gt;</code> 来启用延迟加载的功能。默认情况下，延迟加载的功能是<strong>关闭</strong>的。</p>
<hr>
<p>它的原理是，使用 CGLIB 或 Javassist( 默认 ) 创建目标对象的代理对象。当调用代理对象的延迟加载属性的 getting 方法时，进入拦截器方法。比如调用 <code>a.getB().getName()</code> 方法，进入拦截器的 <code>invoke(...)</code> 方法，发现 <code>a.getB()</code> 需要延迟加载时，那么就会单独发送事先保存好的查询关联 B 对象的 SQL ，把 B 查询上来，然后调用<code>a.setB(b)</code> 方法，于是 <code>a</code> 对象 <code>b</code> 属性就有值了，接着完成<code>a.getB().getName()</code> 方法的调用。这就是延迟加载的基本原理。</p>
<p>当然了，不光是 Mybatis，几乎所有的包括 Hibernate 在内，支持延迟加载的原理都是一样的。</p>
<hr>
<p>这块的源码解析，可见 <a href="http://svip.iocoder.cn/MyBatis/executor-5">《 精尽 MyBatis 源码分析 —— SQL 执行（五）之延迟加载》</a> 文章。</p>
<h2 id="Mybatis-能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"><a href="#Mybatis-能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。" class="headerlink" title="Mybatis 能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"></a>Mybatis 能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。</h2><blockquote>
<p>艿艿：这道题有点难度。理解倒是好理解，主要那块源码的实现，艿艿看的有点懵逼。大体的意思是懂的，但是一些细节没扣完。</p>
</blockquote>
<p>能，Mybatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询。</p>
<blockquote>
<p>艿艿：不过貌似，我自己实际开发中，还是比较喜欢自己去查询和拼接映射的数据。😈</p>
</blockquote>
<ul>
<li>多对一查询，其实就是一对一查询，只需要把 <code>selectOne(...)</code> 修改为 <code>selectList(...)</code> 即可。案例可见 <a href="https://blog.csdn.net/xzm_rainbow/article/details/15336959">《MyBatis：多对一表关系详解》</a> 。</li>
<li>多对多查询，其实就是一对多查询，只需要把 <code>#selectOne(...)</code> 修改为 <code>selectList(...)</code> 即可。案例可见 <a href="https://blog.csdn.net/eson_15/article/details/51655188">《【MyBatis学习10】高级映射之多对多查询》</a> 。</li>
</ul>
<hr>
<p>关联对象查询，有两种实现方式：</p>
<blockquote>
<p>艿艿：所有的技术方案，即会有好处，又会有坏处。很难出现，一个完美的银弹方案。</p>
</blockquote>
<ul>
<li>一种是单独发送一个 SQL 去查询关联对象，赋给主对象，然后返回主对象。好处是多条 SQL 分开，相对简单，坏处是发起的 SQL 可能会比较多。</li>
<li>另一种是使用嵌套查询，嵌套查询的含义为使用 <code>join</code> 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值。好处是只发一个 SQL 查询，就可以把主对象和其关联对象查出来，坏处是 SQL 可能比较复杂。</li>
</ul>
<p>那么问题来了，<code>join</code> 查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个呢？其去重复的原理是 <code>&lt;resultMap&gt;</code> 标签内的<code>&lt;id&gt;</code> 子标签，指定了唯一确定一条记录的 <code>id</code> 列。Mybatis 会根据<code>&lt;id&gt;</code> 列值来完成 100 条记录的去重复功能，<code>&lt;id&gt;</code> 可以有多个，代表了联合主键的语意。</p>
<p>同样主对象的关联对象，也是根据这个原理去重复的。尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。例如：下面 <code>join</code> 查询出来6条记录，一、二列是 Teacher 对象列，第三列为 Student 对象列。Mybatis 去重复处理后，结果为 1 个老师和 6 个学生，而不是 6 个老师和 6 个学生。</p>
<table>
<thead>
<tr>
<th>t_id</th>
<th>t_name</th>
<th>s_id</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>teacher</td>
<td>38</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>39</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>40</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>41</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>42</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>43</td>
</tr>
</tbody></table>
<h2 id="简述-Mybatis-的插件运行原理？以及如何编写一个插件？"><a href="#简述-Mybatis-的插件运行原理？以及如何编写一个插件？" class="headerlink" title="简述 Mybatis 的插件运行原理？以及如何编写一个插件？"></a>简述 Mybatis 的插件运行原理？以及如何编写一个插件？</h2><p>Mybatis 仅可以编写针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor 这 4 种接口的插件。</p>
<p>Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 <code>#invoke(...)</code>方法。当然，只会拦截那些你指定需要拦截的方法。</p>
<hr>
<p>编写一个 MyBatis 插件的步骤如下：</p>
<ol>
<li>首先，实现 Mybatis 的 Interceptor 接口，并实现 <code>#intercept(...)</code> 方法。</li>
<li>然后，在给插件编写注解，指定要拦截哪一个接口的哪些方法即可</li>
<li>最后，在配置文件中配置你编写的插件。</li>
</ol>
<p>具体的，可以参考 <a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#plugins">《MyBatis 官方文档 —— 插件》</a> 。</p>
<hr>
<p>插件的详细解析，可以看看 <a href="http://svip.iocoder.cn/MyBatis/plugin-1">《精尽 MyBatis 源码分析 —— 插件体系（一）之原理》</a> 。</p>
<h2 id="Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>Mybatis 是如何进行分页的？分页插件的原理是什么？</h2><p>Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的<strong>内存分页</strong>，而非<strong>数据库分页</strong>。</p>
<p>所以，实际场景下，不适合直接使用 MyBatis 原有的 RowBounds 对象进行分页。而是使用如下两种方案：</p>
<ul>
<li>在 SQL 内直接书写带有数据库分页的参数来完成数据库分页功能</li>
<li>也可以使用分页插件来完成数据库分页。</li>
</ul>
<p>这两者都是基于数据库分页，差别在于前者是工程师<strong>手动</strong>编写分页条件，后者是插件<strong>自动</strong>添加分页条件。</p>
<hr>
<p>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义分页插件。在插件的拦截方法内，拦截待执行的 SQL ，然后重写 SQL ，根据dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<p>举例：<code>SELECT * FROM student</code> ，拦截 SQL 后重写为：<code>select * FROM student LIMI 0，10</code> 。</p>
<p>目前市面上目前使用比较广泛的 MyBatis 分页插件有：</p>
<ul>
<li><a href="https://github.com/pagehelper/Mybatis-PageHelper">Mybatis-PageHelper</a></li>
<li><a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a></li>
</ul>
<p>从现在看来，<a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a> 逐步使用的更加广泛。</p>
<p>关于 MyBatis 分页插件的原理深入，可以看看 <a href="http://svip.iocoder.cn/MyBatis/plugin-2">《精尽 MyBatis 源码分析 —— 插件体系（二）之 PageHelper》</a> 。</p>
<h2 id="MyBatis-与-Hibernate-有哪些不同？"><a href="#MyBatis-与-Hibernate-有哪些不同？" class="headerlink" title="MyBatis 与 Hibernate 有哪些不同？"></a>MyBatis 与 Hibernate 有哪些不同？</h2><p>Mybatis 和 Hibernate 不同，它<strong>不完全是</strong>一个 ORM 框架，因为MyBatis 需要程序员自己编写 SQL 语句。不过 MyBatis 可以通过 XML 或注解方式灵活配置要运行的 SQL 语句，并将 Java 对象和 SQL 语句映射生成最终执行的 SQL ，最后将 SQL 执行的结果再映射生成 Java 对象。</p>
<p>Mybatis 学习门槛低，简单易学，程序员直接编写原生态 SQL ，可严格控制 SQL 执行性能，灵活度高。但是灵活的前提是 MyBatis 无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套 SQL 映射文件，工作量大。</p>
<p>Hibernate 对象/关系映射能力强，数据库无关性好。如果用 Hibernate 开发可以节省很多代码，提高效率。但是  Hibernate 的缺点是学习门槛高，要精通门槛更高，而且怎么设计 O/R 映射，在性能和对象模型之间如何权衡，以及怎样用好  Hibernate 需要具有很强的经验和能力才行。 </p>
<p>总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。简单总结如下：</p>
<ul>
<li>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取。</li>
<li>Mybatis 属于半自动 ORM 映射工具，在查询关联对象或关联集合对象时，需要手动编写 SQL 来完成。</li>
</ul>
<p>另外，在 <a href="https://www.jianshu.com/p/96171e647885">《浅析 Mybatis 与 Hibernate 的区别与用途》</a> 文章，也是写的非常不错的。</p>
<p>当然，实际上，MyBatis 也可以搭配自动生成代码的工具，提升开发效率，还可以使用 <a href="http://mp.baomidou.com/">MyBatis-Plus</a> 框架，已经内置常用的 SQL 操作，也是非常不错的。</p>
<h2 id="JDBC-编程有哪些不足之处，MyBatis是如何解决这些问题的？"><a href="#JDBC-编程有哪些不足之处，MyBatis是如何解决这些问题的？" class="headerlink" title="JDBC 编程有哪些不足之处，MyBatis是如何解决这些问题的？"></a>JDBC 编程有哪些不足之处，MyBatis是如何解决这些问题的？</h2><p>问题一：SQL 语句写在代码中造成代码不易维护，且代码会比较混乱。</p>
<p>解决方式：将 SQL 语句配置在 Mapper XML 文件中，与 Java 代码分离。</p>
<hr>
<p>问题二：根据参数不同，拼接不同的 SQL 语句非常麻烦。例如 SQL 语句的 WHERE 条件不一定，可能多也可能少，占位符需要和参数一一对应。 </p>
<p>解决方式：MyBatis 提供 <code>&lt;where /&gt;</code>、<code>&lt;if /&gt;</code> 等等动态语句所需要的标签，并支持 OGNL 表达式，简化了动态 SQL 拼接的代码，提升了开发效率。</p>
<hr>
<p>问题三，对结果集解析麻烦，SQL 变化可能导致解析代码变化，且解析前需要遍历。</p>
<p>解决方式：Mybatis 自动将 SQL 执行结果映射成 Java 对象。</p>
<hr>
<p>问题四，数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。</p>
<p>解决方式：在 <code>mybatis-config.xml</code> 中，配置数据链接池，使用连接池管理数据库链接。</p>
<p>😈 当然，即使不使用 MyBatis ，也可以使用数据库连接池。<br>另外，MyBatis 默认提供了数据库连接池的实现，只是说，因为其它开源的数据库连接池性能更好，所以一般很少使用 MyBatis 自带的连接池实现。</p>
<h2 id="Mybatis-比-IBatis-比较大的几个改进是什么？"><a href="#Mybatis-比-IBatis-比较大的几个改进是什么？" class="headerlink" title="Mybatis 比 IBatis 比较大的几个改进是什么？"></a>Mybatis 比 IBatis 比较大的几个改进是什么？</h2><blockquote>
<p>这是一个选择性了解的问题，因为可能现在很多面试官，都没用过 IBatis 框架。</p>
</blockquote>
<ol>
<li>有接口绑定，包括注解绑定 SQL 和 XML 绑定 SQL 。</li>
<li>动态 SQL 由原来的节点配置变成 OGNL 表达式。</li>
<li>在一对一或一对多的时候，引进了 <code>association</code> ，在一对多的时候，引入了 <code>collection</code>节点，不过都是在 <code>&lt;resultMap /&gt;</code> 里面配置。</li>
</ol>
<h2 id="Mybatis-映射文件中，如果-A-标签通过-include-引用了B标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在A标签的前面？"><a href="#Mybatis-映射文件中，如果-A-标签通过-include-引用了B标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在A标签的前面？" class="headerlink" title="Mybatis 映射文件中，如果 A 标签通过 include 引用了B标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在A标签的前面？"></a>Mybatis 映射文件中，如果 A 标签通过 include 引用了B标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在A标签的前面？</h2><blockquote>
<p>老艿艿：这道题目，已经和源码实现，有点关系了。</p>
</blockquote>
<p>虽然 Mybatis 解析 XML 映射文件是<strong>按照顺序</strong>解析的。但是，被引用的 B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。<strong>也就是说，无需按照顺序，进行定义</strong>。</p>
<p>原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为<strong>未解析状态</strong>。然后，继续解析余下的标签，包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析A标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</p>
<p>可能有一些绕，胖友可以看看 <a href="http://svip.iocoder.cn/MyBatis/builder-package-1">《精尽 MyBatis 源码解析 —— MyBatis 初始化（一）之加载 mybatis-config》</a> 。</p>
<p>此处，我们在引申一个问题，Spring IOC 中，存在互相依赖的 Bean 对象，该如何解决呢？答案见 <a href="http://svip.iocoder.cn/Spring/IoC-get-Bean-createBean-5/">《【死磕 Spring】—— IoC 之加载 Bean：创建 Bean（五）之循环依赖处理》</a> 。</p>
<h2 id="简述-Mybatis-的-XML-映射文件和-Mybatis-内部数据结构之间的映射关系？"><a href="#简述-Mybatis-的-XML-映射文件和-Mybatis-内部数据结构之间的映射关系？" class="headerlink" title="简述 Mybatis 的 XML 映射文件和 Mybatis 内部数据结构之间的映射关系？"></a>简述 Mybatis 的 XML 映射文件和 Mybatis 内部数据结构之间的映射关系？</h2><blockquote>
<p>老艿艿：这道题目，已经和源码实现，有点关系了。</p>
</blockquote>
<p>Mybatis 将所有 XML 配置信息都封装到 All-In-One 重量级对象Configuration内部。</p>
<p>在 XML Mapper 文件中：</p>
<ul>
<li><code>&lt;parameterMap&gt;</code> 标签，会被解析为 ParameterMap 对象，其每个子元素会被解析为 ParameterMapping 对象。</li>
<li><code>&lt;resultMap&gt;</code> 标签，会被解析为 ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。</li>
<li>每一个 <code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code> 标签，均会被解析为一个 MappedStatement 对象，标签内的 SQL 会被解析为一个 BoundSql 对象。</li>
</ul>
<h2 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h2><p>参考与推荐如下文章：</p>
<ul>
<li>祖大俊 <a href="https://my.oschina.net/zudajun/blog/747682">《Mybatis3.4.x技术内幕（二十三）：Mybatis面试问题集锦（大结局）》</a></li>
<li>Java3y <a href="https://segmentfault.com/a/1190000013678579">《Mybatis 常见面试题》</a></li>
<li>Homiss <a href="https://github.com/Homiss/Java-interview-questions/blob/master/%E6%A1%86%E6%9E%B6/MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98.md">《MyBatis 面试题》</a></li>
</ul>
]]></content>
      <categories>
        <category>MyBatis</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>精尽 Spring Boot 面试题</title>
    <url>/2016/10/12/%E7%B2%BE%E5%B0%BD%20Spring%20Boot%20%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="精尽-Spring-Boot-面试题"><a href="#精尽-Spring-Boot-面试题" class="headerlink" title="精尽 Spring Boot 面试题"></a>精尽 Spring Boot 面试题</h1><p>以下面试题，基于网络整理，和自己编辑。具体参考的文章，会在文末给出所有的链接。</p>
<p>如果胖友有自己的疑问，欢迎在星球提问，我们一起整理吊吊的 Spring Boot 面试题的大保健。</p>
<p>而题目的难度，艿艿尽量按照从容易到困难的顺序，逐步下去。</p>
<p>在内容上，我们会分成两大块：</p>
<ul>
<li>核心技术篇，分享 Spring Boot 的核心技术相关的内容。</li>
<li>整合篇，分享 Spring Boot 整合一些框架的面试题，例如 JPA 如何集成到 Spring Boot 中。</li>
</ul>
<h1 id="核心技术篇"><a href="#核心技术篇" class="headerlink" title="核心技术篇"></a>核心技术篇</h1><h2 id="Spring-Boot-是什么？"><a href="#Spring-Boot-是什么？" class="headerlink" title="Spring Boot 是什么？"></a>Spring Boot 是什么？</h2><p><a href="https://github.com/spring-projects/spring-boot">Spring Boot</a> 是 Spring 的<strong>子项目</strong>，正如其名字，提供 Spring 的引导( <strong>Boot</strong> )的功能。</p>
<p>通过 Spring Boot ，我们开发者可以快速配置 Spring 项目，引入各种 Spring MVC、Spring  Transaction、Spring AOP、MyBatis 等等框架，而无需不断重复编写繁重的 Spring 配置，降低了 Spring  的使用成本。</p>
<blockquote>
<p>艿艿：犹记当年，Spring XML 为主的时代，大晚上各种搜索 Spring 的配置，苦不堪言。现在有了 Spring Boot 之后，生活真美好。</p>
</blockquote>
<p>Spring Boot 提供了各种 Starter 启动器，提供标准化的默认配置。例如：</p>
<ul>
<li><a href="https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web/2.1.1.RELEASE"><code>spring-boot-starter-web</code></a> 启动器，可以快速配置 Spring MVC 。</li>
<li><a href="https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter/1.3.2"><code>mybatis-spring-boot-starter</code></a> 启动器，可以快速配置 MyBatis 。 </li>
</ul>
<p>并且，Spring Boot 基本已经一统 Java 项目的开发，大量的开源项目都实现了其的 Starter 启动器。例如：</p>
<ul>
<li><a href="https://github.com/apache/incubator-dubbo-spring-boot-project"><code>incubator-dubbo-spring-boot-project</code></a> 启动器，可以快速配置 Dubbo 。</li>
<li><a href="https://github.com/maihaoche/rocketmq-spring-boot-starter"><code>rocketmq-spring-boot-starter</code></a> 启动器，可以快速配置 RocketMQ 。</li>
</ul>
<h2 id="Spring-Boot-提供了哪些核心功能？"><a href="#Spring-Boot-提供了哪些核心功能？" class="headerlink" title="Spring Boot 提供了哪些核心功能？"></a>Spring Boot 提供了哪些核心功能？</h2><ul>
<li><p>1、独立运行 Spring 项目</p>
<p>  Spring Boot 可以以 jar 包形式独立运行，运行一个 Spring Boot 项目只需要通过 <code>java -jar xx.jar</code> 来运行。</p>
</li>
<li><p>2、内嵌 Servlet 容器</p>
<p>  Spring Boot 可以选择内嵌 Tomcat、Jetty 或者 Undertow，这样我们无须以 war 包形式部署项目。</p>
<blockquote>
<p>第 2 点是对第 1 点的补充，在 Spring Boot 未出来的时候，大多数 Web 项目，是打包成 war 包，部署到 Tomcat、Jetty 等容器。</p>
</blockquote>
</li>
<li><p>3、提供 Starter 简化 Maven 配置</p>
<p>  Spring 提供了一系列的 starter pom 来简化 Maven 的依赖加载。例如，当你使用了 <code>spring-boot-starter-web</code> ，会自动加入如下依赖：<img src="http://cdn.tuwenbin.vip/01-1601209309189.jpg" alt="01"><code>spring-boot-starter-web</code> 的 pom 文件</p>
</li>
<li><p>4、<a href="https://www.jianshu.com/p/ddb6e32e3faf">自动配置 Spring Bean</a></p>
<p>  Spring Boot 检测到特定类的存在，就会针对这个应用做一定的配置，进行自动配置 Bean ，这样会极大地减少我们要使用的配置。</p>
<p>  当然，Spring Boot 只考虑大多数的开发场景，并不是所有的场景，若在实际开发中我们需要配置Bean ，而 Spring Boot 没有提供支持，则可以自定义自动配置进行解决。</p>
</li>
<li><p>5、<a href="https://blog.csdn.net/wangshuang1631/article/details/72810412">准生产的应用监控</a></p>
<p>  Spring Boot 提供基于 HTTP、JMX、SSH 对运行时的项目进行监控。</p>
</li>
<li><p>6、无代码生成和 XML 配置</p>
<p>  Spring Boot 没有引入任何形式的代码生成，它是使用的 Spring 4.0 的条件 <code>@Condition</code> 注解以实现根据条件进行配置。同时使用了  Maven /Gradle 的<strong>依赖传递解析机制</strong>来实现 Spring 应用里面的自动配置。</p>
<blockquote>
<p>第 6 点是第 3 点的补充。</p>
</blockquote>
</li>
</ul>
<h2 id="Spring-Boot-有什么优缺点？"><a href="#Spring-Boot-有什么优缺点？" class="headerlink" title="Spring Boot 有什么优缺点？"></a>Spring Boot 有什么优缺点？</h2><blockquote>
<p>艿艿：任何技术栈，有优点必有缺点，没有银弹。</p>
<p>另外，这个问题的回答，我们是基于 <a href="https://blog.csdn.net/fly_zhyu/article/details/76407830">《Spring Boot浅谈(是什么/能干什么/优点和不足)》</a> 整理，所以胖友主要看下这篇文章。</p>
</blockquote>
<p><strong>Spring Boot 的优点</strong></p>
<blockquote>
<p>艿艿：优点和 <a href="http://svip.iocoder.cn/Spring-Boot/Interview/#">「Spring Boot 提供了哪些核心功能？」</a> 问题的答案，是比较重叠的。</p>
</blockquote>
<ul>
<li>1、使【编码】变简单。</li>
<li>2、使【配置】变简单。</li>
<li>3、使【部署】变简单。</li>
<li>4、使【监控】变简单。</li>
</ul>
<p><strong>Spring Boot 的缺点</strong></p>
<blockquote>
<p>艿艿：如下的缺点，基于 <a href="https://blog.csdn.net/fly_zhyu/article/details/76407830">《Spring Boot浅谈(是什么/能干什么/优点和不足)》</a>，考虑的出发点是把 Spring Boot 作为微服务的框架的选型的角度进行考虑。</p>
</blockquote>
<ul>
<li><p>1、没有提供相应的【服务发现和注册】的配套功能。</p>
<blockquote>
<p>艿艿：当然，实际上 Spring Boot 本身是不需要提供这样的功能。服务发现和注册的功能，是在 Spring Cloud 中进行提供。</p>
</blockquote>
</li>
<li><p>2、自身的 acturator 所提供的【监控功能】，也需要与现有的监控对接。</p>
</li>
<li><p>3、没有配套的【安全管控】方案。</p>
<blockquote>
<p>艿艿：关于这一点，艿艿也有点迷糊，Spring Security 是可以比较方便的集成到 Spring Boot 中，所以不晓得这里的【安全管控】的定义是什么。所以这一点，面试的时候回答，可以暂时先省略。</p>
</blockquote>
</li>
<li><p>4、对于 REST 的落地，还需要自行结合实际进行 URI 的规范化工作    </p>
<blockquote>
<p>艿艿：这个严格来说，不算缺点。本身，是规范的范畴。</p>
</blockquote>
</li>
</ul>
<p>所以，上面的缺点，严格来说可能不太适合在面试中回答。艿艿认为，Spring Boot 的缺点主要是，因为自动配置 Spring Bean  的功能，我们可能无法知道，哪些 Bean 被进行创建了。这个时候，如果我们想要自定义一些 Bean ，可能存在冲突，或者不知道实际注入的情况。</p>
<h2 id="Spring-Boot、Spring-MVC-和-Spring-有什么区别？"><a href="#Spring-Boot、Spring-MVC-和-Spring-有什么区别？" class="headerlink" title="Spring Boot、Spring MVC 和 Spring 有什么区别？"></a>Spring Boot、Spring MVC 和 Spring 有什么区别？</h2><p>Spring 的完整名字，应该是 Spring Framework 。它提供了多个模块，Spring IoC、Spring AOP、Spring MVC 等等。所以，Spring MVC 是 Spring Framework 众多模块中的一个。</p>
<p>而 Spring Boot 是构造在 Spring Framework 之上的 Boot 启动器，旨在更容易的配置一个 Spring 项目。</p>
<p>总结说来，如下图所示：<a href="http://static2.iocoder.cn/images/Spring/2018-12-26/02.png"><img src="http://cdn.tuwenbin.vip/02.png" alt="Spring Boot 对比 Spring MVC 对比 Spring ？"></a>Spring Boot 对比 Spring MVC 对比 Spring ？</p>
<h2 id="Spring-Boot-中的-Starter-是什么？"><a href="#Spring-Boot-中的-Starter-是什么？" class="headerlink" title="Spring Boot 中的 Starter 是什么？"></a>Spring Boot 中的 Starter 是什么？</h2><p>比较<strong>通俗</strong>的说法：</p>
<blockquote>
<p>FROM <a href="https://www.cnblogs.com/EasonJim/p/7615801.html">《Spring Boot 中 Starter 是什么》</a></p>
<p>比如我们要在 Spring Boot 中引入 Web MVC 的支持时，我们通常会引入这个模块 <code>spring-boot-starter-web</code> ，而这个模块如果解压包出来会发现里面什么都没有，只定义了一些 <strong>POM</strong> 依赖。如下图所示：<a href="http://static2.iocoder.cn/images/Spring/2018-12-26/03.png"><img src="http://cdn.tuwenbin.vip/20200929103657.png" alt="`spring-boot-starter-web`"></a><code>spring-boot-starter-web</code></p>
<p>经过研究，Starter 主要用来简化依赖用的。比如我们之前做MVC时要引入日志组件，那么需要去找到log4j的版本，然后引入，现在有了Starter之后，直接用这个之后，log4j就自动引入了，也不用关心版本这些问题。</p>
</blockquote>
<p>比较<strong>书名</strong>的说法：</p>
<blockquote>
<p>FROM <a href="http://www.importnew.com/27101.html">《Spring Boot Starter 介绍》</a></p>
<p>依赖管理是任何复杂项目的关键部分。以手动的方式来实现依赖管理不太现实，你得花更多时间，同时你在项目的其他重要方面能付出的时间就会变得越少。</p>
<p>Spring Boot Starter 就是为了解决这个问题而诞生的。Starter <strong>POM</strong> 是一组方便的依赖描述符，您可以将其包含在应用程序中。您可以获得所需的所有 Spring 和相关技术的一站式服务，无需通过示例代码搜索和复制粘贴依赖。</p>
</blockquote>
<h2 id="Spring-Boot-常用的-Starter-有哪些？"><a href="#Spring-Boot-常用的-Starter-有哪些？" class="headerlink" title="Spring Boot 常用的 Starter 有哪些？"></a>Spring Boot 常用的 Starter 有哪些？</h2><ul>
<li><code>spring-boot-starter-web</code> ：提供 Spring MVC + 内嵌的 Tomcat 。</li>
<li><code>spring-boot-starter-data-jpa</code> ：提供 Spring JPA + Hibernate 。</li>
<li><code>spring-boot-starter-data-redis</code> ：提供 Redis 。</li>
<li><code>mybatis-spring-boot-starter</code> ：提供 MyBatis 。</li>
</ul>
<h2 id="创建一个-Spring-Boot-Project-的最简单的方法是什么？"><a href="#创建一个-Spring-Boot-Project-的最简单的方法是什么？" class="headerlink" title="创建一个 Spring Boot Project 的最简单的方法是什么？"></a>创建一个 Spring Boot Project 的最简单的方法是什么？</h2><p>Spring Initializr 是创建 Spring Boot Projects 的一个很好的工具。打开 <code>&quot;https://start.spring.io/&quot;</code> 网站，我们可以看到 Spring Initializr 工具，如下图所示：</p>
<p><a href="http://static2.iocoder.cn/images/Spring/2018-12-26/04.png"><img src="http://cdn.tuwenbin.vip/20200929103721.png" alt="Spring Initializr"></a>Spring Initializr</p>
<ul>
<li>图中的每一个<strong>红线</strong>，都可以填写相应的配置。相信胖友都很熟悉，就不哔哔了。</li>
<li>点击生 GenerateProject ，生成 Spring Boot Project 。</li>
<li>将项目导入 IDEA ，记得选择现有的 Maven 项目。</li>
</ul>
<hr>
<p>当然，我们以前使用 IDEA 创建 Spring 项目的方式，也一样能创建 Spring Boot Project 。Spring Initializr 更多的是，提供一个便捷的工具。</p>
<h2 id="如何统一引入-Spring-Boot-版本？"><a href="#如何统一引入-Spring-Boot-版本？" class="headerlink" title="如何统一引入 Spring Boot 版本？"></a>如何统一引入 Spring Boot 版本？</h2><p><strong>目前有两种方式</strong>。</p>
<p>① 方式一：继承 <code>spring-boot-starter-parent</code> 项目。配置代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;parent&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;1.5.1.RELEASE&lt;&#x2F;version&gt;<br>&lt;&#x2F;parent&gt;<br></code></pre></td></tr></table></figure>

<p>② 方式二：导入 spring-boot-dependencies 项目依赖。配置代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dependencyManagement&gt;<br>    &lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>            &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;<br>            &lt;version&gt;1.5.1.RELEASE&lt;&#x2F;version&gt;<br>            &lt;type&gt;pom&lt;&#x2F;type&gt;<br>            &lt;scope&gt;import&lt;&#x2F;scope&gt;<br>        &lt;&#x2F;dependency&gt;<br>    &lt;&#x2F;dependencies&gt;<br>&lt;&#x2F;dependencyManagement&gt;<br></code></pre></td></tr></table></figure>

<p><strong>如何选择？</strong></p>
<p>因为一般我们的项目中，都有项目自己的 Maven parent 项目，所以【方式一】显然会存在冲突。所以实际场景下，推荐使用【方式二】。</p>
<p>详细的，推荐阅读 <a href="https://blog.csdn.net/rainbow702/article/details/55046298">《Spring Boot 不使用默认的 parent，改用自己的项目的 parent》</a> 文章。</p>
<p>另外，在使用 Spring Cloud 的时候，也可以使用这样的方式。</p>
<h2 id="运行-Spring-Boot-有哪几种方式？"><a href="#运行-Spring-Boot-有哪几种方式？" class="headerlink" title="运行 Spring Boot 有哪几种方式？"></a>运行 Spring Boot 有哪几种方式？</h2><ul>
<li>1、打包成 Fat Jar ，直接使用 <code>java -jar</code> 运行。目前主流的做法，推荐。</li>
<li>2、在 IDEA 或 Eclipse 中，直接运行应用的 Spring Boot 启动类的 <code>#main(String[] args)</code> 启动。适用于开发调试场景。</li>
<li>3、如果是 Web 项目，可以打包成 War 包，使用外部 Tomcat 或 Jetty 等容器。</li>
</ul>
<h2 id="如何打包-Spring-Boot-项目？"><a href="#如何打包-Spring-Boot-项目？" class="headerlink" title="如何打包 Spring Boot 项目？"></a>如何打包 Spring Boot 项目？</h2><p>通过引入 <code>spring-boot-maven-plugin</code> 插件，执行 <code>mvn clean package</code> 命令，将 Spring Boot 项目打成一个 Fat Jar 。后续，我们就可以直接使用 <code>java -jar</code> 运行。</p>
<p>关于 <code>spring-boot-maven-plugin</code> 插件，更多详细的可以看看 [《创建可执行 jar》](<a href="https://qbgbook.gitbooks.io/spring-boot-reference-guide-zh/II">https://qbgbook.gitbooks.io/spring-boot-reference-guide-zh/II</a>. Getting started/11.5. Creating an executable jar.html) 。</p>
<h2 id="如果更改内嵌-Tomcat-的端口？"><a href="#如果更改内嵌-Tomcat-的端口？" class="headerlink" title="如果更改内嵌 Tomcat 的端口？"></a>如果更改内嵌 Tomcat 的端口？</h2><ul>
<li><p>方式一，修改 <code>application.properties</code> 配置文件的 <code>server.port</code> 属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">server.port&#x3D;9090<br></code></pre></td></tr></table></figure>
</li>
<li><p>方式二，通过启动命令增加 <code>server.port</code> 参数进行修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">java -jar xxx.jar --server.port&#x3D;9090<br></code></pre></td></tr></table></figure>

</li>
</ul>
<p>当然，以上的方式，不仅仅适用于 Tomcat ，也适用于 Jetty、Undertow 等服务器。</p>
<h2 id="如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？"><a href="#如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？" class="headerlink" title="如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？"></a>如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？</h2><p>一共有三种方式，可以实现效果：</p>
<ul>
<li><p>【推荐】<code>spring-boot-devtools</code> 插件。注意，这个工具需要配置 IDEA 的自动编译。</p>
</li>
<li><p>Spring Loaded 插件。</p>
<blockquote>
<p>Spring Boot 2.X 后，官方宣布不再支持 Spring Loaded 插件 的更新，所以基本可以无视它了。</p>
</blockquote>
</li>
<li><p><a href="https://www.jianshu.com/p/bab43eaa4e14">JRebel</a> 插件，需要付费。</p>
</li>
</ul>
<p>关于如何使用 <code>spring-boot-devtools</code> 和 Spring Loaded 插件，胖友可以看看 <a href="https://segmentfault.com/a/1190000014488100">《Spring Boot 学习笔记：Spring Boot Developer Tools 与热部署》</a> 。</p>
<h2 id="Spring-Boot-的配置文件有哪几种格式？"><a href="#Spring-Boot-的配置文件有哪几种格式？" class="headerlink" title="Spring Boot 的配置文件有哪几种格式？"></a>Spring Boot 的配置文件有哪几种格式？</h2><p>Spring Boot 目前支持两种格式的配置文件：</p>
<ul>
<li><p><code>.properties</code> 格式。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">server.port &#x3D; 9090<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>.yaml</code> 格式。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">server:<br>    port: 9090<br></code></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<p>可能有胖友不了解 <strong>YAML 格式</strong>？</p>
<p>YAML 是一种人类可读的数据序列化语言，它通常用于配置文件。</p>
<ul>
<li><p>与 Properties 文件相比，如果我们想要在配置文件中添加复杂的属性 YAML 文件就更加<strong>结构化</strong>。从上面的示例，我们可以看出 YAML 具有<strong>分层</strong>配置数据。</p>
</li>
<li><p>当然 YAML 在 Spring 会存在一个缺陷，</p>
<p><code>@PropertySource</code></p>
<p> 注解不支持读取 YAML 配置文件，仅支持 Properties 配置文件。</p>
<ul>
<li>不过这个问题也不大，可以麻烦一点使用 <a href="https://blog.csdn.net/lafengwnagzi/article/details/74178374"><code>@Value</code></a> 注解，来读取 YAML 配置项。</li>
</ul>
</li>
</ul>
<p>实际场景下，艿艿相对比较喜欢使用 Properties 配置文件。个人喜欢~当然，YAML 已经越来越流行了。</p>
<h2 id="Spring-Boot-默认配置文件是什么？"><a href="#Spring-Boot-默认配置文件是什么？" class="headerlink" title="Spring Boot 默认配置文件是什么？"></a>Spring Boot 默认配置文件是什么？</h2><p>对于 Spring Boot 应用，默认的配置文件根目录下的 <strong>application</strong> 配置文件，当然可以是 Properties 格式，也可以是 YAML 格式。</p>
<p>可能有胖友说，我在网上看到面试题中，说还有一个根目录下的 <strong>bootstrap</strong> 配置文件。这个是 Spring Cloud 新增的启动配置文件，<a href="https://my.oschina.net/freeskyjs/blog/1843048">需要引入 <code>spring-cloud-context</code> 依赖后，才会进行加载</a>。它的特点和用途主要是：</p>
<blockquote>
<p>参考 <a href="https://my.oschina.net/neverforget/blog/1525947">《Spring Cloud 中配置文件名 bootstrap.yml 和 application.yml 区别》</a> 文章。</p>
</blockquote>
<ul>
<li>【特点】因为 bootstrap 由父 ApplicationContext 加载，比 application 优先加载。</li>
<li>【特点】因为 bootstrap 优先于 application 加载，所以不会被它覆盖。 </li>
<li>【用途】使用配置中心 Spring Cloud Config 时，需要在 bootstrap 中配置配置中心的地址，从而实现父 ApplicationContext 加载时，从配置中心拉取相应的配置到应用中。</li>
</ul>
<p>另外，<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html">《Appendix A. Common application properties》</a> 中，有 application 配置文件的通用属性列表。</p>
<h2 id="Spring-Boot-如何定义多套不同环境配置？"><a href="#Spring-Boot-如何定义多套不同环境配置？" class="headerlink" title="Spring Boot 如何定义多套不同环境配置？"></a>Spring Boot 如何定义多套不同环境配置？</h2><p>可以参考 <a href="https://blog.csdn.net/top_code/article/details/78570047">《Spring Boot 教程 - Spring Boot Profiles 实现多环境下配置切换》</a> 一文。</p>
<p>但是，需要考虑一个问题，生产环境的配置文件的安全性，显然我们不能且不应该把生产的配置放到项目的 Git 仓库中进行管理。那么应该怎么办呢？</p>
<ul>
<li>方案一，生产环境的配置文件放在生产环境的服务器中，以 <code>java -jar myproject.jar --spring.config.location=/xxx/yyy/application-prod.properties</code> 命令，设置 参数 <code>spring.config.location</code> 指向配置文件。</li>
<li>方案二，使用 Jenkins 在执行打包，配置上 Maven Profile 功能，使用服务器上的配置文件。😈 整体来说，和【方案一】的差异是，将配置文件打包进了 Jar 包中。</li>
<li>方案三，使用配置中心。</li>
</ul>
<h2 id="Spring-Boot-配置加载顺序？"><a href="#Spring-Boot-配置加载顺序？" class="headerlink" title="Spring Boot 配置加载顺序？"></a>Spring Boot 配置加载顺序？</h2><p>在 Spring Boot 中，除了我们常用的 application 配置文件之外，还有：</p>
<ul>
<li>系统环境变量</li>
<li>命令行参数</li>
<li>等等…</li>
</ul>
<p>参考 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html">《Externalized Configuration》</a> 文档，我们整理顺序如下：</p>
<ol>
<li><p><code>spring-boot-devtools</code>依赖的 <code>spring-boot-devtools.properties</code>配置文件。</p>
<blockquote>
<p>这个灰常小众，具体说明可以看看 <a href="https://blog.csdn.net/u011499747/article/details/71746325">《Spring Boot参考文档（12）开发者工具》</a> ，建议无视。</p>
</blockquote>
</li>
<li><p>单元测试上的 <code>@TestPropertySource</code>和 <code>@SpringBootTest</code>注解指定的参数。</p>
<blockquote>
<p>前者的优先级高于后者。可以看看 <a href="https://segmentfault.com/a/1190000010854607">《Spring、Spring Boot 和TestNG 测试指南 - @TestPropertySource》</a> 一文。</p>
</blockquote>
</li>
<li><p>命令行指定的参数。例如 <code>java -jar springboot.jar --server.port=9090</code> 。</p>
</li>
<li><p>命令行中的 <code>spring.application.json</code> 指定参数。例如 <code>java -Dspring.application.json=&#39;&#123;&quot;name&quot;:&quot;Java&quot;&#125;&#39; -jar springboot.jar</code> 。</p>
</li>
<li><p>ServletConfig 初始化参数。</p>
</li>
<li><p>ServletContext 初始化参数。</p>
</li>
<li><p>JNDI 参数。例如 <code>java:comp/env</code> 。</p>
</li>
<li><p>Java 系统变量，即 <code>System#getProperties()</code> 方法对应的。</p>
</li>
<li><p>操作系统环境变量。</p>
</li>
<li><p>RandomValuePropertySource 配置的 <code>random.*</code> 属性对应的值。</p>
</li>
<li><p>Jar <strong>外部</strong>的带指定 profile 的 application 配置文件。例如 <code>application-&#123;profile&#125;.yaml</code> 。</p>
</li>
<li><p>Jar <strong>内部</strong>的带指定 profile 的 application 配置文件。例如 <code>application-&#123;profile&#125;.yaml</code> 。</p>
</li>
<li><p>Jar <strong>外部</strong> application 配置文件。例如 <code>application.yaml</code> 。</p>
</li>
<li><p>Jar <strong>内部</strong> application 配置文件。例如 <code>application.yaml</code> 。</p>
</li>
<li><p>在自定义的 <code>@Configuration</code> 类中定于的 <code>@PropertySource</code> 。</p>
</li>
<li><p>启动的 main 方法中，定义的默认配置。即通过 <code>SpringApplication#setDefaultProperties(Map&lt;String, Object&gt; defaultProperties)</code> 方法进行设置。</p>
</li>
</ol>
<p>嘿嘿，是不是很多很长，不用真的去记住。</p>
<ul>
<li>一般来说，面试官不会因为这个题目回答的不好，对你扣分。</li>
<li>实际使用时，做下测试即可。</li>
<li>每一种配置方式的详细说明，可以看看 <a href="https://segmentfault.com/a/1190000015069140">《Spring Boot 参考指南（外部化配置）》</a> 。</li>
</ul>
<h2 id="Spring-Boot-有哪些配置方式？"><a href="#Spring-Boot-有哪些配置方式？" class="headerlink" title="Spring Boot 有哪些配置方式？"></a>Spring Boot 有哪些配置方式？</h2><p>和 Spring 一样，一共提供了三种方式。</p>
<ul>
<li><p>1、XML 配置文件。</p>
<p>  Bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;bean id&#x3D;&quot;studentBean&quot; class&#x3D;&quot;org.edureka.firstSpring.StudentBean&quot;&gt;<br>    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;Edureka&quot;&gt;&lt;&#x2F;property&gt;<br>&lt;&#x2F;bean&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>2、注解配置。</p>
<p>  您可以通过在相关的类，方法或字段声明上使用注解，将 Bean 配置为组件类本身，而不是使用 XML 来描述 Bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;beans&gt;<br>&lt;context:annotation-config&#x2F;&gt;<br>&lt;!-- bean definitions go here --&gt;<br>&lt;&#x2F;beans&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>3、Java Config 配置。</p>
<p>  Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p>
<ul>
<li><p><code>@Bean</code> 注解扮演与 <code>&lt;bean /&gt;</code> 元素相同的角色。</p>
</li>
<li><p><code>@Configuration</code> 类允许通过简单地调用同一个类中的其他 <code>@Bean</code> 方法来定义 Bean 间依赖关系。</p>
</li>
<li><p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Configuration<br>public class StudentConfig &#123;<br>    <br>    @Bean<br>    public StudentBean myStudent() &#123;<br>        return new StudentBean();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>是不是很熟悉 😈</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>目前主要使用 <strong>Java Config</strong> 配置为主。当然，三种配置方式是可以混合使用的。例如说：</p>
<ul>
<li>Dubbo 服务的配置，艿艿喜欢使用 XML 。</li>
<li>Spring MVC 请求的配置，艿艿喜欢使用 <code>@RequestMapping</code> 注解。</li>
<li>Spring MVC 拦截器的配置，艿艿喜欢 Java Config 配置。</li>
</ul>
<hr>
<p>另外，现在已经是 Spring Boot 的天下，所以更加是 <strong>Java Config</strong> 配置为主。</p>
<h2 id="Spring-Boot-的核心注解是哪个？"><a href="#Spring-Boot-的核心注解是哪个？" class="headerlink" title="Spring Boot 的核心注解是哪个？"></a>Spring Boot 的核心注解是哪个？</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">package cn.iocoder.skywalking.web01;<br><br>import org.springframework.boot.SpringApplication;<br>import org.springframework.boot.autoconfigure.SpringBootApplication;<br><br>@SpringBootApplication<br>public class Web01Application &#123;<br><br>    public static void main(String[] args) &#123;<br>        SpringApplication.run(Web01Application.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>@SpringBootApplication</code> 注解，就是 Spring Boot 的核心注解。</li>
</ul>
<p><code>org.springframework.boot.autoconfigure.@SpringBootApplication</code> 注解的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; SpringBootApplication.java<br><br>@Target(&#123;ElementType.TYPE&#125;)<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>@Inherited<br>@SpringBootConfiguration<br>@EnableAutoConfiguration<br>@ComponentScan(<br>    excludeFilters &#x3D; &#123;@Filter(<br>    type &#x3D; FilterType.CUSTOM,<br>    classes &#x3D; &#123;TypeExcludeFilter.class&#125;<br>), @Filter(<br>    type &#x3D; FilterType.CUSTOM,<br>    classes &#x3D; &#123;AutoConfigurationExcludeFilter.class&#125;<br>)&#125;<br>)<br>public @interface SpringBootApplication &#123;<br>    @AliasFor(<br>        annotation &#x3D; EnableAutoConfiguration.class<br>    )<br>    Class&lt;?&gt;[] exclude() default &#123;&#125;;<br><br>    @AliasFor(<br>        annotation &#x3D; EnableAutoConfiguration.class<br>    )<br>    String[] excludeName() default &#123;&#125;;<br><br>    @AliasFor(<br>        annotation &#x3D; ComponentScan.class,<br>        attribute &#x3D; &quot;basePackages&quot;<br>    )<br>    String[] scanBasePackages() default &#123;&#125;;<br><br>    @AliasFor(<br>        annotation &#x3D; ComponentScan.class,<br>        attribute &#x3D; &quot;basePackageClasses&quot;<br>    )<br>    Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>它组合了 3 个注解，详细说明，胖友看看 <a href="https://blog.csdn.net/claram/article/details/75125749">《Spring Boot 系列：@SpringBootApplication 注解》</a> 。</p>
</li>
<li><p><code>@Configuration</code> 注解，指定类是 <strong>Bean 定义</strong>的配置类。</p>
<blockquote>
<p><code>@Configuration</code> 注解，来自 <code>spring-context</code> 项目，用于 Java Config ，不是 Spring Boot 新带来的。</p>
</blockquote>
</li>
<li><p><code>#ComponentScan</code> 注解，扫描指定包下的 Bean 们。</p>
<blockquote>
<p><code>@ComponentScan</code> 注解，来自 <code>spring-context</code> 项目，用于 Java Config ，不是 Spring Boot 新带来的。</p>
</blockquote>
</li>
<li><p><code>@EnableAutoConfiguration</code> 注解，打开自动配置的功能。如果我们想要关闭某个类的自动配置，可以设置注解的 <code>exclude</code> 或 <code>excludeName</code> 属性。</p>
<blockquote>
<p><code>@EnableAutoConfiguration</code> 注解，来自 <code>spring-boot-autoconfigure</code> 项目，<strong>它才是 Spring Boot 新带来的</strong>。</p>
</blockquote>
</li>
</ul>
<h2 id="什么是-Spring-Boot-自动配置？"><a href="#什么是-Spring-Boot-自动配置？" class="headerlink" title="什么是 Spring Boot 自动配置？"></a>什么是 Spring Boot 自动配置？</h2><p>在 <a href="http://svip.iocoder.cn/Spring-Boot/Interview/#">「Spring Boot 的核心注解是哪个？」</a> 中，我们已经看到，使用 <code>@@EnableAutoConfiguration</code> 注解，打开 Spring Boot 自动配置的功能。具体如何实现的，可以看看如下两篇文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/464d04c36fb1">《@EnableAutoConfiguration 注解的工作原理》</a> 。</li>
<li><a href="https://juejin.im/post/5b679fbc5188251aad213110">《一个面试题引起的 Spring Boot 启动解析》</a></li>
<li>建议，能一边调试，一边看这篇文章。调试很简单，任一搭建一个 Spring Boot 项目即可。</li>
</ul>
<p>如下是一个比较简单的总结：</p>
<ol>
<li>Spring Boot 在启动时扫描项目所依赖的 jar 包，寻找包含<code>spring.factories</code> 文件的 jar 包。</li>
<li>根据 <code>spring.factories</code> 配置加载 AutoConfigure 类。</li>
<li>根据 [<code>@Conditional</code> 等条件注解](<a href="http://svip.iocoder.cn/Spring-Boot/Interview/Spring">http://svip.iocoder.cn/Spring-Boot/Interview/Spring</a> Boot 条件注解) 的条件，进行自动配置并将 Bean 注入 Spring IoC 中。</li>
</ol>
<h2 id="Spring-Boot-有哪几种读取配置的方式？"><a href="#Spring-Boot-有哪几种读取配置的方式？" class="headerlink" title="Spring Boot 有哪几种读取配置的方式？"></a>Spring Boot 有哪几种读取配置的方式？</h2><p>Spring Boot 目前支持 <strong>2</strong> 种读取配置：</p>
<ol>
<li><p><code>@Value</code> 注解，读取配置到属性。最最最常用。</p>
<blockquote>
<p>另外，支持和 <code>@PropertySource</code> 注解一起使用，指定使用的配置文件。</p>
</blockquote>
</li>
<li><p><code>@ConfigurationProperties</code> 注解，读取配置到类上。</p>
<blockquote>
<p>另外，支持和 <code>@PropertySource</code> 注解一起使用，指定使用的配置文件。</p>
</blockquote>
</li>
</ol>
<p>详细的使用方式，可以参考 <a href="https://aoyouzi.iteye.com/blog/2422837">《Spring Boot 读取配置的几种方式》</a> 。</p>
<h2 id="使用-Spring-Boot-后，项目结构是怎么样的呢？"><a href="#使用-Spring-Boot-后，项目结构是怎么样的呢？" class="headerlink" title="使用 Spring Boot 后，项目结构是怎么样的呢？"></a>使用 Spring Boot 后，项目结构是怎么样的呢？</h2><p>我们先来说说项目的分层。一般来说，主流的有两种方式：</p>
<ul>
<li>方式一，<code>controller</code>、<code>service</code>、<code>dao</code> 三个包，每个包下面添加相应的 XXXController、YYYService、ZZZDAO 。</li>
<li>方式二，按照业务模块分包，每个包里面放 Controller、Service、DAO 类。例如，业务模块分成 <code>user</code>、<code>order</code>、<code>item</code> 等等包，在 <code>user</code> 包里放 UserController、UserService、UserDAO 类。</li>
</ul>
<p>那么，使用 Spring Boot 的项目怎么分层呢？艿艿自己的想法</p>
<ul>
<li>现在项目都会进行服务化分拆，每个项目不会特别复杂，所以建议使用【方式一】。</li>
<li>以前的项目，大多是单体的项目，动则项目几万到几十万的代码，当时多采用【方式二】。</li>
</ul>
<p>下面是一个简单的 Spring Boot 项目的 Demo ，如下所示：<a href="http://static2.iocoder.cn/images/Spring/2018-12-26/05.png"><img src="http://cdn.tuwenbin.vip/20200929103740.png" alt="Spring Boot 项目的 Demo"></a>Spring Boot 项目的 Demo</p>
<h2 id="如何在-Spring-Boot-启动的时候运行一些特殊的代码？"><a href="#如何在-Spring-Boot-启动的时候运行一些特殊的代码？" class="headerlink" title="如何在 Spring Boot 启动的时候运行一些特殊的代码？"></a>如何在 Spring Boot 启动的时候运行一些特殊的代码？</h2><p>如果需要在 SpringApplication 启动后执行一些特殊的代码，你可以实现 ApplicationRunner 或 CommandLineRunner 接口，这两个接口工作方式相同，都只提供单一的 run 方法，该方法仅在 <code>SpringApplication#run(...)</code> 方法<strong>完成之前调用</strong>。</p>
<p>一般情况下，我们不太会使用该功能。如果真需要，胖友可以详细看看 [《使用 ApplicationRunner 或 CommandLineRunner 》](<a href="https://qbgbook.gitbooks.io/spring-boot-reference-guide-zh/IV">https://qbgbook.gitbooks.io/spring-boot-reference-guide-zh/IV</a>. Spring Boot features/23.8 Using the ApplicationRunner or CommandLineRunner.html) 。</p>
<h2 id="Spring-Boot-2-X-有什么新特性？"><a href="#Spring-Boot-2-X-有什么新特性？" class="headerlink" title="Spring Boot 2.X 有什么新特性？"></a>Spring Boot 2.X 有什么新特性？</h2><ol>
<li>起步 JDK 8 和支持 JDK 9</li>
<li>第三方库的升级</li>
<li>Reactive Spring</li>
<li>HTTP/2 支持</li>
<li>配置属性的绑定</li>
<li>Gradle 插件</li>
<li>Actuator 改进</li>
<li>数据支持的改进</li>
<li>Web 的改进</li>
<li>支持 Quartz 自动配置</li>
<li>测试的改进</li>
<li>其它…</li>
</ol>
<p>详细的说明，可以看看 <a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-new-features">《Spring Boot 2.0系列文章(二)：Spring Boot 2.0 新特性详解》</a> 。</p>
<h1 id="整合篇"><a href="#整合篇" class="headerlink" title="整合篇"></a>整合篇</h1><h2 id="如何将内嵌服务器换成-Jetty-？"><a href="#如何将内嵌服务器换成-Jetty-？" class="headerlink" title="如何将内嵌服务器换成 Jetty ？"></a>如何将内嵌服务器换成 Jetty ？</h2><p>默认情况下，<code>spring-boot-starter-web</code> 模块使用 Tomcat 作为内嵌的服务器。所以需要去除对 <code>spring-boot-starter-tomcat</code> 模块的引用，添加 <code>spring-boot-starter-jetty</code> 模块的引用。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;<br>    &lt;exclusions&gt;<br>        &lt;exclusion&gt; &lt;!-- 去除 Tomcat --&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;<br>        &lt;&#x2F;exclusion&gt;<br>    &lt;&#x2F;exclusions&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;dependency&gt; &lt;!-- 引入 Jetty --&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-jetty&lt;&#x2F;artifactId&gt;<br>&lt;&#x2F;dependency&gt;<br></code></pre></td></tr></table></figure>

<h2 id="Spring-Boot-中的监视器-Actuator-是什么？"><a href="#Spring-Boot-中的监视器-Actuator-是什么？" class="headerlink" title="Spring Boot 中的监视器 Actuator 是什么？"></a>Spring Boot 中的监视器 Actuator 是什么？</h2><p><code>spring-boot-actuator</code> 提供 Spring Boot 的监视器功能，可帮助我们访问生产环境中正在运行的应用程序的<strong>当前状态</strong>。</p>
<ul>
<li>关于 Spring Boot Actuator 的教程，可以看看 <a href="https://www.jianshu.com/p/af9738634a21">《Spring Boot Actuator 使用》</a> 。</li>
<li>上述教程是基于 Spring Boot 1.X 的版本，如果胖友使用 Spring Boot 2.X 的版本，你将会发现 <code>/beans</code> 等 Endpoint 是不存在的，参考 <a href="https://stackoverflow.com/questions/49174700/spring-boot-2-actuator-endpoint-where-is-beans-endpoint">《Spring boot 2 - Actuator endpoint, where is /beans endpoint》</a> 问题来解决。</li>
</ul>
<p><strong>安全性</strong></p>
<p>Spring Boot 2.X 默认情况下，<code>spring-boot-actuator</code> 产生的 Endpoint 是没有安全保护的，但是 Actuator 可能暴露敏感信息。</p>
<p>所以一般的做法是，引入 <code>spring-boot-start-security</code> 依赖，使用 Spring Security 对它们进行安全保护。</p>
<h2 id="如何集成-Spring-Boot-和-Spring-MVC-？"><a href="#如何集成-Spring-Boot-和-Spring-MVC-？" class="headerlink" title="如何集成 Spring Boot 和 Spring MVC ？"></a>如何集成 Spring Boot 和 Spring MVC ？</h2><ol>
<li><p>引入 <code>spring-boot-starter-web</code> 的依赖。</p>
</li>
<li><p>实现 WebMvcConfigurer 接口，可添加自定义的 Spring MVC 配置。</p>
<blockquote>
<p>因为 Spring Boot 2 基于 JDK 8 的版本，而 JDK 8 提供 <code>default</code> 方法，所以 Spring Boot 2 废弃了 WebMvcConfigurerAdapter 适配类，直接使用 WebMvcConfigurer 即可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; WebMvcConfigurer.java<br>public interface WebMvcConfigurer &#123;<br><br>    &#x2F;** 配置路径匹配器 **&#x2F;<br>    default void configurePathMatch(PathMatchConfigurer configurer) &#123;&#125;<br>    <br>    &#x2F;** 配置内容裁决的一些选项 **&#x2F;<br>    default void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123; &#125;<br><br>    &#x2F;** 异步相关的配置 **&#x2F;<br>    default void configureAsyncSupport(AsyncSupportConfigurer configurer) &#123; &#125;<br><br>    default void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; &#125;<br><br>    default void addFormatters(FormatterRegistry registry) &#123;<br>    &#125;<br><br>    &#x2F;** 添加拦截器 **&#x2F;<br>    default void addInterceptors(InterceptorRegistry registry) &#123; &#125;<br><br>    &#x2F;** 静态资源处理 **&#x2F;<br>    default void addResourceHandlers(ResourceHandlerRegistry registry) &#123; &#125;<br><br>    &#x2F;** 解决跨域问题 **&#x2F;<br>    default void addCorsMappings(CorsRegistry registry) &#123; &#125;<br><br>    default void addViewControllers(ViewControllerRegistry registry) &#123; &#125;<br><br>    &#x2F;** 配置视图解析器 **&#x2F;<br>    default void configureViewResolvers(ViewResolverRegistry registry) &#123; &#125;<br><br>    &#x2F;** 添加参数解析器 **&#x2F;<br>    default void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) &#123;<br>    &#125;<br><br>    &#x2F;** 添加返回值处理器 **&#x2F;<br>    default void addReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler&gt; handlers) &#123; &#125;<br><br>    &#x2F;** 这里配置视图解析器 **&#x2F;<br>    default void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; &#125;<br><br>    &#x2F;** 配置消息转换器 **&#x2F;<br>    default void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; &#125;<br><br>   &#x2F;** 配置异常处理器 **&#x2F;<br>    default void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123; &#125;<br><br>    default void extendHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123; &#125;<br><br>    @Nullable<br>    default Validator getValidator() &#123; return null; &#125;<br><br>    @Nullable<br>    default MessageCodesResolver getMessageCodesResolver() &#123;  return null; &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<p>在使用 Spring MVC 时，我们一般会做如下几件事情：</p>
<ol>
<li>实现自己项目需要的拦截器，并在 WebMvcConfigurer 实现类中配置。可参见 <a href="https://github.com/YunaiV/oceans/blob/2a2d3746905f1349e260e88049e7e28346c7648f/bff/webapp-bff/src/main/java/cn/iocoder/oceans/webapp/bff/config/MVCConfiguration.java">MVCConfiguration</a> 类。</li>
<li>配置 <code>@ControllerAdvice</code> + <code>@ExceptionHandler</code> 注解，实现全局异常处理。可参见 <a href="https://github.com/YunaiV/oceans/blob/2a2d3746905f1349e260e88049e7e28346c7648f/bff/webapp-bff/src/main/java/cn/iocoder/oceans/webapp/bff/config/GlobalExceptionHandler.java">GlobalExceptionHandler</a> 类。</li>
<li>配置 <code>@ControllerAdvice</code> ，实现 ResponseBodyAdvice 接口，实现全局统一返回。可参见 <a href="https://github.com/YunaiV/oceans/blob/2a2d3746905f1349e260e88049e7e28346c7648f/bff/webapp-bff/src/main/java/cn/iocoder/oceans/webapp/bff/config/GlobalResponseBodyAdvice.java">GlobalResponseBodyAdvice</a> 。</li>
</ol>
<p>当然，有一点需要注意，WebMvcConfigurer、ResponseBodyAdvice、<code>@ControllerAdvice</code>、<code>@ExceptionHandler</code> 接口，都是 Spring MVC 框架自身已经有的东西。</p>
<ul>
<li><code>spring-boot-starter-web</code> 的依赖，帮我们解决的是 Spring MVC 的依赖以及相关的 Tomcat 等组件。</li>
</ul>
<h2 id="如何集成-Spring-Boot-和-Spring-Security-？"><a href="#如何集成-Spring-Boot-和-Spring-Security-？" class="headerlink" title="如何集成 Spring Boot 和 Spring Security ？"></a>如何集成 Spring Boot 和 Spring Security ？</h2><p>目前比较主流的安全框架有两个：</p>
<ol>
<li>Spring Security</li>
<li>Apache Shiro</li>
</ol>
<p>对于任何项目来说，安全认证总是少不了，同样适用于使用 Spring Boot 的项目。相对来说，Spring Security 现在会比 Apache Shiro 更流行。</p>
<p>Spring Boot 和 Spring Security 的配置方式比较简单：</p>
<ol>
<li>引入 <code>spring-boot-starter-security</code> 的依赖。</li>
<li>继承 WebSecurityConfigurerAdapter ，添加<strong>自定义</strong>的安全配置。</li>
</ol>
<p>当然，每个项目的安全配置是不同的，需要胖友自己选择。更多详细的使用，建议认真阅读如下文章：</p>
<ul>
<li><a href="http://blog.didispace.com/springbootsecurity/">《Spring Boot中 使用 Spring Security 进行安全控制》</a> ，快速上手。</li>
<li><a href="http://www.iocoder.cn/Spring-Security/good-collection/">《Spring Security 实现原理与源码解析系统 —— 精品合集》</a> ，深入源码。</li>
</ul>
<p>另外，安全是一个很大的话题，感兴趣的胖友，可以看看 <a href="https://www.jdon.com/49653">《Spring Boot 十种安全措施》</a> 一文。</p>
<h2 id="如何集成-Spring-Boot-和-Spring-Security-OAuth2-？"><a href="#如何集成-Spring-Boot-和-Spring-Security-OAuth2-？" class="headerlink" title="如何集成 Spring Boot 和 Spring Security OAuth2 ？"></a>如何集成 Spring Boot 和 Spring Security OAuth2 ？</h2><p>参见 <a href="http://www.iocoder.cn/Spring-Security/OAuth2-learning/">《Spring Security OAuth2 入门》</a> 文章，内容有点多。</p>
<h2 id="如何集成-Spring-Boot-和-JPA-？"><a href="#如何集成-Spring-Boot-和-JPA-？" class="headerlink" title="如何集成 Spring Boot 和 JPA ？"></a>如何集成 Spring Boot 和 JPA ？</h2><ol>
<li>引入 <code>spring-boot-starter-data-jpa</code> 的依赖。</li>
<li>在 application 配置文件中，加入 JPA 相关的少量配置。当然，数据库的配置也要添加进去。</li>
<li>具体编码。</li>
</ol>
<p>详细的使用，胖友可以参考：</p>
<ul>
<li><a href="http://www.iocoder.cn/Spring-Boot/battcn/v2-orm-jpa/">《一起来学 SpringBoot 2.x | 第六篇：整合 Spring Data JPA》</a></li>
</ul>
<p>有两点需要注意：</p>
<ul>
<li>Spring Boot 2 默认使用的数据库连接池是 <a href="https://github.com/brettwooldridge/HikariCP">HikariCP</a> ，目前最好的性能的数据库连接池的实现。</li>
<li><code>spring-boot-starter-data-jpa</code> 的依赖，使用的默认 JPA 实现是 Hibernate 5.X 。</li>
</ul>
<h2 id="如何集成-Spring-Boot-和-MyBatis-？"><a href="#如何集成-Spring-Boot-和-MyBatis-？" class="headerlink" title="如何集成 Spring Boot 和 MyBatis ？"></a>如何集成 Spring Boot 和 MyBatis ？</h2><ol>
<li>引入 <code>mybatis-spring-boot-starter</code> 的依赖。</li>
<li>在 application 配置文件中，加入 MyBatis 相关的少量配置。当然，数据库的配置也要添加进去。</li>
<li>具体编码。</li>
</ol>
<p>详细的使用，胖友可以参考：</p>
<ul>
<li><a href="http://www.iocoder.cn/Spring-Boot/battcn/v2-orm-mybatis/">《一起来学 SpringBoot 2.x | 第七篇：整合 Mybatis》</a></li>
</ul>
<h2 id="如何集成-Spring-Boot-和-RabbitMQ-？"><a href="#如何集成-Spring-Boot-和-RabbitMQ-？" class="headerlink" title="如何集成 Spring Boot 和 RabbitMQ ？"></a>如何集成 Spring Boot 和 RabbitMQ ？</h2><ol>
<li>引入 <code>spring-boot-starter-amqp</code> 的依赖</li>
<li>在 application 配置文件中，加入 RabbitMQ 相关的少量配置。</li>
<li>具体编码。</li>
</ol>
<p>详细的使用，胖友可以参考：</p>
<ul>
<li><a href="http://www.iocoder.cn/Spring-Boot/battcn/v2-queue-rabbitmq/">《一起来学 SpringBoot 2.x | 第十二篇：初探 RabbitMQ 消息队列》</a></li>
<li><a href="http://www.iocoder.cn/Spring-Boot/battcn/v2-queue-rabbitmq-delay/">《一起来学 SpringBoot 2.x | 第十三篇：RabbitMQ 延迟队列》</a></li>
</ul>
<h2 id="如何集成-Spring-Boot-和-Kafka-？"><a href="#如何集成-Spring-Boot-和-Kafka-？" class="headerlink" title="如何集成 Spring Boot 和 Kafka ？"></a>如何集成 Spring Boot 和 Kafka ？</h2><ol>
<li>引入 <code>spring-kafka</code> 的依赖。</li>
<li>在 application 配置文件中，加入 Kafka 相关的少量配置。</li>
<li>具体编码。</li>
</ol>
<p>详细的使用，胖友可以参考：</p>
<ul>
<li><a href="http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/">《Spring Boot系列文章（一）：SpringBoot Kafka 整合使用》</a></li>
</ul>
<h2 id="如何集成-Spring-Boot-和-RocketMQ-？"><a href="#如何集成-Spring-Boot-和-RocketMQ-？" class="headerlink" title="如何集成 Spring Boot 和 RocketMQ ？"></a>如何集成 Spring Boot 和 RocketMQ ？</h2><ol>
<li>引入 <code>rocketmq-spring-boot</code> 的依赖。</li>
<li>在 application 配置文件中，加入 RocketMQ 相关的少量配置。</li>
<li>具体编码。</li>
</ol>
<p>详细的使用，胖友可以参考：</p>
<ul>
<li><a href="http://www.iocoder.cn/RocketMQ/start/spring-boot-example">《我用这种方法在 Spring 中实现消息的发送和消费》</a></li>
</ul>
<h2 id="Spring-Boot-支持哪些日志框架？"><a href="#Spring-Boot-支持哪些日志框架？" class="headerlink" title="Spring Boot 支持哪些日志框架？"></a>Spring Boot 支持哪些日志框架？</h2><p>Spring Boot 支持的日志框架有：</p>
<ul>
<li>Logback</li>
<li>Log4j2</li>
<li>Log4j</li>
<li>Java Util  Logging</li>
</ul>
<p>默认使用的是 Logback 日志框架，也是目前较为推荐的，具体配置，可以参见 <a href="http://www.iocoder.cn/Spring-Boot/battcn/v2-config-logs/">《一起来学 SpringBoot 2.x | 第三篇：SpringBoot 日志配置》</a> 。</p>
<p>因为 Log4j2 的性能更加优秀，也有人在生产上使用，可以参考 <a href="https://www.jianshu.com/p/f18a9cff351d">《Spring Boot Log4j2 日志性能之巅》</a> 配置。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>😈 看完之后，复习复习 Spring Boot 美滋滋。有一种奇怪的感觉，把面试题写成了 Spring 的学习指南。</p>
<p>当然，如果胖友有新的面试题，欢迎在星球一起探讨补充。</p>
<p>参考和推荐如下文章：</p>
<ul>
<li>我有面试宝典 [《<a href="http://www.wityx.com/post/242_1_1.html">经验分享] Spring Boot面试题总结》</a></li>
<li>Java 知音 <a href="https://cloud.tencent.com/developer/article/1348086">《Spring Boot 面试题精华》</a></li>
<li>祖大帅 <a href="https://juejin.im/post/5b679fbc5188251aad213110">《一个面试题引起的 Spring Boot 启动解析》</a></li>
<li>大胡子叔叔_ <a href="https://blog.csdn.net/panhaigang123/article/details/79587612">《Spring Boot + Spring Cloud 相关面试题》</a></li>
<li>墨斗鱼博客 <a href="https://www.mudouyu.com/article/26">《20 道 Spring Boot 面试题》</a></li>
<li>夕阳雨晴 <a href="https://blog.csdn.net/sun1021873926/article/details/78176354">《Spring Boot Starter 的面试题》</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring Boot</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习笔记</title>
    <url>/2019/10/12/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="MySQL学习笔记"><a href="#MySQL学习笔记" class="headerlink" title="MySQL学习笔记"></a>MySQL学习笔记</h1><h2 id="登录和退出MySQL服务器"><a href="#登录和退出MySQL服务器" class="headerlink" title="登录和退出MySQL服务器"></a>登录和退出MySQL服务器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 登录MySQL</span><br><span class="hljs-meta">$</span><span class="bash"> mysql -u root -p12345612</span><br><br><span class="hljs-meta">#</span><span class="bash"> 退出MySQL数据库服务器</span><br>exit;<br></code></pre></td></tr></table></figure>

<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 显示所有数据库<br>show databases;<br><br>-- 创建数据库<br>CREATE DATABASE test;<br><br>-- 切换数据库<br>use test;<br><br>-- 显示数据库中的所有表<br>show tables;<br><br>-- 创建数据表<br>CREATE TABLE pet (<br>    name VARCHAR(20),<br>    owner VARCHAR(20),<br>    species VARCHAR(20),<br>    sex CHAR(1),<br>    birth DATE,<br>    death DATE<br>);<br><br>-- 查看数据表结构<br>-- describe pet;<br>desc pet;<br><br>-- 查询表<br>SELECT * from pet;<br><br>-- 插入数据<br>INSERT INTO pet VALUES (&#39;puffball&#39;, &#39;Diane&#39;, &#39;hamster&#39;, &#39;f&#39;, &#39;1990-03-30&#39;, NULL);<br><br>-- 修改数据<br>UPDATE pet SET name &#x3D; &#39;squirrel&#39; where owner &#x3D; &#39;Diane&#39;;<br><br>-- 删除数据<br>DELETE FROM pet where name &#x3D; &#39;squirrel&#39;;<br><br>-- 删除表<br>DROP TABLE myorder;<br></code></pre></td></tr></table></figure>

<h2 id="建表约束"><a href="#建表约束" class="headerlink" title="建表约束"></a>建表约束</h2><h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 主键约束<br>-- 使某个字段不重复且不得为空，确保表内所有数据的唯一性。<br>CREATE TABLE user (<br>    id INT PRIMARY KEY,<br>    name VARCHAR(20)<br>);<br><br>-- 联合主键<br>-- 联合主键中的每个字段都不能为空，并且加起来不能和已设置的联合主键重复。<br>CREATE TABLE user (<br>    id INT,<br>    name VARCHAR(20),<br>    password VARCHAR(20),<br>    PRIMARY KEY(id, name)<br>);<br><br>-- 自增约束<br>-- 自增约束的主键由系统自动递增分配。<br>CREATE TABLE user (<br>    id INT PRIMARY KEY AUTO_INCREMENT,<br>    name VARCHAR(20)<br>);<br><br>-- 添加主键约束<br>-- 如果忘记设置主键，还可以通过SQL语句设置（两种方式）：<br>ALTER TABLE user ADD PRIMARY KEY(id);<br>ALTER TABLE user MODIFY id INT PRIMARY KEY;<br><br>-- 删除主键<br>ALTER TABLE user drop PRIMARY KEY;<br></code></pre></td></tr></table></figure>

<h3 id="唯一主键"><a href="#唯一主键" class="headerlink" title="唯一主键"></a>唯一主键</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 唯一约束可以为空，而主键约束不能为空<br><br>-- 建表时创建唯一主键<br>CREATE TABLE user (<br>    id INT,<br>    name VARCHAR(20),<br>    UNIQUE(name)<br>);<br><br>-- unique(id,name)表示两个键在一起不重复就行<br>CREATE TABLE user (<br>    id INT,<br>    name VARCHAR(20),<br>    UNIQUE(id,name)<br>);<br><br>-- 添加唯一主键<br>-- 如果建表时没有设置唯一建，还可以通过SQL语句设置（两种方式）：<br>ALTER TABLE user ADD UNIQUE(name);<br>ALTER TABLE user MODIFY name VARCHAR(20) UNIQUE;<br><br>-- 删除唯一主键<br>ALTER TABLE user DROP INDEX name;<br></code></pre></td></tr></table></figure>

<h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 建表时添加非空约束<br>-- 约束某个字段不能为空<br>CREATE TABLE user (<br>    id INT,<br>    name VARCHAR(20) NOT NULL<br>);<br><br>-- 移除非空约束<br>ALTER TABLE user MODIFY name VARCHAR(20);<br></code></pre></td></tr></table></figure>

<h3 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 建表时添加默认约束<br>-- 约束某个字段的默认值<br>CREATE TABLE user2 (<br>    id INT,<br>    name VARCHAR(20),<br>    age INT DEFAULT 10<br>);<br><br>-- 移除非空约束<br>ALTER TABLE user MODIFY age INT;<br></code></pre></td></tr></table></figure>

<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 班级<br>CREATE TABLE classes (<br>    id INT PRIMARY KEY,<br>    name VARCHAR(20)<br>);<br><br>-- 学生表<br>CREATE TABLE students (<br>    id INT PRIMARY KEY,<br>    name VARCHAR(20),<br>    -- 这里的 class_id 要和 classes 中的 id 字段相关联<br>    class_id INT,<br>    -- 表示 class_id 的值必须来自于 classes 中的 id 字段值<br>    FOREIGN KEY(class_id) REFERENCES classes(id)<br>);<br><br>-- 1. 主表（父表）classes 中没有的数据值，在副表（子表）students 中，是不可以使用的；<br>-- 2. 主表中的记录被副表引用时，主表不可以被删除。<br></code></pre></td></tr></table></figure>

<h2 id="数据库的三大设计范式"><a href="#数据库的三大设计范式" class="headerlink" title="数据库的三大设计范式"></a>数据库的三大设计范式</h2><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>只要字段值还可以继续拆分，就不满足第一范式。</p>
<p>范式设计得越详细，对某些实际操作可能会更好，但并非都有好处，需要对项目的实际情况进行设定。</p>
<h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p>在满足第一范式的前提下，其他列都必须完全依赖于主键列。如果出现不完全依赖，只可能发生在联合主键的情况下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 订单表<br>CREATE TABLE myorder (<br>    product_id INT,<br>    customer_id INT,<br>    product_name VARCHAR(20),<br>    customer_name VARCHAR(20),<br>    PRIMARY KEY (product_id, customer_id)<br>);<br></code></pre></td></tr></table></figure>

<p>实际上，在这张订单表中，<code>product_name</code> 只依赖于 <code>product_id</code> ，<code>customer_name</code> 只依赖于 <code>customer_id</code> 。也就是说，<code>product_name</code> 和 <code>customer_id</code> 是没用关系的，<code>customer_name</code> 和 <code>product_id</code> 也是没有关系的。</p>
<p>这就不满足第二范式：其他列都必须完全依赖于主键列！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE myorder (<br>    order_id INT PRIMARY KEY,<br>    product_id INT,<br>    customer_id INT<br>);<br><br>CREATE TABLE product (<br>    id INT PRIMARY KEY,<br>    name VARCHAR(20)<br>);<br><br>CREATE TABLE customer (<br>    id INT PRIMARY KEY,<br>    name VARCHAR(20)<br>);<br></code></pre></td></tr></table></figure>

<p>拆分之后，<code>myorder</code> 表中的 <code>product_id</code> 和 <code>customer_id</code> 完全依赖于 <code>order_id</code> 主键，而 <code>product</code> 和 <code>customer</code> 表中的其他字段又完全依赖于主键。满足了第二范式的设计！</p>
<h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p>在满足第二范式的前提下，除了主键列之外，其他列之间不能有传递依赖关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE myorder (<br>    order_id INT PRIMARY KEY,<br>    product_id INT,<br>    customer_id INT,<br>    customer_phone VARCHAR(15)<br>);<br></code></pre></td></tr></table></figure>

<p>表中的 <code>customer_phone</code> 有可能依赖于 <code>order_id</code> 、 <code>customer_id</code> 两列，也就不满足了第三范式的设计：其他列之间不能有传递依赖关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE myorder (<br>    order_id INT PRIMARY KEY,<br>    product_id INT,<br>    customer_id INT<br>);<br><br>CREATE TABLE customer (<br>    id INT PRIMARY KEY,<br>    name VARCHAR(20),<br>    phone VARCHAR(15)<br>);<br></code></pre></td></tr></table></figure>

<p>修改后就不存在其他列之间的传递依赖关系，其他列都只依赖于主键列，满足了第三范式的设计！</p>
<h2 id="查询练习"><a href="#查询练习" class="headerlink" title="查询练习"></a>查询练习</h2><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 创建数据库<br>CREATE DATABASE select_test;<br>-- 切换数据库<br>USE select_test;<br><br>-- 创建学生表<br>CREATE TABLE student (<br>    no VARCHAR(20) PRIMARY KEY,<br>    name VARCHAR(20) NOT NULL,<br>    sex VARCHAR(10) NOT NULL,<br>    birthday DATE, -- 生日<br>    class VARCHAR(20) -- 所在班级<br>);<br><br>-- 创建教师表<br>CREATE TABLE teacher (<br>    no VARCHAR(20) PRIMARY KEY,<br>    name VARCHAR(20) NOT NULL,<br>    sex VARCHAR(10) NOT NULL,<br>    birthday DATE,<br>    profession VARCHAR(20) NOT NULL, -- 职称<br>    department VARCHAR(20) NOT NULL -- 部门<br>);<br><br>-- 创建课程表<br>CREATE TABLE course (<br>    no VARCHAR(20) PRIMARY KEY,<br>    name VARCHAR(20) NOT NULL,<br>    t_no VARCHAR(20) NOT NULL, -- 教师编号<br>    -- 表示该 tno 来自于 teacher 表中的 no 字段值<br>    FOREIGN KEY(t_no) REFERENCES teacher(no) <br>);<br><br>-- 成绩表<br>CREATE TABLE score (<br>    s_no VARCHAR(20) NOT NULL, -- 学生编号<br>    c_no VARCHAR(20) NOT NULL, -- 课程号<br>    degree DECIMAL,	-- 成绩<br>    -- 表示该 s_no, c_no 分别来自于 student, course 表中的 no 字段值<br>    FOREIGN KEY(s_no) REFERENCES student(no),	<br>    FOREIGN KEY(c_no) REFERENCES course(no),<br>    -- 设置 s_no, c_no 为联合主键<br>    PRIMARY KEY(s_no, c_no)<br>);<br><br>-- 查看所有表<br>SHOW TABLES;<br><br>-- 添加学生表数据<br>INSERT INTO student VALUES(&#39;101&#39;, &#39;曾华&#39;, &#39;男&#39;, &#39;1977-09-01&#39;, &#39;95033&#39;);<br>INSERT INTO student VALUES(&#39;102&#39;, &#39;匡明&#39;, &#39;男&#39;, &#39;1975-10-02&#39;, &#39;95031&#39;);<br>INSERT INTO student VALUES(&#39;103&#39;, &#39;王丽&#39;, &#39;女&#39;, &#39;1976-01-23&#39;, &#39;95033&#39;);<br>INSERT INTO student VALUES(&#39;104&#39;, &#39;李军&#39;, &#39;男&#39;, &#39;1976-02-20&#39;, &#39;95033&#39;);<br>INSERT INTO student VALUES(&#39;105&#39;, &#39;王芳&#39;, &#39;女&#39;, &#39;1975-02-10&#39;, &#39;95031&#39;);<br>INSERT INTO student VALUES(&#39;106&#39;, &#39;陆军&#39;, &#39;男&#39;, &#39;1974-06-03&#39;, &#39;95031&#39;);<br>INSERT INTO student VALUES(&#39;107&#39;, &#39;王尼玛&#39;, &#39;男&#39;, &#39;1976-02-20&#39;, &#39;95033&#39;);<br>INSERT INTO student VALUES(&#39;108&#39;, &#39;张全蛋&#39;, &#39;男&#39;, &#39;1975-02-10&#39;, &#39;95031&#39;);<br>INSERT INTO student VALUES(&#39;109&#39;, &#39;赵铁柱&#39;, &#39;男&#39;, &#39;1974-06-03&#39;, &#39;95031&#39;);<br><br>-- 添加教师表数据<br>INSERT INTO teacher VALUES(&#39;804&#39;, &#39;李诚&#39;, &#39;男&#39;, &#39;1958-12-02&#39;, &#39;副教授&#39;, &#39;计算机系&#39;);<br>INSERT INTO teacher VALUES(&#39;856&#39;, &#39;张旭&#39;, &#39;男&#39;, &#39;1969-03-12&#39;, &#39;讲师&#39;, &#39;电子工程系&#39;);<br>INSERT INTO teacher VALUES(&#39;825&#39;, &#39;王萍&#39;, &#39;女&#39;, &#39;1972-05-05&#39;, &#39;助教&#39;, &#39;计算机系&#39;);<br>INSERT INTO teacher VALUES(&#39;831&#39;, &#39;刘冰&#39;, &#39;女&#39;, &#39;1977-08-14&#39;, &#39;助教&#39;, &#39;电子工程系&#39;);<br><br>-- 添加课程表数据<br>INSERT INTO course VALUES(&#39;3-105&#39;, &#39;计算机导论&#39;, &#39;825&#39;);<br>INSERT INTO course VALUES(&#39;3-245&#39;, &#39;操作系统&#39;, &#39;804&#39;);<br>INSERT INTO course VALUES(&#39;6-166&#39;, &#39;数字电路&#39;, &#39;856&#39;);<br>INSERT INTO course VALUES(&#39;9-888&#39;, &#39;高等数学&#39;, &#39;831&#39;);<br><br>-- 添加添加成绩表数据<br>INSERT INTO score VALUES(&#39;103&#39;, &#39;3-105&#39;, &#39;92&#39;);<br>INSERT INTO score VALUES(&#39;103&#39;, &#39;3-245&#39;, &#39;86&#39;);<br>INSERT INTO score VALUES(&#39;103&#39;, &#39;6-166&#39;, &#39;85&#39;);<br>INSERT INTO score VALUES(&#39;105&#39;, &#39;3-105&#39;, &#39;88&#39;);<br>INSERT INTO score VALUES(&#39;105&#39;, &#39;3-245&#39;, &#39;75&#39;);<br>INSERT INTO score VALUES(&#39;105&#39;, &#39;6-166&#39;, &#39;79&#39;);<br>INSERT INTO score VALUES(&#39;109&#39;, &#39;3-105&#39;, &#39;76&#39;);<br>INSERT INTO score VALUES(&#39;109&#39;, &#39;3-245&#39;, &#39;68&#39;);<br>INSERT INTO score VALUES(&#39;109&#39;, &#39;6-166&#39;, &#39;81&#39;);<br><br>-- 查看表结构<br>SELECT * FROM course;<br>SELECT * FROM score;<br>SELECT * FROM student;<br>SELECT * FROM teacher;<br></code></pre></td></tr></table></figure>

<h3 id="1-到-10"><a href="#1-到-10" class="headerlink" title="1 到 10"></a>1 到 10</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 查询 student 表的所有行<br>SELECT * FROM student;<br><br>-- 查询 student 表中的 name、sex 和 class 字段的所有行<br>SELECT name, sex, class FROM student;<br><br>-- 查询 teacher 表中不重复的 department 列<br>-- DISTINCT: 去重查询<br>SELECT DISTINCT department FROM teacher;<br><br>-- 查询 score 表中成绩在60-80之间的所有行（区间查询和运算符查询）<br>-- BETWEEN xx AND xx: 查询区间, AND 表示 &quot;并且&quot;<br>SELECT * FROM score WHERE degree BETWEEN 60 AND 80;<br>SELECT * FROM score WHERE degree &gt; 60 AND degree &lt; 80;<br><br>-- 查询 score 表中成绩为 85, 86 或 88 的行<br>-- IN: 查询规定中的多个值<br>SELECT * FROM score WHERE degree IN (85, 86, 88);<br><br>-- 查询 student 表中 &#39;95031&#39; 班或性别为 &#39;女&#39; 的所有行<br>-- or: 表示或者关系<br>SELECT * FROM student WHERE class &#x3D; &#39;95031&#39; or sex &#x3D; &#39;女&#39;;<br><br>-- 以 class 降序的方式查询 student 表的所有行<br>-- DESC: 降序，从高到低<br>-- ASC（默认）: 升序，从低到高<br>SELECT * FROM student ORDER BY class DESC;<br>SELECT * FROM student ORDER BY class ASC;<br><br>-- 以 c_no 升序、degree 降序查询 score 表的所有行<br>SELECT * FROM score ORDER BY c_no ASC, degree DESC;<br><br>-- 查询 &quot;95031&quot; 班的学生人数<br>-- COUNT: 统计<br>SELECT COUNT(*) FROM student WHERE class &#x3D; &#39;95031&#39;;<br><br>-- 查询 score 表中的最高分的学生学号和课程编号（子查询或排序查询）。<br>-- (SELECT MAX(degree) FROM score): 子查询，算出最高分<br>SELECT s_no, c_no FROM score WHERE degree &#x3D; (SELECT MAX(degree) FROM score);<br><br>--  排序查询<br>-- LIMIT r, n: 表示从第r行开始，查询n条数据<br>SELECT s_no, c_no, degree FROM score ORDER BY degree DESC LIMIT 0, 1;<br></code></pre></td></tr></table></figure>

<h3 id="分组计算平均成绩"><a href="#分组计算平均成绩" class="headerlink" title="分组计算平均成绩"></a>分组计算平均成绩</h3><p><strong>查询每门课的平均成绩。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- AVG: 平均值<br>SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;3-105&#39;;<br>SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;3-245&#39;;<br>SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;6-166&#39;;<br><br>-- GROUP BY: 分组查询<br>SELECT c_no, AVG(degree) FROM score GROUP BY c_no;<br></code></pre></td></tr></table></figure>

<h3 id="分组条件与模糊查询"><a href="#分组条件与模糊查询" class="headerlink" title="分组条件与模糊查询"></a>分组条件与模糊查询</h3><p><strong>查询 <code>score</code> 表中至少有 2 名学生选修，并以 3 开头的课程的平均分数。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM score;<br>-- c_no 课程编号<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 103  | 3-105 |     92 |<br>| 103  | 3-245 |     86 |<br>| 103  | 6-166 |     85 |<br>| 105  | 3-105 |     88 |<br>| 105  | 3-245 |     75 |<br>| 105  | 6-166 |     79 |<br>| 109  | 3-105 |     76 |<br>| 109  | 3-245 |     68 |<br>| 109  | 6-166 |     81 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<p>分析表发现，至少有 2 名学生选修的课程是 <code>3-105</code> 、<code>3-245</code> 、<code>6-166</code> ，以 3 开头的课程是 <code>3-105</code> 、<code>3-245</code> 。也就是说，我们要查询所有 <code>3-105</code> 和 <code>3-245</code> 的 <code>degree</code> 平均分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 首先把 c_no, AVG(degree) 通过分组查询出来<br>SELECT c_no, AVG(degree) FROM score GROUP BY c_no<br>+-------+-------------+<br>| c_no  | AVG(degree) |<br>+-------+-------------+<br>| 3-105 |     85.3333 |<br>| 3-245 |     76.3333 |<br>| 6-166 |     81.6667 |<br>+-------+-------------+<br><br>-- 再查询出至少有 2 名学生选修的课程<br>-- HAVING: 表示持有<br>HAVING COUNT(c_no) &gt;&#x3D; 2<br><br>-- 并且是以 3 开头的课程<br>-- LIKE 表示模糊查询，&quot;%&quot; 是一个通配符，匹配 &quot;3&quot; 后面的任意字符。<br>AND c_no LIKE &#39;3%&#39;;<br><br>-- 把前面的SQL语句拼接起来，<br>-- 后面加上一个 COUNT(*)，表示将每个分组的个数也查询出来。<br>SELECT c_no, AVG(degree), COUNT(*) FROM score GROUP BY c_no<br>HAVING COUNT(c_no) &gt;&#x3D; 2 AND c_no LIKE &#39;3%&#39;;<br>+-------+-------------+----------+<br>| c_no  | AVG(degree) | COUNT(*) |<br>+-------+-------------+----------+<br>| 3-105 |     85.3333 |        3 |<br>| 3-245 |     76.3333 |        3 |<br>+-------+-------------+----------+<br></code></pre></td></tr></table></figure>

<h3 id="多表查询-1"><a href="#多表查询-1" class="headerlink" title="多表查询 - 1"></a>多表查询 - 1</h3><p><strong>查询所有学生的 <code>name</code>，以及该学生在 <code>score</code> 表中对应的 <code>c_no</code> 和 <code>degree</code> 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT no, name FROM student;<br>+-----+-----------+<br>| no  | name      |<br>+-----+-----------+<br>| 101 | 曾华      |<br>| 102 | 匡明      |<br>| 103 | 王丽      |<br>| 104 | 李军      |<br>| 105 | 王芳      |<br>| 106 | 陆军      |<br>| 107 | 王尼玛    |<br>| 108 | 张全蛋    |<br>| 109 | 赵铁柱    |<br>+-----+-----------+<br><br>SELECT s_no, c_no, degree FROM score;<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 103  | 3-105 |     92 |<br>| 103  | 3-245 |     86 |<br>| 103  | 6-166 |     85 |<br>| 105  | 3-105 |     88 |<br>| 105  | 3-245 |     75 |<br>| 105  | 6-166 |     79 |<br>| 109  | 3-105 |     76 |<br>| 109  | 3-245 |     68 |<br>| 109  | 6-166 |     81 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<p>通过分析可以发现，只要把 <code>score</code> 表中的 <code>s_no</code> 字段值替换成 <code>student</code> 表中对应的 <code>name</code> 字段值就可以了，如何做呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- FROM...: 表示从 student, score 表中查询<br>-- WHERE 的条件表示为，只有在 student.no 和 score.s_no 相等时才显示出来。<br>SELECT name, c_no, degree FROM student, score <br>WHERE student.no &#x3D; score.s_no;<br>+-----------+-------+--------+<br>| name      | c_no  | degree |<br>+-----------+-------+--------+<br>| 王丽      | 3-105 |     92 |<br>| 王丽      | 3-245 |     86 |<br>| 王丽      | 6-166 |     85 |<br>| 王芳      | 3-105 |     88 |<br>| 王芳      | 3-245 |     75 |<br>| 王芳      | 6-166 |     79 |<br>| 赵铁柱    | 3-105 |     76 |<br>| 赵铁柱    | 3-245 |     68 |<br>| 赵铁柱    | 6-166 |     81 |<br>+-----------+-------+--------+<br></code></pre></td></tr></table></figure>

<h3 id="多表查询-2"><a href="#多表查询-2" class="headerlink" title="多表查询 - 2"></a>多表查询 - 2</h3><p><strong>查询所有学生的 <code>no</code> 、课程名称 ( <code>course</code> 表中的 <code>name</code> ) 和成绩 ( <code>score</code> 表中的 <code>degree</code> ) 列。</strong></p>
<p>只有 <code>score</code> 关联学生的 <code>no</code> ，因此只要查询 <code>score</code> 表，就能找出所有和学生相关的 <code>no</code> 和 <code>degree</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT s_no, c_no, degree FROM score;<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 103  | 3-105 |     92 |<br>| 103  | 3-245 |     86 |<br>| 103  | 6-166 |     85 |<br>| 105  | 3-105 |     88 |<br>| 105  | 3-245 |     75 |<br>| 105  | 6-166 |     79 |<br>| 109  | 3-105 |     76 |<br>| 109  | 3-245 |     68 |<br>| 109  | 6-166 |     81 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<p>然后查询 <code>course</code> 表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">+-------+-----------------+<br>| no    | name            |<br>+-------+-----------------+<br>| 3-105 | 计算机导论      |<br>| 3-245 | 操作系统        |<br>| 6-166 | 数字电路        |<br>| 9-888 | 高等数学        |<br>+-------+-----------------+<br></code></pre></td></tr></table></figure>

<p>只要把 <code>score</code> 表中的 <code>c_no</code> 替换成 <code>course</code> 表中对应的 <code>name</code> 字段值就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 增加一个查询字段 name，分别从 score、course 这两个表中查询。<br>-- as 表示取一个该字段的别名。<br>SELECT s_no, name as c_name, degree FROM score, course<br>WHERE score.c_no &#x3D; course.no;<br>+------+-----------------+--------+<br>| s_no | c_name          | degree |<br>+------+-----------------+--------+<br>| 103  | 计算机导论      |     92 |<br>| 105  | 计算机导论      |     88 |<br>| 109  | 计算机导论      |     76 |<br>| 103  | 操作系统        |     86 |<br>| 105  | 操作系统        |     75 |<br>| 109  | 操作系统        |     68 |<br>| 103  | 数字电路        |     85 |<br>| 105  | 数字电路        |     79 |<br>| 109  | 数字电路        |     81 |<br>+------+-----------------+--------+<br></code></pre></td></tr></table></figure>

<h3 id="三表关联查询"><a href="#三表关联查询" class="headerlink" title="三表关联查询"></a>三表关联查询</h3><p><strong>查询所有学生的 <code>name</code> 、课程名 ( <code>course</code> 表中的 <code>name</code> ) 和 <code>degree</code> 。</strong></p>
<p>只有 <code>score</code> 表中关联学生的学号和课堂号，我们只要围绕着 <code>score</code> 这张表查询就好了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM score;<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 103  | 3-105 |     92 |<br>| 103  | 3-245 |     86 |<br>| 103  | 6-166 |     85 |<br>| 105  | 3-105 |     88 |<br>| 105  | 3-245 |     75 |<br>| 105  | 6-166 |     79 |<br>| 109  | 3-105 |     76 |<br>| 109  | 3-245 |     68 |<br>| 109  | 6-166 |     81 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<p>只要把 <code>s_no</code> 和 <code>c_no</code> 替换成 <code>student</code> 和 <code>srouse</code> 表中对应的 <code>name</code> 字段值就好了。</p>
<p>首先把 <code>s_no</code> 替换成 <code>student</code> 表中的 <code>name</code> 字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT name, c_no, degree FROM student, score WHERE student.no &#x3D; score.s_no;<br>+-----------+-------+--------+<br>| name      | c_no  | degree |<br>+-----------+-------+--------+<br>| 王丽      | 3-105 |     92 |<br>| 王丽      | 3-245 |     86 |<br>| 王丽      | 6-166 |     85 |<br>| 王芳      | 3-105 |     88 |<br>| 王芳      | 3-245 |     75 |<br>| 王芳      | 6-166 |     79 |<br>| 赵铁柱    | 3-105 |     76 |<br>| 赵铁柱    | 3-245 |     68 |<br>| 赵铁柱    | 6-166 |     81 |<br>+-----------+-------+--------+<br></code></pre></td></tr></table></figure>

<p>再把 <code>c_no</code> 替换成 <code>course</code> 表中的 <code>name</code> 字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 课程表<br>SELECT no, name FROM course;<br>+-------+-----------------+<br>| no    | name            |<br>+-------+-----------------+<br>| 3-105 | 计算机导论      |<br>| 3-245 | 操作系统        |<br>| 6-166 | 数字电路        |<br>| 9-888 | 高等数学        |<br>+-------+-----------------+<br><br>-- 由于字段名存在重复，使用 &quot;表名.字段名 as 别名&quot; 代替。<br>SELECT student.name as s_name, course.name as c_name, degree <br>FROM student, score, course<br>WHERE student.NO &#x3D; score.s_no<br>AND score.c_no &#x3D; course.no;<br></code></pre></td></tr></table></figure>

<h3 id="子查询加分组求平均分"><a href="#子查询加分组求平均分" class="headerlink" title="子查询加分组求平均分"></a>子查询加分组求平均分</h3><p><strong>查询 <code>95031</code> 班学生每门课程的平均成绩。</strong></p>
<p>在 <code>score</code> 表中根据 <code>student</code>  表的学生编号筛选出学生的课堂号和成绩：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- IN (..): 将筛选出的学生号当做 s_no 的条件查询<br>SELECT s_no, c_no, degree FROM score<br>WHERE s_no IN (SELECT no FROM student WHERE class &#x3D; &#39;95031&#39;);<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 105  | 3-105 |     88 |<br>| 105  | 3-245 |     75 |<br>| 105  | 6-166 |     79 |<br>| 109  | 3-105 |     76 |<br>| 109  | 3-245 |     68 |<br>| 109  | 6-166 |     81 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<p>这时只要将 <code>c_no</code> 分组一下就能得出 <code>95031</code> 班学生每门课的平均成绩：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT c_no, AVG(degree) FROM score<br>WHERE s_no IN (SELECT no FROM student WHERE class &#x3D; &#39;95031&#39;)<br>GROUP BY c_no;<br>+-------+-------------+<br>| c_no  | AVG(degree) |<br>+-------+-------------+<br>| 3-105 |     82.0000 |<br>| 3-245 |     71.5000 |<br>| 6-166 |     80.0000 |<br>+-------+-------------+<br></code></pre></td></tr></table></figure>

<h3 id="子查询-1"><a href="#子查询-1" class="headerlink" title="子查询 - 1"></a>子查询 - 1</h3><p><strong>查询在 <code>3-105</code> 课程中，所有成绩高于 <code>109</code> 号同学的记录。</strong></p>
<p>首先筛选出课堂号为 <code>3-105</code> ，在找出所有成绩高于 <code>109</code> 号同学的的行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM score <br>WHERE c_no &#x3D; &#39;3-105&#39;<br>AND degree &gt; (SELECT degree FROM score WHERE s_no &#x3D; &#39;109&#39; AND c_no &#x3D; &#39;3-105&#39;);<br></code></pre></td></tr></table></figure>

<h3 id="子查询-2"><a href="#子查询-2" class="headerlink" title="子查询 - 2"></a>子查询 - 2</h3><p><strong>查询所有成绩高于 <code>109</code> 号同学的 <code>3-105</code> 课程成绩记录。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 不限制课程号，只要成绩大于109号同学的3-105课程成绩就可以。<br>SELECT * FROM score<br>WHERE degree &gt; (SELECT degree FROM score WHERE s_no &#x3D; &#39;109&#39; AND c_no &#x3D; &#39;3-105&#39;);<br></code></pre></td></tr></table></figure>

<h3 id="YEAR-函数与带-IN-关键字查询"><a href="#YEAR-函数与带-IN-关键字查询" class="headerlink" title="YEAR 函数与带 IN 关键字查询"></a>YEAR 函数与带 IN 关键字查询</h3><p><strong>查询所有和 <code>101</code> 、<code>108</code> 号学生同年出生的 <code>no</code> 、<code>name</code> 、<code>birthday</code> 列。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- YEAR(..): 取出日期中的年份<br>SELECT no, name, birthday FROM student<br>WHERE YEAR(birthday) IN (SELECT YEAR(birthday) FROM student WHERE no IN (101, 108));<br></code></pre></td></tr></table></figure>

<h3 id="多层嵌套子查询"><a href="#多层嵌套子查询" class="headerlink" title="多层嵌套子查询"></a>多层嵌套子查询</h3><p><strong>查询 <code>&#39;张旭&#39;</code> 教师任课的学生成绩表。</strong></p>
<p>首先找到教师编号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT NO FROM teacher WHERE NAME &#x3D; &#39;张旭&#39;<br></code></pre></td></tr></table></figure>

<p>通过 <code>sourse</code> 表找到该教师课程号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT NO FROM course WHERE t_no &#x3D; ( SELECT NO FROM teacher WHERE NAME &#x3D; &#39;张旭&#39; );<br></code></pre></td></tr></table></figure>

<p>通过筛选出的课程号查询成绩表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM score WHERE c_no &#x3D; (<br>    SELECT no FROM course WHERE t_no &#x3D; ( <br>        SELECT no FROM teacher WHERE NAME &#x3D; &#39;张旭&#39; <br>    )<br>);<br></code></pre></td></tr></table></figure>

<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p><strong>查询某选修课程多于5个同学的教师姓名。</strong></p>
<p>首先在 <code>teacher</code> 表中，根据 <code>no</code> 字段来判断该教师的同一门课程是否有至少5名学员选修：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 查询 teacher 表<br>SELECT no, name FROM teacher;<br>+-----+--------+<br>| no  | name   |<br>+-----+--------+<br>| 804 | 李诚   |<br>| 825 | 王萍   |<br>| 831 | 刘冰   |<br>| 856 | 张旭   |<br>+-----+--------+<br><br>SELECT name FROM teacher WHERE no IN (<br>    -- 在这里找到对应的条件<br>);<br></code></pre></td></tr></table></figure>

<p>查看和教师编号有有关的表的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM course;<br>-- t_no: 教师编号<br>+-------+-----------------+------+<br>| no    | name            | t_no |<br>+-------+-----------------+------+<br>| 3-105 | 计算机导论      | 825  |<br>| 3-245 | 操作系统        | 804  |<br>| 6-166 | 数字电路        | 856  |<br>| 9-888 | 高等数学        | 831  |<br>+-------+-----------------+------+<br></code></pre></td></tr></table></figure>

<p>我们已经找到和教师编号有关的字段就在 <code>course</code> 表中，但是还无法知道哪门课程至少有5名学生选修，所以还需要根据 <code>score</code> 表来查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 在此之前向 score 插入一些数据，以便丰富查询条件。<br>INSERT INTO score VALUES (&#39;101&#39;, &#39;3-105&#39;, &#39;90&#39;);<br>INSERT INTO score VALUES (&#39;102&#39;, &#39;3-105&#39;, &#39;91&#39;);<br>INSERT INTO score VALUES (&#39;104&#39;, &#39;3-105&#39;, &#39;89&#39;);<br><br>-- 查询 score 表<br>SELECT * FROM score;<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 101  | 3-105 |     90 |<br>| 102  | 3-105 |     91 |<br>| 103  | 3-105 |     92 |<br>| 103  | 3-245 |     86 |<br>| 103  | 6-166 |     85 |<br>| 104  | 3-105 |     89 |<br>| 105  | 3-105 |     88 |<br>| 105  | 3-245 |     75 |<br>| 105  | 6-166 |     79 |<br>| 109  | 3-105 |     76 |<br>| 109  | 3-245 |     68 |<br>| 109  | 6-166 |     81 |<br>+------+-------+--------+<br><br>-- 在 score 表中将 c_no 作为分组，并且限制 c_no 持有至少 5 条数据。<br>SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5;<br>+-------+<br>| c_no  |<br>+-------+<br>| 3-105 |<br>+-------+<br></code></pre></td></tr></table></figure>

<p>根据筛选出来的课程号，找出在某课程中，拥有至少5名学员的教师编号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT t_no FROM course WHERE no IN (<br>    SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5<br>);<br>+------+<br>| t_no |<br>+------+<br>| 825  |<br>+------+<br></code></pre></td></tr></table></figure>

<p>在 <code>teacher</code> 表中，根据筛选出来的教师编号找到教师姓名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT name FROM teacher WHERE no IN (<br>    -- 最终条件<br>    SELECT t_no FROM course WHERE no IN (<br>        SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5<br>    )<br>);<br></code></pre></td></tr></table></figure>

<h3 id="子查询-3"><a href="#子查询-3" class="headerlink" title="子查询 - 3"></a>子查询 - 3</h3><p><strong>查询 “计算机系” 课程的成绩表。</strong></p>
<p>思路是，先找出 <code>course</code> 表中所有 <code>计算机系</code> 课程的编号，然后根据这个编号查询 <code>score</code> 表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 通过 teacher 表查询所有 &#96;计算机系&#96; 的教师编号<br>SELECT no, name, department FROM teacher WHERE department &#x3D; &#39;计算机系&#39;<br>+-----+--------+--------------+<br>| no  | name   | department   |<br>+-----+--------+--------------+<br>| 804 | 李诚   | 计算机系     |<br>| 825 | 王萍   | 计算机系     |<br>+-----+--------+--------------+<br><br>-- 通过 course 表查询该教师的课程编号<br>SELECT no FROM course WHERE t_no IN (<br>    SELECT no FROM teacher WHERE department &#x3D; &#39;计算机系&#39;<br>);<br>+-------+<br>| no    |<br>+-------+<br>| 3-245 |<br>| 3-105 |<br>+-------+<br><br>-- 根据筛选出来的课程号查询成绩表<br>SELECT * FROM score WHERE c_no IN (<br>    SELECT no FROM course WHERE t_no IN (<br>        SELECT no FROM teacher WHERE department &#x3D; &#39;计算机系&#39;<br>    )<br>);<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 103  | 3-245 |     86 |<br>| 105  | 3-245 |     75 |<br>| 109  | 3-245 |     68 |<br>| 101  | 3-105 |     90 |<br>| 102  | 3-105 |     91 |<br>| 103  | 3-105 |     92 |<br>| 104  | 3-105 |     89 |<br>| 105  | 3-105 |     88 |<br>| 109  | 3-105 |     76 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<h3 id="UNION-和-NOTIN-的使用"><a href="#UNION-和-NOTIN-的使用" class="headerlink" title="UNION 和 NOTIN 的使用"></a>UNION 和 NOTIN 的使用</h3><p><strong>查询 <code>计算机系</code> 与 <code>电子工程系</code> 中的不同职称的教师。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- NOT: 代表逻辑非<br>SELECT * FROM teacher WHERE department &#x3D; &#39;计算机系&#39; AND profession NOT IN (<br>    SELECT profession FROM teacher WHERE department &#x3D; &#39;电子工程系&#39;<br>)<br>-- 合并两个集<br>UNION<br>SELECT * FROM teacher WHERE department &#x3D; &#39;电子工程系&#39; AND profession NOT IN (<br>    SELECT profession FROM teacher WHERE department &#x3D; &#39;计算机系&#39;<br>);<br></code></pre></td></tr></table></figure>

<h3 id="ANY-表示至少一个-DESC-降序"><a href="#ANY-表示至少一个-DESC-降序" class="headerlink" title="ANY 表示至少一个 - DESC ( 降序 )"></a>ANY 表示至少一个 - DESC ( 降序 )</h3><p><strong>查询课程 <code>3-105</code> 且成绩 <u>至少</u> 高于 <code>3-245</code> 的 <code>score</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39;;<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 101  | 3-105 |     90 |<br>| 102  | 3-105 |     91 |<br>| 103  | 3-105 |     92 |<br>| 104  | 3-105 |     89 |<br>| 105  | 3-105 |     88 |<br>| 109  | 3-105 |     76 |<br>+------+-------+--------+<br><br>SELECT * FROM score WHERE c_no &#x3D; &#39;3-245&#39;;<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 103  | 3-245 |     86 |<br>| 105  | 3-245 |     75 |<br>| 109  | 3-245 |     68 |<br>+------+-------+--------+<br><br>-- ANY: 符合SQL语句中的任意条件。<br>-- 也就是说，在 3-105 成绩中，只要有一个大于从 3-245 筛选出来的任意行就符合条件，<br>-- 最后根据降序查询结果。<br>SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39; AND degree &gt; ANY(<br>    SELECT degree FROM score WHERE c_no &#x3D; &#39;3-245&#39;<br>) ORDER BY degree DESC;<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 103  | 3-105 |     92 |<br>| 102  | 3-105 |     91 |<br>| 101  | 3-105 |     90 |<br>| 104  | 3-105 |     89 |<br>| 105  | 3-105 |     88 |<br>| 109  | 3-105 |     76 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<h3 id="表示所有的-ALL"><a href="#表示所有的-ALL" class="headerlink" title="表示所有的 ALL"></a>表示所有的 ALL</h3><p><strong>查询课程 <code>3-105</code> 且成绩高于 <code>3-245</code> 的 <code>score</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 只需对上一道题稍作修改。<br>-- ALL: 符合SQL语句中的所有条件。<br>-- 也就是说，在 3-105 每一行成绩中，都要大于从 3-245 筛选出来全部行才算符合条件。<br>SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39; AND degree &gt; ALL(<br>    SELECT degree FROM score WHERE c_no &#x3D; &#39;3-245&#39;<br>);<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 101  | 3-105 |     90 |<br>| 102  | 3-105 |     91 |<br>| 103  | 3-105 |     92 |<br>| 104  | 3-105 |     89 |<br>| 105  | 3-105 |     88 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<h3 id="复制表的数据作为条件查询"><a href="#复制表的数据作为条件查询" class="headerlink" title="复制表的数据作为条件查询"></a>复制表的数据作为条件查询</h3><p><strong>查询某课程成绩比该课程平均成绩低的 <code>score</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 查询平均分<br>SELECT c_no, AVG(degree) FROM score GROUP BY c_no;<br>+-------+-------------+<br>| c_no  | AVG(degree) |<br>+-------+-------------+<br>| 3-105 |     87.6667 |<br>| 3-245 |     76.3333 |<br>| 6-166 |     81.6667 |<br>+-------+-------------+<br><br>-- 查询 score 表<br>SELECT degree FROM score;<br>+--------+<br>| degree |<br>+--------+<br>|     90 |<br>|     91 |<br>|     92 |<br>|     86 |<br>|     85 |<br>|     89 |<br>|     88 |<br>|     75 |<br>|     79 |<br>|     76 |<br>|     68 |<br>|     81 |<br>+--------+<br><br>-- 将表 b 作用于表 a 中查询数据<br>-- score a (b): 将表声明为 a (b)，<br>-- 如此就能用 a.c_no &#x3D; b.c_no 作为条件执行查询了。<br>SELECT * FROM score a WHERE degree &lt; (<br>    (SELECT AVG(degree) FROM score b WHERE a.c_no &#x3D; b.c_no)<br>);<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 105  | 3-245 |     75 |<br>| 105  | 6-166 |     79 |<br>| 109  | 3-105 |     76 |<br>| 109  | 3-245 |     68 |<br>| 109  | 6-166 |     81 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<h3 id="子查询-4"><a href="#子查询-4" class="headerlink" title="子查询 - 4"></a>子查询 - 4</h3><p><strong>查询所有任课 ( 在 <code>course</code> 表里有课程 ) 教师的 <code>name</code> 和 <code>department</code></strong> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT name, department FROM teacher WHERE no IN (SELECT t_no FROM course);<br>+--------+-----------------+<br>| name   | department      |<br>+--------+-----------------+<br>| 李诚   | 计算机系        |<br>| 王萍   | 计算机系        |<br>| 刘冰   | 电子工程系      |<br>| 张旭   | 电子工程系      |<br>+--------+-----------------+<br></code></pre></td></tr></table></figure>

<h3 id="条件加组筛选"><a href="#条件加组筛选" class="headerlink" title="条件加组筛选"></a>条件加组筛选</h3><p><strong>查询 <code>student</code> 表中至少有 2 名男生的 <code>class</code> 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 查看学生表信息<br>SELECT * FROM student;<br>+-----+-----------+-----+------------+-------+<br>| no  | name      | sex | birthday   | class |<br>+-----+-----------+-----+------------+-------+<br>| 101 | 曾华      | 男  | 1977-09-01 | 95033 |<br>| 102 | 匡明      | 男  | 1975-10-02 | 95031 |<br>| 103 | 王丽      | 女  | 1976-01-23 | 95033 |<br>| 104 | 李军      | 男  | 1976-02-20 | 95033 |<br>| 105 | 王芳      | 女  | 1975-02-10 | 95031 |<br>| 106 | 陆军      | 男  | 1974-06-03 | 95031 |<br>| 107 | 王尼玛    | 男  | 1976-02-20 | 95033 |<br>| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |<br>| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |<br>| 110 | 张飞      | 男  | 1974-06-03 | 95038 |<br>+-----+-----------+-----+------------+-------+<br><br>-- 只查询性别为男，然后按 class 分组，并限制 class 行大于 1。<br>SELECT class FROM student WHERE sex &#x3D; &#39;男&#39; GROUP BY class HAVING COUNT(*) &gt; 1;<br>+-------+<br>| class |<br>+-------+<br>| 95033 |<br>| 95031 |<br>+-------+<br></code></pre></td></tr></table></figure>

<h3 id="NOTLIKE-模糊查询取反"><a href="#NOTLIKE-模糊查询取反" class="headerlink" title="NOTLIKE 模糊查询取反"></a>NOTLIKE 模糊查询取反</h3><p><strong>查询 <code>student</code> 表中不姓 “王” 的同学记录。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- NOT: 取反<br>-- LIKE: 模糊查询<br>mysql&gt; SELECT * FROM student WHERE name NOT LIKE &#39;王%&#39;;<br>+-----+-----------+-----+------------+-------+<br>| no  | name      | sex | birthday   | class |<br>+-----+-----------+-----+------------+-------+<br>| 101 | 曾华      | 男  | 1977-09-01 | 95033 |<br>| 102 | 匡明      | 男  | 1975-10-02 | 95031 |<br>| 104 | 李军      | 男  | 1976-02-20 | 95033 |<br>| 106 | 陆军      | 男  | 1974-06-03 | 95031 |<br>| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |<br>| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |<br>| 110 | 张飞      | 男  | 1974-06-03 | 95038 |<br>+-----+-----------+-----+------------+-------+<br></code></pre></td></tr></table></figure>

<h3 id="YEAR-与-NOW-函数"><a href="#YEAR-与-NOW-函数" class="headerlink" title="YEAR 与 NOW 函数"></a>YEAR 与 NOW 函数</h3><p><strong>查询 <code>student</code> 表中每个学生的姓名和年龄。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 使用函数 YEAR(NOW()) 计算出当前年份，减去出生年份后得出年龄。<br>SELECT name, YEAR(NOW()) - YEAR(birthday) as age FROM student;<br>+-----------+------+<br>| name      | age  |<br>+-----------+------+<br>| 曾华      |   42 |<br>| 匡明      |   44 |<br>| 王丽      |   43 |<br>| 李军      |   43 |<br>| 王芳      |   44 |<br>| 陆军      |   45 |<br>| 王尼玛    |   43 |<br>| 张全蛋    |   44 |<br>| 赵铁柱    |   45 |<br>| 张飞      |   45 |<br>+-----------+------+<br></code></pre></td></tr></table></figure>

<h3 id="MAX-与-MIN-函数"><a href="#MAX-与-MIN-函数" class="headerlink" title="MAX 与 MIN 函数"></a>MAX 与 MIN 函数</h3><p><strong>查询 <code>student</code> 表中最大和最小的 <code>birthday</code> 值。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT MAX(birthday), MIN(birthday) FROM student;<br>+---------------+---------------+<br>| MAX(birthday) | MIN(birthday) |<br>+---------------+---------------+<br>| 1977-09-01    | 1974-06-03    |<br>+---------------+---------------+<br></code></pre></td></tr></table></figure>

<h3 id="多段排序"><a href="#多段排序" class="headerlink" title="多段排序"></a>多段排序</h3><p><strong>以 <code>class</code> 和 <code>birthday</code> 从大到小的顺序查询 <code>student</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM student ORDER BY class DESC, birthday;<br>+-----+-----------+-----+------------+-------+<br>| no  | name      | sex | birthday   | class |<br>+-----+-----------+-----+------------+-------+<br>| 110 | 张飞      | 男  | 1974-06-03 | 95038 |<br>| 103 | 王丽      | 女  | 1976-01-23 | 95033 |<br>| 104 | 李军      | 男  | 1976-02-20 | 95033 |<br>| 107 | 王尼玛    | 男  | 1976-02-20 | 95033 |<br>| 101 | 曾华      | 男  | 1977-09-01 | 95033 |<br>| 106 | 陆军      | 男  | 1974-06-03 | 95031 |<br>| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |<br>| 105 | 王芳      | 女  | 1975-02-10 | 95031 |<br>| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |<br>| 102 | 匡明      | 男  | 1975-10-02 | 95031 |<br>+-----+-----------+-----+------------+-------+<br></code></pre></td></tr></table></figure>

<h3 id="子查询-5"><a href="#子查询-5" class="headerlink" title="子查询 - 5"></a>子查询 - 5</h3><p><strong>查询 “男” 教师及其所上的课程。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM course WHERE t_no in (SELECT no FROM teacher WHERE sex &#x3D; &#39;男&#39;);<br>+-------+--------------+------+<br>| no    | name         | t_no |<br>+-------+--------------+------+<br>| 3-245 | 操作系统     | 804  |<br>| 6-166 | 数字电路     | 856  |<br>+-------+--------------+------+<br></code></pre></td></tr></table></figure>

<h3 id="MAX-函数与子查询"><a href="#MAX-函数与子查询" class="headerlink" title="MAX 函数与子查询"></a>MAX 函数与子查询</h3><p><strong>查询最高分同学的 <code>score</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 找出最高成绩（该查询只能有一个结果）<br>SELECT MAX(degree) FROM score;<br><br>-- 根据上面的条件筛选出所有最高成绩表，<br>-- 该查询可能有多个结果，假设 degree 值多次符合条件。<br>SELECT * FROM score WHERE degree &#x3D; (SELECT MAX(degree) FROM score);<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 103  | 3-105 |     92 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<h3 id="子查询-6"><a href="#子查询-6" class="headerlink" title="子查询 - 6"></a>子查询 - 6</h3><p><strong>查询和 “李军” 同性别的所有同学 <code>name</code> 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 首先将李军的性别作为条件取出来<br>SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;;<br>+-----+<br>| sex |<br>+-----+<br>| 男  |<br>+-----+<br><br>-- 根据性别查询 name 和 sex<br>SELECT name, sex FROM student WHERE sex &#x3D; (<br>    SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;<br>);<br>+-----------+-----+<br>| name      | sex |<br>+-----------+-----+<br>| 曾华      | 男  |<br>| 匡明      | 男  |<br>| 李军      | 男  |<br>| 陆军      | 男  |<br>| 王尼玛    | 男  |<br>| 张全蛋    | 男  |<br>| 赵铁柱    | 男  |<br>| 张飞      | 男  |<br>+-----------+-----+<br></code></pre></td></tr></table></figure>

<h3 id="子查询-7"><a href="#子查询-7" class="headerlink" title="子查询 - 7"></a>子查询 - 7</h3><p><strong>查询和 “李军” 同性别且同班的同学 <code>name</code> 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT name, sex, class FROM student WHERE sex &#x3D; (<br>    SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;<br>) AND class &#x3D; (<br>    SELECT class FROM student WHERE name &#x3D; &#39;李军&#39;<br>);<br>+-----------+-----+-------+<br>| name      | sex | class |<br>+-----------+-----+-------+<br>| 曾华      | 男  | 95033 |<br>| 李军      | 男  | 95033 |<br>| 王尼玛    | 男  | 95033 |<br>+-----------+-----+-------+<br></code></pre></td></tr></table></figure>

<h3 id="子查询-8"><a href="#子查询-8" class="headerlink" title="子查询 - 8"></a>子查询 - 8</h3><p><strong>查询所有选修 “计算机导论” 课程的 “男” 同学成绩表。</strong></p>
<p>需要的 “计算机导论” 和性别为 “男” 的编号可以在 <code>course</code> 和 <code>student</code> 表中找到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM score WHERE c_no &#x3D; (<br>    SELECT no FROM course WHERE name &#x3D; &#39;计算机导论&#39;<br>) AND s_no IN (<br>    SELECT no FROM student WHERE sex &#x3D; &#39;男&#39;<br>);<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 101  | 3-105 |     90 |<br>| 102  | 3-105 |     91 |<br>| 104  | 3-105 |     89 |<br>| 109  | 3-105 |     76 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<h3 id="按等级查询"><a href="#按等级查询" class="headerlink" title="按等级查询"></a>按等级查询</h3><p>建立一个 <code>grade</code> 表代表学生的成绩等级，并插入数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE grade (<br>    low INT(3),<br>    upp INT(3),<br>    grade char(1)<br>);<br><br>INSERT INTO grade VALUES (90, 100, &#39;A&#39;);<br>INSERT INTO grade VALUES (80, 89, &#39;B&#39;);<br>INSERT INTO grade VALUES (70, 79, &#39;C&#39;);<br>INSERT INTO grade VALUES (60, 69, &#39;D&#39;);<br>INSERT INTO grade VALUES (0, 59, &#39;E&#39;);<br><br>SELECT * FROM grade;<br>+------+------+-------+<br>| low  | upp  | grade |<br>+------+------+-------+<br>|   90 |  100 | A     |<br>|   80 |   89 | B     |<br>|   70 |   79 | C     |<br>|   60 |   69 | D     |<br>|    0 |   59 | E     |<br>+------+------+-------+<br></code></pre></td></tr></table></figure>

<p><strong>查询所有学生的 <code>s_no</code> 、<code>c_no</code> 和 <code>grade</code> 列。</strong></p>
<p>思路是，使用区间 ( <code>BETWEEN</code> ) 查询，判断学生的成绩 ( <code>degree</code> )  在 <code>grade</code> 表的 <code>low</code> 和 <code>upp</code> 之间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT s_no, c_no, grade FROM score, grade <br>WHERE degree BETWEEN low AND upp;<br>+------+-------+-------+<br>| s_no | c_no  | grade |<br>+------+-------+-------+<br>| 101  | 3-105 | A     |<br>| 102  | 3-105 | A     |<br>| 103  | 3-105 | A     |<br>| 103  | 3-245 | B     |<br>| 103  | 6-166 | B     |<br>| 104  | 3-105 | B     |<br>| 105  | 3-105 | B     |<br>| 105  | 3-245 | C     |<br>| 105  | 6-166 | C     |<br>| 109  | 3-105 | C     |<br>| 109  | 3-245 | D     |<br>| 109  | 6-166 | B     |<br>+------+-------+-------+<br></code></pre></td></tr></table></figure>

<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>准备用于测试连接查询的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE DATABASE testJoin;<br><br>CREATE TABLE person (<br>    id INT,<br>    name VARCHAR(20),<br>    cardId INT<br>);<br><br>CREATE TABLE card (<br>    id INT,<br>    name VARCHAR(20)<br>);<br><br>INSERT INTO card VALUES (1, &#39;饭卡&#39;), (2, &#39;建行卡&#39;), (3, &#39;农行卡&#39;), (4, &#39;工商卡&#39;), (5, &#39;邮政卡&#39;);<br>SELECT * FROM card;<br>+------+-----------+<br>| id   | name      |<br>+------+-----------+<br>|    1 | 饭卡      |<br>|    2 | 建行卡    |<br>|    3 | 农行卡    |<br>|    4 | 工商卡    |<br>|    5 | 邮政卡    |<br>+------+-----------+<br><br>INSERT INTO person VALUES (1, &#39;张三&#39;, 1), (2, &#39;李四&#39;, 3), (3, &#39;王五&#39;, 6);<br>SELECT * FROM person;<br>+------+--------+--------+<br>| id   | name   | cardId |<br>+------+--------+--------+<br>|    1 | 张三   |      1 |<br>|    2 | 李四   |      3 |<br>|    3 | 王五   |      6 |<br>+------+--------+--------+<br></code></pre></td></tr></table></figure>

<p>分析两张表发现，<code>person</code> 表并没有为 <code>cardId</code> 字段设置一个在 <code>card</code> 表中对应的 <code>id</code> 外键。如果设置了的话，<code>person</code> 中 <code>cardId</code> 字段值为 <code>6</code> 的行就插不进去，因为该 <code>cardId</code> 值在 <code>card</code> 表中并没有。</p>
<h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>要查询这两张表中有关系的数据，可以使用 <code>INNER JOIN</code> ( 内连接 ) 将它们连接在一起。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- INNER JOIN: 表示为内连接，将两张表拼接在一起。<br>-- on: 表示要执行某个条件。<br>SELECT * FROM person INNER JOIN card on person.cardId &#x3D; card.id;<br>+------+--------+--------+------+-----------+<br>| id   | name   | cardId | id   | name      |<br>+------+--------+--------+------+-----------+<br>|    1 | 张三   |      1 |    1 | 饭卡      |<br>|    2 | 李四   |      3 |    3 | 农行卡    |<br>+------+--------+--------+------+-----------+<br><br>-- 将 INNER 关键字省略掉，结果也是一样的。<br>-- SELECT * FROM person JOIN card on person.cardId &#x3D; card.id;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code>card</code> 的整张表被连接到了右边。</p>
</blockquote>
<h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p>完整显示左边的表 ( <code>person</code> ) ，右边的表如果符合条件就显示，不符合则补 <code>NULL</code> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- LEFT JOIN 也叫做 LEFT OUTER JOIN，用这两种方式的查询结果是一样的。<br>SELECT * FROM person LEFT JOIN card on person.cardId &#x3D; card.id;<br>+------+--------+--------+------+-----------+<br>| id   | name   | cardId | id   | name      |<br>+------+--------+--------+------+-----------+<br>|    1 | 张三   |      1 |    1 | 饭卡      |<br>|    2 | 李四   |      3 |    3 | 农行卡    |<br>|    3 | 王五   |      6 | NULL | NULL      |<br>+------+--------+--------+------+-----------+<br></code></pre></td></tr></table></figure>

<h4 id="右外链接"><a href="#右外链接" class="headerlink" title="右外链接"></a>右外链接</h4><p>完整显示右边的表 ( <code>card</code> ) ，左边的表如果符合条件就显示，不符合则补 <code>NULL</code> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM person RIGHT JOIN card on person.cardId &#x3D; card.id;<br>+------+--------+--------+------+-----------+<br>| id   | name   | cardId | id   | name      |<br>+------+--------+--------+------+-----------+<br>|    1 | 张三   |      1 |    1 | 饭卡      |<br>|    2 | 李四   |      3 |    3 | 农行卡    |<br>| NULL | NULL   |   NULL |    2 | 建行卡    |<br>| NULL | NULL   |   NULL |    4 | 工商卡    |<br>| NULL | NULL   |   NULL |    5 | 邮政卡    |<br>+------+--------+--------+------+-----------+<br></code></pre></td></tr></table></figure>

<h4 id="全外链接"><a href="#全外链接" class="headerlink" title="全外链接"></a>全外链接</h4><p>完整显示两张表的全部数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- MySQL 不支持这种语法的全外连接<br>-- SELECT * FROM person FULL JOIN card on person.cardId &#x3D; card.id;<br>-- 出现错误：<br>-- ERROR 1054 (42S22): Unknown column &#39;person.cardId&#39; in &#39;on clause&#39;<br><br>-- MySQL全连接语法，使用 UNION 将两张表合并在一起。<br>SELECT * FROM person LEFT JOIN card on person.cardId &#x3D; card.id<br>UNION<br>SELECT * FROM person RIGHT JOIN card on person.cardId &#x3D; card.id;<br>+------+--------+--------+------+-----------+<br>| id   | name   | cardId | id   | name      |<br>+------+--------+--------+------+-----------+<br>|    1 | 张三   |      1 |    1 | 饭卡      |<br>|    2 | 李四   |      3 |    3 | 农行卡    |<br>|    3 | 王五   |      6 | NULL | NULL      |<br>| NULL | NULL   |   NULL |    2 | 建行卡    |<br>| NULL | NULL   |   NULL |    4 | 工商卡    |<br>| NULL | NULL   |   NULL |    5 | 邮政卡    |<br>+------+--------+--------+------+-----------+<br></code></pre></td></tr></table></figure>

<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>在 MySQL 中，事务其实是一个最小的不可分割的工作单元。事务能够<strong>保证一个业务的完整性</strong>。</p>
<p>比如我们的银行转账：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- a -&gt; -100<br>UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;<br><br>-- b -&gt; +100<br>UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;<br></code></pre></td></tr></table></figure>

<p>在实际项目中，假设只有一条 SQL 语句执行成功，而另外一条执行失败了，就会出现数据前后不一致。</p>
<p>因此，在执行多条有关联 SQL 语句时，<strong>事务</strong>可能会要求这些 SQL 语句要么同时执行成功，要么就都执行失败。</p>
<h3 id="如何控制事务-COMMIT-ROLLBACK"><a href="#如何控制事务-COMMIT-ROLLBACK" class="headerlink" title="如何控制事务 - COMMIT / ROLLBACK"></a>如何控制事务 - COMMIT / ROLLBACK</h3><p>在 MySQL 中，事务的<strong>自动提交</strong>状态默认是开启的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 查询事务的自动提交状态<br>SELECT @@AUTOCOMMIT;<br>+--------------+<br>| @@AUTOCOMMIT |<br>+--------------+<br>|            1 |<br>+--------------+<br></code></pre></td></tr></table></figure>

<p><strong>自动提交的作用</strong>：当我们执行一条 SQL 语句的时候，其产生的效果就会立即体现出来，且不能<strong>回滚</strong>。</p>
<p>什么是回滚？举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE DATABASE bank;<br><br>USE bank;<br><br>CREATE TABLE user (<br>    id INT PRIMARY KEY,<br>    name VARCHAR(20),<br>    money INT<br>);<br><br>INSERT INTO user VALUES (1, &#39;a&#39;, 1000);<br><br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |  1000 |<br>+----+------+-------+<br></code></pre></td></tr></table></figure>

<p>可以看到，在执行插入语句后数据立刻生效，原因是 MySQL 中的事务自动将它<strong>提交</strong>到了数据库中。那么所谓<strong>回滚</strong>的意思就是，撤销执行过的所有 SQL 语句，使其回滚到<strong>最后一次提交</strong>数据时的状态。</p>
<p>在 MySQL 中使用 <code>ROLLBACK</code> 执行回滚：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 回滚到最后一次提交<br>ROLLBACK;<br><br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |  1000 |<br>+----+------+-------+<br></code></pre></td></tr></table></figure>

<p>由于所有执行过的 SQL 语句都已经被提交过了，所以数据并没有发生回滚。那如何让数据可以发生回滚？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 关闭自动提交<br>SET AUTOCOMMIT &#x3D; 0;<br><br>-- 查询自动提交状态<br>SELECT @@AUTOCOMMIT;<br>+--------------+<br>| @@AUTOCOMMIT |<br>+--------------+<br>|            0 |<br>+--------------+<br></code></pre></td></tr></table></figure>

<p>将自动提交关闭后，测试数据回滚：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">INSERT INTO user VALUES (2, &#39;b&#39;, 1000);<br><br>-- 关闭 AUTOCOMMIT 后，数据的变化是在一张虚拟的临时数据表中展示，<br>-- 发生变化的数据并没有真正插入到数据表中。<br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |  1000 |<br>|  2 | b    |  1000 |<br>+----+------+-------+<br><br>-- 数据表中的真实数据其实还是：<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |  1000 |<br>+----+------+-------+<br><br>-- 由于数据还没有真正提交，可以使用回滚<br>ROLLBACK;<br><br>-- 再次查询<br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |  1000 |<br>+----+------+-------+<br></code></pre></td></tr></table></figure>

<p>那如何将虚拟的数据真正提交到数据库中？使用 <code>COMMIT</code> : </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">INSERT INTO user VALUES (2, &#39;b&#39;, 1000);<br>-- 手动提交数据（持久性），<br>-- 将数据真正提交到数据库中，执行后不能再回滚提交过的数据。<br>COMMIT;<br><br>-- 提交后测试回滚<br>ROLLBACK;<br><br>-- 再次查询（回滚无效了）<br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |  1000 |<br>|  2 | b    |  1000 |<br>+----+------+-------+<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>总结</strong></p>
<ol>
<li><p><strong>自动提交</strong></p>
<ul>
<li><p>查看自动提交状态：<code>SELECT @@AUTOCOMMIT</code> ；</p>
</li>
<li><p>设置自动提交状态：<code>SET AUTOCOMMIT = 0</code> 。</p>
</li>
</ul>
</li>
<li><p><strong>手动提交</strong></p>
<p><code>@@AUTOCOMMIT = 0</code> 时，使用 <code>COMMIT</code> 命令提交事务。</p>
</li>
<li><p><strong>事务回滚</strong></p>
<p><code>@@AUTOCOMMIT = 0</code> 时，使用 <code>ROLLBACK</code> 命令回滚事务。</p>
</li>
</ol>
</blockquote>
<p><strong>事务的实际应用</strong>，让我们再回到银行转账项目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 转账<br>UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;<br><br>-- 到账<br>UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;<br><br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |   900 |<br>|  2 | b    |  1100 |<br>+----+------+-------+<br></code></pre></td></tr></table></figure>

<p>这时假设在转账时发生了意外，就可以使用 <code>ROLLBACK</code> 回滚到最后一次提交的状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 假设转账发生了意外，需要回滚。<br>ROLLBACK;<br><br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |  1000 |<br>|  2 | b    |  1000 |<br>+----+------+-------+<br></code></pre></td></tr></table></figure>

<p>这时我们又回到了发生意外之前的状态，也就是说，事务给我们提供了一个可以反悔的机会。假设数据没有发生意外，这时可以手动将数据真正提交到数据表中：<code>COMMIT</code> 。</p>
<h3 id="手动开启事务-BEGIN-START-TRANSACTION"><a href="#手动开启事务-BEGIN-START-TRANSACTION" class="headerlink" title="手动开启事务 - BEGIN / START TRANSACTION"></a>手动开启事务 - BEGIN / START TRANSACTION</h3><p>事务的默认提交被开启 ( <code>@@AUTOCOMMIT = 1</code> ) 后，此时就不能使用事务回滚了。但是我们还可以手动开启一个事务处理事件，使其可以发生回滚：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 使用 BEGIN 或者 START TRANSACTION 手动开启一个事务<br>-- START TRANSACTION;<br>BEGIN;<br>UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;<br>UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;<br><br>-- 由于手动开启的事务没有开启自动提交，<br>-- 此时发生变化的数据仍然是被保存在一张临时表中。<br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |   900 |<br>|  2 | b    |  1100 |<br>+----+------+-------+<br><br>-- 测试回滚<br>ROLLBACK;<br><br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |  1000 |<br>|  2 | b    |  1000 |<br>+----+------+-------+<br></code></pre></td></tr></table></figure>

<p>仍然使用 <code>COMMIT</code> 提交数据，提交后无法再发生本次事务的回滚。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">BEGIN;<br>UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;<br>UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;<br><br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |   900 |<br>|  2 | b    |  1100 |<br>+----+------+-------+<br><br>-- 提交数据<br>COMMIT;<br><br>-- 测试回滚（无效，因为表的数据已经被提交）<br>ROLLBACK;<br></code></pre></td></tr></table></figure>

<h3 id="事务的-ACID-特征与使用"><a href="#事务的-ACID-特征与使用" class="headerlink" title="事务的 ACID 特征与使用"></a>事务的 ACID 特征与使用</h3><p><strong>事务的四大特征：</strong></p>
<ul>
<li><strong>A 原子性</strong>：事务是最小的单位，不可以再分割；</li>
<li><strong>C 一致性</strong>：要求同一事务中的 SQL 语句，必须保证同时成功或者失败；</li>
<li><strong>I 隔离性</strong>：事务1 和 事务2 之间是具有隔离性的；</li>
<li><strong>D 持久性</strong>：事务一旦结束 ( <code>COMMIT</code> ) ，就不可以再返回了 ( <code>ROLLBACK</code> ) 。</li>
</ul>
<h3 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h3><p><strong>事务的隔离性可分为四种 ( 性能从低到高 )</strong> ：</p>
<ol>
<li><p><strong>READ UNCOMMITTED ( 读取未提交 )</strong></p>
<p>如果有多个事务，那么任意事务都可以看见其他事务的<strong>未提交数据</strong>。</p>
</li>
<li><p><strong>READ COMMITTED ( 读取已提交 )</strong></p>
<p>只能读取到其他事务<strong>已经提交的数据</strong>。</p>
</li>
<li><p><strong>REPEATABLE READ ( 可被重复读 )</strong></p>
<p>如果有多个连接都开启了事务，那么事务之间不能共享数据记录，否则只能共享已提交的记录。</p>
</li>
<li><p><strong>SERIALIZABLE ( 串行化 )</strong></p>
<p>所有的事务都会按照<strong>固定顺序执行</strong>，执行完一个事务后再继续执行下一个事务的<strong>写入操作</strong>。</p>
</li>
</ol>
<p>查看当前数据库的默认隔离级别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- MySQL 8.x, GLOBAL 表示系统级别，不加表示会话级别。<br>SELECT @@GLOBAL.TRANSACTION_ISOLATION;<br>SELECT @@TRANSACTION_ISOLATION;<br>+--------------------------------+<br>| @@GLOBAL.TRANSACTION_ISOLATION |<br>+--------------------------------+<br>| REPEATABLE-READ                | -- MySQL的默认隔离级别，可以重复读。<br>+--------------------------------+<br><br>-- MySQL 5.x<br>SELECT @@GLOBAL.TX_ISOLATION;<br>SELECT @@TX_ISOLATION;<br></code></pre></td></tr></table></figure>

<p>修改隔离级别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 设置系统隔离级别，LEVEL 后面表示要设置的隔离级别 (READ UNCOMMITTED)。<br>SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;<br><br>-- 查询系统隔离级别，发现已经被修改。<br>SELECT @@GLOBAL.TRANSACTION_ISOLATION;<br>+--------------------------------+<br>| @@GLOBAL.TRANSACTION_ISOLATION |<br>+--------------------------------+<br>| READ-UNCOMMITTED               |<br>+--------------------------------+<br></code></pre></td></tr></table></figure>

<h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>测试 <strong>READ UNCOMMITTED ( 读取未提交 )</strong> 的隔离性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">INSERT INTO user VALUES (3, &#39;小明&#39;, 1000);<br>INSERT INTO user VALUES (4, &#39;淘宝店&#39;, 1000);<br><br>SELECT * FROM user;<br>+----+-----------+-------+<br>| id | name      | money |<br>+----+-----------+-------+<br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>+----+-----------+-------+<br><br>-- 开启一个事务操作数据<br>-- 假设小明在淘宝店买了一双800块钱的鞋子：<br>START TRANSACTION;<br>UPDATE user SET money &#x3D; money - 800 WHERE name &#x3D; &#39;小明&#39;;<br>UPDATE user SET money &#x3D; money + 800 WHERE name &#x3D; &#39;淘宝店&#39;;<br><br>-- 然后淘宝店在另一方查询结果，发现钱已到账。<br>SELECT * FROM user;<br>+----+-----------+-------+<br>| id | name      | money |<br>+----+-----------+-------+<br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |   200 |<br>|  4 | 淘宝店    |  1800 |<br>+----+-----------+-------+<br></code></pre></td></tr></table></figure>

<p>由于小明的转账是在新开启的事务上进行操作的，而该操作的结果是可以被其他事务（另一方的淘宝店）看见的，因此淘宝店的查询结果是正确的，淘宝店确认到账。但就在这时，如果小明在它所处的事务上又执行了 <code>ROLLBACK</code> 命令，会发生什么？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 小明所处的事务<br>ROLLBACK;<br><br>-- 此时无论对方是谁，如果再去查询结果就会发现：<br>SELECT * FROM user;<br>+----+-----------+-------+<br>| id | name      | money |<br>+----+-----------+-------+<br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>+----+-----------+-------+<br></code></pre></td></tr></table></figure>

<p>这就是所谓的<strong>脏读</strong>，一个事务读取到另外一个事务还未提交的数据。这在实际开发中是不允许出现的。</p>
<h4 id="读取已提交"><a href="#读取已提交" class="headerlink" title="读取已提交"></a>读取已提交</h4><p>把隔离级别设置为 <strong>READ COMMITTED</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;<br>SELECT @@GLOBAL.TRANSACTION_ISOLATION;<br>+--------------------------------+<br>| @@GLOBAL.TRANSACTION_ISOLATION |<br>+--------------------------------+<br>| READ-COMMITTED                 |<br>+--------------------------------+<br></code></pre></td></tr></table></figure>

<p>这样，再有新的事务连接进来时，它们就只能查询到已经提交过的事务数据了。但是对于当前事务来说，它们看到的还是未提交的数据，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 正在操作数据事务（当前事务）<br>START TRANSACTION;<br>UPDATE user SET money &#x3D; money - 800 WHERE name &#x3D; &#39;小明&#39;;<br>UPDATE user SET money &#x3D; money + 800 WHERE name &#x3D; &#39;淘宝店&#39;;<br><br>-- 虽然隔离级别被设置为了 READ COMMITTED，但在当前事务中，<br>-- 它看到的仍然是数据表中临时改变数据，而不是真正提交过的数据。<br>SELECT * FROM user;<br>+----+-----------+-------+<br>| id | name      | money |<br>+----+-----------+-------+<br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |   200 |<br>|  4 | 淘宝店    |  1800 |<br>+----+-----------+-------+<br><br><br>-- 假设此时在远程开启了一个新事务，连接到数据库。<br>$ mysql -u root -p12345612<br><br>-- 此时远程连接查询到的数据只能是已经提交过的<br>SELECT * FROM user;<br>+----+-----------+-------+<br>| id | name      | money |<br>+----+-----------+-------+<br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>+----+-----------+-------+<br></code></pre></td></tr></table></figure>

<p>但是这样还有问题，那就是假设一个事务在操作数据时，其他事务干扰了这个事务的数据。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 小张在查询数据的时候发现：<br>SELECT * FROM user;<br>+----+-----------+-------+<br>| id | name      | money |<br>+----+-----------+-------+<br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |   200 |<br>|  4 | 淘宝店    |  1800 |<br>+----+-----------+-------+<br><br>-- 在小张求表的 money 平均值之前，小王做了一个操作：<br>START TRANSACTION;<br>INSERT INTO user VALUES (5, &#39;c&#39;, 100);<br>COMMIT;<br><br>-- 此时表的真实数据是：<br>SELECT * FROM user;<br>+----+-----------+-------+<br>| id | name      | money |<br>+----+-----------+-------+<br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>|  5 | c         |   100 |<br>+----+-----------+-------+<br><br>-- 这时小张再求平均值的时候，就会出现计算不相符合的情况：<br>SELECT AVG(money) FROM user;<br>+------------+<br>| AVG(money) |<br>+------------+<br>|  820.0000  |<br>+------------+<br></code></pre></td></tr></table></figure>

<p>虽然 <strong>READ COMMITTED</strong> 让我们只能读取到其他事务已经提交的数据，但还是会出现问题，就是<strong>在读取同一个表的数据时，可能会发生前后不一致的情况。</strong>这被称为<strong>不可重复读现象 ( READ COMMITTED )</strong> 。</p>
<h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>将隔离级别设置为 <strong>REPEATABLE READ ( 可被重复读取 )</strong> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br>SELECT @@GLOBAL.TRANSACTION_ISOLATION;<br>+--------------------------------+<br>| @@GLOBAL.TRANSACTION_ISOLATION |<br>+--------------------------------+<br>| REPEATABLE-READ                |<br>+--------------------------------+<br></code></pre></td></tr></table></figure>

<p>测试 <strong>REPEATABLE READ</strong> ，假设在两个不同的连接上分别执行 <code>START TRANSACTION</code> :</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 小张 - 成都</span><br><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">1000</span>);<br><br><span class="hljs-comment">-- 小王 - 北京</span><br><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<br><br><span class="hljs-comment">-- 小张 - 成都</span><br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure>

<p>当前事务开启后，没提交之前，查询不到，提交后可以被查询到。但是，在提交之前其他事务被开启了，那么在这条事务线上，就不会查询到当前有操作事务的连接。相当于开辟出一条单独的线程。</p>
<p>无论小张是否执行过 <code>COMMIT</code> ，在小王这边，都不会查询到小张的事务记录，而是只会查询到自己所处事务的记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;<br>+<span class="hljs-comment">----+-----------+-------+</span><br>| id | name      | money |<br>+<span class="hljs-comment">----+-----------+-------+</span><br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>|  5 | c         |   100 |<br>+<span class="hljs-comment">----+-----------+-------+</span><br></code></pre></td></tr></table></figure>

<p>这是<strong>因为小王在此之前开启了一个新的事务 ( <code>START TRANSACTION</code> ) **，那么</strong>在他的这条新事务的线上，跟其他事务是没有联系的**，也就是说，此时如果其他事务正在操作数据，它是不知道的。</p>
<p>然而事实是，在真实的数据表中，小张已经插入了一条数据。但是小王此时并不知道，也插入了同一条数据，会发生什么呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">1000</span>);<br><span class="hljs-comment">-- ERROR 1062 (23000): Duplicate entry &#x27;6&#x27; for key &#x27;PRIMARY&#x27;</span><br></code></pre></td></tr></table></figure>

<p>报错了，操作被告知已存在主键为 <code>6</code> 的字段。这种现象也被称为<strong>幻读，一个事务提交的数据，不能被其他事务读取到</strong>。</p>
<h4 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h4><p>顾名思义，就是所有事务的<strong>写入操作</strong>全都是串行化的。什么意思？把隔离级别修改成 <strong>SERIALIZABLE</strong> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;<br>SELECT @@GLOBAL.TRANSACTION_ISOLATION;<br>+--------------------------------+<br>| @@GLOBAL.TRANSACTION_ISOLATION |<br>+--------------------------------+<br>| SERIALIZABLE                   |<br>+--------------------------------+<br></code></pre></td></tr></table></figure>

<p>还是拿小张和小王来举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 小张 - 成都<br>START TRANSACTION;<br><br>-- 小王 - 北京<br>START TRANSACTION;<br><br>-- 开启事务之前先查询表，准备操作数据。<br>SELECT * FROM user;<br>+----+-----------+-------+<br>| id | name      | money |<br>+----+-----------+-------+<br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>|  5 | c         |   100 |<br>|  6 | d         |  1000 |<br>+----+-----------+-------+<br><br>-- 发现没有 7 号王小花，于是插入一条数据：<br>INSERT INTO user VALUES (7, &#39;王小花&#39;, 1000);<br></code></pre></td></tr></table></figure>

<p>此时会发生什么呢？由于现在的隔离级别是 <strong>SERIALIZABLE ( 串行化 )</strong> ，串行化的意思就是：假设把所有的事务都放在一个串行的队列中，那么所有的事务都会按照<strong>固定顺序执行</strong>，执行完一个事务后再继续执行下一个事务的<strong>写入操作</strong> ( <strong>这意味着队列中同时只能执行一个事务的写入操作</strong> ) 。</p>
<p>根据这个解释，小王在插入数据时，会出现等待状态，直到小张执行 <code>COMMIT</code> 结束它所处的事务，或者出现等待超时。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>精尽 Redis 面试题</title>
    <url>/2016/10/12/%E7%B2%BE%E5%B0%BD%20Redis%20%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="精尽-Redis-面试题"><a href="#精尽-Redis-面试题" class="headerlink" title="精尽 Redis 面试题"></a>精尽 Redis 面试题</h1><blockquote>
<p>这个面试题是建立在胖友看过 <a href="http://svip.iocoder.cn/Cache/Interview">《精尽【缓存 】面试题》</a> 。</p>
</blockquote>
<p>以下面试题，基于网络整理，和自己编辑。具体参考的文章，会在文末给出所有的链接。</p>
<p>如果胖友有自己的疑问，欢迎在星球提问，我们一起整理吊吊的 Redis 面试题的大保健。</p>
<p>而题目的难度，艿艿尽量按照从容易到困难的顺序，逐步下去。</p>
<h2 id="什么是-Redis-？"><a href="#什么是-Redis-？" class="headerlink" title="什么是 Redis ？"></a>什么是 Redis ？</h2><p><a href="http://lib.csdn.net/base/redis">Redis</a> ，全称 Remote Dictionary Server ，是一个基于内存的高性能 Key-Value <a href="http://lib.csdn.net/base/mysql">数据库</a>。</p>
<p>Redis 已经成为互联网公司在缓存组件选择的唯一。例如说，在各种公有云上，缓存服务都是提供的 Redis。再例如说，招聘简历要求上，都会要求掌握 Redis 。</p>
<h2 id="Redis-有什么优点？"><a href="#Redis-有什么优点？" class="headerlink" title="Redis 有什么优点？"></a>Redis 有什么优点？</h2><p>🦅 <strong>1. 速度快</strong></p>
<p>因为数据存在内存中，类似于 HashMap ，HashMap 的优势就是查找和操作的时间复杂度都是O (1) 。</p>
<blockquote>
<p>Redis 本质上是一个 Key-Value 类型的内存数据库，很像 Memcached ，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。</p>
<p>因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value 数据库。</p>
</blockquote>
<ul>
<li>如果我们查看在<a href="https://help.aliyun.com/document_detail/26350.html">阿里云销售的 Redis 规格</a>，最低的也是 8W QPS 。</li>
</ul>
<p>🦅 <strong>2. 支持丰富数据类型</strong></p>
<p>支持 String ，List，Set，Sorted Set，Hash 五种基础的数据结构。</p>
<blockquote>
<p>Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结构，此外单个 Value 的最大限制是 1GB，不像 Memcached只能保存 1MB 的数据，因此 Redis 可以用来实现很多有用的功能。比方说：</p>
<ul>
<li>用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性能消息队列服务。</li>
<li>用他的 Set 可以做高性能的 tag 系统等等。</li>
</ul>
</blockquote>
<p>同时，在基础的数据结构之上，还提供 <a href="http://redisdoc.com/bitmap/index.html">Bitmap</a>、<a href="http://redisdoc.com/hyperloglog/index.html">HyperLogLog</a>、<a href="http://redisdoc.com/geo/index.html">GEO</a> 等高级的数据结构。</p>
<p>如果面试想要加分，胖友一定要去看看这些高级的数据结构，面试与日常开发，必备神器。</p>
<p>🦅 <strong>3. 丰富的特性</strong></p>
<ul>
<li>订阅发布 Pub / Sub 功能</li>
<li>Key 过期策略</li>
<li>事务</li>
<li>支持多个 DB</li>
<li>计数</li>
<li>…</li>
</ul>
<p>并且在 Redis 5.0 增加了 Stream 功能，一个新的强大的支持多播的可持久化的消息队列，提供类似 Kafka 的功能。</p>
<p>🦅 <strong>4. 持久化存储</strong></p>
<p>Redis 提供 RDB 和 AOF 两种数据的持久化存储方案，解决内存数据库最担心的万一 Redis 挂掉，数据会消失掉。</p>
<p>🦅 <strong>5、高可用</strong></p>
<p>内置 Redis Sentinel ，提供高可用方案，实现主从故障自动转移。</p>
<p>内置 Redis Cluster ，提供集群方案，实现基于槽的分片方案，从而支持更大的 Redis 规模。</p>
<h2 id="Redis-有什么缺点？"><a href="#Redis-有什么缺点？" class="headerlink" title="Redis 有什么缺点？"></a>Redis 有什么缺点？</h2><ul>
<li><p>1、由于 Redis 是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然 Redis 本身有 Key 过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。</p>
<blockquote>
<p>另外，可使用 Redis Cluster、Codis 等方案，对 Redis 进行分区，从单机 Redis 变成集群 Redis 。</p>
</blockquote>
</li>
<li><p>2、如果进行完整重同步，由于需要生成 RDB 文件，并进行传输，会占用主机的 CPU ，并会消耗现网的带宽。不过 Redis2.8 版本，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如，新上线的备机。</p>
</li>
<li><p>3、修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，Redis 不能提供服务。</p>
</li>
</ul>
<h2 id="Redis-和-Memcached-的区别有哪些？"><a href="#Redis-和-Memcached-的区别有哪些？" class="headerlink" title="Redis 和 Memcached 的区别有哪些？"></a>Redis 和 Memcached 的区别有哪些？</h2><blockquote>
<p>艿艿：随着 Memcached 日渐没落，这个问题问的越来越少了。</p>
</blockquote>
<p>🦅 <strong>1. Redis 支持复杂的数据结构</strong></p>
<ul>
<li>Memcached 仅提供简单的字符串。</li>
<li>Redis 提供复杂的数据结构，丰富的数据操作。</li>
</ul>
<p>也因为 Redis 支持复杂的数据结构，Redis 即使晚于 Memcached 推出，却获得更多开发者的青睐。</p>
<p>Redis 相比 Memcached 来说，拥有更多的数据结构，能支持更丰富的数据操作。如果需要缓存能够支持更复杂的结构和操作，Redis 会是不错的选择。</p>
<p>🦅 <strong>2. Redis 原生支持集群模式</strong></p>
<ul>
<li>在 Redis3.x 版本中，官方便能支持 Cluster 模式。</li>
<li>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。</li>
</ul>
<p>🦅 <strong>3. 性能对比</strong></p>
<ul>
<li>Redis 只使用单核，而 Memcached 可以使用多核，所以平均每一个核上 Redis在存储小数据时比 Memcached 性能更高。</li>
<li>在 100k 以上的数据中，Memcached 性能要高于 Redis 。虽然 Redis 最近也在存储大数据的性能上进行优化，但是比起 Memcached，还是稍有逊色。</li>
</ul>
<p>更多关于性能的对比，可以看看 <a href="https://www.jianshu.com/p/34f90813d7c9">《Memcached 与 Redis 的关键性能指标比较》</a> 。</p>
<p>🦅 <strong>4. 内存管理机制不同</strong></p>
<p>相比来说，Redis 的内存管理机制，会更加简单。</p>
<ul>
<li>Redis 采用的是<strong>包装</strong>的 malloc/free ，使用时现场申请的方式。</li>
<li>Memcached 采用的是 Slab Allocation 机制管理内存，预分配的内存池的方式。</li>
</ul>
<p>如果对比两者的内存使用效率：</p>
<ul>
<li>简单的 Key-Value 存储的话，Memcached 的内存利用率更高，可以使用类似内存池。</li>
<li>如果 Redis 采用 hash 结构来做 key-value 存储，由于其组合式的压缩， 其内存利用率会高于 Memcached 。</li>
</ul>
<p>🦅 <strong>5. 网络 IO 模型</strong></p>
<ul>
<li>Memcached 是多线程，非阻塞 IO 复用的网络模型，原型上接近 Nignx 。</li>
<li>Redis 使用单线程的 IO 复用模型，自己封装了一个简单的 AeEvent 事件处理框架，主要实现了 epoll ， kqueue 和 select ，更接近 Apache 早期的模式。</li>
</ul>
<p>🦅 <strong>6. 持久化存储</strong></p>
<ul>
<li>Memcached 不支持持久化存储，重启时，数据被清空。</li>
<li>Redis 支持持久化存储，重启时，可以恢复已持久化的数据。</li>
</ul>
<hr>
<p>也推荐阅读下 <a href="https://www.imooc.com/article/23549">《脚踏两只船的困惑 - Memcached 与 Redis》</a> 。</p>
<h2 id="请说说-Redis-的线程模型？"><a href="#请说说-Redis-的线程模型？" class="headerlink" title="请说说 Redis 的线程模型？"></a>请说说 Redis 的线程模型？</h2><blockquote>
<p>艿艿：这个是我从网络上找的资料，讲的灰常不错。<strong>一般来说，回答道 Redis 是非阻塞 IO ，多路复用</strong>。</p>
</blockquote>
<p>Redis 内部使用文件事件处理器 <code>file event handler</code>，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 Socket，根据 Socket 上的事件来选择对应的事件处理器进行处理。</p>
<p>文件事件处理器的结构包含 4 个部分：</p>
<ul>
<li>多个 Socket 。</li>
<li>IO 多路复用程序。</li>
<li>文件事件分派器。</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）。</li>
</ul>
<p>多个 Socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p>
<p>来看客户端与 redis 的一次通信过程：</p>
<p><img src="http://cdn.tuwenbin.vip/6gtq4m9r.bmp" alt="6gtq4m9r">redis-single-thread-model</p>
<ul>
<li>客户端 Socket01 向 Redis 的 Server Socket 请求建立连接，此时 Server Socket 会产生一个 <code>AE_READABLE</code> 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该事件压入队列中。文件事件分派器从队列中获取该事件，交给<code>连接应答处理器</code>。连接应答处理器会创建一个能与客户端通信的 Socket01，并将该 Socket01 的 <code>AE_READABLE</code> 事件与命令请求处理器关联。</li>
<li>假设此时客户端发送了一个 <code>set key value</code> 请求，此时 Redis 中的 Socket01 会产生 <code>AE_READABLE</code> 事件，IO 多路复用程序将事件压入队列，此时事件分派器从队列中获取到该事件，由于前面 Socket01 的 <code>AE_READABLE</code> 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 Scket01 的 <code>set key value</code> 并在自己内存中完成 <code>set key value</code> 的设置。操作完成后，它会将 Scket01 的 <code>AE_WRITABLE</code> 事件与令回复处理器关联。</li>
<li>如果此时客户端准备好接收返回结果了，那么 Redis 中的 Socket01 会产生一个 <code>AE_WRITABLE</code> 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 <code>ok</code>，之后解除 Socket01 的 <code>AE_WRITABLE</code> 事件与命令回复处理器的关联。</li>
</ul>
<p>这样便完成了一次通信。😈 耐心理解一下，灰常重要。如果还是不能理解，可以在网络上搜一些资料，在理解理解。</p>
<h2 id="为什么-Redis-单线程模型也能效率这么高？"><a href="#为什么-Redis-单线程模型也能效率这么高？" class="headerlink" title="为什么 Redis 单线程模型也能效率这么高？"></a>为什么 Redis 单线程模型也能效率这么高？</h2><ul>
<li><p>1、C 语言实现。</p>
<blockquote>
<p>我们都知道，C 语言的执行速度非常快。</p>
</blockquote>
</li>
<li><p>2、纯内存操作。</p>
<blockquote>
<p>Redis 为了达到最快的读写速度，将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以 Redis 具有快速和数据持久化的特征。</p>
<p>如果不将数据放在内存中，磁盘 I/O 速度为严重影响 Redis 的性能。</p>
</blockquote>
</li>
<li><p>3、基于非阻塞的 IO 多路复用机制。</p>
</li>
<li><p>4、单线程，避免了多线程的频繁上下文切换问题。</p>
<blockquote>
<p>Redis 利用队列技术，将并发访问变为串行访问，消除了传统数据库串行控制的开销。</p>
<p>实际上，Redis 4.0 开始，也开始有了一些异步线程，用于处理一些耗时操作。例如说，异步线程，实现<a href="https://blog.csdn.net/zhanglong_4444/article/details/88350443">惰性删除</a>（解决大 KEY 删除，阻塞主线程）和异步 AOF （解决磁盘 IO 紧张时，fsync 执行一次很慢）等等。</p>
</blockquote>
</li>
<li><p>5、丰富的数据结构。</p>
<blockquote>
<p>Redis 全程使用 hash 结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化。例如，压缩表，对短数据进行压缩存储；再再如，跳表，使用有序的数据结构加快读取的速度。</p>
<p>也因为 Redis 是单线程的，所以可以实现丰富的数据结构，无需考虑并发的问题。</p>
</blockquote>
</li>
</ul>
<h2 id="Redis-是单线程的，如何提高多核-CPU-的利用率？"><a href="#Redis-是单线程的，如何提高多核-CPU-的利用率？" class="headerlink" title="Redis 是单线程的，如何提高多核 CPU 的利用率？"></a>Redis 是单线程的，如何提高多核 CPU 的利用率？</h2><p>可以在同一个服务器部署多个 Redis 的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个 CPU ，你可以考虑一下分区。</p>
<h2 id="Redis-有几种持久化方式？"><a href="#Redis-有几种持久化方式？" class="headerlink" title="Redis 有几种持久化方式？"></a>Redis 有几种持久化方式？</h2><blockquote>
<p>艿艿：这个问题有一丢丢长，耐心看完。</p>
<p>面试的时候，如果不能完整回答出来，也不会有大问题。重点，在于有条理，对 RDB 和 AOF 有理解。</p>
</blockquote>
<p>🦅 <strong>持久化方式</strong></p>
<p>Redis 提供了两种方式，实现数据的持久化到硬盘。</p>
<ul>
<li>1、【全量】RDB 持久化，是指在指定的时间间隔内将内存中的<strong>数据集快照</strong>写入磁盘。实际操作过程是，fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</li>
<li>2、【增量】AOF持久化，以日志的形式记录服务器所处理的每一个<strong>写、删除操作</strong>，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</li>
</ul>
<p>🦅 <strong>RDB 优缺点</strong></p>
<p>① 优点</p>
<ul>
<li>灵活设置备份频率和周期。你可能打算每个小时归档一次最近 24 小时的数据，同时还要每天归档一次最近 30 天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</li>
<li>非常适合冷备份，对于灾难恢复而言，RDB  是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。推荐，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 OSS 分布式存储上。</li>
<li>性能最大化。对于 Redis 的服务进程而言，在开始持久化时，它唯一需要做的只是 fork  出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行 IO 操作了。也就是说，RDB 对 Redis  对外提供的读写服务，影响非常小，可以让 Redis 保持高性能。</li>
<li>恢复更快。相比于 AOF 机制，RDB 的恢复速度更更快，更适合恢复数据，特别是在数据集非常大的情况。</li>
</ul>
<p>② 缺点</p>
<ul>
<li><p>如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么 RDB 将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</p>
<blockquote>
<p>所以，RDB 实际场景下，需要和 AOF 一起使用。</p>
</blockquote>
</li>
<li><p>由于 RDB 是通过 fork 子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是 1 秒钟。</p>
<blockquote>
<p>所以，RDB 建议在业务低估，例如在半夜执行。</p>
</blockquote>
</li>
</ul>
<p>🦅 <strong>AOF 优缺点</strong></p>
<p>① 优点</p>
<ul>
<li><p>该机制可以带来更高的<strong>数据安全性</strong>，即数据持久性。Redis 中提供了 3 种同步策略，即每秒同步、每修改(执行一个命令)同步和不同步。</p>
<ul>
<li>事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。</li>
<li>而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。</li>
<li>至于不同步，无需多言，我想大家都能正确的理解它。</li>
</ul>
</li>
<li><p>由于该机制对日志文件的写入操作采用的是 <strong>append</strong> 模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。</p>
<ul>
<li>因为以 append-only 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高。</li>
<li>另外，如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在 Redis 下一次启动之前，我们可以通过 redis-check-aof 工具来帮助我们解决数据一致性的问题。</li>
</ul>
</li>
<li><p>如果 AOF 日志过大，Redis 可以自动启用 <strong>rewrite</strong>  机制。即使出现后台重写操作，也不会影响客户端的读写。因为在 rewrite log  的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。再创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge  后的日志文件 ready 的时候，再交换新老日志文件即可。</p>
<blockquote>
<p>注意，AOF <strong>rewrite</strong> 机制，和 RDB 一样，也需要 fork 出一次子进程，如果 Redis 内存比较大，可能会因为 fork 阻塞下主进程。</p>
</blockquote>
</li>
<li><p>AOF 包含一个格式清晰、易于理解的日志文件用于记录所有的<strong>修改操作</strong>。事实上，我们也可以通过该文件完成数据的重建。</p>
</li>
</ul>
<p>② 缺点</p>
<ul>
<li>对于相同数量的数据集而言，AOF 文件通常要大于 RDB 文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li>
<li>根据同步策略的不同，AOF 在运行效率上往往会慢于 RDB 。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和 RDB 一样高效。</li>
<li>以前 AOF 发生过 bug ，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF  这种较为复杂的基于命令日志/merge/回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug 。不过 AOF 就是为了避免 rewrite 过程导致的 bug ，因此每次 rewrite 并不是基于旧的指令日志进行 merge  的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。</li>
</ul>
<p>🦅 <strong>如何选择</strong></p>
<ul>
<li><p>不要仅仅使用 RDB，因为那样会导致你丢失很多数据。</p>
</li>
<li><p>也不要仅仅使用 AOF，因为那样有两个问题，第一，你通过 AOF 做冷备，没有 RDB 做冷备，来的恢复速度更快; 第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug 。</p>
</li>
<li><p>Redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF  来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB  来进行快速的数据恢复。</p>
<ul>
<li>如果同时使用 RDB 和 AOF 两种持久化机制，那么在 Redis 重启的时候，会使用 <strong>AOF</strong> 来重新构建数据，因为 AOF 中的<strong>数据更加完整</strong>。</li>
</ul>
<blockquote>
<p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用 RDB 持久化。</p>
<p>有很多用户都只使用 AOF 持久化，但并不推荐这种方式：因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用 RDB 还可以避免之前提到的 AOF 程序的 bug。</p>
</blockquote>
</li>
</ul>
<p>在 Redis4.0 版本开始，允许你使用 RDB-AOF 混合持久化方式，详细可见 <a href="https://yq.aliyun.com/articles/193034">《Redis4.0 之 RDB-AOF 混合持久化》</a> 。也因此，RDB 和 AOF 同时使用，是希望达到安全的持久化的推荐方式。</p>
<hr>
<p>另外，RDB 和 AOF 涉及的知识点蛮多的，可以看看：</p>
<ul>
<li><a href="https://redisbook.readthedocs.io/en/latest/internal/rdb.html">《Redis 设计与实现 —— RDB》</a></li>
<li><a href="https://redisbook.readthedocs.io/en/latest/internal/aof.html">《Redis 设计与实现 —— AOF》</a></li>
</ul>
<p>如下是老钱对这块的总结，可能更加适合面试的场景：</p>
<ul>
<li><p>bgsave 做镜像全量持久化，AOF 做增量持久化。因为 bgsave  会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要 AOF 来配合使用。在 Redis 实例重启时，会使用 bgsave  持久化文件重新构建内存，再使用 AOF 重放近期的操作指令来实现完整恢复重启之前的状态。</p>
<blockquote>
<p>和老钱沟通了下，最后一句重启恢复，使用的是 RDB-AOF 的混合方案。</p>
</blockquote>
</li>
<li><p>对方追问那如果突然机器掉电会怎样？取决于 AOF 日志 sync 属性的配置，如果不要求性能，在每条写指令时都 sync  一下磁盘，就不会丢失数据。但是在高性能的要求下每次都 sync 是不现实的，一般都使用定时 sync ，比如 1 秒 1  次，这个时候最多就会丢失 1 秒的数据。</p>
<blockquote>
<p>实际上，极端情况下，是最多丢失 2 秒的数据。因为 AOF 线程，负责每秒执行一次 fsync 操作，操作完成后，记录最后同步时间。主线程，负责对比上次同步时间，如果超过 2 秒，阻塞等待成功。</p>
</blockquote>
</li>
<li><p>对方追问 bgsave 的原理是什么？你给出两个词汇就可以了，fork 和 cow 。fork 是指 Redis 通过创建子进程来进行  bgsave 操作。cow 指的是 copy on write  ，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p>
<blockquote>
<p>艿艿：这里 bgsave 操作后，会产生 RDB 快照文件。</p>
</blockquote>
</li>
</ul>
<p>为什么不建议在主 Redis 节点开启 RDB 功能呢？因为会带来一定时间的阻塞，特别是数据量大的时候。</p>
<blockquote>
<p>如下来自球友【jian】的回答，感恩~</p>
<ul>
<li>【重点】<strong>子进程 fork 相关的阻塞：在 bgsave 的时候，Redis 主进程会 fork  一个子进程，利用操作系统的写时复制技术，这个子进程在拷贝父进程的时候理论上是很快的，因为并不需要全拷贝，比如主进程虽然占了 10G  内存，但子进程拷贝他可能只要 200 毫秒，我认为也就阻塞了 200  毫秒(此耗时基本跟主进程占用的内存是成正比的)，这个具体的时间可以通过统计项 info stats 里的 last_fork_usec 查看。</strong></li>
<li>CPU 单线程相关的阻塞：Redis 主进程是单线程跑在单核 CPU 上的，如果显示绑定了CPU ，则子进程会与主进程共享一个 CPU  ，而子进程进行持久化的时候是非常占CPU（强势  90%），因此这种情况也可能导致提供服务的主进程发生阻塞（因此如果需要持久化功能，不建议绑定CPU）。</li>
<li>内存相关的阻塞：虽然利用写时复制技术可以大大降低进程拷贝的内存消耗，但这也导致了父进程在处理写请求时需要维护修改的内存页，因此这部分内存过大的话（修改页数多或每页占空间大）也会导致父进程的写操作阻塞。（而不巧的是，Linux中TransparentHugePage 会将复制内存页面单位有 4K 变成 2M ，这对于 Redis 来说是比较不友好的，也是建议优化的，具体可百度之）</li>
<li>磁盘相关的阻塞：极端情况下，假设整个机器的内存已经所剩无几，触发了内存交换（SWAP），则整个 Redis的效率将会非常低下（显然这不仅仅针对 save/bgsave ），因此，关注系统的 io 情况，也是定位阻塞问题的一种方法。</li>
</ul>
<p>艿艿后来又看了下这个答案，是 <a href="https://u.jd.com/lDNJa9">《Redis 开发与运维》</a> 的「5.3 持久化 —— 问题定位于优化」小节。</p>
</blockquote>
<h2 id="Redis-有几种数据“过期”策略？"><a href="#Redis-有几种数据“过期”策略？" class="headerlink" title="Redis 有几种数据“过期”策略？"></a>Redis 有几种数据“过期”策略？</h2><p>Redis 的过期策略，就是指当 Redis 中缓存的 key 过期了，Redis 如何处理。</p>
<p>Redis 提供了 3 种数据过期策略：</p>
<ul>
<li>被动删除：当读/写一个已经过期的 key 时，会触发惰性删除策略，直接删除掉这个过期 key 。</li>
<li>主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以 Redis 会定期主动淘汰一批已过期的 key 。</li>
<li>主动删除：当前已用内存超过 maxmemory 限定时，触发主动清理策略，即 <a href="http://svip.iocoder.cn/Redis/Interview/#">「数据“淘汰”策略」</a> 。</li>
</ul>
<p>在 Redis 中，同时使用了上述 3 种策略，即它们<strong>非互斥</strong>的。</p>
<p>想要进一步了解，可以看看 <a href="https://www.cnblogs.com/chenpingzhao/p/5022467.html">《关于 Redis 数据过期策略》</a> 文章。</p>
<h2 id="Redis-有哪几种数据“淘汰”策略？"><a href="#Redis-有哪几种数据“淘汰”策略？" class="headerlink" title="Redis 有哪几种数据“淘汰”策略？"></a>Redis 有哪几种数据“淘汰”策略？</h2><p>Redis 内存数据集大小上升到一定大小的时候，就会进行数据淘汰策略。</p>
<p>Redis 提供了 6 种数据淘汰策略：</p>
<ol>
<li>volatile-lru</li>
<li>volatile-ttl</li>
<li>volatile-random</li>
<li>allkeys-lru</li>
<li>allkeys-random</li>
<li>【默认策略】no-enviction</li>
</ol>
<p>具体的<strong>每种数据淘汰策略的定义</strong>，和<strong>如何选择讨论策略</strong>，可见 <a href="http://blog.720ui.com/2016/redis_action_02_maxmemory_policy/">《Redis实战（二） 内存淘汰机制》</a> 。</p>
<p>在 Redis 4.0 后，基于 LFU（Least Frequently Used）最近最少使用算法，增加了 2 种淘汰策略：</p>
<ol>
<li>volatile-lfu</li>
<li>allkeys-lfu</li>
</ol>
<p>🦅 <strong>Redis LRU 算法</strong></p>
<p>另外，Redis 的 LRU 算法，<strong>并不是一个严格的 LRU 实现</strong>。这意味着 Redis 不能选择最佳候选键来回收，也就是最久未被访问的那些键。相反，Redis 会尝试执行一个近似的 LRU 算法，通过采样一小部分键，然后在采样键中回收最适合(拥有最久未被访问时间)的那个。</p>
<p><strong>Redis 没有使用真正实现严格的 LRU 算是的原因是，因为消耗更多的内存。然而对于使用 Redis 的应用来说，使用近似的 LRU 算法，事实上是等价的。</strong></p>
<p>具体的可以看看如下文章：</p>
<ul>
<li><a href="http://www.iocoder.cn/Fight/Cannot-think-of-The-interviewer-asked-me-what-if-Redis-runs-out-of-memory/?self">《想不到！面试官问我：Redis 内存满了怎么办？》</a></li>
<li><a href="http://ifeve.com/lru-cache/">《使用 Redis 作为一个 LRU 缓存》</a></li>
</ul>
<p>🦅 <strong>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据？</strong></p>
<blockquote>
<p>艿艿：这个是从网络上找到的一个神奇的问题，并且看了答案之后，觉得有点莫名的对不上。</p>
<p>所以，感觉这个问题的目的是，如何保证热点数据不要被淘汰。</p>
</blockquote>
<p>在 <a href="http://svip.iocoder.cn/Redis/Interview/#">「Redis 有哪几种数据“淘汰”策略？」</a> 问题中，我们已经看到，“Redis 内存数据集大小上升到一定 maxmemory 的时候，就会进行数据淘汰策略。” 。</p>
<p>那么，如果我们此时要保证热点数据不被淘汰，那么需要选择 volatile-lru 或  allkeys-lru 这两个基于 LRU 算法的淘汰策略。</p>
<p>相比较来说，最终会选择 allkeys-lru  淘汰策略。原因是，如果我们的应用对缓存的访问符合幂律分布，也就是存在相对热点数据，或者我们不太清楚我们应用的缓存访问分布状况，我们可以选择  allkeys-lru 策略。如果在 Redis 4.0 版本，可以考虑使用 volatile-lfu  ，更加符合“热”的概念，频率越高，代表越热。</p>
<p>🦅 <strong>Redis 回收进程如何工作的？</strong></p>
<p>理解回收进程如何工作是非常重要的：</p>
<ul>
<li>一个客户端运行了新的写命令，添加了新的数据。</li>
<li>Redis 检查内存使用情况，如果大于 maxmemory 的限制, 则根据设定好的策略进行回收。</li>
<li>Redis 执行新命令。</li>
</ul>
<p>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下（跌宕起伏）。</p>
<h2 id="如果有大量的-key-需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的-key-需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的 key 需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</h2><p>如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，Redis可能会出现短暂的卡顿现象。</p>
<p>一般需要在时间上加一个随机值，使得过期时间分散一些。</p>
<hr>
<p>上次基友也碰到这个问题，请教了下，他的方案是调大 hz 参数，每次过期的 key 更多，从而最终达到避免一次过期过多。</p>
<blockquote>
<p>这个定期的频率，由配置文件中的 hz 参数决定，代表了一秒钟内，后台任务期望被调用的次数。Redis 3.0.0 中的默认值是 10 ，代表每秒钟调用 10 次后台任务。</p>
<p>hz 调大将会提高 Redis 主动淘汰的频率，如果你的 Redis 存储中包含很多冷数据占用内存过大的话，可以考虑将这个值调大，但  Redis 作者建议这个值不要超过 100 。我们实际线上将这个值调大到 100 ，观察到 CPU 会增加 2%  左右，但对冷数据的内存释放速度确实有明显的提高（通过观察 keyspace 个数和 used_memory 大小）。</p>
</blockquote>
<h2 id="Redis-有哪些数据结构？"><a href="#Redis-有哪些数据结构？" class="headerlink" title="Redis 有哪些数据结构？"></a>Redis 有哪些数据结构？</h2><p>如果你是 Redis 普通玩家，可能你的回答是如下五种数据结构：</p>
<ul>
<li>字符串 String</li>
<li>字典Hash</li>
<li>列表List</li>
<li>集合Set</li>
<li>有序集合 SortedSet</li>
</ul>
<p>如果你是 Redis 中级玩家，还需要加上下面几种数据结构：</p>
<ul>
<li>HyperLogLog</li>
<li>Geo</li>
<li>Bitmap</li>
</ul>
<p>如果你是 Redis 高端玩家，你可能玩过 Redis Module ，可以再加上下面几种数据结构：</p>
<ul>
<li>BloomFilter</li>
<li>RedisSearch</li>
<li>Redis-ML</li>
<li>JSON</li>
</ul>
<p>另外，在 Redis 5.0 增加了 Stream 功能，一个新的强大的支持多播的可持久化的消息队列，提供类似 Kafka 的功能。😈 默默跟面试官在装一波。</p>
<h2 id="聊聊-Redis-使用场景"><a href="#聊聊-Redis-使用场景" class="headerlink" title="聊聊 Redis 使用场景"></a>聊聊 Redis 使用场景</h2><p>Redis 可用的场景非常之多：</p>
<ul>
<li>数据缓存</li>
<li>会话缓存</li>
<li>时效性数据</li>
<li>访问频率</li>
<li>计数器</li>
<li>社交列表</li>
<li>记录用户判定信息</li>
<li>交集、并集和差集</li>
<li>热门列表与排行榜</li>
<li>最新动态</li>
<li>消息队列</li>
<li>分布式锁</li>
</ul>
<p>详细的介绍，可以看看如下文章：</p>
<ul>
<li><a href="http://blog.720ui.com/2017/redis_core_use/">《聊聊 Redis 使用场景》</a></li>
<li><a href="https://www.jianshu.com/p/af277c77b1c9">《Redis 应用场景及实例》</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/29665317">《Redis 常见的应用场景解析》</a></li>
<li><a href="https://www.zhihu.com/question/19829601">《Redis 和 Memcached 各有什么优缺点，主要的应用场景是什么样的？》</a></li>
</ul>
<h2 id="Redis-支持的-Java-客户端都有哪些？"><a href="#Redis-支持的-Java-客户端都有哪些？" class="headerlink" title="Redis 支持的 Java 客户端都有哪些？"></a>Redis 支持的 Java 客户端都有哪些？</h2><p>使用比较广泛的有三个 Java 客户端：</p>
<ul>
<li><p>Redisson</p>
<blockquote>
<p>Redisson ，是一个高级的分布式协调 Redis 客服端，能帮助用户在分布式环境中轻松实现一些 Java 的对象 (Bloom  filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map,  ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque,  BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong,  CountDownLatch, Publish / Subscribe, HyperLogLog)。</p>
</blockquote>
</li>
<li><p>Jedis</p>
<blockquote>
<p>Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持。</p>
<p>Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，Jedis 功能较为简单。</p>
<p>Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
</blockquote>
</li>
<li><p>Lettuce</p>
<blockquote>
<p>Lettuce 是一个可伸缩线程安全的 Redis 客户端。多个线程可以共享同一个 RedisConnection 。它利用优秀 Netty NIO 框架来高效地管理多个连接。</p>
</blockquote>
</li>
</ul>
<p>Redis 官方推荐使用 Redisson 或 Jedis 。</p>
<p>Spring Boot 2.x 内置支持 Jedis 和 Lettuce 。一般情况下，建议：</p>
<ul>
<li>使用 Spring Data Redis ，提供了透明使用 Jedis 和 Lettuce  的封装。也就是说，大多数时候，我们可以通过配置使用 Jedis 或 Lettuce 进行 Redis 的操作，而上层使用 Spring Data Redis 提供的统一 API 。</li>
<li>从目前来说，Jedis 会比 Lettuce 更加流行，并且更加稳定。虽然说 Jedis 有一段时间，不再进行更新，但是突然又开始更新，可能是诈尸了。</li>
<li>如果想要更加丰富的特性，例如说分布式锁，布隆过滤器，可以考虑研究下 Redisson 。</li>
</ul>
<h2 id="如何使用-Redis-实现分布式锁？"><a href="#如何使用-Redis-实现分布式锁？" class="headerlink" title="如何使用 Redis 实现分布式锁？"></a>如何使用 Redis 实现分布式锁？</h2><p>Redis 实现分布式锁，需要考虑如下几个方面：</p>
<ul>
<li><p>1、正确的获得锁</p>
<blockquote>
<p>set 指令附带 nx 参数，保证有且只有一个进程获得到。</p>
</blockquote>
</li>
<li><p>2、正确的释放锁</p>
<blockquote>
<p>使用 Lua 脚本，比对锁持有的是不是自己。如果是，则进行删除来释放。</p>
</blockquote>
</li>
<li><p>3、超时的自动释放锁</p>
<blockquote>
<p>set 指令附带 expire 参数，通过过期机制来实现超时释放。</p>
</blockquote>
</li>
<li><p>4、未获得到锁的等待机制</p>
<blockquote>
<p>sleep 或者基于 Redis 的订阅 Pub/Sub 机制。</p>
<p>一些业务场景，可能需要支持获得不到锁，直接返回 false ，不等待。</p>
</blockquote>
</li>
<li><p>5、【可选】锁的重入性</p>
<blockquote>
<p>通过 ThreadLocal<Integer> 记录是第几次获得相同的锁。</p>
<p>1）有且第一次计数为 1 &amp;&amp; 获得锁时，才向 Redis 发起获得锁的操作。 2）有且计数为 0 &amp;&amp; 释放锁时，才向 Redis 发起释放锁的操作。</p>
</blockquote>
</li>
<li><p>6、锁超时的处理</p>
<blockquote>
<p>一般情况下，可以考虑告警 + 后台线程自动续锁的超时时间。通过这样的机制，保证有且仅有一个线程，正在持有锁。</p>
</blockquote>
</li>
<li><p>7、Redis 分布式锁丢失问题</p>
<blockquote>
<p>具体看「方案二：Redlock」。</p>
</blockquote>
</li>
</ul>
<p>下面，我们来详细说下每个方案。</p>
<p>🦅 <strong>方案一：set 指令</strong></p>
<p>先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。</p>
<ul>
<li>这时候对方会告诉你说你回答得不错，然后接着问如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，那会怎么样？</li>
<li>这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得 set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和 expire  合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。</li>
</ul>
<p>所以，我们可以使用 <strong>set</strong> 指令，实现分布式锁。指令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">SET key value [EX seconds] [PX milliseconds] [NX|XX]<br></code></pre></td></tr></table></figure>



<ul>
<li>可以使用 <code>SET key value EX seconds NX</code> 命令，尝试获得锁。</li>
<li>具体的实现，可以参考如下文章：<ul>
<li><a href="http://svip.iocoder.cn/Redisson/ReentrantLock/?self">《精尽 Redisson 源码分析 —— 可重入分布式锁 ReentrantLock》</a></li>
<li><a href="http://www.iocoder.cn/Fight/redisfen-bu-shi-suo-jin-hua-shi/?self">《Redis 分布式锁进化史解读 + 缺陷分析》</a></li>
<li><a href="http://www.iocoder.cn/Fight/Correct-implementation-of-Redis-distributed-locks-by-Java/?self">《Redis 分布式锁的正确实现方式（Java 版）》</a></li>
</ul>
</li>
</ul>
<p>🦅 <strong>方案二：Redlock</strong></p>
<p>set 指令的方案，适合用于在单机 Redis 节点的场景下，在多 Redis 节点的场景下，会存在分布式锁丢失的问题。所以，Redis 作者 Antirez 基于分布式环境下提出了一种更高级的分布式锁的实现方式：Redlock 。</p>
<p>具体的源码解析，可以看看 <a href="http://svip.iocoder.cn/Redisson/RedLock/?self">《精尽 Redisson 源码分析 —— 可靠分布式锁 RedLock》</a> 文章。</p>
<p>具体的方案，胖友可以看看老友飞哥的两篇博客：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/JLEzNqQsx-Lec03eAsXFOQ">《Redlock：Redis分布式锁最牛逼的实现》</a></li>
<li><a href="https://www.jianshu.com/p/f302aa345ca8">《Redisson 实现 Redis 分布式锁的 N 种姿势》</a></li>
</ul>
<p>最近艿艿画了一个 Redisson 实现分布式锁的流程图，胖友可以点击<a href="https://www.processon.com/view/link/5f4c871d079129356ec6f4d7">传送门</a>阅读。</p>
<p>🦅 <strong>对比 Zookeeper 分布式锁</strong></p>
<ul>
<li>从可靠性上来说，Zookeeper 分布式锁好于 Redis 分布式锁。</li>
<li>从性能上来说，Redis 分布式锁好于 Zookeeper 分布式锁。</li>
</ul>
<p>所以，没有绝对的好坏，可以根据自己的业务来具体选择。如果想要更简单，甚至可以考虑基于 MySQL 行锁来实现分布式锁。</p>
<h2 id="如何使用-Redis-实现分布式限流？"><a href="#如何使用-Redis-实现分布式限流？" class="headerlink" title="如何使用 Redis 实现分布式限流？"></a>如何使用 Redis 实现分布式限流？</h2><p>在 Spring Cloud Gateway 中，提供了 Redis 分布式限流器的实现，具体直接看艿艿写的 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-request-rate-limiter/">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.10) 之 RequestRateLimiterGatewayFilterFactory 请求限流》</a> 的 <a href="http://svip.iocoder.cn/Redis/Interview/#">「5.3 Redis Lua 脚本」</a> 部分。</p>
<p>另外，Redisson 库中，也提供了 Redis 分布式限流的实现，不过需要使用 Pro 版本。</p>
<p>🦅 <strong>请用 Redis 和任意语言实现一段恶意登录保护的代码，限制 1 小时内每用户 Id 最多只能登录 5 次。</strong></p>
<p>这个问题，关键点，就是每个用户，每 3600 秒，只能登陆 5 次。这么一想，其实就是一个如何使用 Redis 实现限流的问题。Redis 实现限流，一共有两种方案：</p>
<ul>
<li><p>使用 zset 实现滑动窗口限流。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public boolean isActionAllowed(String userId, String actionKey, int period,<br>    int maxCount) &#123;<br>    String key &#x3D; String.format(&quot;hist:%s:%s&quot;, userId, actionKey); &#x2F;&#x2F; 使用用户编号 + 行为作为 KEY 。这样，我们就可以统计某个用户的操作行为。<br>    long nowTs &#x3D; System.currentTimeMillis(); &#x2F;&#x2F; 获取当前时间。<br>    Pipeline pipe &#x3D; jedis.pipelined(); &#x2F;&#x2F; pipeline 批量操作，提升效率。<br>    pipe.multi(); &#x2F;&#x2F; 此处启动了事务，可以保证指令的原子性。<br>    pipe.zadd(key, nowTs, &quot;&quot; + nowTs); &#x2F;&#x2F; zset 添加，key value score 要看下。<br>    pipe.zremrangeByScore(key, 0, nowTs - (period * 1000)); &#x2F;&#x2F; zremrangeByScore ，移除超过周期的 value 。<br><br>    Response&lt;Long&gt; count &#x3D; pipe.zcard(key); &#x2F;&#x2F; zcard ，计算 zset 的数量<br>    pipe.expire(key, period + 1); &#x2F;&#x2F; 设置过期。这里多 + 1 秒，为了防止网络延迟。<br>    pipe.exec(); &#x2F;&#x2F; pipeline 执行<br>    pipe.close();<br><br>    return count.get() &lt;&#x3D; maxCount; &#x2F;&#x2F; 是否超过最大次数。<br>&#125;<br></code></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>该实现会存在一个问题，可能一个无效的操作，也被记录到次数中。完美的话，可能需要基于 Lua 脚本实现。</li>
<li>另外，上述代码是每秒操作的时间，实际需要改成每 N 秒。比较简单，直接上手怼即可。</li>
</ul>
<ul>
<li><p>使用 Lua 脚本，实现令牌桶限流算法。具体可以看看艿艿对 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-request-rate-limiter/?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.10) 之 RequestRateLimiterGatewayFilterFactory 请求限流》</a> 的源码解析。</p>
</li>
<li><p>使用 Lua 脚本，实现简单的滑动窗口。具体可以看看艿艿对 <a href="http://svip.iocoder.cn/Redisson/RateLimiter/?self">《精尽 Redisson 源码分析 —— 限流器 RateLimiter》</a> 的源码解析。</p>
</li>
</ul>
<h2 id="如何使用-Redis-实现消息队列？"><a href="#如何使用-Redis-实现消息队列？" class="headerlink" title="如何使用 Redis 实现消息队列？"></a>如何使用 Redis 实现消息队列？</h2><p>一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。</p>
<ul>
<li><p>如果对方追问可不可以不用 sleep 呢？list 还有个指令叫 blpop ，在没有消息的时候，它会阻塞住直到消息到来。</p>
</li>
<li><p>如果对方追问能不能生产一次消费多次呢？使用 pub / sub 主题订阅者模式，可以实现 1:N 的消息队列。</p>
</li>
<li><p>如果对方追问 pub / sub 有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 rabbitmq 等。</p>
<blockquote>
<p>之前生产中，艿艿就碰到因为网络闪断，导致订阅的 pub/sub 消息丢失，导致 JVM 应用的数据字典和系统参数等缓存未刷新，业务受到影响。所以，最好还是使用专业的消息队列的订阅功能（广播消费）。</p>
</blockquote>
</li>
<li><p>如果对方追问 redis  如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用  sortedset ，拿时间戳作为 score ，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore  指令获取 N 秒之前的数据轮询进行处理。</p>
<blockquote>
<p>可能很多胖友会觉得抽象，可以看看 <a href="https://cloud.tencent.com/developer/article/1401122">《Redis 学习笔记之延时队列》</a> 。面试中，能回答到 Redis zset 实现延迟队列，还是蛮加分的。</p>
</blockquote>
</li>
</ul>
<p>到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。</p>
<p>当然，实际上 Redis 真的真的真的不推荐作为消息队列使用，它最多只是消息队列的存储层，上层的逻辑，还需要做大量的封装和支持。</p>
<p>另外，在 Redis 5.0 增加了 Stream 功能，一个新的强大的支持多播的可持久化的消息队列，提供类似 Kafka 的功能。</p>
<h2 id="什么是-Redis-Pipelining-？"><a href="#什么是-Redis-Pipelining-？" class="headerlink" title="什么是 Redis Pipelining ？"></a>什么是 Redis Pipelining ？</h2><p>一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。</p>
<blockquote>
<p>注意，Redis Pipelining 是 Redis Client 实现的功能，而不是 Redis Server 提供的特性。假设我们有 3 个请求进行下举例子。</p>
<ul>
<li>未使用 Pipeline 时，那么整个执行的顺序是，req1-&gt;resp1-&gt;req2-&gt;resp2-&gt;req3-&gt;resp3 。</li>
<li>在使用 Pipeline 时，那么整个执行的顺序是，[req1,req2,req3] 一起发给 Redis Server ，而  Redis Server 收到请求后，一个一个请求进行执行，然后响应，不会进行什么特殊处理。而 Client 在收到  resp1,resp2,resp3 后，进行响应给业务上层。</li>
</ul>
<p>所以，Pipeline 的作用，是避免每发一个请求，就阻塞等待这个请求的结果。</p>
</blockquote>
<p>这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。</p>
<p>Redis 很早就支持管道（<a href="http://redis.cn/topics/pipelining.html">pipelining</a>）技术，因此无论你运行的是什么版本，你都可以使用管道（pipelining）操作 Redis。</p>
<p>🦅 <strong>Redis 如何做大量数据插入？</strong></p>
<p>Redis 2.6 开始，Redis-cli 支持一种新的被称之为 pipe mode 的新模式用于执行大量数据插入工作。</p>
<p>具体可见 <a href="http://www.redis.cn/topics/mass-insert.html">《Redis 大量数据插入》</a> 文章。</p>
<h2 id="什么是-Redis-事务？"><a href="#什么是-Redis-事务？" class="headerlink" title="什么是 Redis 事务？"></a>什么是 Redis 事务？</h2><p>和众多其它数据库一样，Redis 作为 NoSQL 数据库也同样提供了事务机制。在 Redis 中，MULTI / EXEC /  DISCARD / WATCH  这四个命令是我们实现事务的基石。相信对有关系型数据库开发经验的开发者而言这一概念并不陌生，即便如此，我们还是会简要的列出 Redis  中事务的实现特征：</p>
<ul>
<li><p>1、在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis 不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行。</p>
<blockquote>
<p>Lua 脚本，也能实现该功能。</p>
</blockquote>
</li>
<li><p>2、和关系型数据库中的事务相比，在 Redis 事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行。</p>
<blockquote>
<p>这一点，非常重要。回答错了，就回家面壁思过，一天不许喝可乐。</p>
<p>这一点，是 Lua 脚本不具备的。</p>
</blockquote>
</li>
<li><p>3、我们可以通过 MULTI 命令开启一个事务，有关系型数据库开发经验的人可以将其理解为 <code>&quot;BEGIN TRANSACTION&quot;</code> 语句。在该语句之后执行的命令，都将被视为事务之内的操作，最后我们可以通过执行 EXEC / DISCARD 命令来提交 / 回滚该事务内的所有操作。这两个 Redis 命令，可被视为等同于关系型数据库中的 COMMIT / ROLLBACK 语句。</p>
<blockquote>
<p>开启事务后，所有语句，发送给 Redis Server ，都会暂存在 Server 中。</p>
</blockquote>
</li>
<li><p>4、在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行 EXEC 命令之后，那么该事务中的所有命令都会被服务器执行。</p>
</li>
</ul>
<p>🦅 <strong>如何实现 Redis CAS 操作？</strong></p>
<p>在 Redis 的事务中，WATCH 命令可用于提供 CAS(check-and-set) 功能。</p>
<p>假设我们通过 WATCH 命令在事务执行之前监控了多个 keys ，倘若在 WATCH 之后有任何 Key 的值发生了变化，EXEC 命令执行的事务都将被放弃，同时返回 <code>nil</code> 应答以通知调用者事务执行失败。</p>
<p>具体的示例，可以看看 <a href="https://www.jianshu.com/p/0244a875aa26">《Redis 事务锁 CAS 实现以及深入误区》</a> 。</p>
<h2 id="Redis-集群都有哪些方案？"><a href="#Redis-集群都有哪些方案？" class="headerlink" title="Redis 集群都有哪些方案？"></a>Redis 集群都有哪些方案？</h2><p>Redis 集群方案如下：</p>
<ul>
<li>1、Redis Sentinel</li>
<li>2、Redis Cluster</li>
<li>3、Twemproxy</li>
<li>4、Codis</li>
<li>5、客户端分片</li>
</ul>
<p>关于前四种，可以看看 <a href="http://blog.720ui.com/2016/redis_action_04_cluster/">《Redis 实战（四）集群机制》</a> 这篇文章。</p>
<p>关于最后一种，客户端分片，在 Redis Cluster 出现之前使用较多，目前已经使用比较少了。实现方式如下：</p>
<blockquote>
<p>在业务代码层实现，起几个毫无关联的 Redis 实例，在代码层，对 Key 进行 hash 计算，然后去对应的 Redis 实例操作数据。</p>
<p>这种方式对 hash 层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。</p>
</blockquote>
<p>🦅 <strong>选择</strong></p>
<p>目前一般在选型上来说：</p>
<ul>
<li><p>体量较小时，选择 Redis Sentinel ，单主 Redis 足以支撑业务。</p>
</li>
<li><p>体量较大时，选择 Redis Cluster ，通过分片，使用更多内存。</p>
<blockquote>
<p>关于这个问题，多大体量需要使用 Redis Cluster 呢？朋友的建议是 10G+ 的时候。主要原因是：</p>
<ul>
<li>1、一次 RDB 时间随着内存越大，会变大越来越久。同时，一次 fork 的时间也会变久。还有，重启通过 RDB 文件，或者 AOF 日志，恢复时间都会变长。</li>
<li>2、体量大之后，读写的 QPS 势必比体量小的时候打的多，那么使用 Redis Cluster 相比 Redis Sentinel ，可以分散读写压力到不同的集群中。</li>
</ul>
</blockquote>
</li>
</ul>
<p>🦅 <strong>Redis 集群如何扩容？</strong></p>
<ul>
<li><p>如果 Redis 被当做<strong>缓存</strong>使用，使用一致性哈希实现动态扩容缩容。</p>
<blockquote>
<p>删除的原因是，不考虑客户端分片的情况，目前基本已经不在用了。</p>
</blockquote>
</li>
<li><p>如果 Redis 被当做一个<strong>持久化存</strong>储使用，必须使用固定的 keys-to-nodes 映射关系，节点的数量一旦确定不能变化。否则的话(即 Redis 节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有 Redis Cluster、Codis 可以做到这样。</p>
</li>
</ul>
<p>如果是 Redis Cluster 集群的扩容，可以看看 <a href="https://u.jd.com/lDNJa9">《Redis 开发与运维》</a> 的「10.4 集群 —— 集群伸缩」小节。简单来说，一共三步：</p>
<ul>
<li>1、准备新节点。</li>
<li>2、加入集群。</li>
<li>3、迁移槽和数据。</li>
</ul>
<h2 id="什么是-Redis-主从同步？"><a href="#什么是-Redis-主从同步？" class="headerlink" title="什么是 Redis 主从同步？"></a>什么是 Redis 主从同步？</h2><p><strong>Redis 主从同步</strong></p>
<p>Redis 的主从同步(replication)机制，允许 Slave 从 Master 那里，通过网络传输拷贝到完整的数据备份，从而达到主从机制。</p>
<ul>
<li>主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据。</li>
<li>一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。</li>
<li>第一次同步时，主节点做一次 bgsave 操作，并同时将后续修改操作记录到内存 buffer ，待完成后将 RDB  文件全量同步到复制节点，复制节点接受完成后将 RDB  镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</li>
</ul>
<p><strong>好处</strong></p>
<p>通过 Redis 的复制功，能可以很好的实现数据库的读写分离，提高服务器的负载能力。主数据库主要进行写操作，而从数据库负责读操作。</p>
<blockquote>
<p>实际上，我们不是非常推荐在 Redis 中，使用读写分离。主要有两个原因：</p>
<ul>
<li>Redis Sentinel 只保证主节点的故障的失效转移，而例如说 Jedis  库，也只监听了主节点的变化，但是从节点故障的情况，Jedis 是不进行处理的。这就会导致，Jedis  读会访问到从节点，导致问题。当然，Redisson 库的功能比较强大，已经支持从节点的故障监听。</li>
<li>如果到达需要读写分离的体量，一般写操作也不一定会少，可以考虑上 Redis Cluster 方案，更加可靠。</li>
</ul>
</blockquote>
<hr>
<p>Redis 主从同步，是很多 Redis 集群方案的基础，例如 Redis Sentinel、Redis Cluster 等等。</p>
<p>更多详细，可以看看如下：</p>
<blockquote>
<p>因为主从复制的内容很多，艿艿这里就不详细哔哔了。实际场景下，对于开发的面试，我们也不会特别问，毕竟更偏运维的内容。</p>
</blockquote>
<ul>
<li><a href="http://redis.cn/topics/replication.html">《Redis 官方文档 —— 复制》</a></li>
<li><a href="https://u.jd.com/lDNJa9">《Redis 开发与运维》</a> 的「6. 复制」章节，更加详细完整。</li>
</ul>
<!--[《Redis 主从架构》](https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-master-slave.md) 。-->

<h2 id="如何使用-Redis-Sentinel-实现高可用？"><a href="#如何使用-Redis-Sentinel-实现高可用？" class="headerlink" title="如何使用 Redis Sentinel 实现高可用？"></a>如何使用 Redis Sentinel 实现高可用？</h2><p>详细，可以看看如下：</p>
<blockquote>
<p>因为 Redis Sentinel 的内容很多，艿艿这里就不详细哔哔了。实际场景下，对于开发的面试，我们也不会特别问，毕竟更偏运维的内容。</p>
</blockquote>
<ul>
<li><a href="http://redis.cn/topics/sentinel.html">《Redis 官方文档 —— Sentinel 高可用》</a></li>
<li><a href="https://u.jd.com/lDNJa9">《Redis 开发与运维》</a> 的「9. 哨兵」章节，更加详细完整。</li>
</ul>
<!--[《Redis 哨兵集群实现高可用》](https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-sentinel.md) 。-->

<h2 id="如果使用-Redis-Cluster-实现高可用？"><a href="#如果使用-Redis-Cluster-实现高可用？" class="headerlink" title="如果使用 Redis Cluster 实现高可用？"></a>如果使用 Redis Cluster 实现高可用？</h2><p>详细，可以看看如下：</p>
<blockquote>
<p>因为 Redis Sentinel 的内容很多，艿艿这里就不详细哔哔了。实际场景下，对于开发的面试，我们也不会特别问，毕竟更偏运维的内容。</p>
</blockquote>
<ul>
<li><a href="http://redis.cn/topics/cluster-tutorial.html">《Redis 官方文档 —— Redis Cluster 集群》</a></li>
<li><a href="https://u.jd.com/lDNJa9">《Redis 开发与运维》</a> 的「10. 集群」章节，更加详细完整。</li>
</ul>
<!--[《Redis 集群模式的工作原理能说一下么？》](https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-cluster.md) 精简版-->

<p>🦅 <strong>说说 Redis 哈希槽的概念？</strong></p>
<p>Redis Cluster 没有使用一致性 hash ，而是引入了哈希槽的概念。</p>
<p>Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。</p>
<p>因为最大是 16384 个哈希槽，所以考虑 Redis 集群中的每个节点都能分配到一个哈希槽，所以最多支持 16384 个 Redis 节点。</p>
<p>为什么是 16384 呢？主要考虑集群内的网络带宽，而 16384 刚好是 2K 字节大小。</p>
<p>🦅 <strong>Redis Cluster 的主从复制模型是怎样的？</strong></p>
<p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了<strong>主从复制</strong>模型，每个节点都会有 N-1 个复制节点。</p>
<p>所以，Redis Cluster 可以说是 Redis Sentinel 带分片的加强版。也可以说：</p>
<ul>
<li>Redis Sentinel 着眼于高可用，在 master 宕机时会自动将 slave 提升为 master ，继续提供服务。</li>
<li>Redis Cluster 着眼于扩展性，在单个 Redis 内存不足时，使用 Cluster 进行分片存储。</li>
</ul>
<p>🦅 <strong>Redis Cluster 方案什么情况下会导致整个集群不可用？</strong></p>
<p>有 A，B，C 三个节点的集群，在没有复制模型的情况下，如果节点 B 宕机了，那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用。当然，这种情况也可以配置 <code>cluster-require-full-coverage=no</code> ，整个集群无需所有槽位覆盖。</p>
<p>🦅 <strong>Redis Cluster 会有写操作丢失吗？为什么？</strong></p>
<p>Redis 并不能保证数据的强一致性，而是【异步复制】，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p>
<blockquote>
<p>艿艿：一定一定一定要注意，无论对于 Redis Sentinel 还是 Redis Cluster 方案，都是通过主从复制，所以在数据的复制方面，都存在相同的情况。</p>
</blockquote>
<p>🦅 <strong>Redis 集群如何选择数据库？</strong></p>
<p>Redis 集群目前无法做数据库选择，默认在 0 数据库。</p>
<p>🦅 <strong>请说说生产环境中的 Redis 是怎么部署的？</strong></p>
<blockquote>
<p>重点问题，仔细理解。</p>
</blockquote>
<ul>
<li><p>Redis Cluster ，10 台机器，5 台机器部署了 Redis 主实例，另外 5 台机器部署了 Redis  的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰 qps 可能可以达到每秒 5 万，5 台机器最多是 25  万读写请求每秒。</p>
</li>
<li><p>机器是什么配置？32G 内存 + 8 核 CPU + 1T 磁盘，但是分配给 Redis 进程的是 10G 内存，一般线上生产环境，Redis 的内存尽量不要超过 10G，超过 10G 可能会有问题。那么，5 台机器对外提供读写，一共有 50G 内存。</p>
</li>
<li><p>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，Redis 从实例会自动变成主实例继续提供读写服务。</p>
</li>
<li><p>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb 。100 条数据是 1mb ，10 万条数据是 1G  。常驻内存的是 200 万条商品数据，占用内存是 20G ，仅仅不到总内存的 50% 。目前高峰期每秒就是 3500 左右的请求量。</p>
<blockquote>
<p>一般来说，当公司体量大了之后，建议是一个业务线独占一个或多个 Redis Cluster 集群，实现好业务线与业务线之间的隔离。</p>
</blockquote>
</li>
<li><p>其实大型的公司，会有基础架构的 Team 负责缓存集群的运维。</p>
</li>
</ul>
<h2 id="什么是-Redis-分区？"><a href="#什么是-Redis-分区？" class="headerlink" title="什么是 Redis 分区？"></a>什么是 Redis 分区？</h2><blockquote>
<p>这个问题，和 <a href="http://svip.iocoder.cn/Redis/Interview/#">「Redis 集群都有哪些方案？」</a> 是同类问题。</p>
<p>简单看看即可，重点还是去理解 Redis Cluster 集群方案。</p>
</blockquote>
<p>🦅 关于如下四个问题，直接看 <a href="http://www.runoob.com/redis/redis-partitioning.html">《Redis 分区》</a> 文章。</p>
<ul>
<li>Redis 分区是什么？</li>
<li>分区的优势？</li>
<li>分区的不足？</li>
<li>分区类型？</li>
</ul>
<p>可能有胖友会懵逼，又是 Redis 主从复制，又是 Redis 分区，又是 Redis 集群。傻傻分不清啊！</p>
<ul>
<li><p>Redis 分区是一种模式，将数据分区到不同的 Redis 节点上，而 Redis 集群的 Redis Cluster、Twemproxy、Codis、客户端分片( 不包括 Redis Sentinel ) 这四种方案，是 Redis 分区的具体实现。</p>
<blockquote>
<p>注意，Redis Sentinel 实现的是 Redis 的高可用，一定要分清楚。实际上，胖友可以对比 MySQL 和 MongoDB 的高可用、集群的方案，发现思路都是一致的。</p>
</blockquote>
</li>
<li><p>Redis 每个分区，如果想要实现高可用，需要使用到 Redis 主从复制。</p>
</li>
</ul>
<p>🦅 <strong>你知道有哪些 Redis 分区实现方案</strong>？</p>
<p>Redis 分区方案，主要分成两种类型：</p>
<ul>
<li>客户端分区，就是在客户端就已经决定数据会被存储到哪个 Redis 节点或者从哪个 Redis 节点读取。大多数客户端已经实现了客户端分区。<ul>
<li>案例：Redis Cluster 和客户端分区。</li>
</ul>
</li>
<li>代理分区，意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些 Redis 实例，然后根据 Redis 的响应结果返回给客户端。<ul>
<li>案例：Twemproxy 和 Codis 。</li>
</ul>
</li>
</ul>
<p>查询路由(Query routing)的意思，是客户端随机地请求任意一个 Redis 实例，然后由 Redis 将请求转发给正确的  Redis 节点。Redis Cluster 实现了一种混合形式的查询路由，但并不是直接将请求从一个Redis 节点转发到另一个 Redis  节点，而是在客户端的帮助下直接 Redirect 到正确的 Redis 节点。</p>
<blockquote>
<p>Redis Cluster 的重定向，可以认真看看 <a href="https://u.jd.com/lDNJa9">《Redis 开发与运维》</a> 的「10.5 集群 - 请求路由」章节。</p>
</blockquote>
<p>🦅 <strong>分布式 Redis 是前期做还是后期规模上来了再做好？为什么？？</strong></p>
<p>如下是网络上的一个答案：</p>
<blockquote>
<p>既然 Redis 是如此的轻量，为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让 Redis 以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p>
<p>一开始就多设置几个 Redis 实例，例如 32 或者 64 个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</p>
<p>这样的话，当你的数据不断增长，需要更多的 Redis 服务器时，你需要做的就是仅仅将 Redis 实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的 Redis 实例从第一台机器迁移到第二台机器。</p>
</blockquote>
<ul>
<li>和飞哥沟通了下，这个操作不是很合理。</li>
<li>无论怎么说，建议，需要搭建下 Redis Sentinel 高可用，至于拓展性，根据自己的情况，是否使用 Redis Cluster  集群。同时， Redis Cluster 集群会有运维的复杂性，同时会存在跨分片操作（例如说 mget 等等）、事务等操作是不支持的。</li>
</ul>
<h2 id="Redis-有哪些重要的健康指标？"><a href="#Redis-有哪些重要的健康指标？" class="headerlink" title="Redis 有哪些重要的健康指标？"></a>Redis 有哪些重要的健康指标？</h2><p>推荐阅读 <a href="https://mp.weixin.qq.com/s/D_khsApGkRckEoV75pYpDA">《Redis 几个重要的健康指标》</a></p>
<ul>
<li>存活情况</li>
<li>连接数</li>
<li>阻塞客户端数量</li>
<li>使用内存峰值</li>
<li>内存碎片率</li>
<li>缓存命中率</li>
<li>OPS</li>
<li>持久化</li>
<li>失效KEY</li>
<li>慢日志</li>
</ul>
<p><strong>如何提高 Redis 命中率？</strong></p>
<p>推荐阅读 <a href="http://www.cnblogs.com/shamo89/p/8383915.html">《如何提高缓存命中率（Redis）》</a> 。</p>
<h2 id="怎么优化-Redis-的内存占用？"><a href="#怎么优化-Redis-的内存占用？" class="headerlink" title="怎么优化 Redis 的内存占用？"></a>怎么优化 Redis 的内存占用？</h2><p>推荐阅读 <a href="https://www.jianshu.com/p/8677603d3865">《Redis 的内存优化》</a></p>
<ul>
<li>redisObject 对象</li>
<li>缩减键值对象</li>
<li>共享对象池</li>
<li>字符串优化</li>
<li>编码优化</li>
<li>控制 key 的数量</li>
</ul>
<p>🦅 <strong>一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素？</strong></p>
<p>一个 Redis 实例，最多能存放多少的 keys ，List、Set、Sorted Set 他们最多能存放多少元素。</p>
<p>理论上，Redis 可以处理多达 2^32 的 keys ，并且在实际中进行了测试，每个实例至少存放了 2 亿 5 千万的 keys。</p>
<p>任何 list、set、和 sorted set 都可以放 2^32 个元素。</p>
<p>🦅 <strong>假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</strong></p>
<p>使用 <code>keys</code> 指令可以扫出指定模式的 key 列表。</p>
<ul>
<li>对方接着追问：如果这个 Redis 正在给线上的业务提供服务，那使用 <code>keys</code> 指令会有什么问题？</li>
<li>这个时候你要回答 Redis 关键的一个特性：Redis 的单线程的。<code>keys</code> 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 <code>scan</code> 指令，<code>scan</code> 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 <code>keys</code> 指令长。</li>
</ul>
<h2 id="Redis-常见的性能问题都有哪些？如何解决？"><a href="#Redis-常见的性能问题都有哪些？如何解决？" class="headerlink" title="Redis 常见的性能问题都有哪些？如何解决？"></a>Redis 常见的性能问题都有哪些？如何解决？</h2><ul>
<li><p>1、<strong>Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件</strong>。</p>
<blockquote>
<p>经过和朋友讨论，主节点开启 AOF 日志功能，尽量避免 AOF 重写。</p>
</blockquote>
<ul>
<li>Master 写内存快照，save 命令调度 rdbSave 函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以 Master 最好不要写内存快照。</li>
<li>Master AOF 持久化，如果不重写 AOF 文件，这个持久化方式对性能的影响是最小的，但是 AOF 文件会不断增大，AOF 文件过大会影响 Master 重启的恢复速度。</li>
<li>所以，Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化。如果数据比较关键，某个 Slave 开启AOF备份数据，策略为每秒同步一次。</li>
</ul>
</li>
<li><p>2、Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。</p>
<ul>
<li>一般来说，出现这个问题，很多时候是因为 Master 的内存过大，一次 AOF 重写需要占用的 CPU 和内存的资源较多，此时可以考虑 Redis Cluster 方案。</li>
</ul>
</li>
<li><p>3、尽量避免在压力很大的主库上增加过多的从库。</p>
<ul>
<li>可以考虑在从上挂载其它的从。</li>
</ul>
</li>
<li><p>4、主从复制不要用图状结构，用单向链表结构更为稳定，即：<code>Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3...</code> 。</p>
<ul>
<li><p>这样的结构，也方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master挂了，可以立刻启用 Slave1 做 Master ，其他不变。</p>
<blockquote>
<p>从节点在切换主节点作为复制源的时候，会重新发起全量复制。所以此处通过 Slave1 挂在 Slave 下，可以规避这个问题。同时，也减少了 Master 的复制压力。当然，坏处就是 Slave1 的延迟可能会高一些些，所以还是需要取舍。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>5、Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。</p>
</li>
</ul>
<hr>
<p>和飞哥沟通过后，他们主节点开启 AOF ，从节点开启 AOF + RDB 。</p>
<p>和晓峰沟通后，他们主节点开启 AOF ，从节点开启 RDB 居多，也有开启 AOF + RDB 的。</p>
<h2 id="修改配置不重启-Redis-会实时生效吗？"><a href="#修改配置不重启-Redis-会实时生效吗？" class="headerlink" title="修改配置不重启 Redis 会实时生效吗？"></a>修改配置不重启 Redis 会实时生效吗？</h2><p>针对运行实例，有许多配置选项可以通过 <code>CONFIG SET</code> 命令进行修改，而无需执行任何形式的重启。</p>
<p>从 Redis 2.2 开始，可以从 AOF 切换到 RDB 的快照持久性或其他方式而不需要重启 Redis。检索 <code>CONFIG GET *</code> 命令获取更多信息。</p>
<p>但偶尔重新启动是必须的，如为升级 Redis 程序到新的版本，或者当你需要修改某些目前 CONFIG 命令还不支持的配置参数的时候。</p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>有些比较凶残的面试官，可能会问我们一些 Redis 数据结构的问题，例如：</p>
<ul>
<li><p>Skiplist 插入和查询原理？</p>
</li>
<li><p>压缩列表的原理？</p>
</li>
<li><p>Redis 底层为什么使用跳跃表而不是红黑树？</p>
<blockquote>
<p>跳跃表在范围查找的时候性能比较高。</p>
</blockquote>
</li>
</ul>
<p>想要了解这块，需要花一定的时间去撸一撸源码，推荐可以看如下两块内容：</p>
<ul>
<li><a href="https://juejin.im/book/5afc2e5f6fb9a07a9b362527?referrer=5904c637b123db3ee479d923">《Redis 深度历险：核心原理与应用实践》</a></li>
<li><a href="https://u.jd.com/Fl5NTt">《Redis 设计与实现》</a></li>
</ul>
<p>推荐先读第一本，可以深入浅出的了解 Redis 原理和源码。然后在读第二本，硬核了解 Redis 的设计与实现（源码）。</p>
<h2 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h2><p>哇哦，爽。虽然过程痛苦，但是中间请教了蛮多人问题，收获颇多哈。</p>
<p>嘿嘿，在回答问题的过程中，胖友会发现一直在推荐 <a href="https://u.jd.com/lDNJa9">《Redis 开发与运维》</a> 这本书。在艿艿整理完第一版 Redis 面试题后，发现对有些 Redis 的面试题，理解还是有所欠缺（当然现在可能也是，哈哈哈），重新翻看了下这本书，发现很多问题都得到了非常不错的解答。所以，推荐再推荐。</p>
<p>参考与推荐如下文章：</p>
<ul>
<li>JeffreyLcm <a href="https://segmentfault.com/a/1190000014507534">《Redis 面试题》</a></li>
<li>烙印99 <a href="https://www.imooc.com/article/36399">《史上最全 Redis 面试题及答案》</a></li>
<li>yanglbme <a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-single-thread-model.md">《Redis 和 Memcached 有什么区别？Redis 的线程模型是什么？为什么单线程的 Redis 比多线程的 Memcached 效率要高得多？》</a></li>
<li>老钱 <a href="https://zhuanlan.zhihu.com/p/32540678">《天下无难试之 Redis 面试题刁难大全》</a></li>
<li>yanglbme <a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-persistence.md">《Redis 的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？》</a></li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>精尽 Java【虚拟机】面试题</title>
    <url>/2016/10/12/%E7%B2%BE%E5%B0%BD%20Java%E3%80%90%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="精尽-Java【虚拟机】面试题"><a href="#精尽-Java【虚拟机】面试题" class="headerlink" title="精尽 Java【虚拟机】面试题"></a>精尽 Java【虚拟机】面试题</h1><p>以下面试题，基于网络整理，和自己编辑。具体参考的文章，会在文末给出所有的链接。</p>
<p>如果胖友有自己的疑问，欢迎在星球提问，我们一起整理吊吊的 Java【虚拟机】面试题的大保健。</p>
<p>而题目的难度，艿艿尽量按照从容易到困难的顺序，逐步下去。</p>
<p>因为 Java 并发涉及到的内容会非常多，本面试题可能很难覆盖到所有的知识点，所以推荐 <a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 。并且，本文会将面试题和该书的章节，大体保持一致。嘻嘻~</p>
<p>另外，本文涉及的面试题会超级超级超级多，所以艿艿已经分了小节，胖友要注意哟。</p>
<p>对于大部分 JVM 的面试题，基本都是概念题，所以艿艿一些面试题如果和 <a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 中，可以找到对应的章节，会进行注明。毕竟，看书可以理解更加深刻。 </p>
<blockquote>
<p>艿艿：因为和字节码、指令级，理解起来相对复杂，实际面试问的也相对少。所以，本文暂时先不写。当然，未来肯定要补的，这么有趣的东西，胖友说是不是。</p>
</blockquote>
<h1 id="走近-Java"><a href="#走近-Java" class="headerlink" title="走近 Java"></a>走近 Java</h1><h2 id="什么是虚拟机？"><a href="#什么是虚拟机？" class="headerlink" title="什么是虚拟机？"></a>什么是虚拟机？</h2><p>Java 虚拟机，是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚拟机执行的字节码文件( <code>.class</code> )。 </p>
<p>Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p>
<p>但是，跨平台的是 Java 程序(包括字节码文件)，，而不是 JVM。JVM 是用 C/C++ 开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM 。</p>
<p><a href="http://static2.iocoder.cn/5f64c6b9436f6efbe54cfc2d01727301"><img src="http://cdn.tuwenbin.vip/20201006094005" alt="不同平台，不同 JVM"></a>不同平台，不同 JVM</p>
<ul>
<li>也就是说，JVM 能够跨计算机体系结构来执行 Java 字节码，主要是由于 JVM 屏蔽了与各个计算机平台相关的软件或者硬件之间的差异，使得与平台相关的耦合统一由 JVM 提供者来实现。</li>
</ul>
<h2 id="JVM-由哪些部分组成？"><a href="#JVM-由哪些部分组成？" class="headerlink" title="JVM 由哪些部分组成？"></a>JVM 由哪些部分组成？</h2><blockquote>
<p>考察对 JVM 体系结构的掌握</p>
<p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「2.2 运行时数据区域」</a> 。</p>
</blockquote>
<p>JVM 的结构基本上由 4 部分组成：</p>
<blockquote>
<p>注意打钩的 4 个地方。</p>
</blockquote>
<p><a href="http://static2.iocoder.cn/images/JDK/2020_02_10/01.jpg"><img src="http://cdn.tuwenbin.vip/20201006094012.jpg" alt="img"></a></p>
<ul>
<li><p><strong>类加载器</strong>，在 JVM 启动时或者类运行时将需要的 class 加载到 JVM 中。</p>
</li>
<li><p><strong>内存区</strong>，将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块，如实际机器上的各种功能的寄存器或者 PC 指针的记录器等。</p>
<blockquote>
<p>关于这一块，我们在 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「Java 内存区域与内存溢出异常」</a> 也会细看。</p>
</blockquote>
</li>
<li><p><strong>执行引擎</strong>，执行引擎的任务是负责执行 class 文件中包含的字节码指令，相当于实际机器上的 CPU 。</p>
</li>
<li><p><strong>本地方法调用</strong>，调用 C 或 C++ 实现的本地方法的代码返回结果。</p>
</li>
</ul>
<h2 id="怎样通过-Java-程序来判断-JVM-是-32-位-还是-64-位？"><a href="#怎样通过-Java-程序来判断-JVM-是-32-位-还是-64-位？" class="headerlink" title="怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？"></a>怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？</h2><p>Sun 有一个 Java System 属性来确定JVM的位数：32 或 64。</p>
<ul>
<li><code>sun.arch.data.model=32 // 32 bit JVM</code></li>
<li><code>sun.arch.data.model=64 // 64 bit JVM</code></li>
</ul>
<p>我可以使用以下语句来确定 JVM 是 32 位还是 64 位：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">System.getProperty(&quot;sun.arch.data.model&quot;)<br></code></pre></td></tr></table></figure>

<p>🦅 <strong>32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？</strong></p>
<p>理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB ，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约 3GB。</p>
<p>64 位 JVM 允许指定最大的堆内存，理论上可以达到 2^64 ，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB 。甚至有的 JVM，如 Azul ，堆内存到 1000G 都是可能的。</p>
<p>🦅 <strong>64 位 JVM 中，int 的长度是多数？</strong></p>
<p>Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位或者 4 个字节。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。</p>
<h1 id="Java-内存区域与内存溢出异常"><a href="#Java-内存区域与内存溢出异常" class="headerlink" title="Java 内存区域与内存溢出异常"></a>Java 内存区域与内存溢出异常</h1><h2 id="JVM-运行内存的分类？"><a href="#JVM-运行内存的分类？" class="headerlink" title="JVM 运行内存的分类？"></a>JVM 运行内存的分类？</h2><blockquote>
<p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「2.3.1 对象的创建」</a> 。</p>
</blockquote>
<p>JVM 运行内存的分类如下图所示：</p>
<blockquote>
<p>注意，这个图是基于 JDK6 版本的运行内存的分类。</p>
</blockquote>
<p><a href="http://static2.iocoder.cn/images/JDK/2020_02_10/02.png"><img src="http://cdn.tuwenbin.vip/20201006094020.png" alt="img"></a></p>
<ul>
<li><p>程序计数器</p>
<p>： Java 线程私有，类似于操作系统里的 PC 计数器，它可以看做是当前线程所执行的字节码的行号指示器。</p>
<ul>
<li>如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。</li>
<li>此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</li>
</ul>
</li>
<li><p>虚拟机栈（栈内存）</p>
<p>：Java线程私有，虚拟机栈描述的是 Java 方法执行的内存模型：</p>
<ul>
<li>每个方法在执行的时候，都会创建一个栈帧用于存储局部变量、操作数、动态链接、方法出口等信息。</li>
<li>每个方法调用都意味着一个栈帧在虚拟机栈中入栈到出栈的过程。</li>
</ul>
</li>
<li><p><strong>本地方法栈</strong> ：和 Java 虚拟机栈的作用类似，区别是该区域为 JVM 提供使用 Native 方法的服务。</p>
</li>
<li><p>堆内存</p>
<p>（线程共享）：所有线程共享的一块区域，垃圾收集器管理的主要区域。</p>
<ul>
<li>目前主要的垃圾回收算法都是分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等，默认情况下新生代按照 <code>8:1:1</code> 的比例来分配。</li>
<li>根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘一样。</li>
</ul>
</li>
<li><p>方法区</p>
<p>（线程共享）：各个线程共享的一个区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<ul>
<li>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</li>
<li>运行时常量池：是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。</li>
</ul>
</li>
</ul>
<p>🦅 <strong>直接内存是不是虚拟机运行时数据区的一部分？</strong></p>
<p>参见 <a href="https://blog.csdn.net/leaf_0303/article/details/78961936">《JVM 直接内存》</a> 文章。</p>
<p>直接内存(Direct Memory)，并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中农定义的内存区域。在 JDK1.4 中新加入了 NIO(New Input/Output) 类，引入了一种基于通道(Channel)与缓冲区（Buffer）的 I/O  方式，它可以使用 native 函数库直接分配堆外内存，然后通脱一个存储在 Java 堆中的 DirectByteBuffer  对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p>
<ul>
<li>本机直接内存的分配不会受到 Java 堆大小的限制，受到本机总内存大小限制。</li>
<li>配置虚拟机参数时，不要忽略直接内存，防止出现 OutOfMemoryError 异常。</li>
</ul>
<p>🦅 <strong>直接内存（堆外内存）与堆内存比较？</strong></p>
<ol>
<li>直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显。</li>
<li>直接内存 IO 读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显。</li>
</ol>
<p>🦅 <strong>实际上，后续的版本，主要对【方法区】做了一定的调整</strong></p>
<ul>
<li><p>JDK7 的改变</p>
<ul>
<li>存储在永久代的部分数据就已经转移到了 Java Heap 或者是 Native Heap。但永久代仍存在于 JDK7 中，但是并没完全移除。</li>
<li>常量池和静态变量放到 Java 堆里。</li>
</ul>
</li>
<li><p>JDK8 的改变</p>
<ul>
<li><p>废弃 PermGen（永久代），新增 Metaspace（元数据区）。</p>
</li>
<li><p>那么方法区还在么？FROM 狼哥 的解答：方法区在 Metaspace 中了，方法区都是一个概念的东西。😈 狼哥通过撸源码获得该信息。</p>
<blockquote>
<p>因为，《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。</p>
<p>同时，大多数用的 JVM 都是 Sun 公司的 HotSpot 。在 HotSpot 上把 GC 分代收集扩展至方法区，或者说使用永久带来实现方法区。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>参考文章</p>
<ul>
<li><a href="https://www.cnblogs.com/SaraMoring/p/5713732.html">《JVM 内存堆布局图解分析》</a></li>
<li><a href="https://www.jianshu.com/p/855b38c57925">《笔记之 JVM 方法区：永久带 VS 元空间》</a></li>
<li><a href="https://blog.csdn.net/wenniuwuren/article/details/51170275">《JVM —— 移除永久代》</a></li>
<li><a href="https://www.bbsmax.com/A/RnJW679gzq/">《JDK 源码剖析五：JDK8 —— 废弃永久代（PermGen）迎来元空间（Metaspace）》</a></li>
<li><a href="https://www.cnblogs.com/paddix/p/5309550.html">《Java8 内存模型 —— 永久代(PermGen)和元空间(Metaspace)》</a></li>
</ul>
</li>
</ul>
<p>🦅 <strong>JDK8 之后 Perm Space 有哪些变动? MetaSpace ⼤⼩默认是⽆限的么? 还是你们会通过什么⽅式来指定⼤⼩?</strong></p>
<ul>
<li>JDK8 后用元空间替代了 Perm Space ；字符串常量存放到堆内存中。</li>
<li>MetaSpace 大小默认没有限制，一般根据系统内存的大小。JVM 会动态改变此值。</li>
<li>可以通过 JVM 参数配置<ul>
<li><code>-XX:MetaspaceSize</code> ： 分配给类元数据空间（以字节计）的初始大小（Oracle  逻辑存储上的初始高水位，the initial high-water-mark）。此值为估计值，MetaspaceSize  的值设置的过大会延长垃圾回收时间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。</li>
<li><code>-XX:MaxMetaspaceSize</code> ：分配给类元数据空间的最大值，超过此值就会触发Full GC 。此值默认没有限制，但应取决于系统内存的大小，JVM 会动态地改变此值。</li>
</ul>
</li>
</ul>
<p>🦅 <strong>为什么要废弃永久代？</strong></p>
<p>1）现实使用中易出问题。</p>
<p>由于永久代内存经常不够用或发生内存泄露，爆出异常 <code>java.lang.OutOfMemoryError: PermGen</code> 。</p>
<ul>
<li>字符串存在永久代中，容易出现性能问题和内存溢出。</li>
<li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</li>
</ul>
<p>2）永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</p>
<p>3）Oracle 可能会将HotSpot 与 JRockit 合二为一。</p>
<p>参照 JEP122 ：<a href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122</a> ，原文截取：</p>
<blockquote>
<p>Motivation</p>
<p>This is part of the JRockit and Hotspot convergence effort. JRockit  customers do not need to configure the permanent generation (since  JRockit does not have a permanent generation) and are accustomed to not  configuring the permanent generation.</p>
</blockquote>
<p>即：移除永久代是为融合 HotSpot JVM 与 JRockit VM 而做出的努力，因为 JRockit 没有永久代，不需要配置永久代。</p>
<h2 id="Java-内存堆和栈区别？"><a href="#Java-内存堆和栈区别？" class="headerlink" title="Java 内存堆和栈区别？"></a>Java 内存堆和栈区别？</h2><ul>
<li>栈内存用来存储基本类型的变量和对象的引用变量；堆内存用来存储Java中的对象，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</li>
<li>栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存；堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。</li>
<li>如果栈内存没有可用的空间存储方法调用和局部变量，JVM 会抛出 <code>java.lang.StackOverFlowError</code> 错误；如果是堆内存没有可用的空间存储生成的对象，JVM 会抛出 <code>java.lang.OutOfMemoryError</code> 错误。</li>
<li>栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满。<code>-Xss</code> 选项设置栈内存的大小，<code>-Xms</code> 选项可以设置堆的开始时的大小。</li>
</ul>
<p>当然，如果你记不住这个些，只要记住如下即可：</p>
<blockquote>
<p>JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。</p>
</blockquote>
<p><a href="http://static2.iocoder.cn/images/JDK/2020_02_10/03.png"><img src="http://cdn.tuwenbin.vip/20201006094027.png" alt="img"></a></p>
<h2 id="JAVA-对象创建的过程？"><a href="#JAVA-对象创建的过程？" class="headerlink" title="JAVA 对象创建的过程？"></a>JAVA 对象创建的过程？</h2><blockquote>
<p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「2.3.1 对象的创建」</a> 。</p>
<p>注意，加粗的文字部分。</p>
</blockquote>
<p>JAVA 对象创建的过程，如下图所示：<a href="http://static2.iocoder.cn/images/JDK/2020_02_10/06.png"><img src="http://cdn.tuwenbin.vip/20201006094030.png" alt="JAVA 对象创建的过程"></a>JAVA 对象创建的过程</p>
<ul>
<li>Java 中对象的创建就是在堆上分配内存空间的过程，此处说的对象创建仅限于 new 关键字创建的普通 Java 对象，不包括数组对象的创建。</li>
</ul>
<p>1）检测类是否被加载</p>
<p>当虚拟机遇到 <code>new</code> 指令时，首先先去检查这个指令的参数是否能在常量池中<strong>定位到一个类的符号引用</strong>，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就执行类加载过程。</p>
<p>2）为对象分配内存</p>
<p>类加载完成以后，虚拟机就开始为对象分配内存，此时所需内存的大小就已经确定了。只需要在堆上分配所需要的内存即可。</p>
<p>具体的分配内存有两种情况：第一种情况是内存空间绝对规整，第二种情况是内存空间是不连续的。</p>
<ul>
<li>对于内存绝对规整的情况相对简单一些，虚拟机只需要在被占用的内存和可用空间之间移动指针即可，这种方式被称为“<strong>指针碰撞</strong>”。</li>
<li>对于内存不规整的情况稍微复杂一点，这时候虚拟机需要维护一个列表，来记录哪些内存是可用的。分配内存的时候需要找到一个可用的内存空间，然后在列表上记录下已被分配，这种方式成为“<strong>空闲列表</strong>”。</li>
</ul>
<p>多线程并发时会出现正在给对象 A 分配内存，还没来得及修改指针，对象 B 又用这个指针<strong>分配内存</strong>，这样就出现问题了。解决这种问题有两种方案：</p>
<ul>
<li>第一种，是采用同步的办法，使用 CAS 来保证操作的原子性。</li>
<li>另一种，是每个线程分配内存都在自己的空间内进行，即是每个线程都在堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB），分配内存的时候再TLAB上分配，互不干扰。可以通过 <code>-XX:+/-UseTLAB</code> 参数决定。</li>
</ul>
<p>3）为分配的内存空间初始化零值</p>
<p>对象的内存分配完成后，还需要将对象的内存空间都初始化为零值，这样能保证对象即使没有赋初值，也可以直接使用。</p>
<p>4）对对象进行其他设置</p>
<p>分配完内存空间，初始化零值之后，虚拟机还需要对对象进行其他必要的设置，设置的地方都在对象头中，包括这个对象所属的类，类的元数据信息，对象的 hashcode ，GC 分代年龄等信息。</p>
<p>5）执行 init 方法</p>
<p>执行完上面的步骤之后，在虚拟机里这个对象就算创建成功了，但是对于 Java 程序来说还需要执行 init  方法才算真正的创建完成，因为这个时候对象只是被初始化零值了，还没有真正的去根据程序中的代码分配初始值，调用了 init  方法之后，这个对象才真正能使用。</p>
<p>到此为止一个对象就产生了，这就是 new 关键字创建对象的过程。过程如下：</p>
<p><a href="http://static2.iocoder.cn/images/JDK/2020_02_10/07.png"><img src="http://cdn.tuwenbin.vip/20201006094035.png" alt="JAVA 对象创建的过程"></a>JAVA 对象创建的过程</p>
<blockquote>
<p>另外，这个问题，面试官可能引申成 “<code>A a = new A()</code> 经历过什么过程”的问题。</p>
</blockquote>
<h2 id="对象的内存布局是怎样的？"><a href="#对象的内存布局是怎样的？" class="headerlink" title="对象的内存布局是怎样的？"></a>对象的内存布局是怎样的？</h2><blockquote>
<p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「2.3.2 对象的内存布局」</a> 。</p>
</blockquote>
<p>对象的内存布局包括三个部分：</p>
<ul>
<li>对象头：对象头包括两部分信息。<ul>
<li>第一部分，是存储对象自身的运行时数据，如哈希码，GC 分代年龄，锁状态标志，线程持有的锁等等。</li>
<li>第二部分，是类型指针，即对象指向类元数据的指针。</li>
</ul>
</li>
<li>实例数据：就是数据。</li>
<li>对齐填充：不是必然的存在，就是为了对齐。</li>
</ul>
<h2 id="对象是如何定位访问的？"><a href="#对象是如何定位访问的？" class="headerlink" title="对象是如何定位访问的？"></a>对象是如何定位访问的？</h2><blockquote>
<p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「2.3.3 对象的访问定位」</a> 。</p>
</blockquote>
<p>对象的访问定位有两种：</p>
<ul>
<li>句柄定位：Java 堆会画出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。<a href="http://static2.iocoder.cn/images/JDK/2020_02_10/04.png"><img src="http://cdn.tuwenbin.vip/20201006094040.png" alt="句柄定位"></a>句柄定位</li>
<li>直接指针访问：Java 堆对象的不居中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址。 <a href="http://static2.iocoder.cn/images/JDK/2020_02_10/05.png"><img src="http://cdn.tuwenbin.vip/20201006094044.png" alt="直接指针访问"></a>直接指针访问</li>
</ul>
<p>🦅 <strong>对比两种方式？</strong></p>
<p>这两种对象访问方式各有优势。</p>
<ul>
<li>使用句柄来访问的最大好处，就是 reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</li>
<li>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</li>
</ul>
<p>我们目前主要虚拟机 Sun HotSpot 而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。</p>
<h2 id="有哪些-OutOfMemoryError-异常？"><a href="#有哪些-OutOfMemoryError-异常？" class="headerlink" title="有哪些 OutOfMemoryError 异常？"></a>有哪些 OutOfMemoryError 异常？</h2><blockquote>
<p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「2.4 实战：OutOfMemoryError 异常」</a> 。</p>
</blockquote>
<p>在 Java 虚拟机中规范的描述中，除了程序计数器外，虚拟机内存的其它几个运行时区域都有发生的 OutOfMemoryError(简称为“OOM”) 异常的可能。</p>
<ul>
<li><p>Java 堆溢出</p>
</li>
<li><p>虚拟机栈和本地方法栈溢出</p>
</li>
<li><p>方法区和运行时常量池溢出</p>
<blockquote>
<p>从 JDK8 开始，就变成元数据区的内存溢出。</p>
</blockquote>
</li>
<li><p>本机直接内存溢出</p>
</li>
</ul>
<p><strong>1）Java 堆溢出</strong></p>
<p>重现方式，参见 <a href="https://blog.csdn.net/sells2012/article/details/18654915">《Java 堆溢出》</a> 文章。</p>
<p>另外，Java 堆溢出的原因，有可能是内存泄露，可以使用 MAT 进行分析。</p>
<p><strong>2）虚拟机栈和本地方法栈溢出</strong></p>
<p>由于在 HotSpot 虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于 HotSpot 来说，虽然 <code>-Xoss</code> 参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由 <code>-Xss</code>参数设定。</p>
<p>关于虚拟机栈和本地方法栈，在 Java 虚拟机规范中描述了两种异常：</p>
<ul>
<li><p>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 StackOverflowError 异常。</p>
<blockquote>
<p>StackOverflowError 不属于 OOM 异常哈。</p>
</blockquote>
</li>
<li><p>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出 OutOfMemoryError 异常。</p>
</li>
</ul>
<p>重现方式，参见 <a href="https://blog.csdn.net/en_joker/article/details/79727675">《OutOfMemoryError 异常 —— 虚拟机栈和本地方法栈溢出》</a> 文章。</p>
<p><strong>3）运行时常量池溢出</strong></p>
<p>因为 JDK7 将常量池和静态变量放到 Java 堆里，所以无法触发运行时常量池溢出。如果想要触发，可以使用 JDK6 的版本。</p>
<p>重现方式，参见 <a href="https://www.niuhp.com/java/jvm-oom-pg.html">《JVM 内存溢出 - 方法区及运行时常量池溢出》</a> 文章。</p>
<p><strong>4）方法区的内存溢出</strong></p>
<p>因为 JDK8 将方法区溢出，所以无法触发方法区的内存溢出溢出。如果想要触发，可以使用 JDK7 的版本。</p>
<p>重现方式，参见 <a href="https://blog.csdn.net/tanga842428/article/details/52636836">《Java 方法区溢出》</a> 文章。</p>
<p><strong>5）元数据区的内存溢出</strong></p>
<p>实际上，方法区的内存溢出在 JDK8 中，变成了元数据区的内存溢出。所以，重现方式，还是参见 <a href="https://blog.csdn.net/tanga842428/article/details/52636836">《Java 方法区溢出》</a> 文章，只是说，需要增加 <code>-XX:MaxMetaspaceSize=10m</code> VM 配置项。</p>
<p><strong>6）本机直接内存溢出</strong></p>
<p>重现方式，参见 <a href="https://www.niuhp.com/java/jvm-oom-direct.html">《JVM 内存溢出 —— 直接内存溢出》</a> 文章。</p>
<hr>
<p>另外，非常推荐一篇文章，胖友耐心阅读，提供了更多有趣的案例，<a href="https://www.jianshu.com/p/2fdee831ed03">《Java 内存溢出(OOM)异常完全指南》</a> 。</p>
<p>🦅 <strong>当出现了内存溢出，你怎么排错？</strong></p>
<ul>
<li>1、首先，控制台查看错误日志。</li>
<li>2、然后，使用 JDK 自带的 jvisualvm 工具查看系统的堆栈日志。</li>
<li>3、定位出内存溢出的空间：堆，栈还是永久代（JDK8 以后不会出现永久代的内存溢出）。<ul>
<li>如果是堆内存溢出，看是否创建了超大的对象。</li>
<li>如果是栈内存溢出，看是否创建了超大的对象，或者产生了死循环。</li>
</ul>
</li>
</ul>
<h2 id="Java-中会存在内存泄漏吗？"><a href="#Java-中会存在内存泄漏吗？" class="headerlink" title="Java 中会存在内存泄漏吗？"></a>Java 中会存在内存泄漏吗？</h2><p>理论上 Java 因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是 Java 被广泛使用于服务器端编程的一个重要原因）。然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被 GC 回收也会发生内存泄露。例如说：</p>
<ul>
<li>Hibernate 的 Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象。</li>
<li>使用 Netty 的堆外的 ByteBuf 对象，在使用完后，并未归还，导致使用的一点一点在泄露。</li>
</ul>
<h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><h2 id="什么是垃圾回收机制？"><a href="#什么是垃圾回收机制？" class="headerlink" title="什么是垃圾回收机制？"></a>什么是垃圾回收机制？</h2><blockquote>
<p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「3.1 概述」</a> 。</p>
</blockquote>
<ul>
<li>Java 中对象是采用 <code>new</code> 或者反射的方法创建的，这些对象的创建都是在堆(Heap)中分配的，所有对象的回收都是由 Java 虚拟机通过垃圾回收机制完成的。GC 为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控。</li>
<li>Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。</li>
<li>可以调用下面的方法之一：<code>System#gc()</code> 或 <code>Runtime#getRuntime()#gc()</code> ，但 JVM 也可以屏蔽掉显示的垃圾回收调用。</li>
</ul>
<p>🦅 <strong>为什么不建议在程序中显式的声明 <code>System.gc()</code> ？</strong></p>
<p>因为显式声明是做堆内存全扫描，也就是 Full GC ，是需要停止所有的活动的(Stop  The World Collection)，对应用很大可能存在影响。</p>
<p>另外，调用 <code>System.gc()</code> 方法后，不会立即执行 Full GC ，而是虚拟机自己决定的。</p>
<p>🦅 <strong>如果一个对象的引用被设置为 <code>null</code> , GC 会立即释放该对象的内存么?</strong></p>
<p>不会, 这个对象将会在下一次 GC 循环中被回收。</p>
<p>🦅 <strong><code>#finalize()</code> 方法什么时候被调用？它的目的是什么？</strong></p>
<blockquote>
<p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「3.2.4 生存还是死亡」</a> 。</p>
</blockquote>
<p><code>#finallize()</code> 方法，是在释放该对象内存前由 GC (垃圾回收器)调用。</p>
<ul>
<li>通常建议在这个方法中释放该对象持有的资源，例如持有的堆外内存、和远程服务的长连接。</li>
<li>一般情况下，不建议重写该方法。</li>
<li>对于一个对象，该方法有且仅会被调用一次。</li>
</ul>
<h2 id="如何判断一个对象是否已经死去？"><a href="#如何判断一个对象是否已经死去？" class="headerlink" title="如何判断一个对象是否已经死去？"></a>如何判断一个对象是否已经死去？</h2><blockquote>
<p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「3.2 对象已死吗」</a> 。</p>
</blockquote>
<p>有两种方式：</p>
<ol>
<li>引用计数</li>
<li>可达性分析</li>
</ol>
<p><strong>1）引用计数</strong></p>
<p>每个对象有一个引用计数属性，新增一个引用时计数加 1 ，引用释放时计数减 1 ，计数为 0 时可以回收。此方法简单，无法解决对象相互循环引用的问题。目前在用的有 Python、ActionScript3 等语言。</p>
<p><strong>2）可达性分析（Reachability Analysis）</strong></p>
<p>从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。不可达对象。目前在用的有 Java、C# 等语言。</p>
<p>🦅 <strong>如果 A 和 B 对象循环引用，是否可以被 GC？</strong></p>
<p>可以，因为 Java 采用可达性分析的判断方式。</p>
<p>🦅 <strong>在 Java 语言里，可作为 GC Roots 的对象包括以下几种？</strong></p>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中的类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中 JNI(即一般说的 Native 方法)中引用的对象。</li>
</ol>
<p>🦅 <strong>方法区是否能被回收？</strong></p>
<p>方法区可以被回收，但是价值很低，主要回收废弃的常量和无用的类。</p>
<p>如何判断无用的类，需要完全满足如下三个条件：</p>
<ol>
<li>该类所有实例都被回收（Java 堆中没有该类的对象）。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方利用反射访问该类。</li>
</ol>
<h2 id="Java-对象有哪些引用类型？"><a href="#Java-对象有哪些引用类型？" class="headerlink" title="Java 对象有哪些引用类型？"></a>Java 对象有哪些引用类型？</h2><blockquote>
<p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「3.2.3 再谈引用类型」</a> 。</p>
</blockquote>
<p>Java 一共有四种引用类型：</p>
<ul>
<li>强引用</li>
<li>软引用（SoftReference）</li>
<li>弱引用（WeakReference）</li>
<li>虚引用（PhantomReference）</li>
</ul>
<p><strong>1）强引用</strong></p>
<p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<blockquote>
<p>艿艿：不然，代码都没法写了 😈</p>
</blockquote>
<p><strong>2）软引用（SoftReference）</strong></p>
<p>如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<p>使用示例，见 <a href="http://svip.iocoder.cn/MyBatis/cache-package/">《精尽 MyBatis 源码分析 —— 缓存模块》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「2.10 SoftCache」</a> 小节。</p>
<p><strong>3）弱引用（WeakReference）</strong></p>
<p>如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它  所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<p>使用示例，见</p>
<ul>
<li><a href="http://svip.iocoder.cn/MyBatis/cache-package/">《精尽 MyBatis 源码分析 —— 缓存模块》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「2.9 WeakCache」</a> 小节。</li>
<li><a href="http://svip.iocoder.cn/Netty/ByteBuf-1-3-ByteBuf-resource-leak-detector/">《精尽 Netty 源码解析 —— Buffer 之 ByteBuf（三）内存泄露检测》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「4. ResourceLeakDetector」</a> 小节。</li>
</ul>
<p><strong>4）虚引用（PhantomReference）</strong></p>
<p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p>
<p>虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃  圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
<hr>
<p>如果胖友想看看各种引用在 GC 下的效果，可以看看 <a href="http://www.iocoder.cn/Fight/Four-reference-types-in-Java/?vip">《Java 中的四种引用类型》</a> 提供的代码示例。</p>
<p>🦅 <strong>WeakReference 与 SoftReference的区别？</strong></p>
<p>虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率。</p>
<ul>
<li>但是 WeakReference 一旦失去最后一个强引用，就会被 GC 回收</li>
<li>而 SoftReference 虽然不能阻止被回收，但是可以延迟到 JVM 内存不足的时候。</li>
</ul>
<p>🦅 <strong>为什么要有不同的引用类型？</strong></p>
<p>不像 C 语言，我们可以控制内存的申请和释放，在 Java 中有时候我们需要适当的控制对象被回收的时机，因此就诞生了不同的引用类型，可以说不同的引用类型实则是对 GC 回收时机不可控的妥协。有以下几个使用场景可以充分的说明：</p>
<ul>
<li>利用软引用和弱引用解决 OOM 问题。用一个 HashMap 来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM 会自动回收这些缓存图片对象所占用的空间，从而有效地避免了 OOM 的问题.</li>
<li>通过软引用实现 Java 对象的高速缓存。比如我们创建了一 Person  的类，如果每次需要查询一个人的信息，哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这将引起大量 Person  对象的消耗，并且由于这些对象的生命周期相对较短，会引起多次 GC 影响性能。此时，通过软引用和 HashMap  的结合可以构建高速缓存，提供性能。</li>
</ul>
<h2 id="JVM-垃圾回收算法？"><a href="#JVM-垃圾回收算法？" class="headerlink" title="JVM 垃圾回收算法？"></a>JVM 垃圾回收算法？</h2><blockquote>
<p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「3.3 垃圾回收算法」</a> 。</p>
</blockquote>
<p>有四种算法：</p>
<ol>
<li>标记-清除算法</li>
<li>标记-整理算法</li>
<li>复制算法</li>
<li>分代收集算法</li>
</ol>
<p><strong>1）标记-清除算法</strong></p>
<p>标记-清除（Mark-Sweep）算法，是现代垃圾回收算法的思想基础。</p>
<p>标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。</p>
<p>一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象（好多资料说标记出要回收的对象，其实明白大概意思就可以了）。然后，在清除阶段，清除所有未被标记的对象。</p>
<p><a href="http://static2.iocoder.cn/f07ac7c68994aa21b7b4271073ea4e5b"><img src="http://cdn.tuwenbin.vip/20201006094053" alt="标记-清除算法"></a>标记-清除算法</p>
<ul>
<li>缺点：<ul>
<li>1、效率问题，标记和清除两个过程的效率都不高。</li>
<li>2、空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ul>
</li>
</ul>
<p><strong>2）标记-整理算法</strong></p>
<p>标记整理算法，类似与标记清除算法，不过它标记完对象后，不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。</p>
<p><a href="http://static2.iocoder.cn/52ea9a3813e09621c563b1cd4bdf0d22"><img src="http://cdn.tuwenbin.vip/20201006094057" alt="标记-整理算法"></a>标记-整理算法</p>
<ul>
<li>优点：<ul>
<li>1、相对标记清除算法，解决了内存碎片问题。</li>
<li>2、没有内存碎片后，对象创建内存分配也更快速了（可以使用TLAB进行分配）。</li>
</ul>
</li>
<li>缺点：<ul>
<li>1、效率问题，（同标记清除算法）标记和整理两个过程的效率都不高。</li>
</ul>
</li>
</ul>
<p><strong>3）复制算法</strong></p>
<p>复制算法，可以解决效率问题，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存用完了，就将还存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次清理掉，这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可（还可使用TLAB进行高效分配内存）。</p>
<p><a href="http://static2.iocoder.cn/cc3f228ca5353fd5deb4b22b7a9709e6"><img src="http://cdn.tuwenbin.vip/20201006094100" alt="复制算法"></a>复制算法</p>
<ul>
<li>图的上半部分是未回收前的内存区域，图的下半部分是回收后的内存区域。通过图，我们发现不管回收前还是回收后都有一半的空间未被利用。</li>
<li>优点：<ul>
<li>1、效率高，没有内存碎片。</li>
</ul>
</li>
<li>缺点：<ul>
<li>1、浪费一半的内存空间。</li>
<li>2、复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。</li>
</ul>
</li>
</ul>
<p><strong>4）分代收集算法</strong></p>
<p>当前商业虚拟机都是采用分代收集算法，它根据对象存活周期的不同将内存划分为几块，一般是把 Java 堆分为新生代和老年代，然后根据各个年代的特点采用最适当的收集算法。</p>
<ul>
<li>在新生代中，每次垃圾收集都发现有大批对象死去，只有少量存活，就选用复制算法。</li>
<li>而老年代中，因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记清理”或者“标记整理”算法来进行回收。</li>
</ul>
<p><a href="http://static2.iocoder.cn/fec52af474f1250831d46b541e0fe7a9"><img src="http://cdn.tuwenbin.vip/20201006094104" alt="分代收集算法"></a>分代收集算法</p>
<ul>
<li>图的左半部分是未回收前的内存区域，右半部分是回收后的内存区域。</li>
<li>对象分配策略：<ul>
<li>对象优先在 Eden 区域分配，如果对象过大直接分配到 Old 区域。</li>
<li>长时间存活的对象进入到 Old 区域。</li>
</ul>
</li>
<li>改进自复制算法<ul>
<li>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM 公司的专门研究表明，新生代中的对象 98% 是“朝生夕死”的，所以并不需要按照 <code>1:1</code> 的比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块  Survivor 。当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉  Eden 和刚才用过的 Survivor 空间。</li>
<li>HotSpot 虚拟机默认 Eden 和 2 块 Survivor 的大小比例是 <code>8:1:1</code>，也就是每次新生代中可用内存空间为整个新生代容量的 90%（80%+10%），只有 10% 的内存会被“浪费”。当然，98%  的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于 10% 的对象存活，当 Survivor  空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</li>
</ul>
</li>
</ul>
<h2 id="什么是安全点？"><a href="#什么是安全点？" class="headerlink" title="什么是安全点？"></a>什么是安全点？</h2><blockquote>
<p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「3.4.2 安全点」</a> 。</p>
</blockquote>
<p>SafePoint 安全点，顾名思义是指一些特定的位置，当线程运行到这些位置时，线程的一些状态可以被确定(the thread’s  representation of it’s Java machine state is well described)，比如记录OopMap  的状态，从而确定 GC Root 的信息，使 JVM 可以安全的进行一些操作，比如开始 GC 。</p>
<p>SafePoint 指的特定位置主要有：</p>
<ol>
<li>循环的末尾 (防止大循环的时候一直不进入 Safepoint ，而其他线程在等待它进入 Safepoint )。</li>
<li>方法返回前。</li>
<li>调用方法的 Call 之后。</li>
<li>抛出异常的位置。</li>
</ol>
<p>详细的内容，可以看看 <a href="https://my.oschina.net/wenbo123/blog/1822414">《深入学习 JVM-JVM 安全点和安全区域》</a> 。</p>
<ul>
<li><p>如何使线程中断</p>
<ul>
<li><p>主动式</p>
<blockquote>
<p>主动式 JVM 设置一个全局变量，线程去按照某种策略检查这个变量一旦发现是 SafePoint 就主动挂起。</p>
<p>HostSpot 虚拟机采用的是主动式使线程中断。</p>
</blockquote>
</li>
<li><p>被动式</p>
<blockquote>
<p>被动式就是发个信号，例如关机、Control+C ，带来的问题就是不可控，发信号的时候不知道线程处于什么状态。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>安全区域</p>
<blockquote>
<p>如果程序长时间不执行，比如线程调用的 sleep 方法，这时候程序无法响应 JVM 中断请求这时候线程无法到达安全点，显然 JVM 也不可能等待程序唤醒，这时候就需要安全区域了。</p>
<p>安全区域是指一段代码片中，引用关系不会发生变化，在这个区域任何地方 GC 都是安全的，安全区域可以看做是安全点的一个扩展。</p>
<ul>
<li>线程执行到安全区域的代码时，首先标识自己进入了安全区域，这样 GC 时就不用管进入安全区域的线程了.</li>
<li>线程要离开安全区域时就检查 JVM 是否完成了 GC Roots 枚举（或者整个 GC 过程），如果完成就继续执行，如果没有完成就等待直到收到可以安全离开的信号。</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="JVM-垃圾收集器有哪些？"><a href="#JVM-垃圾收集器有哪些？" class="headerlink" title="JVM 垃圾收集器有哪些？"></a>JVM 垃圾收集器有哪些？</h2><blockquote>
<p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「3.5 垃圾收集器」</a> 。</p>
</blockquote>
<p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</p>
<ul>
<li><p>新生代收集器</p>
<ul>
<li><p>Serial 收集器</p>
</li>
<li><p>ParNew 收集器</p>
<blockquote>
<p>ParNew 收集器，是 Serial 收集器的多线程版。</p>
</blockquote>
</li>
<li><p>Parallel Scavenge 收集器</p>
</li>
</ul>
</li>
<li><p>老年代收集器</p>
<ul>
<li>Serial Old 收集器<ul>
<li>Serial Old 收集器，是  Serial 收集器的老年代版本。</li>
</ul>
</li>
<li>Parallel Old 收集器<ul>
<li>Parallel Old 收集器，是 Parallel Scavenge 收集器的老年代版本。</li>
</ul>
</li>
<li>CMS 收集器</li>
</ul>
</li>
<li><p>新生代 + 老年代收集器</p>
<ul>
<li>G1 收集器</li>
<li>ZGC 收集器</li>
</ul>
</li>
</ul>
<p>小结表格如下：</p>
<table>
<thead>
<tr>
<th>收集器</th>
<th>串行、并行or并发</th>
<th>新生代/老年代</th>
<th>算法</th>
<th>目标</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Serial</strong></td>
<td>串行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>单CPU环境下的Client模式</td>
</tr>
<tr>
<td><strong>Serial Old</strong></td>
<td>串行</td>
<td>老年代</td>
<td>标记-整理</td>
<td>响应速度优先</td>
<td>单CPU环境下的Client模式、CMS的后备预案</td>
</tr>
<tr>
<td><strong>ParNew</strong></td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>响应速度优先</td>
<td>多CPU环境时在Server模式下与CMS配合</td>
</tr>
<tr>
<td><strong>Parallel Scavenge</strong></td>
<td>并行</td>
<td>新生代</td>
<td>复制算法</td>
<td>吞吐量优先</td>
<td>在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td><strong>Parallel Old</strong></td>
<td>并行</td>
<td>老年代</td>
<td>标记-整理</td>
<td>吞吐量优先</td>
<td>在后台运算而不需要太多交互的任务</td>
</tr>
<tr>
<td><strong>CMS</strong></td>
<td>并发</td>
<td>老年代</td>
<td>标记-清除</td>
<td>响应速度优先</td>
<td>集中在互联网站或B/S系统服务端上的Java应用</td>
</tr>
<tr>
<td><strong>G1</strong></td>
<td>并发</td>
<td>both</td>
<td>标记-整理+复制算法</td>
<td>响应速度优先</td>
<td>面向服务端应用，将来替换CMS</td>
</tr>
</tbody></table>
<p>关于每种垃圾收集器的说明，请看 如下文章：</p>
<ul>
<li><a href="https://crowhawk.github.io/2017/08/15/jvm_3/">《深入理解 JVM(3) —— 7 种垃圾收集器》</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/43608166">《一文读懂 Java 11 的 ZGC 为何如此高效》</a></li>
</ul>
<p>🦅 <strong>G1 和 CMS 的区别？</strong></p>
<ul>
<li><p>CMS ：并发标记清除。他的主要步骤有：初始收集，并发标记，重新标记，并发清除（删除）、重置。</p>
</li>
<li><p>G1：主要步骤：初始标记，并发标记，重新标记，复制清除（整理）</p>
</li>
<li><p>CMS 的缺点是对 CPU 的要求比较高。G1是将内存化成了多块，所有对内段的大小有很大的要求。</p>
</li>
<li><p>CMS是清除，所以会存在很多的内存碎片。G1是整理，所以碎片空间较小。</p>
</li>
<li><p>G1 和 CMS 都是响应优先把，他们的目的都是尽量控制 STW 时间。</p>
<blockquote>
<p>G1 和 CMS 的 Full GC 都是单线程 mark sweep compact 算法，直到 JDK10 才优化为并行的。</p>
</blockquote>
</li>
</ul>
<p>感兴趣的胖友，可以看看 <a href="http://engineering.xueqiu.com/blog/2015/06/25/jvm-gc-tuning/">《GC 优化的一些总结》</a> 的分析。</p>
<p>🦅 <strong>CMS 算法的过程，CMS 回收过程中 JVM 是否需要暂停？</strong></p>
<p>会有短暂的停顿。详细的，可以看看 [《<a href="https://blog.csdn.net/wfh6732/article/details/57490195">jvm][面试] 并发收集器 CMS(Concurrent Mark-Sweep)》</a> 。</p>
<p>🦅 <strong>如何使用指定的垃圾收集器</strong></p>
<table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:+UserSerialGC</td>
<td>串行垃圾收集器</td>
</tr>
<tr>
<td>-XX:+UserParrallelGC</td>
<td>并行垃圾收集器</td>
</tr>
<tr>
<td>-XX:+UseConcMarkSweepGC</td>
<td>并发标记扫描垃圾回收器</td>
</tr>
<tr>
<td>-XX:ParallelCMSThreads</td>
<td>并发标记扫描垃圾回收器 =为使用的线程数量</td>
</tr>
<tr>
<td>-XX:+UseG1GC</td>
<td>G1垃圾回收器</td>
</tr>
</tbody></table>
<h2 id="对象分配规则是什么？"><a href="#对象分配规则是什么？" class="headerlink" title="对象分配规则是什么？"></a>对象分配规则是什么？</h2><blockquote>
<p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「3.6 对象分配与回收策略」</a> 。</p>
</blockquote>
<ul>
<li><p>对象优先分配在 Eden 区。</p>
<blockquote>
<p>如果 Eden 区无法分配，那么尝试把活着的对象放到 Survivor0 中去（Minor GC）</p>
<ul>
<li>如果 Survivor0 可以放入，那么放入之后清除 Eden 区。</li>
<li>如果 Survivor0 不可以放入，那么尝试把 Eden 和 Survivor0 的存活对象放到 Survivor1 中。<ul>
<li>如果 Survivor1 可以放入，那么放入 Survivor1 之后清除 Eden 和 Survivor0 ，之后再把 Survivor1 中的对象复制到 Survivor0 中，保持 Survivor1 一直为空。</li>
<li>如果 Survivor1 不可以放入，那么直接把它们放入到老年代中，并清除 Eden 和 Survivor0 ，这个过程也称为<strong>分配担保</strong>。</li>
</ul>
</li>
</ul>
<p>ps：清除 Eden、Survivor 区，就是 Minor GC 。</p>
<p>总结来说，分配的顺序是：新生代（Eden =&gt; Survivor0 =&gt; Survivor1）=&gt; 老年代</p>
</blockquote>
</li>
<li><p>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。</p>
<blockquote>
<p>这样做的目的是，避免在 Eden 区和两个 Survivor 区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</p>
</blockquote>
</li>
<li><p>长期存活的对象进入老年代。</p>
<blockquote>
<p>虚拟机为每个对象定义了一个年龄计数器，如果对象经过了 1 次 Minor GC 那么对象会进入 Survivor 区，之后每经过一次 Minor GC 那么对象的年龄加 1 ，知道达到阀值对象进入老年区。</p>
</blockquote>
</li>
<li><p>动态判断对象的年龄。</p>
<blockquote>
<p>为了更好的适用不同程序的内存情况，虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代。</p>
<p>如果 Survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</p>
</blockquote>
</li>
<li><p>空间分配担保。</p>
<blockquote>
<p>每次进行 Minor GC 时，JVM 会计算 Survivor 区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次 Full GC ，如果小于检查 HandlePromotionFailure 设置，如果 <code>true</code> 则只进行 Monitor GC ，如果 <code>false</code> 则进行 Full GC 。</p>
</blockquote>
</li>
</ul>
<p>如下是一张对象创建时，分配内存的图：<a href="http://static2.iocoder.cn/bc22a30cbe93b8dedda080144a73b613"><img src="http://cdn.tuwenbin.vip/20201006094112" alt="内存分配"></a>内存分配</p>
<p>🦅 <strong>为什么新生代内存需要有两个 Survivor 区？</strong></p>
<p>详细的原因，可以看 <a href="https://blog.csdn.net/qq_27093465/article/details/79802884">《为什么新生代内存需要有两个 Survivor 区》</a> 文章。</p>
<h2 id="什么是新生代-GC-和老年代-GC？"><a href="#什么是新生代-GC-和老年代-GC？" class="headerlink" title="什么是新生代 GC 和老年代 GC？"></a>什么是新生代 GC 和老年代 GC？</h2><p>GC 经常发生的区域是堆区，堆区还可以细分为</p>
<p><a href="http://static2.iocoder.cn/67796f9fc657b7b4dd0054f561248f5b"><img src="http://cdn.tuwenbin.vip/20201006094115" alt="堆"></a>堆</p>
<ul>
<li>新生代<ul>
<li>一个 Eden 区</li>
<li>两个 Survivor 区</li>
</ul>
</li>
<li>老年代</li>
</ul>
<blockquote>
<p>默认新生代(Young)与老年代(Old)的比例的值为 <code>1:2</code> (该值可以通过参数 <code>–XX:NewRatio</code> 来指定)。</p>
<p>默认的 <code>Eden:from:to=8:1:1</code> (可以通过参数 <code>–XX:SurvivorRatio</code> 来设定)。</p>
</blockquote>
<p><strong>新生代GC（MinorGC/YoungGC）</strong>：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 MinorGC 非常频繁，一般回收速度也比较快。</p>
<p><strong>老年代GC（MajorGC/FullGC）</strong>：指发生在老年代的 GC，出现了  MajorGC，经常会伴随至少一次的 MinorGC（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行  MajorGC 的策略选择过程）。MajorGC 的速度一般会比 MinorGC 慢 10 倍以上。</p>
<p>🦅 <strong>什么情况下会出现 Young GC？</strong></p>
<p>对象优先在新生代 Eden 区中分配，如果 Eden 区没有足够的空间时，就会触发一次 Young GC 。</p>
<p>🦅 <strong>什么情况下回出现 Full GC？</strong></p>
<p>Full GC 的触发条件有多个，FULL GC 的时候会 STOP THE WORD 。</p>
<ul>
<li>1、在执行 Young GC 之前，JVM 会进行空间分配担保——如果老年代的连续空间小于新生代对象的总大小（或历次晋升的平均大小），则触发一次 Full GC 。</li>
<li>2、大对象直接进入老年代，从年轻代晋升上来的老对象，尝试在老年代分配内存时，但是老年代内存空间不够。</li>
<li>3、显式调用 <code>System#gc()</code> 方法时。</li>
</ul>
<h1 id="虚拟机性能监控与故障处理工具"><a href="#虚拟机性能监控与故障处理工具" class="headerlink" title="虚拟机性能监控与故障处理工具"></a>虚拟机性能监控与故障处理工具</h1><h2 id="JDK-的命令行工具有哪些可以监控虚拟机？"><a href="#JDK-的命令行工具有哪些可以监控虚拟机？" class="headerlink" title="JDK 的命令行工具有哪些可以监控虚拟机？"></a>JDK 的命令行工具有哪些可以监控虚拟机？</h2><blockquote>
<p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「4.2 JDK 的命令行工具」</a> 。</p>
</blockquote>
<ul>
<li><p>jps ：虚拟机进程状况工具</p>
<blockquote>
<p>JVM Process Status Tool ，显示指定系统内所有的HotSpot虚拟机进程。</p>
</blockquote>
</li>
<li><p>jstat ：虚拟机统计信息监控工具</p>
<blockquote>
<p>JVM statistics Monitoring ，是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p>
</blockquote>
</li>
<li><p>jinfo ：Java 配置信息工具</p>
<blockquote>
<p>JVM Configuration info ，这个命令作用是实时查看和调整虚拟机运行参数。</p>
</blockquote>
</li>
<li><p>jmap ：Java 内存映射工具</p>
<blockquote>
<p>JVM Memory Map ，命令用于生成 heap dump 文件。</p>
</blockquote>
</li>
<li><p>jhat ：虚拟机堆转储快照分析工具</p>
<blockquote>
<p>JVM Heap Analysis Tool ，命令是与 jmap 搭配使用，用来分析 jmap 生成的 dump 文件。jhat 内置了一个微型 的HTTP/HTML 服务器，生成 dump 的分析结果后，可以在浏览器中查看。</p>
</blockquote>
</li>
<li><p>jstack ：Java 堆栈跟踪工具</p>
<blockquote>
<p>Java Stack Trace ，用于生成 Java 虚拟机当前时刻的线程快照。</p>
</blockquote>
</li>
<li><p>HSDIS ：JIT 生成代码反编译</p>
</li>
</ul>
<h2 id="JDK-的可视化工具有哪些可以监控虚拟机？"><a href="#JDK-的可视化工具有哪些可以监控虚拟机？" class="headerlink" title="JDK 的可视化工具有哪些可以监控虚拟机？"></a>JDK 的可视化工具有哪些可以监控虚拟机？</h2><blockquote>
<p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「4.3 JDK 的可视化工具」</a> 。</p>
</blockquote>
<ul>
<li><p>Java 自带</p>
<ul>
<li><p>JConsole ：Java 监视与管理控制台</p>
<blockquote>
<p>Java Monitoring and Management Console 是从 Java5 开始，在 JDK 中自带的 Java 监控和管理控制台，用于对 JVM 中内存，线程和类等的监控。</p>
</blockquote>
</li>
<li><p><a href="https://blog.csdn.net/a19881029/article/details/8432368/">VisualVM</a> ：多合一故障处理工具</p>
<blockquote>
<p>JDK 自带全能工具，可以分析内存快照、线程快照、监控内存变化、GC变化等。</p>
<p>特别是 BTrace 插件，动态跟踪分析工具。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>第三方</p>
<ul>
<li><p>MAT ：内存分析工具</p>
<blockquote>
<p>Memory Analyzer Tool ，一个基于 Eclipse 的内存分析工具，是一个快速、功能丰富的 Java heap 分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。</p>
</blockquote>
</li>
<li><p>[GChisto](<a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/GC">http://svip.iocoder.cn/Java/VirtualMachine/Interview/GC</a> 日志分析工具 —— GChisto) ：一款专业分析 GC 日志的工具。</p>
</li>
</ul>
</li>
</ul>
<p>另外，一些开源项目，例如 <a href="https://github.com/apache/incubator-skywalking">SkyWalking</a>、<a href="https://github.com/dianping/cat">Cat</a> ，也提供了 JVM 监控的功能，更加适合生产环境，对 JVM 的监控。</p>
<h2 id="怎么获取-Java-程序使用的内存？"><a href="#怎么获取-Java-程序使用的内存？" class="headerlink" title="怎么获取 Java 程序使用的内存？"></a>怎么获取 Java 程序使用的内存？</h2><p>可以通过 <code>java.lang.Runtime</code> 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。</p>
<ul>
<li><code>Runtime#freeMemory()</code> 方法，返回剩余空间的字节数。</li>
<li><code>Runtime#totalMemory()</code> 方法，总内存的字节数。</li>
<li><code>Runtime#maxMemory()</code> 方法，返回最大内存的字节数。</li>
</ul>
<h1 id="调优案例分析与实战"><a href="#调优案例分析与实战" class="headerlink" title="调优案例分析与实战"></a>调优案例分析与实战</h1><p>在 <a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「第5章 调优案例分析与实战」</a> 中，已经提供了一些案例，建议胖友可以看看。</p>
<h2 id="常见-GC-的优化配置？"><a href="#常见-GC-的优化配置？" class="headerlink" title="常见 GC 的优化配置？"></a>常见 GC 的优化配置？</h2><table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-Xms</td>
<td>初始化堆内存大小</td>
</tr>
<tr>
<td>-Xmx</td>
<td>堆内存最大值</td>
</tr>
<tr>
<td>-Xmn</td>
<td>新生代大小</td>
</tr>
<tr>
<td>-XX:PermSize</td>
<td>初始化永久代大小</td>
</tr>
<tr>
<td>-XX:MaxPermSize</td>
<td>永久代最大容量</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>设置年轻代中 Eden 区与 Survivor 区的比值</td>
</tr>
<tr>
<td>-XX:Xmn</td>
<td>设置年轻代大小</td>
</tr>
</tbody></table>
<p>另外，也可以看看 <a href="https://blog.csdn.net/zhaojw_420/article/details/70527138">《JVM 调优》</a> 文章。</p>
<h2 id="如何排查线程-Full-GC-频繁的问题？"><a href="#如何排查线程-Full-GC-频繁的问题？" class="headerlink" title="如何排查线程 Full GC 频繁的问题？"></a>如何排查线程 Full GC 频繁的问题？</h2><ul>
<li><a href="https://blog.csdn.net/wilsonpeng3/article/details/70064336/">《线上 Full GC 频繁的排查》</a></li>
<li><a href="https://blog.csdn.net/chenleixing/article/details/46706039/">《触发 JVM 进行 Full GC 的情况及应对策略》</a></li>
</ul>
<p>🦅 <strong>JVM 的永久代中会发生垃圾回收么？</strong></p>
<ul>
<li><p><strong>Young GC</strong> 不会发生在永久代。</p>
</li>
<li><p>如果永久代满了或者是超过了临界值，会触发完全垃圾回收(<strong>Full GC</strong>)。如果我们仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免 Full GC 是非常重要的原因。</p>
<blockquote>
<p>Java8 ：从永久代到元数据区 (注：Java8 中已经移除了永久代，新加了一个叫做元数据区的 native 内存区)。</p>
</blockquote>
</li>
</ul>
<h2 id="有看过-GC-日志么？"><a href="#有看过-GC-日志么？" class="headerlink" title="有看过 GC 日志么？"></a>有看过 GC 日志么？</h2><blockquote>
<p>艿艿：这个问题，一般面试不会问，加进来，主要让胖友知道，有这么个知识点。</p>
</blockquote>
<p>参见文章如下：</p>
<ul>
<li>[《<a href="https://www.jianshu.com/p/fd1d4f21733a">JVM]理解GC日志》</a></li>
<li><a href="https://blog.csdn.net/TimHeath/article/details/53053106">《GC 日志查看分析》</a></li>
</ul>
<h2 id="TODO-JVM-线程案例"><a href="#TODO-JVM-线程案例" class="headerlink" title="TODO JVM 线程案例"></a>TODO JVM 线程案例</h2><p>TODO 问晓峰<br>TODO 问阿牛<br>TODO 问狼哥<br>TODO 问闪电侠<br>TODO 问超哥</p>
<h1 id="TODO-类文件结构"><a href="#TODO-类文件结构" class="headerlink" title="TODO 类文件结构"></a>TODO 类文件结构</h1><h1 id="TODO-虚拟机类加载机制"><a href="#TODO-虚拟机类加载机制" class="headerlink" title="TODO 虚拟机类加载机制"></a>TODO 虚拟机类加载机制</h1><blockquote>
<p>类加载器，是面试的重点，所以要掌握好。当然，相对来说难度也不算上~</p>
</blockquote>
<h2 id="类加载器是有了解吗？"><a href="#类加载器是有了解吗？" class="headerlink" title="类加载器是有了解吗？"></a>类加载器是有了解吗？</h2><blockquote>
<p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「7.4 类加载器」</a> 。</p>
</blockquote>
<p>类加载器(ClassLoader)，用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序(<code>.java</code> 文件)在经过 Java 编译器编译之后就被转换成 Java 字节代码(<code>.class</code> 文件)。</p>
<p>类加载器，负责读取 Java 字节代码，并转换成 <code>java.lang.Class</code> 类的一个实例。</p>
<ul>
<li>每个这样的实例用来表示一个 Java 类。通过此实例的 <code>Class#newInstance(...)</code> 方法，就可以创建出该类的一个对象。</li>
<li>实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</li>
</ul>
<h2 id="类加载发生的时机是什么时候？"><a href="#类加载发生的时机是什么时候？" class="headerlink" title="类加载发生的时机是什么时候？"></a>类加载发生的时机是什么时候？</h2><blockquote>
<p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「7.2 类加载的时机」</a> 。</p>
</blockquote>
<p>虚拟机严格规定，有且仅有 5 种情况必须对类进行加载：</p>
<blockquote>
<p>注意，有些文章会称为对类进行“初始化”。</p>
</blockquote>
<ul>
<li>1、遇到 <code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code> 这四条字节码指令时，如果类还没进行初始化，则需要先触发其初始化。</li>
<li>2、使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用的时候，如果类还没进行初始化，则需要先触发其初始化。</li>
<li>3、当初始化了一个类的时候，如果发现其父类还没进行初始化，则需要先触发其父类的初始化。</li>
<li>4、当虚拟机启动时，用户需要指定一个执行的主类，即调用其 <code>#main(String[] args)</code> 方法，虚拟机则会先初始化该主类。</li>
<li>5、当使用 JDK7 的动态语言支持时，如果一个 <code>java.lang.invoke.MethodHandle</code> 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ul>
<h2 id="类加载器是如何加载-Class-文件的？"><a href="#类加载器是如何加载-Class-文件的？" class="headerlink" title="类加载器是如何加载 Class 文件的？"></a>类加载器是如何加载 Class 文件的？</h2><blockquote>
<p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「7.2 类加载的时机」</a> 。</p>
</blockquote>
<p>下图所示是 ClassLoader 加载一个 <code>.class</code> 文件到 JVM 时需要经过的步骤：</p>
<p><a href="http://static2.iocoder.cn/images/JDK/2020_02_10/08.png"><img src="http://cdn.tuwenbin.vip/20201006094123.png" alt="类加载器是如何加载 class 文件"></a>类加载器是如何加载 class 文件</p>
<ul>
<li><p>第一个阶段，加载(Loading)，是找到 <code>.class</code> 文件并把这个文件包含的字节码加载到内存中。</p>
</li>
<li><p>第二阶段，连接(Linking)，又可以分为三个步骤，分别是字节码验证、Class 类数据结构分析及相应的内存分配、最后的符号表的解析。</p>
</li>
<li><p>第三阶段，Initialization(类中静态属性和初始化赋值)，以及Using(静态块的执行)等。</p>
<blockquote>
<p>注意，不包括卸载(Unloading)部分。</p>
</blockquote>
</li>
</ul>
<p>🦅 <strong>1）加载</strong></p>
<blockquote>
<p>加载是“类加载”过程的第一阶段，胖友不要混淆这两个名字。</p>
</blockquote>
<p>在加载阶段，虚拟机需要完成以下三件事情：</p>
<ul>
<li>通过一个类的全限定名来获取其定义的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在Java堆中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为对方法区中这些数据的访问入口。</li>
</ul>
<p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个 <code>java.lang.Class</code> 类的对象，这样便可以通过该对象访问方法区中的这些数据。</p>
<p>🦅 <strong>2）加载</strong></p>
<p><strong>2.1 验证：确保被加载的类的正确性</strong></p>
<p>验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>验证阶段大致会完成4个阶段的检验动作：</p>
<ul>
<li>文件格式验证：验证字节流是否符合 Class 文件格式的规范。例如：是否以 <code>0xCAFEBABE</code> 开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>
<li>元数据验证：对字节码描述的信息进行语义分析（注意：对比 javac 编译阶段的语义分析），以保证其描述的信息符合 Java 语言规范的要求。例如：这个类是否有父类，除了 <code>java.lang.Object</code> 之外。</li>
<li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li>符号引用验证：确保解析动作能正确执行。</li>
</ul>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 <code>-Xverifynone</code> 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<p><strong>2.2 准备：为类的静态变量分配内存，并将其初始化为默认值</strong></p>
<p>准备阶段，是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>
<ul>
<li><p>1、这时候进行内存分配的仅包括类变量(<code>static</code>)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</p>
<blockquote>
<p>思考下，对于类本身，静态变量就是其属性。</p>
</blockquote>
</li>
<li><p>2、这里所设置的初始值通常情况下是数据类型默认的零值(如 <code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code> 等），而不是被在 Java 代码中被显式地赋予的值。</p>
<p>  假设一个类变量的定义为： <code>public static int value = 3</code>。那么静态变量 <code>value</code> 在准备阶段过后的初始值为 <code>0</code>，而不是 <code>3</code>。因为这时候尚未开始执行任何 Java 方法，而把 <code>value</code> 赋值为 <code>3</code> 的 <code>public static</code> 指令是在程序编译后，存放于<strong>类构造器</strong> <code>&lt;clinit&gt;()</code> 方法之中的，所以把 <code>value</code> 赋值为 <code>3</code> 的动作将在初始化阶段才会执行。</p>
<blockquote>
<p>这里还需要注意如下几点：</p>
<ul>
<li>对基本数据类型来说，对于类变量(<code>static</code>)和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li>
<li>对于同时被 <code>static</code> 和 <code>final</code> 修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被 <code>final</code> 修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li>
<li>对于引用数据类型 reference 来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的空值，即 <code>null</code> 。</li>
<li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的“空”值。</li>
</ul>
</blockquote>
</li>
<li><p>3、如果类字段的字段属性表中存在 ConstantValue 属性，即同时被 <code>final</code> 和 <code>static</code> 修饰，那么在准备阶段变量 <code>value</code> 就会被初始化为 ConstValue 属性所指定的值。</p>
<p>  假设上面的类变量 <code>value</code> 被定义为： <code>public static final int value = 3</code> 。编译时， <code>javac</code> 将会为 <code>value</code> 生成 ConstantValue 属性。在准备阶段虚拟机就会根据 ConstantValue 的设置将 <code>value</code> 赋值为 3。我们可以理解为 <code>static final</code> 常量在编译期就将其结果放入了调用它的类的常量池中。</p>
</li>
</ul>
<p><strong>2.3 解析：把类中的符号引用转换为直接引用</strong></p>
<blockquote>
<p>这个步骤，艿艿看的也有点懵逼。</p>
<p>R 大在 <a href="https://www.zhihu.com/question/50258991">《JVM 符号引用转换直接引用的过程?》</a> 和 <a href="https://www.zhihu.com/question/30300585">《JVM 里的符号引用如何存储？》</a> 做过解答，看的还是懵逼。</p>
</blockquote>
<p>解析阶段，是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作，主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行。</p>
<ul>
<li>符号引用，就是一组符号来描述目标，可以是任何字面量。</li>
<li>直接引用，就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li>
</ul>
<p>🦅 <strong>3）初始化</strong></p>
<p>初始化，为类的静态变量赋予正确的初始值，JVM 负责对类进行初始化，主要对类变量进行初始化。在 Java 中对类变量进行初始值设定有两种方式：</p>
<ul>
<li>1、声明类变量是指定初始值。</li>
<li>2、使用静态代码块为类变量指定初始值。</li>
</ul>
<p>JVM 初始化步骤：</p>
<ul>
<li>1、假如这个类还没有被加载和连接，则程序先加载并连接该类。</li>
<li>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类。</li>
<li>3、假如类中有初始化语句，则系统依次执行这些初始化语句。</li>
</ul>
<h2 id="什么是双亲委派模型（Parent-Delegation-Model）？"><a href="#什么是双亲委派模型（Parent-Delegation-Model）？" class="headerlink" title="什么是双亲委派模型（Parent Delegation Model）？"></a>什么是双亲委派模型（Parent Delegation Model）？</h2><blockquote>
<p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「7.4.2 双亲委派模型」</a> 。</p>
</blockquote>
<p>类加载器 ClassLoader 是具有层次结构的，也就是父子关系，如下图所示：</p>
<p><a href="http://static2.iocoder.cn/images/JDK/2020_02_10/09.png"><img src="http://cdn.tuwenbin.vip/20201006094129.png" alt="双亲委派模型"></a>双亲委派模型</p>
<ul>
<li><p>Bootstrap ClassLoader ：根类加载器，负责加载 Java 的核心类，它不是 <code>java.lang.ClassLoader</code> 的子类，而是由 JVM 自身实现。</p>
<blockquote>
<p>此处，说的是 Hotspot 的情况下。</p>
</blockquote>
</li>
<li><p>Extension ClassLoader ：扩展类加载器，扩展类加载器的加载路径是 JDK 目录下 <code>jre/lib/ext</code> 。扩展加载器的 <code>#getParent()</code> 方法返回 <code>null</code> ，实际上扩展类加载器的父类加载器是根加载器，只是根加载器并不是 Java 实现的。</p>
</li>
<li><p>System ClassLoader ：系统(应用)类加载器，它负责在 JVM 启动时加载来自 Java 命令的 <code>-classpath</code> 选项、<code>java.class.path</code> 系统属性或 <code>CLASSPATH</code> 环境变量所指定的 jar 包和类路径。程序可以通过 <code>#getSystemClassLoader()</code> 来获取系统类加载器。系统加载器的加载路径是程序运行的当前路径。</p>
</li>
<li><p>该模型要求除了顶层的 Bootstrap 启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。简略代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; java.lang.ClassLoader<br><br>public abstract class ClassLoader &#123;<br><br>    &#x2F;&#x2F; ... 省略其它代码<br><br>    &#x2F;&#x2F; The parent class loader for delegation<br>    &#x2F;&#x2F; Note: VM hardcoded the offset of this field, thus all new fields<br>    &#x2F;&#x2F; must be added *after* it.<br>    private final ClassLoader parent;<br><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>每个类加载器都有自己的命名空间（由该加载器及所有父类加载器所加载的类组成。</p>
<ul>
<li>在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类。</li>
<li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类）。</li>
<li>类加载器负责加载所有的类，同一个类(一个类用其全限定类名(包名加类名)标志)只会被加载一次。</li>
</ul>
</li>
</ul>
<p>🦅 <strong>Java 虚拟机是如何判定两个 Java 类是相同的？</strong></p>
<p>Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。<strong>只有两者都相同的情况，才认为两个类是相同的</strong>。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。</p>
<p>比如一个 Java 类 <code>com.example.Sample</code> ，编译之后生成了字节代码文件 <code>Sample.class</code> 。两个不同的类加载器 ClassLoaderA 和  ClassLoaderB 分别读取了这个 <code>Sample.class</code> 文件，并定义出两个 <code>java.lang.Class</code> 类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException 。</p>
<p>🦅 <strong>双亲委派模型的工作过程？</strong></p>
<ul>
<li><p>1、当前 ClassLoader 首先从自己已经加载的类中，查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。</p>
<blockquote>
<p>每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，等下次加载的时候就可以直接返回了。</p>
</blockquote>
</li>
<li><p>2、当前 ClassLoader 的缓存中没有找到被加载的类的时候</p>
<ul>
<li>委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 bootstrap ClassLoader。</li>
<li>当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。</li>
</ul>
</li>
</ul>
<p>让我们来简单撸下源码。代码如下：</p>
<blockquote>
<p>艿艿：要不要跟面试官吹下，自己看过源码得知~</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; java.lang.ClassLoader<br>&#x2F;&#x2F; 删除部分无关代码<br><br>protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123;<br>    synchronized (getClassLoadingLock(name)) &#123;<br>        &#x2F;&#x2F; 首先，从缓存中获得 name 对应的类<br>        Class&lt;?&gt; c &#x3D; findLoadedClass(name);<br>        if (c &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 获得不到<br>            try &#123;<br>                &#x2F;&#x2F; 其次，如果父类非空，使用它去加载类<br>                if (parent !&#x3D; null) &#123;<br>                    c &#x3D; parent.loadClass(name, false);<br>                &#x2F;&#x2F; 其次，如果父类为空，使用 Bootstrap 去加载类<br>                &#125; else &#123;<br>                    c &#x3D; findBootstrapClassOrNull(name);<br>                &#125;<br>            &#125; catch (ClassNotFoundException e) &#123;<br>            &#125;<br><br>            if (c &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 还是加载不到<br>                &#x2F;&#x2F; 最差，使用自己去加载类<br>                c &#x3D; findClass(name);<br>            &#125;<br>        &#125;<br>        &#x2F;&#x2F; 如果要解析类，则进行解析<br>        if (resolve) &#123;<br>            resolveClass(c);<br>        &#125;<br>        return c;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>🦅 <strong>为什么优先使用父 ClassLoader 加载类？</strong></p>
<ul>
<li><p>1、共享功能：可以避免重复加载，当父亲已经加载了该类的时候，子类不需要再次加载，一些 Framework 层级的类一旦被顶层的 ClassLoader 加载过就缓存在内存里面，以后任何地方用到都不需要重新加载。</p>
</li>
<li><p>2、隔离功能：主要是为了安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String  ，同时也避免了重复加载，因为 JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader  加载就是不同的两个类，如果相互转型的话会抛 <code>java.lang.ClassCaseException</code> 。</p>
<blockquote>
<p>这也就是说，即使我们自己定义了一个 <code>java.util.String</code> 类，也不会被重复加载。</p>
</blockquote>
</li>
</ul>
<h2 id="什么是破坏双亲委托模型？"><a href="#什么是破坏双亲委托模型？" class="headerlink" title="什么是破坏双亲委托模型？"></a>什么是破坏双亲委托模型？</h2><blockquote>
<p><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「7.4.3 破坏双亲委派模型」</a> 。</p>
</blockquote>
<p>正如我们上面看到的源码，破坏双亲委托模型，需要做的是，<code>#loadClass(String name, boolean resolve)</code> 方法中，不调用父 <code>parent</code> ClassLoader 方法去加载类，那么就成功了。那么我们要做的仅仅是，错误的覆盖 <code>##loadClass(String name, boolean resolve)</code> 方法，不去使用父 <code>parent</code> ClassLoader 方法去加载类即可。</p>
<p>想要深入的胖友，可以深入看看如下文章：</p>
<ul>
<li><a href="https://blog.csdn.net/dangwanma6489/article/details/80244981">《Tomcat 类加载器之为何违背双亲委派模型》</a></li>
<li><a href="https://blog.csdn.net/yangcheng33/article/details/52631940">《真正理解线程上下文类加载器（多案例分析）》</a> 提供了多种打破双亲委托模型的案例。</li>
<li><a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview/#">「第 9 章 类加载及执行子系统的案例与实战」</a></li>
</ul>
<p>🦅 <strong>如何自定义 ClassLoader 类？</strong></p>
<p>直接参考 <a href="https://www.jianshu.com/p/3036b46f1188">《Java 自定义 ClassLoader 实现 JVM 类加载》</a> 文章即可。</p>
<p>🦅 <strong>OSGI 如何实现模块化热部署？</strong></p>
<blockquote>
<p>艿艿：了解即可。</p>
</blockquote>
<p>OSGI 实现模块化热部署的关键，是它自定义的类加载器机制的实现。每一个程序模块都有一个自己的类加载器，当需要等换一个模块时，就把模块连同类加载器一起换掉以实现代码的热替换。</p>
<h1 id="TODO-虚拟机字节码执行引擎"><a href="#TODO-虚拟机字节码执行引擎" class="headerlink" title="TODO 虚拟机字节码执行引擎"></a>TODO 虚拟机字节码执行引擎</h1><h1 id="TODO-早期（编译期）优化"><a href="#TODO-早期（编译期）优化" class="headerlink" title="TODO 早期（编译期）优化"></a>TODO 早期（编译期）优化</h1><h2 id="TODO-JIT"><a href="#TODO-JIT" class="headerlink" title="TODO JIT"></a>TODO JIT</h2><p>有时我们会听到 JIT 这个概念，并说它是 JVM 的一部分，这让我们很困惑。JIT 是 JVM  的一部分，它可以在同一时间编译类似的字节码来优化将字节码转换为机器特定语言的过程相似的字节码，从而将优化字节码转换为机器特定语言的过程，这样减少转换过程所需要花费的时间。</p>
<h1 id="TODO-晚期（运行期）优化"><a href="#TODO-晚期（运行期）优化" class="headerlink" title="TODO 晚期（运行期）优化"></a>TODO 晚期（运行期）优化</h1><h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>总的来说，JVM 主要提问的点，如下脑图：</p>
<p><a href="http://static2.iocoder.cn/f20e86724ff310733d7556bd203dc061"><img src="http://cdn.tuwenbin.vip/20201006094136" alt="脑图"></a>脑图</p>
<p>参考与推荐如下文章：</p>
<ul>
<li><a href="https://www.cnblogs.com/wmyskxz/p/9045972.html">《Java 面试知识点解析(三)——JVM篇》</a></li>
<li><a href="https://www.jianshu.com/p/54eb60cfa7bd">《总结的 JVM 面试题》</a></li>
<li><a href="https://troywu0.gitbooks.io/spark/content/java%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E8%BF%87%E7%A8%8B.html">《JAVA 对象创建的过程》</a></li>
<li><a href="https://www.cnblogs.com/smyhvae/p/4810168.html">《Java 虚拟机详解 —— JVM 常见问题总结》</a></li>
</ul>
]]></content>
      <categories>
        <category>虚拟机</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>精尽 Spring 面试题</title>
    <url>/2016/10/12/%E7%B2%BE%E5%B0%BD%20Spring%20%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="精尽-Spring-面试题"><a href="#精尽-Spring-面试题" class="headerlink" title="精尽 Spring 面试题"></a>精尽 Spring 面试题</h1><p>以下面试题，基于网络整理，和自己编辑。具体参考的文章，会在文末给出所有的链接。</p>
<p>如果胖友有自己的疑问，欢迎在星球提问，我们一起整理吊吊的 Spring 面试题的大保健。</p>
<p>而题目的难度，艿艿尽量按照从容易到困难的顺序，逐步下去。</p>
<blockquote>
<p>注意 1 ，这个面试题，暂时不包括 Spring MVC 部分。主要以 Spring IoC、Spring AOP、Spring Transaction 为主。</p>
<p>注意 2 ，T T Spring 怎么会有这么多问题，艿艿自己面试很多都不太问，跟背书一样。所以整理的过程，真的是痛苦万分。</p>
</blockquote>
<p>Spring 是一个很庞大的技术体系，可以说包容一切，所以本文我们按照下面的顺序，罗列各种面试题：</p>
<ul>
<li>Spring <strong>整体</strong>相关的面试</li>
<li>Spring <strong>IoC</strong> 相关的面试题</li>
<li>Spring <strong>AOP</strong> 相关的面试题</li>
<li>Spring <strong>Transaction</strong> 相关的面试题</li>
<li>Spring <strong>Data Access</strong> 相关的面试题</li>
</ul>
<h1 id="Spring-整体"><a href="#Spring-整体" class="headerlink" title="Spring 整体"></a>Spring 整体</h1><h2 id="什么是-Spring-Framework？"><a href="#什么是-Spring-Framework？" class="headerlink" title="什么是 Spring Framework？"></a>什么是 Spring Framework？</h2><p>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</p>
<ul>
<li><p>它是轻量级、松散耦合的。</p>
<blockquote>
<p>它的轻量级主要是相对于 EJB 。随着 Spring 的体系越来越庞大，大家被 Spring 的配置搞懵逼了，所以后来出了 Spring Boot 。</p>
</blockquote>
</li>
<li><p>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。</p>
</li>
<li><p>它可以集成其他框架，如 Spring MVC、Hibernate、MyBatis 等，所以又称为框架的框架( 粘合剂、脚手架 )。</p>
</li>
</ul>
<h2 id="Spring-Framework-中有多少个模块，它们分别是什么？"><a href="#Spring-Framework-中有多少个模块，它们分别是什么？" class="headerlink" title="Spring Framework 中有多少个模块，它们分别是什么？"></a>Spring Framework 中有多少个模块，它们分别是什么？</h2><p>如下是一张比较早期版本的 Spring Framework 的模块图：</p>
<blockquote>
<p>艿艿：因为它的配色比较好看，哈哈哈哈。所以，没自己画一个最新的。</p>
</blockquote>
<p><img src="http://cdn.tuwenbin.vip/hyxytp5m.bmp" alt="hyxytp5m">Spring Framework</p>
<p>我们按照一个一个分块来说。</p>
<p><strong>Spring 核心容器</strong></p>
<blockquote>
<p>对应图中，Core Container 。</p>
</blockquote>
<p>该层基本上是 Spring Framework 的核心。它包含以下模块：</p>
<ul>
<li><p>Spring Core</p>
</li>
<li><p>Spring Bean</p>
<blockquote>
<p>核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC）模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 </p>
</blockquote>
</li>
<li><p>Spring Context</p>
<blockquote>
<p>Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、事件机制、校验和调度功能。  </p>
</blockquote>
</li>
<li><p>SpEL (Spring Expression Language)</p>
<blockquote>
<p>Spring 表达式语言全称为 “Spring Expression Language”，缩写为 “SpEL” ，类似于 Struts2  中使用的 OGNL 表达式语言，能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与 Spring 功能完美整合，如能用来配置  Bean 定义。</p>
</blockquote>
</li>
</ul>
<p>或者说，这块就是 Spring IoC 。</p>
<p><strong>数据访问</strong></p>
<blockquote>
<p>对应图中，Data Access 。</p>
</blockquote>
<p>该层提供与数据库交互的支持。它包含以下模块：</p>
<ul>
<li><p>JDBC (Java DataBase Connectivity)</p>
<blockquote>
<p>Spring 对 JDBC 的封装模块，提供了对关系数据库的访问。</p>
</blockquote>
</li>
<li><p>ORM (Object Relational Mapping)</p>
<blockquote>
<p>Spring ORM 模块，提供了对 hibernate5 和 JPA 的集成。</p>
<ul>
<li>hibernate5 是一个 ORM 框架。</li>
<li>JPA 是一个 Java 持久化 API 。</li>
</ul>
</blockquote>
</li>
<li><p>OXM (Object XML Mappers)</p>
<blockquote>
<p>Spring 提供了一套类似 ORM 的映射机制，用来将 Java 对象和 XML 文件进行映射。这就是 Spring 的对象 XML 映射功能，有时候也成为 XML 的序列化和反序列化。</p>
<p>用的比较少，胖友了解下即可。</p>
</blockquote>
</li>
<li><p>Transaction</p>
<blockquote>
<p>Spring 简单而强大的事务管理功能，包括声明式事务和编程式事务。 </p>
</blockquote>
</li>
</ul>
<p><strong>Web</strong></p>
<p>该层提供了创建 Web 应用程序的支持。它包含以下模块：</p>
<ul>
<li><p>WebMVC</p>
<blockquote>
<p>MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。 </p>
</blockquote>
</li>
<li><p>WebFlux</p>
<blockquote>
<p>基于 Reactive 库的响应式的 Web 开发框架 </p>
<p>不了解的胖友，可以看看 <a href="https://www.ibm.com/developerworks/cn/java/spring5-webflux-reactive/index.html">《使用 Spring 5 的 WebFlux 开发反应式 Web 应用》</a></p>
</blockquote>
</li>
<li><p>WebSocket</p>
<blockquote>
<p>Spring 4.0 的一个最大更新是增加了对 Websocket 的支持。</p>
<p>Websocket 提供了一个在 Web 应用中实现高效、双向通讯，需考虑客户端(浏览器)和服务端之间高频和低延时消息交换的机制。</p>
<p>一般的应用场景有：在线交易、网页聊天、游戏、协作、数据可视化等。</p>
</blockquote>
</li>
<li><p><del>Portlet</del> 已经废弃</p>
</li>
</ul>
<p><strong>AOP</strong></p>
<p>该层支持面向切面编程。它包含以下模块：</p>
<ul>
<li><p>AOP</p>
<blockquote>
<p>通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。</p>
<p>Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。 </p>
</blockquote>
</li>
<li><p>Aspects </p>
<blockquote>
<p>该模块为与 AspectJ 的集成提供支持。</p>
</blockquote>
</li>
<li><p>Instrumentation</p>
<blockquote>
<p>该层为类检测和类加载器实现提供支持。</p>
<p>用的比较少，胖友了解下即可。</p>
</blockquote>
</li>
</ul>
<p><strong>其它</strong></p>
<ul>
<li><p>JMS (Java Messaging Service)</p>
<blockquote>
<p>提供了一个 JMS 集成框架，简化了 JMS API 的使用。</p>
<p>可能有胖友不太了解 JMS ，可以看看 <a href="https://www.cnblogs.com/chenpi/p/5559349.html">《JMS(Java消息服务)入门教程》</a> 。</p>
</blockquote>
</li>
<li><p>Test</p>
<blockquote>
<p>该模块为使用 JUnit 和 TestNG 进行测试提供支持。</p>
</blockquote>
</li>
<li><p>Messaging</p>
<blockquote>
<p>该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。</p>
</blockquote>
</li>
</ul>
<h2 id="使用-Spring-框架能带来哪些好处？"><a href="#使用-Spring-框架能带来哪些好处？" class="headerlink" title="使用 Spring 框架能带来哪些好处？"></a>使用 Spring 框架能带来哪些好处？</h2><p>下面列举了一些使用 Spring 框架带来的主要好处：</p>
<blockquote>
<p>艿艿：注意，下文中加粗的内容，这是本句话的关键。</p>
</blockquote>
<ul>
<li><strong>DI</strong> ：**<a href="http://howtodoinjava.com/2013/03/19/inversion-of-control-ioc-and-dependency-injection-di-patterns-in-spring-framework-and-related-interview-questions/">Dependency Injection(DI)</a>** 方法，使得构造器和 JavaBean、properties 文件中的依赖关系一目了然。</li>
<li><strong>轻量级</strong>：与 EJB 容器相比较，IoC 容器更加趋向于<strong>轻量级</strong>。这样一来 IoC 容器在有限的内存和 CPU 资源的情况下，进行应用程序的开发和发布就变得十分有利。</li>
<li><strong>面向切面编程(AOP)**： Spring 支持面向</strong>切面编程**，同时把应用的业务逻辑与系统的服务分离开来。</li>
<li><strong>集成主流框架</strong>：Spring 并没有闭门造车，Spring <strong>集成</strong>了已有的技术栈，比如 ORM 框架、Logging 日期框架、J2EE、Quartz 和 JDK Timer ，以及其他视图技术。</li>
<li>模块化：Spring 框架是按照<strong>模块</strong>的形式来组织的。由包和类的命名，就可以看出其所属的模块，开发者仅仅需要选用他们需要的模块即可。</li>
<li><strong>便捷的测试</strong>：要 <a href="http://howtodoinjava.com/2013/04/19/how-to-unit-test-spring-security-authentication-with-junit/">测试一项用Spring开发的应用程序</a> 十分简单，因为<strong>测试</strong>相关的环境代码都已经囊括在框架中了。更加简单的是，利用 JavaBean 形式的 POJO 类，可以很方便的利用依赖注入来写入测试数据。</li>
<li><strong>Web 框架</strong>：Spring 的 <strong>Web 框架</strong>亦是一个精心设计的 Web MVC 框架，为开发者们在 Web 框架的选择上提供了一个除了主流框架比如 Struts 、过度设计的、不流行 Web 框架的以外的有力选项。</li>
<li><strong>事务管理</strong>：Spring 提供了一个便捷的<strong>事务管理</strong>接口，适用于小型的本地事物处理（比如在单 DB 的环境下）和复杂的共同事物处理（比如利用 JTA 的复杂 DB 环境）。</li>
<li><strong>异常处理</strong>：Spring 提供一个方便的 API ，将特定技术的异常(由JDBC, Hibernate, 或 JDO 抛出)转化为一致的、Unchecked 异常。</li>
</ul>
<p>当然，Spring 代码优点的同时，一定会带来相应的缺点：</p>
<ul>
<li><p>每个框架都有的问题，调试阶段不直观，后期的 bug 对应阶段，不容易判断问题所在。要花一定的时间去理解它。</p>
</li>
<li><p>把很多 JavaEE 的东西封装了，在满足快速开发高质量程序的同时，隐藏了实现细节。</p>
<blockquote>
<p>这就导致，很多工程师，离开了 Spring 之后，就不知道怎么工作了。从 Java 工程师，变成了 Spring 工程师。对于有追求的我们，还是需要知其然，知其所以然。</p>
</blockquote>
</li>
</ul>
<h2 id="Spring-框架中都用到了哪些设计模式？"><a href="#Spring-框架中都用到了哪些设计模式？" class="headerlink" title="Spring 框架中都用到了哪些设计模式？"></a>Spring 框架中都用到了哪些设计模式？</h2><p>Spring 框架中使用到了大量的设计模式，下面列举了比较有代表性的：</p>
<ul>
<li>代理模式 — 在 AOP 和 remoting 中被用的比较多。</li>
<li>单例模式 — 在 Spring 配置文件中定义的 Bean 默认为单例模式。</li>
<li>模板方法 — 用来解决代码重复的问题。比如 <a href="http://howtodoinjava.com/2015/02/20/spring-restful-client-resttemplate-example/">RestTemplate</a>、JmsTemplate、JdbcTemplate 。</li>
<li>前端控制器 — Spring提供了 DispatcherServlet 来对请求进行分发。</li>
<li>视图帮助(View Helper) — Spring 提供了一系列的 JSP 标签，高效宏来辅助将分散的代码整合在视图里。</li>
<li>依赖注入 — 贯穿于 BeanFactory / ApplicationContext 接口的核心理念。</li>
<li>工厂模式 — BeanFactory 用来创建对象的实例。</li>
</ul>
<p>当然，感兴趣的胖友，觉得不过瘾，可以看看艿艿基友知秋写的几篇文章：</p>
<ul>
<li><a href="http://www.iocoder.cn/Spring/DesignPattern-1">《Spring 框架中的设计模式(一)》</a></li>
<li><a href="http://www.iocoder.cn/Spring/DesignPattern-2">《Spring 框架中的设计模式(二)》</a></li>
<li><a href="http://www.iocoder.cn/Spring/DesignPattern-3">《Spring 框架中的设计模式(三)》</a></li>
<li><a href="http://www.iocoder.cn/Spring/DesignPattern-4">《Spring 框架中的设计模式(四)》</a></li>
<li><a href="http://www.iocoder.cn/Spring/DesignPattern-5">《Spring 框架中的设计模式(五)》</a></li>
</ul>
<h1 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h1><blockquote>
<p>下面，我们会将分成 IoC 和 Bean 两部分来分享 Spring 容器的内容。</p>
<ul>
<li>IoC ，侧重在于容器。</li>
<li>Bean ，侧重在于被容器管理的 Bean 。</li>
</ul>
</blockquote>
<h2 id="什么是-Spring-IoC-容器？"><a href="#什么是-Spring-IoC-容器？" class="headerlink" title="什么是 Spring IoC 容器？"></a>什么是 Spring IoC 容器？</h2><blockquote>
<p>注意，正确的拼写是 IoC 。</p>
</blockquote>
<p>Spring 框架的核心是 Spring IoC 容器。容器创建 Bean 对象，将它们装配在一起，配置它们并管理它们的完整生命周期。</p>
<ul>
<li>Spring 容器使用<strong>依赖注入</strong>来管理组成应用程序的 Bean 对象。</li>
<li>容器通过读取提供的<strong>配置元数据</strong> Bean Definition 来接收对象进行实例化，配置和组装的指令。</li>
<li>该配置元数据 Bean Definition 可以通过 XML，Java 注解或 Java Config 代码<strong>提供</strong>。</li>
</ul>
<blockquote>
<p>艿艿，注意上面三段段话的<strong>加粗</strong>部分的内容。</p>
</blockquote>
<p><img src="http://cdn.tuwenbin.vip/hlvdxl2z.bmp" alt="hlvdxl2z">Spring IoC</p>
<h2 id="什么是依赖注入？"><a href="#什么是依赖注入？" class="headerlink" title="什么是依赖注入？"></a>什么是依赖注入？</h2><p>在依赖注入中，你不必主动、手动创建对象，但必须描述如何创建它们。</p>
<ul>
<li>你不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。</li>
<li>然后，再由 IoC 容器将它们装配在一起。</li>
</ul>
<p>另外，依赖注入的英文缩写是 Dependency Injection ，简称 DI 。</p>
<h2 id="IoC-和-DI-有什么区别？"><a href="#IoC-和-DI-有什么区别？" class="headerlink" title="IoC 和 DI 有什么区别？"></a>IoC 和 DI 有什么区别？</h2><blockquote>
<p>艿艿的吐槽，最怕这种概念题。下面引用知乎上的一个讨论：<a href="https://www.zhihu.com/question/25392984">《IoC 和DI 有什么区别？》</a></p>
</blockquote>
<p>IoC 是个更宽泛的概念，DI 是更具体的。引用郑烨的一篇博客，引用郑烨的一篇博客，<a href="https://link.zhihu.com/?target=http://dreamhead.blogbus.com/logs/125334.html">我眼中的Spring</a></p>
<blockquote>
<p><strong>Dependency Injection</strong><br>原来，它叫 IoC 。<br>Martin Flower 发话了，是个框架都有 IoC ，这不足以新生容器反转的“如何定位插件的具体实现”，于是，它有了个新名字，Dependency Injection 。</p>
<p>其实，它就是一种将调用者与被调用者分离的思想，Uncle Bob 管它叫DIP（Dependency Inversion Principle），并把它归入OO设计原则。<br>同 Spring 相比，它更早进入我的大脑。一切都是那么朦胧，直至 Spring 出现。  </p>
<p>慢慢的，我知道了它还分为三种：</p>
<ul>
<li>Interface Injection（type 1）</li>
<li>Setter Injection（type 2）</li>
<li>Constructor Injection（type 3）。</li>
</ul>
<p>Martin Flower那篇为它更名的大作让我心目关于它的一切趋于完整。</p>
<p>在 Spring 中，它是一切的基础。Spring 的种种优势随之而来。<br>于我而言，它为我带来更多的是思维方式的转变，恐怕以后我再也无法写出那种一大块的全功能程序了。</p>
</blockquote>
<h2 id="可以通过多少种方式完成依赖注入？"><a href="#可以通过多少种方式完成依赖注入？" class="headerlink" title="可以通过多少种方式完成依赖注入？"></a>可以通过多少种方式完成依赖注入？</h2><p>通常，依赖注入可以通过<strong>三种</strong>方式完成，即：</p>
<blockquote>
<p>上面一个问题的三种方式的英文，下面是三种方式的中文。</p>
</blockquote>
<ul>
<li>接口注入</li>
<li>构造函数注入</li>
<li>setter 注入</li>
</ul>
<p>目前，在 Spring Framework 中，仅使用构造函数和 setter 注入这<strong>两种</strong>方式。</p>
<p>那么这两种方式各有什么优缺点呢？胖友可以简单阅读 <a href="https://my.oschina.net/itblog/blog/203746">《Spring两种依赖注入方式的比较》</a>，不用太较真。综述来说：</p>
<table>
<thead>
<tr>
<th>构造函数注入</th>
<th>setter 注入</th>
</tr>
</thead>
<tbody><tr>
<td>没有部分注入</td>
<td>有部分注入</td>
</tr>
<tr>
<td>不会覆盖 setter 属性</td>
<td>会覆盖 setter 属性</td>
</tr>
<tr>
<td>任意修改都会创建一个新实例</td>
<td>任意修改不会创建一个新实例</td>
</tr>
<tr>
<td>适用于设置很多属性</td>
<td>适用于设置少量属性</td>
</tr>
</tbody></table>
<ul>
<li>实际场景下，setting 注入使用的更多。</li>
</ul>
<h2 id="Spring-中有多少种-IoC-容器？"><a href="#Spring-中有多少种-IoC-容器？" class="headerlink" title="Spring 中有多少种 IoC 容器？"></a>Spring 中有多少种 IoC 容器？</h2><p>Spring 提供了两种( 不是“个” ) IoC 容器，分别是 BeanFactory、ApplicationContext 。</p>
<p><strong>BeanFactory</strong></p>
<blockquote>
<p>BeanFactory 在 <code>spring-beans</code> 项目提供。</p>
</blockquote>
<p>BeanFactory ，就像一个包含 Bean 集合的工厂类。它会在客户端要求时实例化 Bean 对象。</p>
<p><strong>ApplicationContext</strong></p>
<blockquote>
<p>ApplicationContext 在 <code>spring-context</code> 项目提供。</p>
</blockquote>
<p>ApplicationContext 接口扩展了 BeanFactory 接口，它在 BeanFactory 基础上提供了一些额外的功能。内置如下功能：</p>
<ul>
<li>MessageSource ：管理 message ，实现国际化等功能。</li>
<li>ApplicationEventPublisher ：事件发布。</li>
<li>ResourcePatternResolver ：多资源加载。</li>
<li>EnvironmentCapable ：系统 Environment（profile + Properties）相关。</li>
<li>Lifecycle ：管理生命周期。</li>
<li>Closable ：关闭，释放资源</li>
<li>InitializingBean：自定义初始化。</li>
<li>BeanNameAware：设置 beanName 的 Aware 接口。</li>
</ul>
<p>另外，ApplicationContext 会自动初始化非懒加载的 Bean 对象们。</p>
<p>详细的内容，感兴趣的胖友，可以看看 <a href="http://svip.iocoder.cn/Spring/ApplicationContext/">《【死磕 Spring】—— ApplicationContext 相关接口架构分析》</a> 一文。源码之前无秘密。简单总结下 BeanFactory 与 ApplicationContext 两者的差异：</p>
<blockquote>
<p>艿艿：可能很多胖友没看过源码，所以会比较难。</p>
</blockquote>
<table>
<thead>
<tr>
<th>BeanFactory</th>
<th>ApplicationContext</th>
</tr>
</thead>
<tbody><tr>
<td>它使用懒加载</td>
<td>它使用即时加载</td>
</tr>
<tr>
<td>它使用语法显式提供资源对象</td>
<td>它自己创建和管理资源对象</td>
</tr>
<tr>
<td>不支持国际化</td>
<td>支持国际化</td>
</tr>
<tr>
<td>不支持基于依赖的注解</td>
<td>支持基于依赖的注解</td>
</tr>
</tbody></table>
<p>另外，BeanFactory 也被称为<strong>低级</strong>容器，而 ApplicationContext 被称为<strong>高级</strong>容器。</p>
<h2 id="请介绍下常用的-BeanFactory-容器？"><a href="#请介绍下常用的-BeanFactory-容器？" class="headerlink" title="请介绍下常用的 BeanFactory 容器？"></a>请介绍下常用的 BeanFactory 容器？</h2><p>BeanFactory 最常用的是 XmlBeanFactory 。它可以根据 XML 文件中定义的内容，创建相应的 Bean。</p>
<h2 id="请介绍下常用的-ApplicationContext-容器？"><a href="#请介绍下常用的-ApplicationContext-容器？" class="headerlink" title="请介绍下常用的 ApplicationContext 容器？"></a>请介绍下常用的 ApplicationContext 容器？</h2><p>以下是三种较常见的 ApplicationContext 实现方式：</p>
<ul>
<li><p>1、ClassPathXmlApplicationContext ：从 ClassPath 的 XML 配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(“bean.xml”);<br></code></pre></td></tr></table></figure>
</li>
<li><p>2、FileSystemXmlApplicationContext ：由文件系统中的XML配置文件读取上下文。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ApplicationContext context &#x3D; new FileSystemXmlApplicationContext(“bean.xml”);<br></code></pre></td></tr></table></figure>
</li>
<li><p>3、XmlWebApplicationContext ：由 Web 应用的XML文件读取上下文。例如我们在 Spring MVC 使用的情况。</p>
</li>
</ul>
<p>当然，目前我们更多的是使用 Spring Boot 为主，所以使用的是第四种 ApplicationContext 容器，ConfigServletWebServerApplicationContext 。</p>
<h2 id="列举一些-IoC-的一些好处？"><a href="#列举一些-IoC-的一些好处？" class="headerlink" title="列举一些 IoC 的一些好处？"></a>列举一些 IoC 的一些好处？</h2><ul>
<li>它将最小化应用程序中的代码量。</li>
<li>它以最小的影响和最少的侵入机制促进松耦合。</li>
<li>它支持即时的实例化和延迟加载 Bean 对象。</li>
<li>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</li>
</ul>
<h2 id="简述-Spring-IoC-的实现机制？"><a href="#简述-Spring-IoC-的实现机制？" class="headerlink" title="简述 Spring IoC 的实现机制？"></a>简述 Spring IoC 的实现机制？</h2><p>简单来说，Spring 中的 IoC 的实现原理，就是<strong>工厂模式</strong>加<strong>反射机制</strong>。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">interface Fruit &#123;<br><br>     public abstract void eat();<br>     <br>&#125;<br>class Apple implements Fruit &#123;<br><br>    public void eat()&#123;<br>        System.out.println(&quot;Apple&quot;);<br>    &#125;<br>    <br>&#125;<br>class Orange implements Fruit &#123;<br>    public void eat()&#123;<br>        System.out.println(&quot;Orange&quot;);<br>    &#125;<br>&#125;<br><br>class Factory &#123;<br><br>    public static Fruit getInstance(String className) &#123;<br>        Fruit f &#x3D; null;<br>        try &#123;<br>            f &#x3D; (Fruit) Class.forName(className).newInstance();<br>        &#125; catch (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        return f;<br>    &#125;<br>    <br>&#125;<br><br>class Client &#123;<br><br>    public static void main(String[] args) &#123;<br>        Fruit f &#x3D; Factory.getInstance(&quot;io.github.dunwu.spring.Apple&quot;);<br>        if(f !&#x3D; null)&#123;<br>            f.eat();<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Fruit 接口，有 Apple 和 Orange 两个实现类。</li>
<li>Factory 工厂，通过反射机制，创建 <code>className</code> 对应的 Fruit 对象。</li>
<li>Client 通过 Factory 工厂，获得对应的 Fruit 对象。</li>
<li>😈 实际情况下，Spring IoC 比这个复杂很多很多，例如单例 Bean 对象，Bean 的属性注入，相互依赖的 Bean 的处理，以及等等。</li>
</ul>
<p>在基友 <a href="http://www.iocoder.cn/Fight/Interview-poorly-asked-Spring-IOC-process-1/">《面试问烂的 Spring IoC 过程》</a> 的文章中，把 Spring IoC 相关的内容，讲的非常不错。</p>
<h2 id="Spring-框架中有哪些不同类型的事件？"><a href="#Spring-框架中有哪些不同类型的事件？" class="headerlink" title="Spring 框架中有哪些不同类型的事件？"></a>Spring 框架中有哪些不同类型的事件？</h2><p>Spring 的 ApplicationContext 提供了支持事件和代码中监听器的功能。</p>
<p>我们可以创建 Bean 用来监听在 ApplicationContext 中发布的事件。如果一个 Bean 实现了 ApplicationListener 接口，当一个ApplicationEvent 被发布以后，Bean 会自动被通知。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class AllApplicationEventListener implements ApplicationListener&lt;ApplicationEvent&gt; &#123;  <br>    <br>    @Override  <br>    public void onApplicationEvent(ApplicationEvent applicationEvent) &#123;  <br>        &#x2F;&#x2F; process event  <br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>Spring 提供了以下五种标准的事件：</p>
<ol>
<li>上下文更新事件（ContextRefreshedEvent）：该事件会在ApplicationContext 被初始化或者更新时发布。也可以在调用ConfigurableApplicationContext 接口中的 <code>#refresh()</code> 方法时被触发。</li>
<li>上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext 的 <code>#start()</code> 方法开始/重新开始容器时触发该事件。</li>
<li>上下文停止事件（ContextStoppedEvent）：当容器调用 ConfigurableApplicationContext 的 <code>#stop()</code> 方法停止容器时触发该事件。</li>
<li>上下文关闭事件（ContextClosedEvent）：当ApplicationContext 被关闭时触发该事件。容器被关闭时，其管理的所有单例 Bean 都被销毁。</li>
<li>请求处理事件（RequestHandledEvent）：在 We b应用中，当一个HTTP 请求（request）结束触发该事件。</li>
</ol>
<hr>
<p>除了上面介绍的事件以外，还可以通过扩展 ApplicationEvent 类来开发<strong>自定义</strong>的事件。</p>
<p>① 示例自定义的事件的类，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class CustomApplicationEvent extends ApplicationEvent&#123;  <br><br>    public CustomApplicationEvent(Object source, final String msg) &#123;  <br>        super(source);<br>    &#125;  <br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>② 为了监听这个事件，还需要创建一个监听器。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class CustomEventListener implements ApplicationListener&lt;CustomApplicationEvent&gt; &#123;<br><br>    @Override  <br>    public void onApplicationEvent(CustomApplicationEvent applicationEvent) &#123;  <br>        &#x2F;&#x2F; handle event  <br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>③ 之后通过 ApplicationContext 接口的 <code>#publishEvent(Object event)</code> 方法，来发布自定义事件。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 创建 CustomApplicationEvent 事件<br>CustomApplicationEvent customEvent &#x3D; new CustomApplicationEvent(applicationContext, &quot;Test message&quot;);<br>&#x2F;&#x2F; 发布事件<br>applicationContext.publishEvent(customEvent);<br></code></pre></td></tr></table></figure>

<h1 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h1><h2 id="什么是-Spring-Bean-？"><a href="#什么是-Spring-Bean-？" class="headerlink" title="什么是 Spring Bean ？"></a>什么是 Spring Bean ？</h2><ul>
<li>Bean 由 Spring IoC 容器实例化，配置，装配和管理。</li>
<li>Bean 是基于用户提供给 IoC 容器的配置元数据 Bean Definition 创建。</li>
</ul>
<p>这个问题，胖友可以在回过头看 <a href="http://svip.iocoder.cn/Spring/Interview/#">「什么是 Spring IoC 容器？」</a> 问题，相互对照。</p>
<h2 id="Spring-有哪些配置方式"><a href="#Spring-有哪些配置方式" class="headerlink" title="Spring 有哪些配置方式"></a>Spring 有哪些配置方式</h2><p>单纯从 Spring Framework 提供的方式，一共有三种：</p>
<ul>
<li><p>1、XML 配置文件。</p>
<p>Bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;bean id&#x3D;&quot;studentBean&quot; class&#x3D;&quot;org.edureka.firstSpring.StudentBean&quot;&gt;<br>    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;Edureka&quot;&gt;&lt;&#x2F;property&gt;<br>&lt;&#x2F;bean&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>2、注解配置。</p>
<p>您可以通过在相关的类，方法或字段声明上使用注解，将 Bean 配置为组件类本身，而不是使用 XML 来描述 Bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;beans&gt;<br>&lt;context:annotation-config&#x2F;&gt;<br>&lt;!-- bean definitions go here --&gt;<br>&lt;&#x2F;beans&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>3、Java Config 配置。</p>
<p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p>
<ul>
<li><p><code>@Bean</code> 注解扮演与 <code>&lt;bean /&gt;</code> 元素相同的角色。</p>
</li>
<li><p><code>@Configuration</code> 类允许通过简单地调用同一个类中的其他 <code>@Bean</code> 方法来定义 Bean 间依赖关系。</p>
</li>
<li><p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Configuration<br>public class StudentConfig &#123;<br>    <br>    @Bean<br>    public StudentBean myStudent() &#123;<br>        return new StudentBean();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>是不是很熟悉 😈</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>目前主要使用 <strong>Java Config</strong> 配置为主。当然，三种配置方式是可以混合使用的。例如说：</p>
<ul>
<li>Dubbo 服务的配置，艿艿喜欢使用 XML 。</li>
<li>Spring MVC 请求的配置，艿艿喜欢使用 <code>@RequestMapping</code> 注解。</li>
<li>Spring MVC 拦截器的配置，艿艿喜欢 Java Config 配置。</li>
</ul>
<hr>
<p>另外，现在已经是 Spring Boot 的天下，所以更加是 <strong>Java Config</strong> 配置为主。</p>
<h2 id="Spring-支持几种-Bean-Scope-？"><a href="#Spring-支持几种-Bean-Scope-？" class="headerlink" title="Spring 支持几种 Bean Scope ？"></a>Spring 支持几种 Bean Scope ？</h2><blockquote>
<p>艿艿，这个是一个比较小众的题目，简单了解即可。</p>
</blockquote>
<p>Spring Bean 支持 5 种 Scope ，分别如下：</p>
<ul>
<li>Singleton - 每个 Spring IoC 容器仅有一个单 Bean 实例。<strong>默认</strong></li>
<li>Prototype - 每次请求都会产生一个新的实例。</li>
<li>Request - 每一次 HTTP 请求都会产生一个新的 Bean 实例，并且该 Bean 仅在当前 HTTP 请求内有效。</li>
<li>Session - 每一个的 Session 都会产生一个新的 Bean 实例，同时该 Bean 仅在当前 HTTP Session 内有效。</li>
<li>Application - 每一个 Web Application 都会产生一个新的 Bean ，同时该 Bean 仅在当前 Web Application 内有效。</li>
</ul>
<blockquote>
<p>另外，网络上很多文章说有 Global-session 级别，它是 Portlet 模块独有，目前已经废弃，在 Spring5 中是找不到的。</p>
</blockquote>
<p>仅当用户使用支持 Web 的 ApplicationContext 时，<strong>最后三个才可用</strong>。</p>
<p>再补充一点，开发者是可以<strong>自定义</strong> Bean Scope ，具体可参见 <a href="https://blog.csdn.net/elim168/article/details/75581670">《Spring（10）—— Bean 作用范围（二）—— 自定义 Scope》</a> 。</p>
<p>不错呢，还是那句话，这个题目简单了解下即可，实际常用的只有 Singleton 和 Prototype 两种级别，甚至说，只有 Singleton 级别。😈</p>
<h2 id="Spring-Bean-在容器的生命周期是什么样的？"><a href="#Spring-Bean-在容器的生命周期是什么样的？" class="headerlink" title="Spring Bean 在容器的生命周期是什么样的？"></a>Spring Bean 在容器的生命周期是什么样的？</h2><blockquote>
<p>艿艿说：这是一个比较高级的 Spring 的面试题，非常常见，并且答对比较加分。当然，如果实际真正弄懂，需要对 Spring Bean 的源码，有比较好的理解，所以 <a href="http://svip.iocoder.cn/categories/Spring/">《精尽 Spring 源码》</a> 系列，该读还是读吧。</p>
</blockquote>
<blockquote>
<p>艿艿：要注意下面每段话，艿艿进行加粗的地方。</p>
</blockquote>
<p>Spring Bean 的<strong>初始化</strong>流程如下：</p>
<ul>
<li><p>实例化 Bean 对象</p>
<ul>
<li><p>Spring 容器根据配置中的 Bean Definition(定义)中<strong>实例化</strong> Bean 对象。</p>
<blockquote>
<p>Bean Definition 可以通过 XML，Java 注解或 Java Config 代码提供。</p>
</blockquote>
</li>
<li><p>Spring 使用依赖注入<strong>填充</strong>所有属性，如 Bean 中所定义的配置。</p>
</li>
</ul>
</li>
<li><p>Aware 相关的属性，注入到 Bean 对象</p>
<ul>
<li>如果 Bean 实现 <strong>BeanNameAware</strong> 接口，则工厂通过传递 Bean 的 beanName 来调用 <code>#setBeanName(String name)</code> 方法。 </li>
<li>如果 Bean 实现 <strong>BeanFactoryAware</strong> 接口，工厂通过传递自身的实例来调用 <code>#setBeanFactory(BeanFactory beanFactory)</code> 方法。</li>
</ul>
</li>
<li><p>调用相应的方法，进一步初始化 Bean 对象</p>
<ul>
<li>如果存在与 Bean 关联的任何 <strong>BeanPostProcessor</strong> 们，则调用 <code>#preProcessBeforeInitialization(Object bean, String beanName)</code> 方法。 </li>
<li>如果 Bean 实现 <strong>InitializingBean</strong> 接口，则会调用 <code>#afterPropertiesSet()</code> 方法。</li>
<li>如果为 Bean 指定了 <strong>init</strong> 方法（例如 <code>&lt;bean /&gt;</code> 的 <code>init-method</code> 属性），那么将调用该方法。</li>
<li>如果存在与 Bean 关联的任何 <strong>BeanPostProcessor</strong> 们，则将调用 <code>#postProcessAfterInitialization(Object bean, String beanName)</code> 方法。</li>
</ul>
</li>
</ul>
<p>Spring Bean 的<strong>销毁</strong>流程如下：</p>
<ul>
<li>如果 Bean 实现 <strong>DisposableBean</strong> 接口，当 spring 容器关闭时，会调用 <code>#destroy()</code> 方法。</li>
<li>如果为 bean 指定了 <strong>destroy</strong> 方法（例如 <code>&lt;bean /&gt;</code> 的 <code>destroy-method</code> 属性），那么将调用该方法。</li>
</ul>
<p>整体如下图：<img src="http://cdn.tuwenbin.vip/qkhgsvo4.bmp" alt="qkhgsvo4">流程图</p>
<p>无意中，艿艿又翻到一张有趣的整体图，如下图：</p>
<p><img src="http://cdn.tuwenbin.vip/t1but0ou.bmp" alt="t1but0ou">流程图</p>
<h2 id="什么是-Spring-的内部-bean？"><a href="#什么是-Spring-的内部-bean？" class="headerlink" title="什么是 Spring 的内部 bean？"></a>什么是 Spring 的内部 bean？</h2><p>只有将 Bean <strong>仅</strong>用作另一个 Bean 的属性时，才能将 Bean 声明为内部 Bean。</p>
<ul>
<li>为了定义 Bean，Spring 提供基于 XML 的配置元数据在 <code>&lt;property&gt;</code>或 <code>&lt;constructor-arg&gt;</code> 中提供了 <code>&lt;bean&gt;</code>元素的使用。</li>
<li>内部 Bean 总是<strong>匿名</strong>的，并且它们总是作为<strong>原型 Prototype</strong> 。</li>
</ul>
<p>例如，假设我们有一个 Student 类，其中引用了 Person 类。这里我们将只创建一个 Person 类实例并在 Student 中使用它。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; Student.java<br><br>public class Student &#123;<br><br>    private Person person;<br>    <br>    &#x2F;&#x2F; ... Setters and Getters<br>&#125;<br><br>&#x2F;&#x2F; Person.java<br><br>public class Person &#123;<br><br>    private String name;<br>    private String address;<br>    <br>    &#x2F;&#x2F; ... Setters and Getters<br>&#125;<br>&lt;!-- bean.xml --&gt;<br><br>&lt;bean id&#x3D;“StudentBean&quot; class&#x3D;&quot;com.edureka.Student&quot;&gt;<br>    &lt;property name&#x3D;&quot;person&quot;&gt;<br>        &lt;!--This is inner bean --&gt;<br>        &lt;bean class&#x3D;&quot;com.edureka.Person&quot;&gt;<br>            &lt;property name&#x3D;&quot;name&quot; value&#x3D;“Scott&quot;&gt;&lt;&#x2F;property&gt;<br>            &lt;property name&#x3D;&quot;address&quot; value&#x3D;“Bangalore&quot;&gt;&lt;&#x2F;property&gt;<br>        &lt;&#x2F;bean&gt;<br>    &lt;&#x2F;property&gt;<br>&lt;&#x2F;bean&gt;<br></code></pre></td></tr></table></figure>

<h2 id="什么是-Spring-装配？"><a href="#什么是-Spring-装配？" class="headerlink" title="什么是 Spring 装配？"></a>什么是 Spring 装配？</h2><p>当 Bean 在 Spring 容器中组合在一起时，它被称为<strong>装配</strong>或 <strong>Bean 装配</strong>。Spring 容器需要知道需要什么 Bean 以及容器应该如何使用依赖注入来将 Bean 绑定在一起，同时装配 Bean 。</p>
<blockquote>
<p>装配，和上文提到的 DI 依赖注入，实际是一个东西。</p>
</blockquote>
<p><strong>自动装配有哪些方式？</strong></p>
<p>Spring 容器能够自动装配 Bean 。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 Bean 的协作者。</p>
<p>自动装配的不同模式：</p>
<ul>
<li>no - 这是默认设置，表示没有自动装配。应使用显式 Bean 引用进行装配。</li>
<li>byName - 它根据 Bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 Bean 。</li>
<li>【最常用】<strong>byType</strong> - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 Bean 类型匹配，则匹配并装配属性。</li>
<li>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li>
<li>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li>
</ul>
<p><strong>自动装配有什么局限？</strong></p>
<blockquote>
<p>艿艿：这个题目，了解下即可，也不是很准确。</p>
</blockquote>
<ul>
<li><p>覆盖的可能性 - 您始终可以使用 <code>&lt;constructor-arg&gt;</code> 和 <code>&lt;property&gt;</code> 设置指定依赖项，这将覆盖自动装配。</p>
</li>
<li><p>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。</p>
<blockquote>
<p>这种，严格来说，也不能称为局限。因为可以通过配置文件来解决。</p>
</blockquote>
</li>
<li><p>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。</p>
</li>
</ul>
<h2 id="解释什么叫延迟加载？"><a href="#解释什么叫延迟加载？" class="headerlink" title="解释什么叫延迟加载？"></a>解释什么叫延迟加载？</h2><p>默认情况下，容器启动之后会将所有作用域为<strong>单例</strong>的 Bean 都创建好，但是有的业务场景我们并不需要它提前都创建好。此时，我们可以在Bean 中设置 <code>lzay-init = &quot;true&quot;</code> 。</p>
<ul>
<li>这样，当容器启动之后，作用域为单例的 Bean ，就不在创建。</li>
<li>而是在获得该 Bean 时，才真正在创建加载。</li>
</ul>
<h2 id="Spring-框架中的单例-Bean-是线程安全的么？"><a href="#Spring-框架中的单例-Bean-是线程安全的么？" class="headerlink" title="Spring 框架中的单例 Bean 是线程安全的么？"></a>Spring 框架中的单例 Bean 是线程安全的么？</h2><p>Spring 框架并没有对<a href="http://howtodoinjava.com/2012/10/22/singleton-design-pattern-in-java/">单例</a> Bean 进行任何多线程的封装处理。</p>
<ul>
<li>关于单例 Bean 的<a href="http://howtodoinjava.com/2014/06/02/what-is-thread-safety/">线程安全</a>和并发问题，需要开发者自行去搞定。</li>
<li>并且，单例的线程安全问题，也不是 Spring 应该去关心的。Spring 应该做的是，提供根据配置，创建单例 Bean 或多例 Bean 的功能。</li>
</ul>
<p>当然，但实际上，大部分的 Spring Bean 并没有可变的状态(比如Serview 类和 DAO 类)，所以在某种程度上说 Spring 的单例 Bean 是线程安全的。</p>
<p>如果你的 Bean 有多种状态的话，就需要自行保证线程安全。最浅显的解决办法，就是将多态 Bean 的作用域( Scope )由 Singleton 变更为 Prototype 。</p>
<h2 id="Spring-Bean-怎么解决循环依赖的问题？"><a href="#Spring-Bean-怎么解决循环依赖的问题？" class="headerlink" title="Spring Bean 怎么解决循环依赖的问题？"></a>Spring Bean 怎么解决循环依赖的问题？</h2><blockquote>
<p>艿艿说：能回答出这个问题的，一般是比较厉害的。</p>
</blockquote>
<p>这是个比较复杂的问题，有能力的胖友，建议看下 <a href="http://svip.iocoder.cn/Spring/IoC-get-Bean-createBean-5/">《【死磕 Spring】—— IoC 之加载 Bean：创建 Bean（五）之循环依赖处理》</a></p>
<p>感觉，不通过源码，很难解释清楚这个问题。如果看不懂的胖友，可以在认真看完，在星球里，我们一起多交流下。好玩的。</p>
<h1 id="Spring-注解"><a href="#Spring-注解" class="headerlink" title="Spring 注解"></a>Spring 注解</h1><p>这块内容，实际写在 <a href="http://svip.iocoder.cn/Spring/Interview/#">「Spring Bean」</a> 中比较合适，考虑到后续的问题，都是关于注解的，所以单独起一个大的章节。</p>
<h2 id="什么是基于注解的容器配置？"><a href="#什么是基于注解的容器配置？" class="headerlink" title="什么是基于注解的容器配置？"></a>什么是基于注解的容器配置？</h2><p>不使用 XML 来描述 Bean 装配，开发人员通过在相关的类，方法或字段声明上使用<strong>注解</strong>将配置移动到组件类本身。它可以作为 XML 设置的替代方案。例如：</p>
<p>Spring 的 Java 配置是通过使用 <code>@Bean</code> 和 <code>@Configuration</code> 来实现。</p>
<ul>
<li><code>@Bean</code> 注解，扮演与 <code>&lt;bean /&gt;</code> 元素相同的角色。</li>
<li><code>@Configuration</code> 注解的类，允许通过简单地调用同一个类中的其他 <code>@Bean</code> 方法来定义 Bean 间依赖关系。</li>
</ul>
<p>示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Configuration<br>public class StudentConfig &#123;<br><br>    @Bean<br>    public StudentBean myStudent() &#123;<br>        return new StudentBean();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="如何在-Spring-中启动注解装配？"><a href="#如何在-Spring-中启动注解装配？" class="headerlink" title="如何在 Spring 中启动注解装配？"></a>如何在 Spring 中启动注解装配？</h2><p>默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置 <code>&lt;context：annotation-config /&gt;</code> 元素在 Spring 配置文件中启用它。</p>
<p>当然，如果胖友是使用 Spring Boot ，默认情况下已经开启。</p>
<h2 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h2><ul>
<li><code>@Component</code> ：它将 Java 类标记为 Bean 。它是任何 Spring 管理组件的<strong>通用</strong>构造型。</li>
<li><code>@Controller</code> ：它将一个类标记为 Spring Web MVC <strong>控制器</strong>。</li>
<li><code>@Service</code> ：此注解是组件注解的特化。它不会对 <code>@Component</code> 注解提供任何其他行为。您可以在<strong>服务层</strong>类中使用 @Service 而不是 <code>@Component</code> ，因为它以更好的方式指定了意图。</li>
<li><code>@Repository</code> ：这个注解是具有类似用途和功能的 <code>@Component</code> 注解的特化。它为 <strong>DAO</strong> 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException 。</li>
</ul>
<h2 id="Required-注解有什么用？"><a href="#Required-注解有什么用？" class="headerlink" title="@Required 注解有什么用？"></a>@Required 注解有什么用？</h2><p><code>@Required</code> 注解，应用于 Bean 属性 setter 方法。  </p>
<ul>
<li>此注解仅指示必须在配置时使用 Bean 定义中的显式属性值或使用自动装配填充受影响的 Bean 属性。</li>
<li>如果尚未填充受影响的 Bean 属性，则容器将抛出 BeanInitializationException 异常。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class Employee &#123;<br><br>    private String name;<br>    <br>    @Required<br>    public void setName(String name)&#123;<br>        this.name&#x3D;name;<br>    &#125;<br>    <br>    public string getName()&#123;<br>        return name;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>T T 貌似平时很少用这个注解噢。</li>
</ul>
<h2 id="Autowired-注解有什么用？"><a href="#Autowired-注解有什么用？" class="headerlink" title="@Autowired 注解有什么用？"></a>@Autowired 注解有什么用？</h2><p><code>@Autowired</code> 注解，可以更准确地控制应该在何处以及如何进行自动装配。</p>
<ul>
<li>此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 Bean。</li>
<li>默认情况下，它是类型驱动的注入。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class EmpAccount &#123;<br>    <br>    @Autowired<br>    private Employee emp;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Qualifier-注解有什么用？"><a href="#Qualifier-注解有什么用？" class="headerlink" title="@Qualifier 注解有什么用？"></a>@Qualifier 注解有什么用？</h2><p>当你创建多个<strong>相同类型</strong>的 Bean ，并希望仅使用属性装配<strong>其中一个</strong> Bean 时，您可以使用 <code>@Qualifier</code> 注解和 <code>@Autowired</code> 通过指定 ID 应该装配哪个<strong>确切的</strong> Bean 来消除歧义。</p>
<p>例如，应用中有两个类型为 Employee 的 Bean ID 为 <code>&quot;emp1&quot;</code> 和 <code>&quot;emp2&quot;</code> ，此处，我们希望 EmployeeAccount Bean 注入 <code>&quot;emp1&quot;</code> 对应的 Bean 对象。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class EmployeeAccount &#123;<br><br>    @Autowired<br>    @Qualifier(emp1)<br>    private Employee emp;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><blockquote>
<p>Spring AOP 的面试题中，大多数都是概念题，主要是对切面的理解。概念点主要有：</p>
<ul>
<li>AOP</li>
<li>Aspect</li>
<li>JoinPoint</li>
<li>PointCut</li>
<li>Advice</li>
<li>Target</li>
<li>AOP Proxy</li>
<li>Weaving</li>
</ul>
</blockquote>
<ul>
<li>在阅读完 <a href="http://svip.iocoder.cn/Spring/Interview/#">「Spring AOP」</a> 的面试题后，在回过头思考下这些概念点，到底理解了多少。注意，不是背，理解！</li>
</ul>
<p>非常推荐阅读如下两篇文章：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000007469968">《彻底征服 Spring AOP 之理论篇》</a></li>
<li><a href="https://segmentfault.com/a/1190000007469982">《彻底征服 Spring AOP 之实战篇》</a></li>
</ul>
<h2 id="什么是-AOP-？"><a href="#什么是-AOP-？" class="headerlink" title="什么是 AOP ？"></a>什么是 AOP ？</h2><p>AOP(Aspect-Oriented Programming)，即<strong>面向切面编程</strong>, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成， 提供了与 OOP 不同的抽象软件结构的视角。</p>
<ul>
<li>在 OOP 中，以类( Class )作为基本单元</li>
<li>在 AOP 中，以**切面( Aspect )**作为基本单元。</li>
</ul>
<h2 id="什么是-Aspect-？"><a href="#什么是-Aspect-？" class="headerlink" title="什么是 Aspect ？"></a>什么是 Aspect ？</h2><p>Aspect 由 <strong>PointCut</strong> 和 <strong>Advice</strong> 组成。</p>
<ul>
<li>它既包含了横切逻辑的定义，也包括了连接点的定义。</li>
<li>Spring AOP 就是负责实施切面的框架，它将切面所定义的横切逻辑编织到切面所指定的连接点中。</li>
</ul>
<p>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p>
<ol>
<li>如何通过 PointCut 和 Advice 定位到特定的 <strong>JoinPoint</strong> 上。</li>
<li>如何在 Advice 中编写切面代码。</li>
</ol>
<p><strong>可以简单地认为, 使用 @Aspect 注解的类就是切面</strong></p>
<p><img src="http://cdn.tuwenbin.vip/iddff34h.bmp" alt="iddff34h">流程图</p>
<h2 id="什么是-JoinPoint"><a href="#什么是-JoinPoint" class="headerlink" title="什么是 JoinPoint ?"></a>什么是 JoinPoint ?</h2><p>JoinPoint ，<strong>切点</strong>，程序运行中的一些时间点, 例如：</p>
<ul>
<li>一个方法的执行。</li>
<li>或者是一个异常的处理。</li>
</ul>
<p>在 Spring AOP 中，JoinPoint 总是方法的执行点。</p>
<h2 id="什么是-PointCut-？"><a href="#什么是-PointCut-？" class="headerlink" title="什么是 PointCut ？"></a>什么是 PointCut ？</h2><p>PointCut ，<strong>匹配</strong> JoinPoint 的谓词(a predicate that matches join points)。</p>
<blockquote>
<p>简单来说，PointCut 是匹配 JoinPoint 的条件。</p>
</blockquote>
<ul>
<li>Advice 是和特定的 PointCut 关联的，并且在 PointCut 相匹配的 JoinPoint 中执行。即 <code>Advice =&gt; PointCut =&gt; JoinPoint</code> 。</li>
<li>在 Spring 中, 所有的方法都可以认为是 JoinPoint ，但是我们并不希望在所有的方法上都添加 Advice 。<strong>而 PointCut 的作用</strong>，就是提供一组规则(使用 AspectJ PointCut expression language 来描述) 来匹配 JoinPoint ，给满足规则的 JoinPoint 添加 Advice 。</li>
</ul>
<p>😈 是不是觉得有点绕，实际场景下，其实也不会弄的这么清楚~~</p>
<h2 id="关于-JoinPoint-和-PointCut-的区别"><a href="#关于-JoinPoint-和-PointCut-的区别" class="headerlink" title="关于 JoinPoint 和 PointCut 的区别"></a>关于 JoinPoint 和 PointCut 的区别</h2><p>JoinPoint 和 PointCut 本质上就是<strong>两个不同纬度上</strong>的东西。</p>
<ul>
<li>在 Spring AOP 中，所有的方法执行都是 JoinPoint 。而 PointCut 是一个描述信息，它修饰的是 JoinPoint ，通过 PointCut ，我们就可以确定哪些 JoinPoint 可以被织入 Advice 。</li>
<li>Advice 是在 JoinPoint 上执行的，而 PointCut 规定了哪些 JoinPoint 可以执行哪些 Advice 。</li>
</ul>
<p>或者，我们在换一种说法：</p>
<ol>
<li>首先，Advice 通过 PointCut 查询需要被织入的 JoinPoint 。</li>
<li>然后，Advice 在查询到 JoinPoint 上执行逻辑。</li>
</ol>
<h2 id="什么是-Advice-？"><a href="#什么是-Advice-？" class="headerlink" title="什么是 Advice ？"></a>什么是 Advice ？</h2><p>Advice ，<strong>通知</strong>。</p>
<ul>
<li>特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice 。</li>
<li>Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的<strong>拦截器</strong>。</li>
</ul>
<p><strong>有哪些类型的 Advice？</strong></p>
<ul>
<li>Before - 这些类型的 Advice 在 JoinPoint 方法之前执行，并使用 <code>@Before</code> 注解标记进行配置。</li>
<li>After Returning - 这些类型的 Advice 在连接点方法正常执行后执行，并使用 <code>@AfterReturning</code> 注解标记进行配置。</li>
<li>After Throwing - 这些类型的 Advice 仅在 JoinPoint 方法通过抛出异常退出并使用 <code>@AfterThrowing</code> 注解标记配置时执行。</li>
<li>After Finally - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 <code>@After</code> 注解标记进行配置。</li>
<li>Around - 这些类型的 Advice 在连接点之前和之后执行，并使用 <code>@Around</code> 注解标记进行配置。</li>
</ul>
<p>😈 看起来，是不是和拦截器的执行时间，有几分相似。实际上，用于拦截效果的各种实现，大体都是类似的。</p>
<h2 id="什么是-Target-？"><a href="#什么是-Target-？" class="headerlink" title="什么是 Target ？"></a>什么是 Target ？</h2><p>Target ，织入 Advice 的<strong>目标对象</strong>。目标对象也被称为 <strong>Advised Object</strong> 。</p>
<ul>
<li>因为 Spring AOP 使用运行时代理的方式来实现 Aspect ，因此 Advised Object 总是一个代理对象(Proxied Object) 。</li>
<li><strong>注意, Advised Object 指的不是原来的对象，而是织入 Advice 后所产生的代理对象</strong>。</li>
<li>Advice + Target Object = Advised Object = Proxy 。</li>
</ul>
<h2 id="AOP-有哪些实现方式？"><a href="#AOP-有哪些实现方式？" class="headerlink" title="AOP 有哪些实现方式？"></a>AOP 有哪些实现方式？</h2><p>实现 AOP 的技术，主要分为两大类：</p>
<ul>
<li><p>① <strong>静态代理</strong> - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强。</p>
<ul>
<li><p>编译时编织（特殊编译器实现）</p>
</li>
<li><p>类加载时编织（特殊的类加载器实现）。</p>
<blockquote>
<p>例如，SkyWalking 基于 Java Agent 机制，配置上 ByteBuddy 库，实现类加载时编织时增强，从而实现链路追踪的透明埋点。</p>
<p>感兴趣的胖友，可以看看 <a href="http://www.kailing.pub/article/index/arcid/178.html">《SkyWalking 源码分析之 JavaAgent 工具 ByteBuddy 的应用》</a> 。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>② <strong>动态代理</strong> - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。目前 Spring 中使用了两种动态代理库：</p>
<ul>
<li>JDK 动态代理</li>
<li>CGLIB</li>
</ul>
</li>
</ul>
<p>那么 Spring 什么时候使用 JDK 动态代理，什么时候使用 CGLIB 呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; From 《Spring 源码深度解析》P172<br>&#x2F;&#x2F; Spring AOP 部分使用 JDK 动态代理或者 CGLIB 来为目标对象创建代理。（建议尽量使用 JDK 的动态代理）<br>&#x2F;&#x2F; 如果被代理的目标对象实现了至少一个接口，则会使用 JDK 动态代理。所有该目标类型实现的接口都讲被代理。<br>&#x2F;&#x2F; 若该目标对象没有实现任何接口，则创建一个 CGLIB 代理。<br>&#x2F;&#x2F; 如果你希望强制使用 CGLIB 代理，（例如希望代理目标对象的所有方法，而不只是实现自接口的方法）那也可以。但是需要考虑以下两个方法：<br>&#x2F;&#x2F;      1&gt; 无法通知(advise) Final 方法，因为它们不能被覆盖。<br>&#x2F;&#x2F;      2&gt; 你需要将 CGLIB 二进制发型包放在 classpath 下面。<br>&#x2F;&#x2F; 为什么 Spring 默认使用 JDK 的动态代理呢？笔者猜测原因如下：<br>&#x2F;&#x2F;      1&gt; 使用 JDK 原生支持，减少三方依赖<br>&#x2F;&#x2F;      2&gt; JDK8 开始后，JDK 代理的性能差距 CGLIB 的性能不会太多。可参见：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;haiq&#x2F;p&#x2F;4304615.html<br></code></pre></td></tr></table></figure>

<ul>
<li>实际上，Spring AOP 的代码量不大，与其在窗户外面不清不楚，不如捅破它！感兴趣的胖友，可以撸一撸 <a href="http://svip.iocoder.cn/Spring/aop-simple-intro/">《精尽 Spring 源码分析 —— AOP 源码简单导读》</a> 。</li>
</ul>
<p>或者，我们来换一个解答答案：</p>
<p>Spring AOP 中的动态代理主要有两种方式，</p>
<ul>
<li><p>JDK 动态代理</p>
<p>JDK 动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是 InvocationHandler 接口和 Proxy 类。</p>
</li>
<li><p>CGLIB 动态代理</p>
<p>如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类。当然，Spring 也支持配置，<strong>强制</strong>使用 CGLIB 动态代理。<br>CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 <code>final</code> ，那么它是无法使用 CGLIB 做动态代理的。  </p>
</li>
</ul>
<h2 id="Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？"></a>Spring AOP and AspectJ AOP 有什么区别？</h2><ul>
<li>代理方式不同<ul>
<li>Spring AOP 基于动态代理方式实现。</li>
<li>AspectJ AOP 基于静态代理方式实现。</li>
</ul>
</li>
<li>PointCut 支持力度不同<ul>
<li>Spring AOP <strong>仅</strong>支持方法级别的 PointCut 。</li>
<li>AspectJ AOP 提供了完全的 AOP 支持，它还支持属性级别的 PointCut 。</li>
</ul>
</li>
</ul>
<h2 id="什么是编织（Weaving）？"><a href="#什么是编织（Weaving）？" class="headerlink" title="什么是编织（Weaving）？"></a>什么是编织（Weaving）？</h2><p>Weaving ，<strong>编织</strong>。</p>
<ul>
<li>为了创建一个 Advice 对象而链接一个 Aspect 和其它应用类型或对象，称为编织（Weaving）。</li>
<li>在 Spring AOP 中，编织在运行时执行，即动态代理。请参考下图：<img src="http://cdn.tuwenbin.vip/nv5yvktr.bmp" alt="nv5yvktr">Proxy</li>
</ul>
<h2 id="Spring-如何使用-AOP-切面？"><a href="#Spring-如何使用-AOP-切面？" class="headerlink" title="Spring 如何使用 AOP 切面？"></a>Spring 如何使用 AOP 切面？</h2><p>在 Spring AOP 中，有两种方式配置 AOP 切面：</p>
<ul>
<li>基于 <strong>XML</strong> 方式的切面实现。</li>
<li>基于 <strong>注解</strong> 方式的切面实现。</li>
</ul>
<p>目前，主流喜欢使用 <strong>注解</strong> 方式。胖友可以看看 <a href="https://segmentfault.com/a/1190000007469982">《彻底征服 Spring AOP 之实战篇》</a> 。</p>
<h1 id="Spring-Transaction"><a href="#Spring-Transaction" class="headerlink" title="Spring Transaction"></a>Spring Transaction</h1><p>非常推荐阅读如下文章：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247484702&idx=1&sn=c04261d63929db09ff6df7cadc7cca21&chksm=fa497aafcd3ef3b94082da7bca841b5b7b528eb2a52dbc4eb647b97be63a9a1cf38a9e71bf90&token=165108535&lang=zh_CN#rd">《可能是最漂亮的 Spring 事务管理详解》</a></li>
</ul>
<h2 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h2><p>事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。</p>
<p>这样可以防止出现脏数据，防止数据库数据出现问题。</p>
<h2 id="事务的特性指的是？"><a href="#事务的特性指的是？" class="headerlink" title="事务的特性指的是？"></a>事务的特性指的是？</h2><p>指的是 <strong>ACID</strong> ，如下图所示：</p>
<p><img src="http://cdn.tuwenbin.vip/8i4h2cu4.bmp" alt="8i4h2cu4">事务的特性</p>
<ol>
<li><strong>原子性</strong> Atomicity  ：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>
<li><strong>一致性</strong> Consistency ：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7">约束</a>、<a href="https://zh.wikipedia.org/wiki/%E8%A7%A6%E5%8F%91%E5%99%A8_(%E6%95%B0%E6%8D%AE%E5%BA%93)">触发器</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E7%BA%A7%E8%81%94%E5%9B%9E%E6%BB%9A&action=edit&redlink=1">级联回滚</a>等。</li>
<li><strong>隔离性</strong> Isolation  ：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable  read）和串行化（Serializable）。</li>
<li><strong>持久性</strong> Durability ：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ol>
<h2 id="列举-Spring-支持的事务管理类型？"><a href="#列举-Spring-支持的事务管理类型？" class="headerlink" title="列举 Spring 支持的事务管理类型？"></a>列举 Spring 支持的事务管理类型？</h2><p>目前 Spring 提供两种类型的事务管理：</p>
<ul>
<li><strong>声明式</strong>事务：通过使用注解或基于 XML 的配置事务，从而事务管理与业务代码分离。</li>
<li><strong>编程式</strong>事务：通过编码的方式实现事务管理，需要在代码中显式的调用事务的获得、提交、回滚。它为您提供极大的灵活性，但维护起来非常困难。</li>
</ul>
<p>实际场景下，我们一般使用 Spring Boot + 注解的<strong>声明式</strong>事务。具体的示例，胖友可以看看 <a href="https://www.jianshu.com/p/cddeca2c9245">《Spring Boot 事务注解详解》</a> 。</p>
<p>另外，也推荐看看 <a href="https://blog.csdn.net/xktxoo/article/details/77919508">《Spring 事务管理 － 编程式事务、声明式事务》</a> 一文。</p>
<h2 id="Spring-事务如何和不同的数据持久层框架做集成？"><a href="#Spring-事务如何和不同的数据持久层框架做集成？" class="headerlink" title="Spring 事务如何和不同的数据持久层框架做集成？"></a>Spring 事务如何和不同的数据持久层框架做集成？</h2><p>① 首先，我们先明确下，这里数据持久层框架，指的是 Spring JDBC、Hibernate、Spring JPA、MyBatis 等等。</p>
<p>② 然后，Spring 事务的管理，是通过 <code>org.springframework.transaction.PlatformTransactionManager</code> 进行管理，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; PlatformTransactionManager.java<br><br>public interface PlatformTransactionManager &#123;<br><br>    &#x2F;&#x2F; 根据事务定义 TransactionDefinition ，获得 TransactionStatus 。 <br>    TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;<br><br>    &#x2F;&#x2F; 根据情况，提交事务<br>    void commit(TransactionStatus status) throws TransactionException;<br>    <br>    &#x2F;&#x2F; 根据情况，回滚事务<br>    void rollback(TransactionStatus status) throws TransactionException;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>PlatformTransactionManager 是负责事务管理的接口，一共有三个接口方法，分别负责事务的获得、提交、回滚。</p>
</li>
<li><p><code>#getTransaction(TransactionDefinition definition)</code>方法，根据事务定义 TransactionDefinition ，获得 TransactionStatus 。</p>
<ul>
<li>为什么不是创建事务呢？因为如果当前如果已经有事务，则不会进行创建，一般来说会跟当前线程进行绑定。如果不存在事务，则进行创建。</li>
<li>为什么返回的是 TransactionStatus 对象？在 TransactionStatus 中，不仅仅包含事务属性，还包含事务的其它信息，例如是否只读、是否为新创建的事务等等。😈 下面，也会详细解析 TransactionStatus 。</li>
</ul>
</li>
<li><p>事务 TransactionDefinition 是什么？😈 下面，也会详细解析 TransactionStatus 。</p>
</li>
<li><p><code>#commit(TransactionStatus status)</code>方法，根据 TransactionStatus 情况，提交事务。</p>
<ul>
<li><p>为什么根据 TransactionStatus 情况，进行提交？例如说，带<code>@Transactional</code>注解的的 A 方法，会调用 <code>@Transactional</code>注解的的 B 方法。</p>
</li>
<li><p>在 B 方法结束调用后，会执行 <code>PlatformTransactionManager#commit(TransactionStatus status)</code> 方法，此处事务<strong>是不能</strong>、<strong>也不会</strong>提交的。</p>
<ul>
<li>而是在 A 方法结束调用后，执行 <code>PlatformTransactionManager#commit(TransactionStatus status)</code> 方法，提交事务。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>#rollback(TransactionStatus status)</code>方法，根据 TransactionStatus 情况，回滚事务。</p>
<ul>
<li>为什么根据 TransactionStatus 情况，进行回滚？原因同 <code>#commit(TransactionStatus status)</code> 方法。</li>
</ul>
</li>
</ul>
<p>③ 再之后，PlatformTransactionManager 有<strong>抽象子</strong>类 <code>org.springframework.transaction.support.AbstractPlatformTransactionManager</code> ，基于 <a href="https://blog.csdn.net/carson_ho/article/details/54910518">模板方法模式</a> ，实现事务整体逻辑的骨架，而抽象 <code>#doCommit(DefaultTransactionStatus status)</code>、<code>#doRollback(DefaultTransactionStatus status)</code> 等等方法，交由子类类来实现。</p>
<blockquote>
<p>前方高能，即将进入关键的 ④ 步骤。</p>
</blockquote>
<p>④ 最后，不同的数据持久层框架，会有其对应的 PlatformTransactionManager 实现类，如下图所示：<img src="http://cdn.tuwenbin.vip/6y2o9r32.bmp" alt="6y2o9r32">事务的特性</p>
<ul>
<li>所有的实现类，都基于 AbstractPlatformTransactionManager 这个骨架类。</li>
<li>HibernateTransactionManager ，和 Hibernate5 的事务管理做集成。</li>
<li>DataSourceTransactionManager ，和 JDBC 的事务管理做集成。所以，它也适用于 MyBatis、Spring JDBC 等等。</li>
<li>JpaTransactionManager ，和 JPA 的事务管理做集成。</li>
</ul>
<p>如下，是一个比较常见的 XML 方式来配置的事务管理器，使用的是 DataSourceTransactionManager 。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!-- 事务管理器 --&gt;<br>&lt;bean id&#x3D;&quot;transactionManager&quot;<br>class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;<br>    &lt;!-- 数据源 --&gt;<br>    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;<br>&lt;&#x2F;bean&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>正如上文所说，它适用于 MyBatis、Spring JDBC 等等。</li>
</ul>
<hr>
<p>😈 是不是很有趣，更多详细的解析，可见如下几篇文章：</p>
<ul>
<li><a href="http://svip.iocoder.cn/categories/Spring/">《精尽 Spring 源码分析 —— Transaction 源码简单导读》</a></li>
<li><a href="http://svip.iocoder.cn/MyBatis/transaction-package/">《精尽 MyBatis 源码分析 —— 事务模块》</a></li>
<li><a href="http://svip.iocoder.cn/MyBatis/Spring-Integration-4/">《精尽 MyBatis 源码解析 —— Spring 集成（四）之事务》</a></li>
</ul>
<h2 id="为什么在-Spring-事务中不能切换数据源？"><a href="#为什么在-Spring-事务中不能切换数据源？" class="headerlink" title="为什么在 Spring 事务中不能切换数据源？"></a>为什么在 Spring 事务中不能切换数据源？</h2><p>做过 Spring 多数据源的胖友，都会有个惨痛的经历，为什么在开启事务的 Service 层的方法中，无法切换数据源呢？因为，在 Spring 的事务管理中，<strong>所使用的数据库连接会和当前线程所绑定</strong>，即使我们设置了另外一个数据源，使用的还是当前的数据源连接。</p>
<p>另外，多个数据源且需要事务的场景，本身会带来<strong>多事务一致性</strong>的问题，暂时没有特别好的解决方案。</p>
<p>所以一般一个应用，推荐除非了读写分离所带来的多数据源，其它情况下，建议只有一个数据源。并且，随着微服务日益身形，一个服务对应一个 DB 是比较常见的架构选择。</p>
<h2 id="Transactional-注解有哪些属性？如何使用？"><a href="#Transactional-注解有哪些属性？如何使用？" class="headerlink" title="@Transactional 注解有哪些属性？如何使用？"></a>@Transactional 注解有哪些属性？如何使用？</h2><p><code>@Transactional</code> 注解的<strong>属性</strong>如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>String</td>
<td>可选的限定描述符，指定使用的事务管理器</td>
</tr>
<tr>
<td>propagation</td>
<td>enum: Propagation</td>
<td>可选的事务传播行为设置</td>
</tr>
<tr>
<td>isolation</td>
<td>enum: Isolation</td>
<td>可选的事务隔离级别设置</td>
</tr>
<tr>
<td>readOnly</td>
<td>boolean</td>
<td>读写或只读事务，默认读写</td>
</tr>
<tr>
<td>timeout</td>
<td>int (in seconds granularity)</td>
<td>事务超时时间设置</td>
</tr>
<tr>
<td>rollbackFor</td>
<td>Class对象数组，必须继承自Throwable</td>
<td>导致事务回滚的异常类数组</td>
</tr>
<tr>
<td>rollbackForClassName</td>
<td>类名数组，必须继承自Throwable</td>
<td>导致事务回滚的异常类名字数组</td>
</tr>
<tr>
<td>noRollbackFor</td>
<td>Class对象数组，必须继承自Throwable</td>
<td>不会导致事务回滚的异常类数组</td>
</tr>
<tr>
<td>noRollbackForClassName</td>
<td>类名数组，必须继承自Throwable</td>
<td>不会导致事务回滚的异常类名字数组</td>
</tr>
</tbody></table>
<ul>
<li>一般情况下，我们直接使用 <code>@Transactional</code> 的所有属性默认值即可。</li>
</ul>
<p>具体<strong>用法</strong>如下：</p>
<ul>
<li><code>@Transactional</code> 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 <code>public</code> 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。</li>
<li>虽然 <code>@Transactional</code> 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， <strong><code>@Transactional</code> 注解应该只被应用到 <code>public</code> 方法上，这是由 Spring AOP 的本质决定的</strong>。如果你在 <code>protected</code>、<code>private</code> 或者默认可见性的方法上使用 <code>@Transactional</code> 注解，这将被忽略，也不会抛出任何异常。<strong>这一点，非常需要注意</strong>。</li>
</ul>
<hr>
<p>下面，我们来简单说下<strong>源码</strong>相关的东西。</p>
<p><code>@Transactional</code> 注解的属性，会解析成 <code>org.springframework.transaction.TransactionDefinition</code> 对象，即事务定义。TransactionDefinition 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public interface TransactionDefinition &#123;<br><br>	int getPropagationBehavior(); &#x2F;&#x2F; 事务的传播行为<br>	int getIsolationLevel(); &#x2F;&#x2F; 事务的隔离级别<br>	int getTimeout(); &#x2F;&#x2F; 事务的超时时间<br>	boolean isReadOnly(); &#x2F;&#x2F; 事务是否只读<br>	@Nullable<br>	String getName(); &#x2F;&#x2F; 事务的名字<br><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>可能会胖友有以后，<code>@Transactional</code> 注解的 <code>rollbackFor</code>、<code>rollbackForClassName</code>、<code>noRollbackFor</code>、<code>noRollbackForClassName</code> 属性貌似没体现出来？它们提现在 TransactionDefinition 的实现类 RuleBasedTransactionAttribute 中。</li>
<li><code>#getPropagationBehavior()</code> 方法，返回事务的<strong>传播行为</strong>，该值是个枚举，在下面来说。</li>
<li><code>#getIsolationLevel()</code> 方法，返回事务的<strong>隔离级别</strong>，该值是个枚举，在下面来说。</li>
</ul>
<h2 id="什么是事务的隔离级别？分成哪些隔离级别？"><a href="#什么是事务的隔离级别？分成哪些隔离级别？" class="headerlink" title="什么是事务的隔离级别？分成哪些隔离级别？"></a>什么是事务的隔离级别？分成哪些隔离级别？</h2><p>关于这个问题，涉及的内容会比较多，胖友直接看如下两篇文章：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/25419593">《数据库四大特性以及事务隔离级别》</a></li>
<li><a href="https://www.jianshu.com/p/4e3edbedb9a8">《五分钟搞清楚 MySQL 事务隔离级别》</a></li>
</ul>
<p>另外，有一点非常重要，不同数据库对四个隔离级别的支持和实现略有不同。因为我们目前互联网主要使用 MySQL 为主，所以至少要搞懂 MySQL 对隔离级别的支持和实现情况。</p>
<p>在 TransactionDefinition 接口中，定义了“<strong>四种</strong>”的隔离级别枚举。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; TransactionDefinition.java<br><br>&#x2F;**<br> * 【Spring 独有】使用后端数据库默认的隔离级别<br> *<br> * MySQL 默认采用的 REPEATABLE_READ隔离级别<br> * Oracle 默认采用的 READ_COMMITTED隔离级别<br> *&#x2F;<br>int ISOLATION_DEFAULT &#x3D; -1;<br><br>&#x2F;**<br> * 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读<br> *&#x2F;<br>int ISOLATION_READ_UNCOMMITTED &#x3D; Connection.TRANSACTION_READ_UNCOMMITTED;<br><br>&#x2F;**<br> * 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生<br> *&#x2F;<br>int ISOLATION_READ_COMMITTED &#x3D; Connection.TRANSACTION_READ_COMMITTED;<br>&#x2F;**<br> * 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。<br> *&#x2F;<br>int ISOLATION_REPEATABLE_READ &#x3D; Connection.TRANSACTION_REPEATABLE_READ;<br>&#x2F;**<br> * 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。<br> *<br> * 但是这将严重影响程序的性能。通常情况下也不会用到该级别。<br> *&#x2F;<br>int ISOLATION_SERIALIZABLE &#x3D; Connection.TRANSACTION_SERIALIZABLE;<br></code></pre></td></tr></table></figure>

<h2 id="什么是事务的传播级别？分成哪些传播级别？"><a href="#什么是事务的传播级别？分成哪些传播级别？" class="headerlink" title="什么是事务的传播级别？分成哪些传播级别？"></a>什么是事务的传播级别？分成哪些传播级别？</h2><p>事务的<strong>传播行为</strong>，指的是当前带有事务配置的方法，需要怎么处理事务。</p>
<ul>
<li><p>例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p>
</li>
<li><p>有一点需要注意，事务的传播级别，并不是数据库事务规范中的名词，<strong>而是 Spring 自身所定义的</strong>。通过事务的传播级别，Spring 才知道如何处理事务，是创建一个新事务呢，还是继续使用当前的事务。</p>
<blockquote>
<p>艿艿的自我吐槽：是不是有种背概念背的想哭</p>
</blockquote>
</li>
</ul>
<p>在 TransactionDefinition 接口中，定义了<strong>三类七种</strong>传播级别。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; TransactionDefinition.java<br><br>&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 支持当前事务的情况 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; <br><br>&#x2F;**<br> * 如果当前存在事务，则使用该事务。<br> * 如果当前没有事务，则创建一个新的事务。<br> *&#x2F;<br>int PROPAGATION_REQUIRED &#x3D; 0;<br>&#x2F;**<br> * 如果当前存在事务，则使用该事务。<br> * 如果当前没有事务，则以非事务的方式继续运行。<br> *&#x2F;<br>int PROPAGATION_SUPPORTS &#x3D; 1;<br>&#x2F;**<br> * 如果当前存在事务，则使用该事务。<br> * 如果当前没有事务，则抛出异常。<br> *&#x2F;<br>int PROPAGATION_MANDATORY &#x3D; 2;<br><br>&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 不支持当前事务的情况 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; <br><br>&#x2F;**<br> * 创建一个新的事务。<br> * 如果当前存在事务，则把当前事务挂起。<br> *&#x2F;<br>int PROPAGATION_REQUIRES_NEW &#x3D; 3;<br>&#x2F;**<br> * 以非事务方式运行。<br> * 如果当前存在事务，则把当前事务挂起。<br> *&#x2F;<br>int PROPAGATION_NOT_SUPPORTED &#x3D; 4;<br>&#x2F;**<br> * 以非事务方式运行。<br> * 如果当前存在事务，则抛出异常。<br> *&#x2F;<br>int PROPAGATION_NEVER &#x3D; 5;<br><br>&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 其他情况 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; <br><br>&#x2F;**<br> * 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行。<br> * 如果当前没有事务，则等价于 &#123;@link TransactionDefinition#PROPAGATION_REQUIRED&#125;<br> *&#x2F;<br>int PROPAGATION_NESTED &#x3D; 6;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>分类之后，其实还是比较好记的。当然，绝大数场景，我们只用 <code>PROPAGATION_REQUIRED</code> 传播级别。</p>
</li>
<li><p>这里需要指出的是，前面的六种事务传播行为是 Spring 从 EJB 中引入的，他们共享相同的概念。而 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">PROPAGATION_NESTED<br></code></pre></td></tr></table></figure>

<p> 是 Spring 所特有的。</p>
<ul>
<li>以 <code>PROPAGATION_NESTED</code>  启动的事务内嵌于外部事务中（如果存在外部事务的话），此时，内嵌事务并不是一个独立的事务，它依赖于外部事务的存在，只有通过外部的事务提交，才能引起内部事务的提交，嵌套的子事务不能单独提交。如果熟悉 JDBC  中的保存点（SavePoint）的概念，那嵌套事务就很容易理解了，其实嵌套的子事务就是保存点的一个应用，一个事务中可以包括多个保存点，每一个嵌套子事务。另外，外部事务的回滚也会导致嵌套子事务的回滚。</li>
<li>😈 当然，虽然上面 <code>PROPAGATION_NESTED</code> 文字很长，实际我们基本没用过。或者说，去掉基本，我们根本没用过。</li>
</ul>
</li>
</ul>
<h2 id="什么是事务的超时属性？"><a href="#什么是事务的超时属性？" class="headerlink" title="什么是事务的超时属性？"></a>什么是事务的超时属性？</h2><p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。</p>
<p>在 TransactionDefinition 中以 <code>int</code> 的值来表示超时时间，其单位是秒。</p>
<p>当然，这个属性，貌似我们基本也没用过。</p>
<h2 id="什么是事务的只读属性？"><a href="#什么是事务的只读属性？" class="headerlink" title="什么是事务的只读属性？"></a>什么是事务的只读属性？</h2><p>事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。</p>
<ul>
<li>所谓事务性资源就是指那些被事务管理的资源，比如数据源、JMS 资源，以及自定义的事务性资源等等。</li>
<li>如果确定只对事务性资源进行只读操作，那么我们可以将事务标志为只读的，以提高事务处理的性能。感兴趣的胖友，可以看看 <a href="https://my.oschina.net/uniquejava/blog/80954">《不使用事务和使用只读事务的区别 》</a> 。</li>
</ul>
<p>在 TransactionDefinition 中以 <code>boolean</code> 类型来表示该事务是否只读。</p>
<h2 id="什么是事务的回滚规则？"><a href="#什么是事务的回滚规则？" class="headerlink" title="什么是事务的回滚规则？"></a>什么是事务的回滚规则？</h2><p>回滚规则，定义了哪些异常会导致事务回滚而哪些不会。</p>
<ul>
<li>默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的）。 </li>
<li>但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。</li>
</ul>
<p>注意，事务的回滚规则，并不是数据库事务规范中的名词，<strong>而是 Spring 自身所定义的</strong>。</p>
<h2 id="简单介绍-TransactionStatus-？"><a href="#简单介绍-TransactionStatus-？" class="headerlink" title="简单介绍 TransactionStatus ？"></a>简单介绍 TransactionStatus ？</h2><blockquote>
<p>艿艿：这个可能不是一个面试题，主要满足下大家的好奇心。</p>
</blockquote>
<p>TransactionStatus 接口，记录事务的状态，不仅仅包含事务本身，还包含事务的其它信息。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; TransactionStatus.java<br><br>public interface TransactionStatus extends SavepointManager, Flushable &#123;<br><br>    &#x2F;**<br>     * 是否是新创建的事务<br>     *&#x2F;<br>    boolean isNewTransaction();<br><br>    &#x2F;**<br>     * 是否有 Savepoint<br>     *<br>     * 在 &#123;@link TransactionDefinition#PROPAGATION_NESTED&#125; 传播级别使用。<br>     *&#x2F;<br>    boolean hasSavepoint();<br><br>    &#x2F;**<br>     * 设置为只回滚<br>     *&#x2F;<br>    void setRollbackOnly();<br>    &#x2F;**<br>     * 是否为只回滚<br>     *&#x2F;<br>    boolean isRollbackOnly();<br><br>    &#x2F;**<br>     * 执行 flush 操作<br>     *&#x2F;<br>    @Override<br>    void flush();<br><br>    &#x2F;**<br>     * 是否事务已经完成<br>     *&#x2F;<br>    boolean isCompleted();<br><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>为什么没有事务对象呢？在 TransactionStatus 的实现类 DefaultTransactionStatus 中，有个 <code>Object transaction</code> 属性，表示事务对象。</li>
<li><code>#isNewTransaction()</code> 方法，表示是否是新创建的事务。有什么用呢？答案结合 <a href="http://svip.iocoder.cn/Spring/Interview/#">「Spring 事务如何和不同的数据持久层框架做集成？」</a> 问题，我们对 <code>#commit(TransactionStatus status)</code> 方法的解释。通过该方法，我们可以判断，当前事务是否当前方法所创建的，只有创建事务的方法，<strong>才能且应该真正的提交事务</strong>。</li>
</ul>
<h2 id="使用-Spring-事务有什么优点？"><a href="#使用-Spring-事务有什么优点？" class="headerlink" title="使用 Spring 事务有什么优点？"></a>使用 Spring 事务有什么优点？</h2><ol>
<li>通过 PlatformTransactionManager ，为不同的数据层持久框架提供统一的 API ，无需关心到底是原生 JDBC、Spring JDBC、JPA、Hibernate 还是 MyBatis 。</li>
<li>通过使用声明式事务，使业务代码和事务管理的逻辑分离，更加清晰。</li>
</ol>
<p>从倾向上来说，艿艿比较喜欢<strong>注解</strong> + 声明式事务。</p>
<h1 id="Spring-Data-Access"><a href="#Spring-Data-Access" class="headerlink" title="Spring Data Access"></a>Spring Data Access</h1><blockquote>
<p>艿艿：这块的问题，感觉面试问的不多，至少我很少问。哈哈哈。就当做下了解，万一问了呢。</p>
</blockquote>
<h2 id="Spring-支持哪些-ORM-框架？"><a href="#Spring-支持哪些-ORM-框架？" class="headerlink" title="Spring 支持哪些 ORM 框架？"></a>Spring 支持哪些 ORM 框架？</h2><ul>
<li>Hibernate</li>
<li>JPA</li>
<li>MyBatis</li>
<li><a href="https://docs.spring.io/spring/docs/3.0.0.M4/reference/html/ch13s04.html">JDO</a></li>
<li><a href="https://db.apache.org/ojb/docu/howtos/howto-use-spring.html">OJB</a></li>
</ul>
<p>可能会有胖友说，不是应该还有 Spring JDBC 吗。注意，Spring JDBC 不是 ORM 框架。</p>
<h2 id="在-Spring-框架中如何更有效地使用-JDBC-？"><a href="#在-Spring-框架中如何更有效地使用-JDBC-？" class="headerlink" title="在 Spring 框架中如何更有效地使用 JDBC ？"></a>在 Spring 框架中如何更有效地使用 JDBC ？</h2><p>Spring 提供了 Spring JDBC 框架，方便我们使用 JDBC 。</p>
<p>对于开发者，只需要使用 JdbcTemplate 类，它提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p>
<p>没有使用过的胖友，可以看看 <a href="https://www.tianmaying.com/tutorial/spring-jdbc-data-accessing">《Spring JDBC 访问关系型数据库》</a> 文章。</p>
<h2 id="Spring-数据数据访问层有哪些异常？"><a href="#Spring-数据数据访问层有哪些异常？" class="headerlink" title="Spring 数据数据访问层有哪些异常？"></a>Spring 数据数据访问层有哪些异常？</h2><p>通过使用 Spring 数据数据访问层，它统一了各个数据持久层框架的不同异常，统一进行提供 <code>org.springframework.dao.DataAccessException</code> 异常及其子类。如下图所示：</p>
<p><img src="http://cdn.tuwenbin.vip/hrq2vhvj.bmp" alt="hrq2vhvj">流程图</p>
<h2 id="使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="使用 Spring 访问 Hibernate 的方法有哪些？"></a>使用 Spring 访问 Hibernate 的方法有哪些？</h2><blockquote>
<p>艿艿：这个问题很灵异，因为艿艿已经好久不使用 Hibernate 了，所以答案是直接复制的。</p>
</blockquote>
<p>我们可以通过两种方式使用 Spring 访问 Hibernate：</p>
<ul>
<li>使用 Hibernate 模板和回调进行控制反转。</li>
<li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点。</li>
</ul>
<blockquote>
<p>艿艿：不过我记得，12 年我用过 Spring JPA 的方式，操作 Hibernate 。具体可参考 <a href="http://www.iocoder.cn/Spring-Boot/battcn/v2-orm-jpa/">《一起来学 SpringBoot 2.x | 第六篇：整合 Spring Data JPA》</a> 。 </p>
</blockquote>
<p>当然，我们可以再来看一道 <a href="https://www.cnblogs.com/xiaoheike/p/5150553.html">《JPA 规范与 ORM 框架之间的关系是怎样的呢？》</a> 。这个问题，我倒是问过面试的候选人，哈哈哈哈。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>整理 Spring 面试题的过程中，又把 Spring 的知识点又复习了一遍。我突然有点想念，那本被我翻烂的 <a href="https://book.douban.com/subject/26767354/">《Spring 实战》</a> 。😈 我要买一本原版的！！！</p>
<p>参考与推荐如下文章：</p>
<ul>
<li>Java 架构 <a href="https://yq.aliyun.com/articles/669702">《Spring 面试题》</a></li>
<li>永顺 <a href="https://segmentfault.com/a/1190000007469968">《彻底征服 Spring AOP 之理论篇》</a></li>
<li>陌上桑花开花 <a href="https://blog.csdn.net/u014079773/article/details/52453002">《Java 面试题集（七）– Spring常见面试问题》</a></li>
<li>一人浅醉 <a href="https://www.cnblogs.com/yepei/p/4716112.html">《Spring 的 @Transactional 注解详细用法》</a></li>
<li>dalaoyang <a href="https://juejin.im/post/5b065000f265da0de45235e6">《Spring 面试题》</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>精尽计算机网络面试题</title>
    <url>/2016/10/12/%E7%B2%BE%E5%B0%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="精尽计算机网络面试题"><a href="#精尽计算机网络面试题" class="headerlink" title="精尽计算机网络面试题"></a>精尽计算机网络面试题</h1><p>以下面试题，基于网络整理，和自己编辑。具体参考的文章，会在文末给出所有的链接。</p>
<p>如果胖友有自己的疑问，欢迎在星球提问，我们一起整理吊吊的【网络】面试题的大保健。</p>
<p>而题目的难度，艿艿尽量按照从容易到困难的顺序，逐步下去。</p>
<p>因为网络是个很大的话题，所以本文以常见的 TCP 和 HTTP 题目为主，例如：</p>
<ul>
<li>TCP 三次握手、四次挥手是什么？</li>
<li>HTTP1.0、HTTP1.1、HTTP2 等的区别？</li>
<li>…</li>
</ul>
<p><strong>注意，经常问的问题，会在前面加【重要】标识</strong>。</p>
<h1 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h1><p>强烈推荐阅读两篇文章：</p>
<blockquote>
<p>艿艿：可以后续回过头来看。</p>
</blockquote>
<ul>
<li><a href="https://blog.csdn.net/justloveyou_/article/details/69611328">《计算机网络体系结构综述（上）》</a></li>
<li><a href="https://blog.csdn.net/justloveyou_/article/details/69612153">《计算机网络体系结构综述（下）》</a></li>
</ul>
<p>简单一瞥：</p>
<ul>
<li><strong>OSI 七层体系结构</strong>具有概念清楚、理论完整的特点，是一个理论上的国际标准，但却不是事实上的国际标准。</li>
<li>具有简单易用特点的 <strong>TCP/IP 四层体系结构</strong>则是事实上的标准。</li>
<li>需要指出的是，<strong>五层体系结构</strong>虽然综合了 OSI 和 TCP/IP 的优点，但其只是为了学术学习研究而提出的，没有具体的实际意义。</li>
<li>三者结构示意图如下所示：<img src="http://cdn.tuwenbin.vip/d6f64b4331cc61156c5a098c18ce05a9.png" alt="1">原理体系结构 VS OS VS TCP/IP</li>
</ul>
<h2 id="简述-OSI-七层体系结构"><a href="#简述-OSI-七层体系结构" class="headerlink" title="简述 OSI 七层体系结构"></a>简述 OSI 七层体系结构</h2><blockquote>
<p>艿艿：比较复杂，至少要说出有哪些层。</p>
</blockquote>
<p>自上而下是：</p>
<ul>
<li>应用层（数据）：确定进程之间通信的性质以满足用户需要以及提供网络与用户应用</li>
<li>表示层（数据）：主要解决用户信息的语法表示问题，如加密解密</li>
<li>会话层（数据）：提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制，如服务器验证用户登录便是由会话层完成的</li>
<li>传输层（段）：实现网络不同主机上用户进程之间的数据通信，可靠<br>与不可靠的传输，传输层的错误检测，流量控制等</li>
<li>网络层（包）：提供逻辑地址（IP）、选路，数据从源端到目的端的<br>传输</li>
<li>数据链路层（帧）：将上层数据封装成帧，用MAC地址访问媒介，错误检测与修正</li>
<li>物理层（比特流）：设备之间比特流的传输，物理接口，电气特性等</li>
</ul>
<p>详细可以看 <a href="https://blog.csdn.net/justloveyou_/article/details/69612153">《计算机网络体系结构综述（下）》</a> 的 <a href="http://svip.iocoder.cn/Net/Interview/#">「二. OSI 七层体系结构简述」</a> 小节。</p>
<p><a href="https://user-gold-cdn.xitu.io/2018/7/29/164e529309f0fa33?imageslim">OSI 七层体系结构</a></p>
<h2 id="简述-TCP-IP-四层体系结构"><a href="#简述-TCP-IP-四层体系结构" class="headerlink" title="简述 TCP/IP 四层体系结构"></a>简述 TCP/IP 四层体系结构</h2><blockquote>
<p>艿艿：比较复杂，至少要说出有哪些层。</p>
</blockquote>
<p>自上而下是：</p>
<blockquote>
<p>实际上，如果我们把一些 RPC 框架的分层套到 TCP/IP 四层体系结构，也是可以的。跳到 <a href="http://svip.iocoder.cn/Dubbo/Interview/">《精尽 Dubbo 面试题》</a> 的 <a href="http://svip.iocoder.cn/Dubbo/Interview/#Dubbo-%E6%A1%86%E6%9E%B6%E7%9A%84%E5%88%86%E5%B1%82%E8%AE%BE%E8%AE%A1">「Dubbo 框架的分层设计」</a> 问题瞅瞅噢。</p>
</blockquote>
<ul>
<li><p>应用层</p>
<blockquote>
<p>HTTP、TELNET、FTP、SMTP</p>
</blockquote>
</li>
<li><p>传输层</p>
<blockquote>
<p>TCP、UDP</p>
</blockquote>
</li>
<li><p>网络层</p>
<blockquote>
<p>IP、ICMP</p>
</blockquote>
</li>
<li><p>数据接口</p>
<blockquote>
<p>PPP</p>
</blockquote>
</li>
</ul>
<p>详细可以看 <a href="https://blog.csdn.net/justloveyou_/article/details/69612153">《计算机网络体系结构综述（下）》</a> 的 <a href="http://svip.iocoder.cn/Net/Interview/#">「三. TCP/IP 四层体系结构」</a> 小节。</p>
<h2 id="知道各个层使用的是哪个数据交换设备？"><a href="#知道各个层使用的是哪个数据交换设备？" class="headerlink" title="知道各个层使用的是哪个数据交换设备？"></a>知道各个层使用的是哪个数据交换设备？</h2><blockquote>
<p>这个问题，了解即可。</p>
</blockquote>
<ul>
<li><p>网关：应用层、传输层。</p>
<blockquote>
<p>网关在传输层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。</p>
<p>网关的结构也和路由器类似，不同的是互连层。网关既可以用于广域网互连，也可以用于局域网互连。</p>
</blockquote>
</li>
<li><p>【重点】路由器：网络层</p>
<blockquote>
<p>路由选择、存储转发</p>
</blockquote>
</li>
<li><p>【重点】交换机：数据链路层、网络层</p>
<blockquote>
<p>识别数据包中的 MAC 地址信息，根据 MAC 地址进行转发，并将这些 MAC 地址与对应的端口记录在自己内部的一个地址表中。</p>
</blockquote>
</li>
<li><p>网桥：数据链路层</p>
<blockquote>
<p>将两个 LAN 连起来，根据 MAC 地址来转发帧。</p>
</blockquote>
</li>
<li><p>集线器（Hub）：物理层</p>
<blockquote>
<p>纯硬件设备，主要用来连接计算机等网络终端。</p>
</blockquote>
</li>
<li><p>中继器：物理层</p>
<blockquote>
<p>在比特级别对网络信号进行再生和重定时，从而使得它们能够在网络上传输更长的距离。</p>
</blockquote>
</li>
</ul>
<p>🦅 <strong>交换机是什么？</strong></p>
<p>在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的 MAC（网卡的硬件地址）的 NIC（网卡）挂接在哪个端口上，通过内部交换矩阵迅速将数据包传送到目的端口。<strong>目的 MAC 若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表中</strong>。</p>
<p>交换机工作于 OSI 参考模型的第二层，即数据链路层。交换机内部的 CPU 会在每个端口成功连接时，通过 ARP 协议学习它的 MAC  地址，保存成一张 ARP 表。在今后的通讯中，发往该 MAC  地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不能划分网络层广播，即广播域。</p>
<p>🦅  <strong>路由器是什么？</strong></p>
<p>路由器（Router），是一种计算机网络设备，提供了路由与转发两种重要机制，可以决定数据包从来源端到目的端所经过的路由路径（host 到 host 之间的传输路径），这个过程称为<strong>路由</strong>；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为<strong>转发</strong>。所以，路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。</p>
<p>路由工作在 OSI 模型的第三层 —— 即网络层，例如 IP 协议。当然，这也是路由器与交换器的<strong>差别</strong>，路由器是属于 OSI 第三层的产品，交换器是 OSI 第二层的产品(这里特指二层交换机)。</p>
<p>🦅 <strong>常见的路由选择协议，以及它们的区别？</strong></p>
<p>常见的路由选择协议有：RIP 协议、OSPF 协议。</p>
<ul>
<li>RIP 协议：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是 15 跳。如果大于 15 跳，它就会丢弃数据包。</li>
<li>OSPF 协议：底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。</li>
</ul>
<p>🦅 <strong>什么是网关设备？</strong></p>
<p>这个我们就不在本文中多写，感兴趣的胖友，可以看看 <a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E5%85%B3">《维基百科 —— 网关》</a> 文章。</p>
<p>🦅 <strong>详细说明 Keepalived 的故障切换工作原理？</strong></p>
<p>这种故障切换，是通过 <strong>VRRP</strong> 协议来实现的。</p>
<ul>
<li>主节点会按一定的时间间隔发送心跳信息的广播包，告诉备节点自己的存活状态信息。</li>
<li>当主节点发生故障时，备节点在一段时间内就收到广播包，从而判断主节点出现故障，因此会调用自身的接管程序来接管主节点的 IP 资源及服务。</li>
<li>当主节点恢复时，备节点会主动释放资源，恢复到接管前的状态，从而来实现主备故障切换</li>
</ul>
<p>例如，MySQL 基于 Keepalived 实现高可用。详细的，可以看看 <a href="https://www.cnblogs.com/gomysql/p/3856484.html">《Keepalived + MySQL实现高可用》</a> 。</p>
<h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><h2 id="IP-地址的分类？"><a href="#IP-地址的分类？" class="headerlink" title="IP 地址的分类？"></a>IP 地址的分类？</h2><p>IP 地址是指互联网协议地址，是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p>
<p>IP 地址编址方案将IP地址空间划分为 A、B、C、D、E 五类，其中 A、B、C 是基本类，D、E 类作为多播和保留使用，为特殊地址。</p>
<p>每个 IP 地址包括两个标识码（ID），即网络 ID 和主机 ID 。同一个物理网络上的所有主机都使用同一个网络 ID ，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机 ID 与其对应。A~E 类地址的特点如下：</p>
<p><img src="http://cdn.tuwenbin.vip/l7re66fk.bmp">五类互联网地址</p>
<ul>
<li>A 类地址：以 0 开头，第一个字节范围：0~127 。</li>
<li>B 类地址：以 10 开头，第一个字节范围：128~191 。</li>
<li>C 类地址：以 110 开头，第一个字节范围：192~223。</li>
<li>D 类地址：以 1110 开头，第一个字节范围：224~239 。</li>
<li>E 类地址：以 1111 开头，保留地址。</li>
</ul>
<p>详细的，可以看看 <a href="https://blog.csdn.net/kzadmxz/article/details/73658168">《IP 地址分类（A类 B类 C类 D类 E类）》</a> 文章。</p>
<p>🦅 <strong>IP 地址与物理地址的区别？</strong></p>
<ul>
<li>物理地址(MAC 地址)，是数据链路层和物理层使用的地址。</li>
<li>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。</li>
<li>其中 ARP 协议用于 IP 地址与物理地址的对应。</li>
</ul>
<p>详细的，可以看看 <a href="http://blog.sciencenet.cn/blog-411071-1037673.html">《即生瑜，何生亮 —— MAC 地址与 IP 地址》</a> 文章。</p>
<h2 id="网络层的-ARP-协议工作原理？"><a href="#网络层的-ARP-协议工作原理？" class="headerlink" title="网络层的 ARP 协议工作原理？"></a>网络层的 ARP 协议工作原理？</h2><p>网络层的 ARP 协议完成了 IP 地址与物理地址的映射。</p>
<ul>
<li>首先，每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。</li>
<li>当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP 列表中是否存在该 IP 地址对应的 MAC 地址：<ul>
<li>如果有，就直接将数据包发送到这个 MAC 地址。</li>
<li>如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的 MAC 地址。此 ARP 请求数据包里包括源主机的 IP  地址、硬件地址、以及目的主机的 IP 地址。网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 I P地址一致。<ul>
<li>如果不相同，就忽略此数据包。</li>
<li>如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中(如果 ARP 表中已经存在该 IP 的信息，则将其覆盖)，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址。<ul>
<li>源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。</li>
<li>如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意，在 OSI 模型中 ARP 协议属于链路层；而在 TCP/IP 模型中，ARP 协议属于网络层。</p>
</blockquote>
<h2 id="如何划分子网、超网？"><a href="#如何划分子网、超网？" class="headerlink" title="如何划分子网、超网？"></a>如何划分子网、超网？</h2><p>🦅 <strong>如何划分子网？</strong></p>
<blockquote>
<p>艿艿：可选了解。</p>
</blockquote>
<p>划分子网（变长子网掩码 VLSM）：划分子网的方法是从网络的主机号借用若干位作为子网号 subnet-id ，与此同时主机号也减少相应位数（总位数 32 位不变）。</p>
<p>由此两级 IP 地址可变为三级 IP 地址：<code>IP地址 ::= &#123;&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;&#125;</code> ，划分子网只是把 IP 地址的主机号这部分进行再划分，并不改变 IP 地址原来的网络号。</p>
<p>🦅 <strong>如何划分超网？</strong></p>
<blockquote>
<p>艿艿：可选了解。</p>
</blockquote>
<p>构造超网（无分类编址 CIDR）：CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，把 32 位的 IP 地址划分为两个部分。</p>
<p>例如：<code>128.14.35.7/20</code> 是某个 CIDR 地址块中的一个地址，其前 20 位是网络前缀（用下划线表示的部分），后面的 12 位为主机号</p>
<p>🦅 <strong>子网掩码的作用？</strong></p>
<p>子网掩码只有一个作用，就是将某个 IP 地址划分成<strong>网络地址</strong>和<strong>主机地址</strong>两部分。</p>
<p>用于子网掩码的位数，决定于可能的子网数目和每个子网的主机数目。</p>
<h2 id="什么是单播、组播-多播-、广播、任播？"><a href="#什么是单播、组播-多播-、广播、任播？" class="headerlink" title="什么是单播、组播(多播)、广播、任播？"></a>什么是单播、组播(多播)、广播、任播？</h2><blockquote>
<p>艿艿：这个问题，一般面试应该不问，主要是为了大家扩充下知识面吧。</p>
</blockquote>
<ul>
<li><strong>单播</strong>(unicast): 是指封包在计算机网络的传输中，目的地址为单一目标的一种传输方式。它是现今网络应用最为广泛，通常所使用的网络协议或服务大多采用单播传输，例如一切基于TCP的协议。</li>
<li><strong>组播</strong>(multicast): 也叫多播， 多点广播或群播。 指把信息同时传递给一组目的地址。它使用策略是最高效的，因为消息在每条网络链路上只需传递一次，而且只有在链路分叉的时候，消息才会被复制。</li>
<li><strong>广播</strong>(broadcast):是指封包在计算机网络中传输时，目的地址为网络中所有设备的一种传输方式。实际上，这里所说的“所有设备”也是限定在一个范围之中，称为“广播域”。</li>
<li><strong>任播</strong>(anycast):是一种网络寻址和路由的策略，使得资料可以根据路由拓朴来决定送到“最近”或“最好”的目的地。</li>
</ul>
<p>感兴趣的胖友，可以详细看 <a href="https://colobu.com/2014/10/21/udp-and-unicast-multicast-broadcast-anycast/">《单播，组播(多播)，广播以及任播》</a> 文章。</p>
<h2 id="区别-IPv4-和-IPv6-？"><a href="#区别-IPv4-和-IPv6-？" class="headerlink" title="区别 IPv4 和 IPv6 ？"></a>区别 IPv4 和 IPv6 ？</h2><ul>
<li>我们大多数人使用的是第二代互联网 IPv4 技术，它的最大问题是网络地址资源有限，从理论上讲能编址 1600 万个网络、链接 40 亿台主机。而根据相关数据，全球 IPv4 的 IP 地址已经即将用完。</li>
<li>而 IPv6 是作为 IETF 设计的用于替代现行版本 IP 协议(IPv4)的下一代 IP 协议，其 IPV6 地址长度为 12 8位，地址空间增大了 2^98 次方倍，几乎可以说是用之不竭的。所以随着 IPv4 不足，支持 IPv6 的网络势必会增长。</li>
</ul>
<h1 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h1><blockquote>
<p>艿艿：这个小节，可以快速看。因为，面试不一定问的很多。</p>
</blockquote>
<h2 id="ICMP-协议的主要功能？"><a href="#ICMP-协议的主要功能？" class="headerlink" title="ICMP 协议的主要功能？"></a>ICMP 协议的主要功能？</h2><p>用于在 IP 主机、路由器之间传递控制消息。</p>
<p>如下图所示：<img src="http://cdn.tuwenbin.vip/2tktfu0r.bmp" alt="2tktfu0r">ICMP 协议</p>
<h2 id="简述一下-ping-的原理？"><a href="#简述一下-ping-的原理？" class="headerlink" title="简述一下 ping 的原理？"></a>简述一下 ping 的原理？</h2><p>一般在网络不通的时候，大家会用 ping 测一下网络是否通畅。</p>
<p>ping 是基于 ICMP 协议工作的。ICMP 全称 Internet Control Message Protocol ，就是互联网<strong>控制</strong>报文协议。这里的关键词是“控制”，那具体是怎么控制的呢？ 网络包在异常负责的网络环境中传输时，会遇到各种问题，当遇到问题时，要传出消息，报告情况，这样才能调整传输策略。</p>
<p>ICMP 报文是封装在 IP 包里面的。因为传输指令的时候，肯定需要源地址和目标地址。如下图：<img src="http://cdn.tuwenbin.vip/sk250l8t.bmp" alt="sk250l8t">ICMP 报文</p>
<h2 id="什么是-Traceroute-？"><a href="#什么是-Traceroute-？" class="headerlink" title="什么是 Traceroute ？"></a>什么是 Traceroute ？</h2><blockquote>
<p>Traceroute 是构建在 ICMP 协议之上的应用。</p>
</blockquote>
<p>Traceroute ，是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。</p>
<blockquote>
<p>前面说到，尽管 ping 工具也可以进行侦测，但是，因为 IP 头的限制，ping 不能完全的记录下所经过的路由器。所以Traceroute 正好就填补了这个缺憾。</p>
</blockquote>
<p>Traceroute 的<strong>原理</strong>是非常非常的有意思。</p>
<blockquote>
<ul>
<li>它受到目的主机的 IP 后，首先给目的主机发送一个 TTL=1（还记得 TTL 是什么吗？）的 UDP(后面就知道  UDP是什么了)数据包，而经过的第一个路由器收到这个数据包以后，就自动把 TTL 减1，而 TTL 变为 0  以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的 ICMP 数据报给主机。</li>
<li>主机收到这个数据报以后再发一个 TTL=2 的 UDP 数据报给目的主机，然后刺激第二个路由器给主机发 ICMP 数据 报。如此往复直到到达目的主机。</li>
</ul>
<p>这样，traceroute 就拿到了所有的路由器 IP 。从而避开了 IP 头只能记录有限路由 IP 的问题。</p>
</blockquote>
<p>有人要问，我怎么知道 UDP 到没到达目的主机呢？</p>
<blockquote>
<p>这就涉及一个技巧的问题，TCP 和 UDP 协议有一个端口号定义，而普通的网络程序只监控少数的几个号码较小的端口，比如说 80、23  等等。而 traceroute 发送的是端口号 &gt;30000(真变态) 的 UDP  包，所以到达目的主机的时候，目的主机只能发送一个端口不可达的 ICMP 数据报给主机。主机接到这个报告以后就知道，目标主机到了。</p>
</blockquote>
<p>😈 很多情况下，在我们 ping 不通目标地址时，会尝试使用 traceroute 命令，看看是否在中间哪个 IP 无法访问。</p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="TCP-是什么？"><a href="#TCP-是什么？" class="headerlink" title="TCP 是什么？"></a>TCP 是什么？</h2><p>TCP(Transmission Control Protocol)，传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。主要特点如下：</p>
<ul>
<li><p>TCP 是面向连接的。</p>
<blockquote>
<p>就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接</p>
</blockquote>
</li>
<li><p>每一条 TCP 连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）。</p>
</li>
<li><p>TCP 提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达。</p>
</li>
<li><p>TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据。</p>
</li>
<li><p>面向字节流。</p>
<blockquote>
<p>TCP 中的“流”（Stream），指的是流入进程或从进程流出的字节序列。</p>
<p>“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</p>
</blockquote>
</li>
</ul>
<h2 id="TCP-对应的应用层协议？"><a href="#TCP-对应的应用层协议？" class="headerlink" title="TCP 对应的应用层协议？"></a>TCP 对应的应用层协议？</h2><ul>
<li>FTP ：定义了文件传输协议，使用 21 端口。常说某某计算机开了 FTP 服务便是启动了文件传输服务。下载文件，上传主页，都要用到 FTP 服务。</li>
<li>Telnet ：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于 DOS 模式下的通信服务。如以前的 BBS 是纯字符界面的，支持 BBS 的服务器将 23 端口打开，对外提供服务。</li>
<li>邮箱<ul>
<li>SMTP ：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么 SMTP 端口设置这个栏，服务器开放的是 25 号端口。</li>
<li>POP3 ：它是和 SMTP 对应，POP3 用于接收邮件。通常情况下，POP3 协议所用的是 110 端口。也是说，只要你有相应的使用 POP3 协议的程序（例如 Foxmail 或 Outlook），就可以不以 Web 方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是  163 邮箱就没有必要先进入网易网站，再进入自己的邮箱来收信）。</li>
</ul>
</li>
<li>HTTP ：从 Web 服务器传输超文本到本地浏览器的传送协议。</li>
</ul>
<h2 id="TCP-头部是怎么样的？"><a href="#TCP-头部是怎么样的？" class="headerlink" title="TCP 头部是怎么样的？"></a>TCP 头部是怎么样的？</h2><ul>
<li><a href="https://github.com/jawil/blog/issues/14">《通俗大白话来理解 TCP 协议的三次握手和四次分手》</a> 的 <a href="http://svip.iocoder.cn/Net/Interview/#">「TCP头部」</a> 小节。</li>
<li><a href="https://blog.csdn.net/qq_34501940/article/details/51073691">《TCP 协议的学习    （二）TCP 头部信息》</a></li>
</ul>
<h2 id="【重要】什么是-TCP-三次握手？"><a href="#【重要】什么是-TCP-三次握手？" class="headerlink" title="【重要】什么是 TCP 三次握手？"></a>【重要】什么是 TCP 三次握手？</h2><p>三次握手，简单来说，就是：</p>
<p><a href="https://camo.githubusercontent.com/91cee189ca7c400e3be6aa35cdda000ecbb58930/687474703a2f2f6f6f327239726e7a702e626b742e636c6f7564646e2e636f6d2f3630363537332d32303137303331373139313333363933322d313635343735313132332e706e67">TCP 三次握手的漫画</a></p>
<ul>
<li>发送方：我要和你建立链接？</li>
<li>接收方：你真的要和我建立链接么？</li>
<li>发送方：我真的要和你建立链接，成功。</li>
</ul>
<p>详细来说，步骤如下：</p>
<p><img src="http://cdn.tuwenbin.vip/hfd2awzv.bmp" alt="hfd2awzv">TCP 三次握手的干货</p>
<ul>
<li><p>第一次握手：Client 将标志位 <code>SYN=1</code> ，随机产生一个值 <code>seq=J</code> ，并将该数据包发送给 Server 。此时，Client 进入SYN_SENT 状态，等待 Server 确认。</p>
</li>
<li><p>第二次握手：Server 收到数据包后由标志位 <code>SYN=1</code> 知道Client请求建立连接，Server 将标志位 <code>SYN</code> 和 <code>ACK</code> 都置为 1 ，<code>ack=J+1</code>，随机产生一个值 <code>seq=K</code> ，并将该数据包发送给 Client 以确认连接请求，Server 进入 <code>SYN_RCVD</code> 状态。此时，Server 进入 SYC_RCVD 状态。</p>
</li>
<li><p>第三次握手：Client 收到确认后，检查 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ack<br></code></pre></td></tr></table></figure>

<p> 是否为 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">J+1<br></code></pre></td></tr></table></figure>

<p> ，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ACK<br></code></pre></td></tr></table></figure>

<p> 是否为 1 。</p>
<ul>
<li>如果正确，则将标志位 <code>ACK</code> 置为 1 ，<code>ack=K+1</code> ，并将该数据包发送给 Server 。此时，Client 进入 ESTABLISHED 状态。</li>
<li>Server 检查 <code>ack</code> 是否为 <code>K+1</code> ，<code>ACK</code> 是否为 1 ，如果正确则连接建立成功。此时 Server 进入 ESTABLISHED 状态，完成三次握手，随后 Client 与 Server 之间可以开始传输数据了。</li>
</ul>
</li>
<li><p>仔细看来，Client 会发起两次数据包，分别是 <code>SYNC</code> 和 <code>ACK</code> ；Server 会发起一次数据包，包含 <code>SYNC</code> 和 <code>ACK</code> 。也就是说，三次握手的过程中，Client 和 Server 互相做了一次 <code>SYNC</code> 和 <code>ACK</code> 。</p>
</li>
</ul>
<p>🦅 <strong>为什么 TCP 连接需要三次握手，两次不可以么，为什么？</strong></p>
<p>为了防止<strong>已失效的连接请求</strong>报文突然又传送到了服务端，因而产生错误。</p>
<blockquote>
<p>客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达 Server 。</p>
<ul>
<li>若不采用“三次握手”，那么只要 Server 发出确认数据包，新的连接就建立了。由于 Client  此时并未发出建立连接的请求，所以其不会理睬 Server 的确认，也不与 Server 通信；而这时 Server 一直在等待 Client  的请求，这样 Server 就白白浪费了一定的资源。</li>
<li>若采用“三次握手”，在这种情况下，由于 Server 端没有收到来自客户端的确认，则就会知道 Client 并没有要求建立请求，就不会建立连接。</li>
</ul>
</blockquote>
<p>在 <a href="https://github.com/jawil/blog/issues/14">《通俗大白话来理解 TCP 协议的三次握手和四次挥手》</a> 中，搜 <a href="http://svip.iocoder.cn/Net/Interview/#">“为什么要三次握手”</a> 关键字，也有非常好的解答。</p>
<ul>
<li><strong>这就很明白了，防止了服务器端的一直等待而浪费资源</strong>。</li>
</ul>
<p><strong>🦅 客户端不断进行请求链接会怎样？</strong></p>
<p>服务器端准备为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认后创建。如果此时客户端一直不确认，会造成 SYN 攻击，即：</p>
<blockquote>
<p>SYN 攻击，英文为 SYN Flood ，是一种典型的 DoS/DDoS 攻击。</p>
</blockquote>
<ul>
<li><p>1、客户端向服务端发送请求连接数据包。</p>
</li>
<li><p>2、服务端向客户端发送确认数据包。</p>
</li>
<li><p>3、客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认。</p>
<blockquote>
<p>这是这一步！！！</p>
</blockquote>
</li>
</ul>
<p>🚀 如何检测 SYN 攻击？检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。在 Linux/Unix 上可以使用系统自带的 netstat 命令来检测 SYN 攻击。</p>
<p>🚀 怎么解决 SYN 攻击呢？答案是<strong>只能预防</strong>，没有彻底根治的办法，除非不使用 TCP 。方式如下：</p>
<ul>
<li><p>1、限制同时打开 SYN 半链接的数目</p>
<blockquote>
<p>艿艿：是不是很像我们常用的“限流”。</p>
</blockquote>
</li>
<li><p>2、缩短 SYN 半链接的 Timeout 时间</p>
<blockquote>
<p>艿艿：是不是很像我们常用的“超时”。</p>
</blockquote>
</li>
<li><p>3、关闭不必要的服务。</p>
<blockquote>
<p>艿艿：酱紫，这个服务就不会被 SYN 攻击连接。</p>
</blockquote>
</li>
<li><p>4、增加最大半连接数。</p>
</li>
<li><p>5、过滤网关防护。</p>
</li>
<li><p>6、</p>
<p>SYN cookie</p>
<p> 技术。</p>
<blockquote>
<p>艿艿：有一点点重新“设计” TCP 的味道，或者可以理解成对 TCP 的增强。</p>
</blockquote>
</li>
</ul>
<h2 id="【重要】什么是-TCP-四次挥手？"><a href="#【重要】什么是-TCP-四次挥手？" class="headerlink" title="【重要】什么是 TCP 四次挥手？"></a>【重要】什么是 TCP 四次挥手？</h2><p>四次挥手，简单来说，就是：</p>
<ul>
<li>发送方：我要和你断开连接！</li>
<li>接收方：好的，断吧。</li>
<li>接收方：我也要和你断开连接！</li>
<li>发送方：好的，断吧。</li>
</ul>
<p>详细来说，步骤如下：</p>
<p><img src="http://cdn.tuwenbin.vip/q4pj31zz.bmp" alt="q4pj31zz"></p>
<p>TCP 四次挥手的干货</p>
<blockquote>
<p>如下使用 Client 和 Server 的方式，仅仅是为了方便，也是可以从 Server 向 Client 发起。</p>
</blockquote>
<ul>
<li>第一次挥手：Client 发送一个 <code>FIN=M</code> ，用来关闭 Client 到 Server 的数据传送。此时，Client 进入 FIN_WAIT_1 状态。</li>
<li>第二次挥手，Server 收到 <code>FIN</code> 后，发送一个 <code>ACK</code> 给 Client ，确认序号为 <code>M+1</code>（与 <code>SYN</code> 相同，一个 <code>FIN</code> 占用一个序号）。此时，Server 进入 CLOSE_WAIT 状态。注意，TCP 链接处于<strong>半关闭</strong>状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。</li>
<li>第三次挥手，Server 发送一个 <code>FIN=N</code> ，用来关闭 Server 到 Client 的数据传送。此时 Server 进入 LAST_ACK 状态。</li>
<li>第四次挥手，Client 收到 <code>FIN</code> 后，此时 Client 进入 TIME_WAIT 状态。接着，Client 发送一个 <code>ACK</code> 给 Server ，确认序号为 <code>N+1</code> 。Server 接收到后，此时 Server 进入 CLOSED 状态，完成四次挥手。</li>
</ul>
<p>🦅 <strong>为什么要四次挥手？</strong></p>
<p>TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。<strong>TCP 是全双工模式</strong>，这就意味着：</p>
<ul>
<li><p>当主机 1 发出 <code>FIN</code> 报文段时，只是表示主机 1 已经没有数据要发送了，主机 1 告诉主机 2 ，它的数据已经全部发送完毕了；<strong>但是，这个时候主机 1 还是可以接受来自主机 2 的数据；</strong>当主机 2 返回 <code>ACK</code> 报文段时，表示它已经知道主机 1 没有数据发送了，但是主机 2 还是可以发送数据到主机 1 的。</p>
<blockquote>
<p>艿艿：因为主机 2 此时可能还有数据想要发送给主机 1 ，所以挥手不能像握手只有三次，而是多了那么“一次”！</p>
</blockquote>
</li>
<li><p>当主机 2 也发送了 <code>FIN</code> 报文段时，这个时候就表示主机 2 也没有数据要发送了，就会告诉主机 1 ，我也没有数据要发送了，之后彼此就会愉快的中断这次 TCP 连接。</p>
<blockquote>
<p>艿艿：我们把四次挥手，理解成一次和平的挥手~</p>
</blockquote>
</li>
</ul>
<p>如果要正确的理解四次的原理，就需要了解四次挥手过程中的状态变化。</p>
<blockquote>
<p>主动方=发送方；被动方=接收方。</p>
<p>状态前面的（主动方）（被动方），表示该状态属于谁。</p>
</blockquote>
<ul>
<li><p>（主动方）FIN_WAIT_1 ：这个状态要好好解释一下，其实 FIN_WAIT_1 和 FIN_WAIT_2 状态的真正含义都是表示等待对方的 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">FIN<br></code></pre></td></tr></table></figure>

<p> 报文。而这两种状态的区别是：</p>
<ul>
<li>FIN_WAIT_1 状态实际上是当 Socket 在 ESTABLISHED 状态时，它想主动关闭连接，向对方发送了 <code>FIN</code> 报文，此时该 Socket 即进入到 FIN_WAIT_1 状态。</li>
<li>而当对方回应 <code>ACK</code> 报文后，则进入到 FIN_WAIT_2 状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应<code>ACK</code> 报文。所以， FIN_WAIT_1 状态一般是比较难见到的，而 FIN_WAIT_2 状态还有时常常可以用 netstat 看到。</li>
</ul>
</li>
<li><p>（主动方）FIN_WAIT_2 ：上面已经详细解释了这种状态，实际上 FIN_WAIT_2 状态下的 Socket，表示半连接，也即有一方要求 close 连接，但另外还告诉对方，我暂时还有点数据需要传送给你(<code>ACK</code> 信息)，稍后再关闭连接。</p>
</li>
<li><p>（被动方）CLOSE_WAIT ：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方 close 一个 Socket 后发送 <code>FIN</code> 报文给自己，你系统毫无疑问地会回应一个 <code>ACK</code> 报文给对方，此时则进入到 CLOSE_WAIT 状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close 这个 Socket ，发送 <code>FIN</code> 报文给对方，也即关闭连接。所以你在 CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。</p>
</li>
<li><p>（被动方）LAST_ACK ：这个状态还是比较容易好理解的，它是被动关闭一方在发送 <code>FIN</code> 报文后，最后等待对方的 <code>ACK</code> 报文。当收到 <code>ACK</code> 报文后，也即可以进入到 CLOSED 可用状态了。</p>
</li>
<li><p>（主动方）TIME_WAIT ：表示收到了对方的 <code>FIN</code> 报文，并发送出了 <code>ACK</code> 报文，就等 <a href="https://blog.csdn.net/xiaofei0859/article/details/6044694">2MSL</a> 后即可回到 CLOSED 可用状态了。如果 FIN_WAIT_1 状态下，收到了对方同时带 <code>FIN</code> 标志和 <code>ACK</code> 标志的报文时，可以直接进入到 TIME_WAIT 状态，而无须经过 FIN_WAIT_2 状态。</p>
<blockquote>
<p><strong>为何一定要等 2MSL ？</strong></p>
<p>如果不等，释放的端口可能会重连刚断开的服务器端口，这样依然存活在网络里的老的 TCP 报文可能与新 TCP 连接报文冲突，造成数据冲突，为避免此种情况，需要耐心等待网络老的 TCP 连接的活跃报文全部死翘翘，2MSL 时间可以满足这个需求（尽管非常保守）！</p>
<p>更多，可以看看知乎 <a href="https://www.zhihu.com/question/67013338">《为什么 TCP 4 次挥手时等待为 2MSL？》</a> 的讨论。</p>
</blockquote>
</li>
<li><p>CLOSED ：表示连接中断。</p>
</li>
</ul>
<p>另外，关于 TIME_WAIT 和 CLOSE_WAIT 状态的区别，胖友可以在细看下 <a href="https://blog.csdn.net/kobejayandy/article/details/17655739">《TIME_WAIT 和 CLOSE_WAIT 状态区别》</a> 。</p>
<h2 id="【重要】TCP-数据如何传输？"><a href="#【重要】TCP-数据如何传输？" class="headerlink" title="【重要】TCP 数据如何传输？"></a>【重要】TCP 数据如何传输？</h2><p>建立连接后，两台主机就可以相互传输数据了。如下图所示：<img src="http://cdn.tuwenbin.vip/20201007095117.bmp" alt="2n6prj62">TCP 套接字的数据交换过程</p>
<ul>
<li><p>上图给出了主机 A 分 2 次（分 2 个数据包）向主机 B 传递 200 字节的过程。</p>
</li>
<li><p>首先，主机 A 通过 1 个数据包发送 100 个字节的数据，数据包的 <code>Seq</code>号设置为 1200 。主机 B 为了确认这一点，向主机 A 发送 <code>ACK</code></p>
<p> 包，并将 <code>Ack</code>号设置为 1301 。</p>
<ul>
<li><p>为了保证数据准确到达，目标机器在收到数据包（包括 <code>SYN</code> 包、<code>FIN</code> 包、普通数据包等）包后必须立即回传 <code>ACK</code> 包，这样发送方才能确认数据传输成功。</p>
</li>
<li><p>此时 <code>Ack</code>号为 1301 而不是 1201，原因在于 <code>Ack</code></p>
<p> 号的增量为传输的数据字节数。假设每次 <code>Ack</code>号不加传输的字节数，这样虽然可以确认数据包的传输，但无法明确 100 字节全部正确传递还是丢失了一部分，比如只传递了 80 字节。因此按如下的公式确认 <code>Ack</code>号：<code>Ack</code>号 = <code>Seq</code>号 + 传递的字节数 + 1 </p>
<ul>
<li>与三次握手协议相同，最后加 1 是为了告诉对方要传递的 <code>Seq</code> 号。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>OK，让我们重新来看下 TCP 的整个过程。如下图所示：<a href="https://camo.githubusercontent.com/36cf7d4e1598683fe72a5e1c3e837b16840f4085/687474703a2f2f6f6f327239726e7a702e626b742e636c6f7564646e2e636f6d2f6a656c6c797468696e6b544350342e6a7067">TCP 过程</a></p>
<p>🦅 <strong>TCP 数据传输丢失怎么办？</strong></p>
<blockquote>
<p>艿艿：这个问题，也可以改成提问，什么是 TCP 重传。</p>
</blockquote>
<p>因为各种原因，TCP 数据包可能存在丢失的情况，TCP 会进行数据重传。如下图所示：</p>
<p><img src="http://cdn.tuwenbin.vip/ig9iz01q.bmp" alt="ig9iz01q">TCP套接字数据传输过程中发生错误</p>
<ul>
<li><p>上图表示通过 <code>Seq</code> 1301 数据包向主机 B 传递 100 字节的数据，但中间发生了错误，主机 B 未收到。经过一段时间后，主机 A 仍未收到对于 <code>Seq</code> 1301 的 <code>ACK</code> 确认，因此尝试重传数据。为了完成数据包的重传，TCP 套接字每次发送数据包时都会<strong>启动定时器</strong>，如果在一定时间内没有收到目标机器传回的 <code>ACK</code> 包，那么定时器超时，数据包会重传。上图演示的是数据包丢失的情况，也会有 <code>ACK</code> 包丢失的情况，一样会重传。</p>
</li>
<li><p>重传超时时间(RTO，Retransmission Time Out)</p>
<blockquote>
<p>这个值太大了会导致不必要的等待，太小会导致不必要的重传，理论上最好是网络 RTT 时间，但又受制于网络距离与瞬态时延变化，所以实际上使用自适应的动态算法（例如 Jacobson 算法和 Karn 算法等）来确定超时时间。</p>
<p>往返时间（RTT，Round-Trip Time）表示从发送端发送数据开始，到发送端收到来自接收端的 <code>ACK</code> 确认包（接收端收到数据后便立即确认），总共经历的时延。</p>
</blockquote>
</li>
<li><p>重传次数</p>
<blockquote>
<p>TCP 数据包重传次数，根据系统设置的不同而有所区别。有些系统，一个数据包只会被重传 3 次，如果重传 3 次后还未收到该数据包的 <code>ACK</code> 确认，就不再尝试重传。但有些要求很高的业务系统，会不断地重传丢失的数据包，以尽最大可能保证业务数据的正常交互。</p>
<p>最后需要说明的是，发送端只有在收到对方的 <code>ACK</code> 确认包后，才会清空输出缓冲区中的数据。</p>
</blockquote>
</li>
</ul>
<p><strong>ps：TCP 数据传输的过程，和 MQ Broker 投递消息给 Consumer 是一样的，只有在 Consumer Ack 确认消息已经消费，该消息才不会再被投递给 Consumer 。</strong></p>
<p>另外，也推荐阅读 <a href="https://wizardforcel.gitbooks.io/network-basic/content/8.html">《网络基本功（九）：细说TCP重传》</a> 。</p>
<h2 id="【重要】什么是-TCP-滑动窗口？"><a href="#【重要】什么是-TCP-滑动窗口？" class="headerlink" title="【重要】什么是 TCP 滑动窗口？"></a>【重要】什么是 TCP 滑动窗口？</h2><p>在看 TCP 滑动窗口的概念之前，我们先来看看它出现的<strong>背景</strong>？</p>
<blockquote>
<p>将 TCP 与 UDP 这样的简单传输协议区分开来的是，它传输数据的质量。TCP 对于发送数据进行跟踪，这种数据管理需要协议有以下两大关键功能：</p>
<ul>
<li>可靠性：保证数据确实到达目的地。如果未到达，能够发现并重传。</li>
<li>数据流控：管理数据的发送速率，以使接收设备不致于过载。</li>
</ul>
<p>要完成这些任务，整个协议操作是围绕<strong>滑动窗口</strong> + <strong>确认机制</strong>来进行的。因此，理解了滑动窗口，也就是理解了 TCP 。</p>
</blockquote>
<p>那么，到底什么是 TCP 滑动窗口呢？</p>
<blockquote>
<p>滑动窗口协议，是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。</p>
<p>TCP 的滑动窗口解决了端到端的流量控制问题，允许接受方对传输进行限制，直到它拥有足够的缓冲空间来容纳更多的数据。</p>
</blockquote>
<p>可能这么描述之后，胖友会有点懵逼，那么建议看下面三篇文章，耐心~</p>
<ul>
<li><p><a href="https://www.cnblogs.com/luoquan/p/4886345.html">《TCP 滑动窗口控制流量的原理》</a></p>
<blockquote>
<p>比较易懂的一篇文章。</p>
</blockquote>
</li>
<li><p><a href="https://wizardforcel.gitbooks.io/network-basic/content/7.html">《网络基本功（八）：细说 TCP 滑动窗口》</a></p>
<blockquote>
<p>更为详细的一篇文章。</p>
</blockquote>
</li>
<li><p><a href="https://www.zhihu.com/question/32255109">《TCP 协议的滑动窗口具体是怎样控制流量的？》</a></p>
<blockquote>
<p>知乎上的讨论，重点看「wuxinliulei」和「安静的木小昊」的回答。特别是后者的，回答很生动形象。</p>
</blockquote>
</li>
</ul>
<h2 id="TCP-协议如何来保证传输的可靠性？"><a href="#TCP-协议如何来保证传输的可靠性？" class="headerlink" title="TCP 协议如何来保证传输的可靠性？"></a>TCP 协议如何来保证传输的可靠性？</h2><p>TCP 提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用 TCP 的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个 TCP 连接。</p>
<ul>
<li>在一个 TCP 连接中，仅有两方进行彼此通信。</li>
<li>而字节流服务意味着两个应用程序通过 TCP 链接交换 8bit 字节构成的字节流，TCP 不在字节流中插入记录标识符。</li>
</ul>
<p>对于可靠性，TCP 通过以下方式进行保证：</p>
<ul>
<li>数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据。</li>
<li>对失序数据包重排序：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TC P报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层。</li>
<li>丢弃重复数据：对于重复数据，能够丢弃重复数据。</li>
<li>应答机制：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。</li>
<li>超时重发：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
<li>流量控制：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP 使用的流量控制协议是可变大小的<strong>滑动窗口协议</strong>。</li>
</ul>
<h2 id="什么是-TCP-拥堵？"><a href="#什么是-TCP-拥堵？" class="headerlink" title="什么是 TCP 拥堵？"></a>什么是 TCP 拥堵？</h2><p>计算机网络中的带宽、交换结点中的缓存及处理机等都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做<strong>拥塞</strong>。</p>
<p>🦅 <strong>怎么解决 TCP 拥堵？</strong></p>
<p>通过拥塞控制来解决。拥堵控制，就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。注意，拥塞控制和流量控制不同，前者是一个<strong>全局性</strong>的过程，而后者指<strong>点对点</strong>通信量的控制。</p>
<p>拥塞控制的方法主要有以下四种：</p>
<ul>
<li>1、慢开始。</li>
<li>2、拥塞避免。</li>
<li>3、快重传。</li>
<li>4、快恢复。</li>
</ul>
<p><strong>1）慢开始</strong></p>
<p>不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。</p>
<p><strong>2）拥塞避免</strong></p>
<p>拥塞避免算法，让拥塞窗口缓慢增长，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1 ，而不是加倍，这样拥塞窗口按线性规律缓慢增长。</p>
<p><img src="http://cdn.tuwenbin.vip/8opvlv8d.bmp" alt="8opvlv8d">慢开始和拥塞避免算法的实现举例</p>
<p><strong>3）快重传</strong></p>
<p>快重传，要求接收方在收到一个<strong>失序的报文段</strong>后就立即发出<strong>重复确认</strong>（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时捎带确认。</p>
<p>快重传算法规定，发送方只要一连收到三个重复确认，就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>
<p><img src="http://cdn.tuwenbin.vip/txe7yfox.bmp" alt="txe7yfox">快重传的示意图</p>
<p><strong>4）快恢复</strong></p>
<p>快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 ssthresh 门限减半。</p>
<ul>
<li>但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。</li>
<li>所以此时不执行慢开始算法，而是将 cwnd 设置为 ssthresh 的大小，然后执行拥塞避免算法。</li>
</ul>
<p><img src="http://cdn.tuwenbin.vip/lxqlfqfm.bmp" alt="lxqlfqfm">从连续收到三个重复的确认转入拥堵避免</p>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><h2 id="UDP-是什么？"><a href="#UDP-是什么？" class="headerlink" title="UDP 是什么？"></a>UDP 是什么？</h2><p>UDP（User Data Protocol，用户数据报协议），是与 TCP 相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去。</p>
<p>主要特点如下：</p>
<ul>
<li><p>UDP 是无连接的。</p>
</li>
<li><p>UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）。</p>
</li>
<li><p>UDP 是面向报文的。</p>
</li>
<li><p>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。</p>
<blockquote>
<p>对实时应用很有用，如 直播，实时视频会议等</p>
</blockquote>
</li>
<li><p>UDP 支持一对一、一对多、多对一和多对多的交互通信。</p>
</li>
<li><p>UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。</p>
</li>
</ul>
<h2 id="UDP-对应的应用层协议？"><a href="#UDP-对应的应用层协议？" class="headerlink" title="UDP 对应的应用层协议？"></a>UDP 对应的应用层协议？</h2><ul>
<li>DNS ：用于域名解析服务，将域名地址转换为 IP 地址。DNS 用的是 53 号端口。</li>
<li>SNMP ：简单网络管理协议，使用 161 号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</li>
<li>TFTP(Trivial File Transfer Protocol)：简单文件传输协议，该协议在熟知端口 69 上使用 UDP 服务。</li>
</ul>
<h2 id="【重要】TCP-与-UDP-的区别"><a href="#【重要】TCP-与-UDP-的区别" class="headerlink" title="【重要】TCP 与 UDP 的区别"></a>【重要】TCP 与 UDP 的区别</h2><blockquote>
<p>这个问题，上面在介绍 TCP 和 UDP 都提到了，就是做了整合哈。</p>
</blockquote>
<p>TCP(Transmission Control Protocol)和 UDP(User Datagram Protocol) 协议属于传输层协议，它们之间的区别包括：</p>
<p><img src="http://cdn.tuwenbin.vip/fv7et7b4.bmp" alt="fv7et7b4"></p>
<p>TCP 与 UDP 的区别</p>
<ul>
<li>TCP 是面向连接的；UDP 是无连接的。</li>
<li>TCP 是可靠的；UDP 是不可靠的。</li>
<li>TCP 只支持点对点通信；UDP 支持一对一、一对多、多对一、多对多的通信模式。</li>
<li>TCP 是面向字节流的；UDP 是面向报文的。</li>
<li>TCP 有拥塞控制机制；UDP 没有拥塞控制，适合媒体通信。</li>
<li>TCP 首部开销(20 个字节)，比 UDP 的首部开销(8 个字节)要大。</li>
</ul>
<p>🦅 <strong>为什么 TCP 叫数据流模式？ UDP 叫数据报模式？</strong></p>
<p>所谓的<strong>“流模式”</strong>，是指<strong>TCP 发送端发送几次数据和接收端接收几次数据是没有必然联系的</strong>。</p>
<ul>
<li>比如你通过 TCP 连接给另一端发送数据，你只调用了一次 write ，发送了 100 个字节，但是对方可以分 10 次收完，每次 10 个字节；你也可以调用 10 次 write ，每次 10 个字节，但是对方可以一次就收完。</li>
<li>原因：这是因为 TCP 是面向连接的，一个 Socket 中收到的数据都是由同一台主机发出，且有序地到达，所以每次读取多少数据都可以。</li>
</ul>
<p>所谓的<strong>“数据报模式”</strong>，是指 <strong>UDP 发送端调用了几次 write ，接收端必须用相同次数的 read 读完</strong>。</p>
<ul>
<li>UDP 是基于报文的，在接收的时候，每次最多只能读取一个报文，报文和报文是不会合并的，如果缓冲区小于报文长度，则多出的部分会被丢弃。</li>
<li>原因：这是因为 UDP 是无连接的，只要知道接收端的 IP 和端口，任何主机都可以向接收端发送数据。这时候，如果一次能读取超过一个报文的数据，则会乱套。</li>
</ul>
<h2 id="UDP-报文的格式"><a href="#UDP-报文的格式" class="headerlink" title="UDP 报文的格式"></a>UDP 报文的格式</h2><p>UDP 报文格式</p>
<p><img src="http://cdn.tuwenbin.vip/6yf91kke.bmp" alt="6yf91kke"></p>
<ul>
<li>16 位 * 4 = 64 位 = 8 字节。</li>
</ul>
<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h2 id="DNS-是什么？"><a href="#DNS-是什么？" class="headerlink" title="DNS 是什么？"></a>DNS 是什么？</h2><ul>
<li>域名解析，<a href="http://www.xxx.com/">www.xxx.com</a> 转换成 IP ，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。</li>
<li>DNS 协议运行在 UDP 协议之上，使用端口号 53 。</li>
</ul>
<h2 id="主机解析域名的顺序？"><a href="#主机解析域名的顺序？" class="headerlink" title="主机解析域名的顺序？"></a>主机解析域名的顺序？</h2><ol>
<li>浏览器缓存</li>
<li>找本机的 hosts 文件</li>
<li>路由缓存</li>
<li>找 DNS 服务器(本地域名、顶级域名、根域名)<ul>
<li><a href="https://blog.csdn.net/wuchuanpingstone/article/details/6720723">迭代查询</a></li>
<li><a href="https://blog.csdn.net/wuchuanpingstone/article/details/6720723">递归查询</a></li>
</ul>
</li>
</ol>
<h2 id="DNS-使用什么协议？"><a href="#DNS-使用什么协议？" class="headerlink" title="DNS 使用什么协议？"></a>DNS 使用什么协议？</h2><blockquote>
<p>参见 <a href="https://benbenxiongyuan.iteye.com/blog/1088085">《DNS使用的是 TCP 协议还是 UDP 协议》</a> 文章。</p>
</blockquote>
<p>既使用 TCP 又使用 UDP 。</p>
<ul>
<li><p>区域传送时使用 TCP 协议。</p>
<blockquote>
<ul>
<li>辅域名服务器会定时（一般时 3 小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用 TCP 而不是 UDP ，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。</li>
<li>TCP 是一种可靠的连接，保证了数据的准确性。</li>
</ul>
</blockquote>
</li>
<li><p>域名解析时使用 UDP 协议。</p>
<blockquote>
<ul>
<li><p>客户端向 DNS 服务器查询域名，一般返回的内容都不超过 512 字节，用 UDP 传输即可。</p>
<blockquote>
<p>UDP 报文的最大长度为 512 字节。</p>
</blockquote>
</li>
<li><p>不用经过 TCP 三次握手，这样 DNS 服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向 DNS 服务器查询的时候使用 TCP ，但事实上，很多 DNS 服务器进行配置的时候，仅支持 UDP 查询包。</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP-是什么？"><a href="#HTTP-是什么？" class="headerlink" title="HTTP 是什么？"></a>HTTP 是什么？</h2><p>HTTP 协议，是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p>
<p>主要特点如下：</p>
<ul>
<li><p>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST 等等。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。</p>
</li>
<li><p>数据格式灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由Content-Type 加以标记。</p>
</li>
<li><p>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
<blockquote>
<p>主要指的是不使用 Keep-Alive 机制的情况下。</p>
</blockquote>
</li>
<li><p>无状态：HTTP 协议是无状态协议。无状态，是指协议对于事务处理没有记忆能力。无状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
<blockquote>
<p>无状态，所以更容易做服务的扩容，支撑更大的访问量。</p>
</blockquote>
</li>
<li><p>支持 B/S 及 C/S 模式。</p>
<blockquote>
<p>另外，HTTP 协议已经不仅仅使用在浏览器上。在前后端分离的架构中，又或者微服务架构的内部通信中，HTTP 因为其数据格式的通用性，和语言无关，被大规模使用。</p>
</blockquote>
</li>
</ul>
<h2 id="HTTP-基本格式"><a href="#HTTP-基本格式" class="headerlink" title="HTTP 基本格式"></a>HTTP 基本格式</h2><blockquote>
<p>艿艿：详细的，可以看看 <a href="https://github.com/kaiye/kaiye.github.com/issues/3">《猫哥网络编程系列：详解 BAT 面试题》</a> 文章。</p>
</blockquote>
<p>🦅 <strong>HTTP 请求格式</strong></p>
<p><img src="http://cdn.tuwenbin.vip/60wx40i3.bmp" alt="60wx40i3">HTTP 请求格式</p>
<ul>
<li>请求行：用来说明请求类型，要访问的资源以及所使用的 HTTP 版本。</li>
<li>请求头部：紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息从第二行起为请求头部。<ul>
<li>HOST ，将指出请求的目的地。</li>
<li>User-Agent ，服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础。该信息由你的浏览器来定义，并且在每个请求中自动发送等等</li>
<li>…</li>
</ul>
</li>
<li>空行：请求头部后面的空行是必须的。</li>
<li>请求数据：也叫主体，可以添加任意的其他数据。</li>
</ul>
<p>🦅 <strong>HTTP 响应格式</strong></p>
<p><img src="http://cdn.tuwenbin.vip/wbgf4n3x.bmp" alt="wbgf4n3x">HTTP 响应格式</p>
<ul>
<li>状态行：由 HTTP 协议版本号、状态码、状态消息三部分组成。</li>
<li>消息报头：用来说明客户端要使用的一些附加信息。</li>
<li>空行：消息报头后面的空行是必须的。</li>
<li>响应正文：服务器返回给客户端的文本信息。</li>
</ul>
<p>🦅 <strong>URI 和 URL 的区别？</strong></p>
<p>见 <a href="https://www.jianshu.com/p/ba15d066f777">《URI 和 URL 的区别》</a> 文章。</p>
<h2 id="HTTP-协议包括哪些请求？"><a href="#HTTP-协议包括哪些请求？" class="headerlink" title="HTTP 协议包括哪些请求？"></a>HTTP 协议包括哪些请求？</h2><ul>
<li>GET: 对服务器资源的简单请求。</li>
<li>POST: 用于发送包含用户提交数据的请求。</li>
<li>HEAD：类似于 GET 请求，不过返回的响应中没有具体内容，用于获取报头。</li>
<li>PUT：传说中请求文档的一个版本。</li>
<li>DELETE：发出一个删除指定文档的请求。</li>
<li>TRACE：发送一个请求副本，以跟踪其处理进程。</li>
<li>OPTIONS：返回所有可用的方法，检查服务器支持哪些方法。</li>
<li>CONNECT：用于 SSL 隧道的基于代理的请求。</li>
</ul>
<p>🦅 <strong>GET 和 POST 的区别？</strong></p>
<table>
<thead>
<tr>
<th>请求方式</th>
<th>数据位置</th>
<th>明文密文</th>
<th>数据安全</th>
<th>长度限制</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>HTTP 请求的 path 中</td>
<td>明文</td>
<td>不安全</td>
<td>长度较小，一般 2k</td>
<td>查询数据</td>
</tr>
<tr>
<td>POST</td>
<td>HTTP 请求 body 中</td>
<td>可明可密</td>
<td>安全</td>
<td>支持较大数据传输</td>
<td>修改数据</td>
</tr>
</tbody></table>
<ul>
<li><p>GET 请求可被缓存；POST 请求不会被缓存。</p>
</li>
<li><p>GET 请求可被收藏为书签；POST 不能被收藏为书签。</p>
</li>
<li><p>【非常有趣】参见 <a href="https://www.oschina.net/news/77354/http-get-post-different">《99%的人理解错 HTTP 中 GET 与 POST 的区别》</a></p>
<blockquote>
<ul>
<li>对于 GET 方式的请求，浏览器会把 HTTP header 和 data 一并发送出去，服务器响应 200（返回数据）。</li>
<li>而对于 POST，浏览器先发送 header ，服务器响应 100 continue ，浏览器再发送 data ，服务器响应 200 ok（返回数据）。</li>
</ul>
<p>也就是说，GET 只需要汽车跑一趟就把货送到了，而 POS T得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。</p>
<p>ps：不过要注意，POST 具体发几次，也和浏览器的实现有关系。例如：Firefox 只发一次。<br>ps2：据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的 TCP 在验证数据包完整性上，有非常大的优点。</p>
</blockquote>
</li>
</ul>
<h2 id="HTTP-有哪些状态码？"><a href="#HTTP-有哪些状态码？" class="headerlink" title="HTTP 有哪些状态码？"></a>HTTP 有哪些状态码？</h2><ul>
<li>1×× : 请求处理中，请求已被接受，正在处理</li>
<li>2×× : 请求成功，请求被成功处理<ul>
<li>200 OK // 客户端请求成功</li>
</ul>
</li>
<li>3×× : 重定向，要完成请求必须进行进一步处理<ul>
<li>301 Moved Permanently // 永久重定向,使用域名跳转</li>
<li>302 Found // 临时重定向,未登陆的用户访问用户中心重定向到登录页面</li>
</ul>
</li>
<li>4×× : 客户端错误，请求不合法<ul>
<li>400 Bad Request // 客户端请求有语法错误，不能被服务器所理解</li>
<li>401 Unauthorized // 请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用</li>
<li>403 Forbidden // 服务器收到请求，但是拒绝提供服务</li>
<li>404 Not Found // 请求资源不存在，eg：输入了错误的 URL</li>
</ul>
</li>
<li>5×× : 服务器端错误，服务器不能处理合法请求<ul>
<li>500 Internal Server Error // 服务器发生不可预期的错误</li>
<li>503 Server Unavailable // 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li>
</ul>
</li>
</ul>
<p>完整的状态码列表，可以看看 <a href="https://zh.wikipedia.org/zh-hans/HTTP%E7%8A%B6%E6%80%81%E7%A0%81">《HTTP 状态码》</a> 文章。</p>
<p>🦅 <strong>forward 和 redirect 的区别？</strong></p>
<ul>
<li>直接转发方式（Forward），客户端和浏览器只发出一次请求，Servlet、HTML、JSP 或其它信息资源，由第二个信息资源响应该请求，在请求对象 request 中，保存的对象对于每个信息资源是共享的。</li>
<li>间接转发方式（Redirect），实际是两次 HTTP 请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个 URL 发出请求，从而达到转发的目的。</li>
</ul>
<p>详细的，请看 <a href="https://www.cnblogs.com/Qian123/p/5345527.html">《请求转发（Forward）和重定向（Redirect）的区别》</a> 。</p>
<p>🦅 <strong>HTTP 返回码中 301 与 302 的区别？</strong></p>
<p>301，302 都是 HTTP 状态的编码，都代表着某个 URL 发生了转移，不同之处在于：</p>
<ul>
<li>301 redirect: 301 代表永久性转移(Permanently Moved)。</li>
<li>302 redirect: 302 代表暂时性转移(Temporarily Moved)。</li>
</ul>
<p>详细的，请看 <a href="https://blog.csdn.net/qmhball/article/details/7838989">《HTTP 返回码中 301 与 302 的区别》</a> 文章。</p>
<h2 id="HTTP、TCP、Socket-的关系是什么？"><a href="#HTTP、TCP、Socket-的关系是什么？" class="headerlink" title="HTTP、TCP、Socket 的关系是什么？"></a>HTTP、TCP、Socket 的关系是什么？</h2><ul>
<li>TCP/IP 代表传输控制协议/网际协议，指的是一系列协议族。</li>
<li>HTTP 本身就是一个协议，是从 Web 服务器传输超文本到本地浏览器的传送协议。</li>
<li>Socket 是 TCP/IP 网络的 API ，其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面。对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。</li>
</ul>
<p>综上所述：</p>
<ul>
<li>需要 IP 协议来连接网络</li>
<li>TCP 是一种允许我们安全传输数据的机制，使用 TCP 协议来传输数据的 HTTP 是 Web 服务器和客户端使用的特殊协议。</li>
<li>HTTP 基于 TCP 协议，所以可以使用 Socket 去建立一个 TCP 连接。</li>
</ul>
<h2 id="Cookies-和-Session-的区别"><a href="#Cookies-和-Session-的区别" class="headerlink" title="Cookies 和 Session 的区别"></a>Cookies 和 Session 的区别</h2><ul>
<li><p>Session 在服务器端，Cookie 在客户端（浏览器）。</p>
<blockquote>
<p>Session 默认被存在在服务器的一个文件里（不是内存）。</p>
</blockquote>
</li>
<li><p>Session 的运行依赖 sessionid ，而 sessionid 是存在 Cookie 中的，也就是说，如果浏览器禁用了 Cookie ，同时 session 也会失效。但是，可以通过其它方式实现，比如在 url 参数中传递 sessionid 。</p>
</li>
<li><p>Session 可以放在文件、数据库、或内存中都可以。</p>
</li>
<li><p>【关键】<strong>用户验证这种场合一般会用 Session</strong> 。</p>
</li>
</ul>
<h2 id="【重要】一次完整的-HTTP-请求所经历的步骤"><a href="#【重要】一次完整的-HTTP-请求所经历的步骤" class="headerlink" title="【重要】一次完整的 HTTP 请求所经历的步骤"></a>【重要】一次完整的 HTTP 请求所经历的步骤</h2><blockquote>
<p>这里的客户端，更多指的是浏览器。</p>
</blockquote>
<ul>
<li><p>1、DNS 解析(通过访问的域名找出其 IP 地址，递归搜索)。</p>
</li>
<li><p>2、HTTP 请求，当输入一个请求时，建立一个 Socket 连接发起 TCP的 3 次握手。</p>
<blockquote>
<p>如果是 HTTPS 请求，会略微有不同。等到 HTTPS 小节，我们在来讲。</p>
</blockquote>
</li>
<li><p>3.1、客户端向服务器发送请求命令（一般是 GET 或 POST 请求）。</p>
<blockquote>
<p>这个是补充内容，面试一般不用回答。</p>
<p>客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</p>
<p>客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定 IP 地址的 MAC 地址，然后发送 ARP 请求查找目的地址，如果得到回应后就可以使用 ARP 的请求应答交换的 IP 数据包现在就可以传输了，然后发送 IP 数据包到达服务器的地址。</p>
</blockquote>
</li>
<li><p>3.2、客户端发送请求头信息和数据。</p>
</li>
<li><p>4.1、服务器发送应答头信息。</p>
</li>
<li><p>4.2、服务器向客户端发送数据。</p>
</li>
<li><p>5、服务器关闭 TCP 连接（4次挥手）。</p>
<blockquote>
<p>这里是否关闭 TCP 连接，也根据 HTTP Keep-Alive 机制有关。</p>
<p>同时，客户端也可以主动发起关闭 TCP 连接。</p>
</blockquote>
</li>
<li><p>6、客户端根据返回的 HTML、CSS、JS 进行渲染。</p>
</li>
</ul>
<p>如下是《图解HTTP》提供的图片：<img src="http://cdn.tuwenbin.vip/5cupel3h.bmp" alt="5cupel3h">HTTP 请求所经历的步骤</p>
<h2 id="HTTP1-0-和-HTTP1-1-有什么区别？"><a href="#HTTP1-0-和-HTTP1-1-有什么区别？" class="headerlink" title="HTTP1.0 和 HTTP1.1 有什么区别？"></a>HTTP1.0 和 HTTP1.1 有什么区别？</h2><p>主要是如下 8 点：</p>
<ul>
<li><p>1、可扩展性</p>
</li>
<li><p>2、缓存</p>
</li>
<li><p>3、带宽优化</p>
<blockquote>
<p>带来了<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81">分块传输</a> 。可能的话，面试也会问。</p>
</blockquote>
</li>
<li><p>【最重要】4、长连接</p>
</li>
<li><p>5、消息传递</p>
</li>
<li><p>6、Host 头域</p>
</li>
<li><p>7、错误提示</p>
</li>
<li><p>8、内容协商</p>
</li>
</ul>
<p>详细的每一点的说明，可以看 <a href="https://blog.csdn.net/ForgotAboutGirl/article/details/6936982">《HTTP1.0 与 HTTP1.1 的区别》</a> 文章，特别是第 4 点【长连接】。</p>
<blockquote>
<p>HTTP1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）。</p>
<ul>
<li>长连接（PersistentConnection）：处理在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。在 HTTP1.1中 默认开启<code>Connection：keep-alive</code> ，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。</li>
<li>请求的流水线（Pipelining）：HTTP1.1  还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。</li>
</ul>
<p>推荐，在看看 <a href="http://www.nowamagic.net/academy/detail/23350305">《HTTP Keep-Alive 是什么？如何工作？》</a> 文章。</p>
<p>关于这一点，可能演变的问题有：</p>
<ul>
<li>HTTP 的长连接是什么意思？</li>
<li>HTTP Keep-Alive 机制是什么？</li>
<li>HTTP Keep-Alive 机制和 TCP Keep-Alive 有什么区别？</li>
</ul>
</blockquote>
<h2 id="SPDY-是什么？"><a href="#SPDY-是什么？" class="headerlink" title="SPDY 是什么？"></a>SPDY 是什么？</h2><blockquote>
<p>艿艿：关于这个问题，了解就好。</p>
<p>HTTP Working-Group 最终决定以 SPDY/2 为基础，开发 HTTP/2 。</p>
</blockquote>
<p>2012 年，Google 如一声惊雷提出了 SPDY 的方案，优化了 HTTP1.X 的请求延迟，解决了 HTTP1.X 的安全性，具体如下：</p>
<ul>
<li><p>1、降低延迟</p>
<blockquote>
<p>针对 HTTP 高延迟的问题，SPDY 优雅的采取了多路复用（multiplexing）。多路复用通过多个请求 Stream 共享一个 Tcp连 接的方式，解决了 HOL blocking 的问题，降低了延迟同时提高了带宽的利用率。</p>
</blockquote>
</li>
<li><p>2、请求优先级（request prioritization）</p>
<blockquote>
<p>多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY 允许给每个 request 设置优先级，这样重要的请求就会优先得到响应。</p>
<p>比如浏览器加载首页，首页的 html 内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</p>
</blockquote>
</li>
<li><p>3、header 压缩</p>
<blockquote>
<p>前面提到 HTTP1.x 的 header 很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</p>
</blockquote>
</li>
<li><p>4、基于 HTTPS 的加密协议传输</p>
<blockquote>
<p>大大提高了传输数据的安全性。</p>
</blockquote>
</li>
<li><p>5、服务端推送（server push）</p>
<blockquote>
<p>采用了 SPDY 的网页，例如我的网页有一个 <code>sytle.css</code> 的请求，在客户端收到 <code>sytle.css</code> 数据的同时，服务端会将 <code>sytle.js</code> 的文件推送给客户端。当客户端再次尝试获取 <code>sytle.js</code> 时就可以直接从缓存中获取到，不用再发请求了。</p>
<p>🙂 和我们理解的服务端推送，有点（非常）不一样哈。</p>
</blockquote>
</li>
</ul>
<p>🚀 SPDY 构成图如下：<img src="http://cdn.tuwenbin.vip/wknsy7np.bmp" alt="wknsy7np">SPDY 构成图</p>
<ul>
<li>SPDY 位于 HTTP 之下，TCP 和 SSL 之上，这样可以轻松兼容老版本的 HTTP 协议(将 HTTP1.x 的内容封装成一种新的 frame 格式)，同时可以使用已有的 SSL 功能。</li>
</ul>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>推荐先看下 <a href="http://juejin.im/post/58c5268a61ff4b005d99652a">《九个问题从入门到熟悉 HTTPS》</a> 文章，写的很有趣~</p>
<p>另外，也看看 <a href="https://blog.csdn.net/ustccw/article/details/76691248">《SSL/TLS 双向认证(一) – SSL/TLS工作原理》</a> 文章，写的更技术向~</p>
<p>下面的面试题的答案，我们会基于上述文章来整理。</p>
<h2 id="HTTPS-是什么？"><a href="#HTTPS-是什么？" class="headerlink" title="HTTPS 是什么？"></a>HTTPS 是什么？</h2><p>HTTPS ，实际就是在 TCP 层与 HTTP 层之间加入了 SSL/TLS 来为上层的安全保驾护航，主要用到对称加密、非对称加密、证书，等技术进行客户端与服务器的数据加密传输，最终达到保证整个通信的安全性。</p>
<p><img src="http://cdn.tuwenbin.vip/49rb21xy.bmp" alt="49rb21xy"></p>
<p>一句话概括：<strong>HTTP + 加密 + 认证 + 完整性保护 = HTTPS</strong> 。</p>
<p>🦅 <strong>什么是 SSL 呢？什么是 TLS 呢？</strong></p>
<p>官方定义，SSL 是安全套接层(secure sockets layer)；TLS 是 SSL 的继任者，叫传输层安全(transport layer security)。</p>
<p>它们存在的唯一目的就是保证上层通讯安全的一套机制。它的发展依次经历了下面几个时期，像手机软件升级一样，每次更新都添加或去除功能，比如引进新的加密算法，修改握手方式等。</p>
<ul>
<li>SSL1.0: 已废除</li>
<li>SSL2.0: RFC6176 ，已废除</li>
<li>SSL3.0: RFC6101 ，基本废除</li>
<li><strong>TLS1.0</strong>: RFC2246 ，目前大都采用此种方式</li>
<li>TLS1.1: RFC4346</li>
<li>TLS1.2: RFC5246 ，没有广泛使用</li>
<li>TLS1.3: IETF 正在酝酿中</li>
</ul>
<blockquote>
<p>艿艿：为了下面描述方便，统一先叫 SSL 。</p>
</blockquote>
<p>🦅 <strong>SSL/TLS 协议作用？</strong></p>
<ol>
<li><p>认证用户和服务器，确保数据发送到正确的客户机和服务器。</p>
<blockquote>
<p>客户端必须避免中间人攻击，即除了真正的服务器，任何第三方都无法冒充服务器。</p>
</blockquote>
</li>
<li><p>加密数据以防止数据中途被窃取。</p>
</li>
<li><p>维护数据的完整性，确保数据在传输过程中不被改变。</p>
</li>
</ol>
<h2 id="HTTP-和-HTTPS-的区别？"><a href="#HTTP-和-HTTPS-的区别？" class="headerlink" title="HTTP 和 HTTPS 的区别？"></a>HTTP 和 HTTPS 的区别？</h2><ul>
<li><p>端口不同：HTTP 与 HTTPS 使用不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</p>
<blockquote>
<p>艿艿：个人的想法，实际 HTTPS 也是可以使用 80 端口，但是考虑继续保持 HTTP 的兼容，只好退而求其次，使用 443 端口。</p>
</blockquote>
</li>
<li><p>资源消耗：和 HTTP 通信相比，HTTPS 通信会由于加解密处理消耗更多的 CPU 和内存资源。</p>
</li>
<li><p>开销：HTTPS 通信需要证书，而证书一般需要向认证机构申请免费或者付费购买。</p>
<blockquote>
<p>HTTPS 可以有效的防止运营商劫持，解决了防劫持的一个大问题。</p>
</blockquote>
</li>
</ul>
<h2 id="SSL-加密方式是什么？"><a href="#SSL-加密方式是什么？" class="headerlink" title="SSL 加密方式是什么？"></a>SSL 加密方式是什么？</h2><blockquote>
<ul>
<li>对称密钥加密，是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方。</li>
<li>非对称加密，指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。</li>
</ul>
</blockquote>
<p>SSL 协议，即用到了对称加密也用到了非对称加密，如下图所示：<img src="http://cdn.tuwenbin.vip/sbh9hdy2.bmp">SSL 加密过程</p>
<blockquote>
<p>TODO 这个配图有问题。原图我在翻，貌似不小心被我删除了。。。。</p>
</blockquote>
<ul>
<li><p>在建立传输链路时，SSL 首先对对称加密的密钥使用公钥进行非对称加密。</p>
<blockquote>
<p>艿艿：注意哟，这里 Server 返回给 Client 的不是公钥( <code>server.pub</code> )，而是 <code>server.crt</code> 。Client 需要使用 <code>ca.key</code> 从 <code>server.crt</code> 中解密出公钥( <code>server.pub</code> ) 。</p>
</blockquote>
</li>
<li><p>链路建立好之后，SSL 对传输内容使用公钥( <code>server.pub</code> )对称加密。</p>
</li>
</ul>
<p>🦅 <strong>为什么公钥传输的步骤这么复杂呢？</strong></p>
<p>答案请看 <a href="http://juejin.im/post/58c5268a61ff4b005d99652a">《九个问题从入门到熟悉 HTTPS》</a> 文章的如下问题：</p>
<ul>
<li>Q5: 那公钥怎么传输</li>
<li>Q6: 你在逗我么。。。。</li>
<li>Q7: 怎么知道证书有没有被篡改？</li>
<li>Q8: 这样可以防止第三方冒充服务器么</li>
</ul>
<p>也就是说，通过 CA 来保证。至于 <code>server.crt</code> 证书是怎么申请的呢？请看 <a href="https://blog.csdn.net/ustccw/article/details/76691248">《SSL/TLS 双向认证(一) – SSL/TLS工作原理》</a> 文章的 <a href="http://svip.iocoder.cn/Net/Interview/#">「CA 的证书 ca.crt 和 SSL Server 的证书 server.crt  是什么关系呢？ 」</a> 问题的解答。</p>
<blockquote>
<p>艿艿：看这块，我已经要被绕晕了！！！耐心~胖友，理解后会很爽。</p>
</blockquote>
<h2 id="什么是单向认证、双向认证？"><a href="#什么是单向认证、双向认证？" class="headerlink" title="什么是单向认证、双向认证？"></a>什么是单向认证、双向认证？</h2><ul>
<li><p>单向认证，指的是只有一个对象校验对端的证书合法性。</p>
<blockquote>
<p>通常都是 Client 来校验服务器的合法性。那么 Client 需要一个<code>ca.crt</code> ，服务器需要 <code>server.crt</code> 和 <code>server.key</code> 。</p>
</blockquote>
</li>
<li><p>双向认证，指的是相互校验，Server 需要校验每个 Client ，Client 也需要校验服务器。</p>
<blockquote>
<ul>
<li>Server 需要 <code>server.key</code>、<code>server.crt</code>、<code>ca.crt</code> 。</li>
<li>Client 需要 <code>client.key</code>、<code>client.crt</code>、<code>ca.crt</code> 。</li>
</ul>
</blockquote>
</li>
</ul>
<p>🦅 <strong>1）单向认证的过程？</strong></p>
<p>![AVFY_SQWK{Z4`$IXLDKXN$9](<a href="http://cdn.tuwenbin.vip/20200927233916.png)%E5%8D%95%E5%90%91%E8%AE%A4%E8%AF%81">http://cdn.tuwenbin.vip/20200927233916.png)单向认证</a></p>
<ul>
<li><p>1、客户端向服务端发送 SSL 协议版本号、加密算法种类、随机数等信息。</p>
</li>
<li><p>2、服务端给客户端返回 SSL 协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书。</p>
</li>
<li><p>3、客户端使用服务端返回的信息验证服务器的合法性，包括：</p>
<ul>
<li><p>证书是否过期。</p>
</li>
<li><p>发型服务器证书的 CA 是否可靠。</p>
</li>
<li><p>返回的公钥是否能正确解开返回证书中的数字签名。</p>
</li>
<li><p>服务器证书上的域名是否和服务器的实际域名相匹配</p>
<blockquote>
<p>验证通过后，将继续进行通信；否则，终止通信。</p>
</blockquote>
</li>
<li><p>4、客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择。</p>
</li>
<li><p>5、服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。</p>
</li>
</ul>
</li>
<li><p>6、服务器将选择好的加密方案通过明文方式返回给客户端。</p>
</li>
<li><p>7、客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器。</p>
</li>
<li><p>8、服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。</p>
<blockquote>
<p><strong>在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全</strong>。</p>
</blockquote>
</li>
</ul>
<p>🦅 <strong>2）双向认证的过程？</strong></p>
<p>双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下：</p>
<p><img src="http://cdn.tuwenbin.vip/20200927235121.png">双向认证</p>
<ul>
<li><p>1、客户端向服务端发送 SSL 协议版本号、加密算法种类、随机数等信息。</p>
</li>
<li><p>2、服务端给客户端返回 SSL 协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书。</p>
</li>
<li><p>3、客户端使用服务端返回的信息验证服务器的合法性，包括：</p>
<ul>
<li><p>证书是否过期。</p>
</li>
<li><p>发型服务器证书的 CA 是否可靠。</p>
</li>
<li><p>返回的公钥是否能正确解开返回证书中的数字签名。</p>
</li>
<li><p>服务器证书上的域名是否和服务器的实际域名相匹配</p>
<blockquote>
<p>验证通过后，将继续进行通信；否则，终止通信。</p>
</blockquote>
</li>
<li><p><strong>【新增】4、服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端。</strong></p>
</li>
<li><p><strong>【新增】5、验证客户端的证书，通过验证后，会获得客户端的公钥。</strong></p>
</li>
<li><p>6、客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择。</p>
</li>
<li><p>7、服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。</p>
</li>
</ul>
</li>
<li><p>8、服务器将选择好的加密方案通过明文方式返回给客户端。</p>
</li>
<li><p>9、客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器。</p>
</li>
<li><p>10、服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。</p>
<blockquote>
<p><strong>在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全</strong>。</p>
</blockquote>
</li>
</ul>
<p>🦅 <strong>如何选择单向认证还是双向认证</strong></p>
<ul>
<li><p>一般一个站点很多用户访问就用单向认证。</p>
</li>
<li><p>企业接口对接就用双向认证。</p>
<blockquote>
<p>如果想要提高 APP 的安全级别，也可以考虑双向认证。因为，APP 天然方便放入客户端证书，从而提高安全级别。</p>
</blockquote>
</li>
</ul>
<h2 id="为什么抓包工具还能抓到-HTTPS-数据包并解密成功呢"><a href="#为什么抓包工具还能抓到-HTTPS-数据包并解密成功呢" class="headerlink" title="为什么抓包工具还能抓到 HTTPS 数据包并解密成功呢"></a>为什么抓包工具还能抓到 HTTPS 数据包并解密成功呢</h2><p>不是说HTTPS在网络中传输的是密文吗？这个问题就是<strong>中间者攻击</strong>（man in zhe middle）。</p>
<p><img src="http://cdn.tuwenbin.vip/20200927235159.png" alt="img">中间者攻击原理图</p>
<ul>
<li>解决办法，就是 HTTPS 单向验证。在客户端中内置服务器公钥，在第三步服务器返回的公钥，除了验证公钥的有效性之外，再比对公钥是不是和内置的公钥一样，不一样说明被中间者攻击了，就断开链接不在请求了。</li>
<li>这个原理的前提是服务器的私钥没有泄露，客户端的代码不会被破解，道高一尺魔高一丈。信息安全就是在合理的范围内，选择比较合适的加密方法，没有绝对论，只有相对论。在某个范围内比较安全。</li>
</ul>
<h2 id="HTTPS-握手会影响性能么？"><a href="#HTTPS-握手会影响性能么？" class="headerlink" title="HTTPS 握手会影响性能么？"></a>HTTPS 握手会影响性能么？</h2><p>TCP 有三次握手，再加上 HTTPS 的四次握手，影响肯定有，但是可以接受。</p>
<ul>
<li>首先，HTTPS 肯定会更慢一点，时间主要花费在两组 SSL 之间的耗时和证书的读取验证上，对称算法的加解密时间几乎可以忽略不计。</li>
<li>而且如果不是首次握手，后续的请求并不需要完整的握手过程。客户端可以把上次的加密情况直接发送给服务器从而快速恢复，具体细节可以参考 <a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">《图解 SSL/TLS 协议》</a> 。</li>
<li>除此以外，SSL 握手的时间并不是只能用来传递加密信息，还可以承担起客户端和服务器沟通 HTTP2 兼容情况的任务。因此从 HTTPS 切换到 HTTP2.0 不会有任何性能上的开销，反倒是得益于 HTTP2.0 的多路复用等技术，后续可以节约大量时间。</li>
<li>如果把 HTTPS2.0 当做目标，那么 HTTPS 的性能损耗就更小了，远远比不上它带来的安全性提升。</li>
</ul>
<h1 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h1><p><img src="http://cdn.tuwenbin.vip/20200927235254.png" alt="img">HTTP2 和 HTTP1.1 的区别</p>
<h2 id="什么是-HTTP2-0-？"><a href="#什么是-HTTP2-0-？" class="headerlink" title="什么是 HTTP2.0 ？"></a>什么是 HTTP2.0 ？</h2><p>HTTP2.0 ，可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，如下：</p>
<ul>
<li>HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS 。</li>
<li>HTTP2.0 消息头的压缩算法采用 <a href="https://link.jianshu.com/?t=http://http2.github.io/http2-spec/compression.html">HPACK</a>，而非 SPDY 采用的 <a href="https://link.jianshu.com/?t=http://zh.wikipedia.org/wiki/DEFLATE">DEFLATE</a> 。</li>
</ul>
<h2 id="HTTP2-0-和-HTTP1-X-相比的新特性？"><a href="#HTTP2-0-和-HTTP1-X-相比的新特性？" class="headerlink" title="HTTP2.0 和 HTTP1.X 相比的新特性？"></a>HTTP2.0 和 HTTP1.X 相比的新特性？</h2><ul>
<li><p>1、新的二进制格式（Binary Format）</p>
<blockquote>
<p>HTTP1.x 的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 0 和 1 的组合。基于这种考虑 HTTP2.0 的协议解析决定采用二进制格式，实现方便且健壮。</p>
</blockquote>
</li>
<li><p>同 SPDY 对 HTTP1.1 的改进。</p>
<ul>
<li>2、降低延迟</li>
<li>3、多路复用（MultiPlexing）</li>
<li>4、header 压缩</li>
<li>5、服务端推送（server push）</li>
</ul>
</li>
</ul>
<h2 id="Nginx-怎么做-HTTP2-0-的升级改造？"><a href="#Nginx-怎么做-HTTP2-0-的升级改造？" class="headerlink" title="Nginx 怎么做 HTTP2.0 的升级改造？"></a>Nginx 怎么做 HTTP2.0 的升级改造？</h2><ul>
<li>1、虽然 HTTP2.0 其实可以支持非 HTTPS 的，但是现在主流的浏览器像 Chrome，Firefox 表示还是只支持基于 TLS 部署的 HTTP2.0协议，所以要想升级成 HTTP2.0 还是先升级 HTTPS 为好。</li>
<li>2、当你的网站已经升级 HTTPS 之后，那么升级 HTTP2.0 就简单很多，如果你使用 NGINX ，只要在配置文件中启动相应的协议就可以了，可以参考 <a href="https://link.jianshu.com/?t=https://www.nginx.com/wp-content/uploads/2015/09/NGINX_HTTP2_White_Paper_v4.pdf">NGINX白皮书</a>，<a href="https://link.jianshu.com/?t=https://www.nginx.com/blog/nginx-1-9-5/">NGINX配置HTTP2.0官方指南</a> 。</li>
<li>3、使用了 HTTP2.0 那么，原本的 HTTP1.x 怎么办？这个问题其实不用担心，HTTP2.0 完全兼容 HTTP1.x 的语义，对于不支持 HTTP2.0 的浏览器，NGINX 会自动向下兼容的。</li>
</ul>
<p>在我们内部的微服务 API 接口，也可以做 HTTP2 的改造，可以参考如下文章：</p>
<blockquote>
<p>艿艿：选读，作为知识的扩充</p>
</blockquote>
<ul>
<li><a href="https://www.jianshu.com/p/ed3f8f983764">《Spring Cloud 使用 HTTP2》</a></li>
<li><a href="https://www.jianshu.com/p/7ddcdd3847d6">《再说 SpringBoot2.0 与 HTTP/2》</a></li>
</ul>
<h2 id="HTTP2-0-的多路复用和-HTTP1-X-中的长连接复用有什么区别？"><a href="#HTTP2-0-的多路复用和-HTTP1-X-中的长连接复用有什么区别？" class="headerlink" title="HTTP2.0 的多路复用和 HTTP1.X 中的长连接复用有什么区别？"></a>HTTP2.0 的多路复用和 HTTP1.X 中的长连接复用有什么区别？</h2><ul>
<li>HTTP/1.0：一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接。</li>
<li>HTTP/1.1：Pipeling 解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会。一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞。</li>
<li>HTTP/2：多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行。</li>
</ul>
<p>如下图所示：<img src="http://cdn.tuwenbin.vip/20200927235520.png">HTTP/1.1 对比 HTTP/2</p>
<p>🦅  <strong>HTTP2.0 多路复用有多好？</strong></p>
<blockquote>
<p>艿艿：最近重新看了 TCP ，发现再看这个问题，真的是有趣！</p>
</blockquote>
<p>HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP  连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP  慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。</p>
<p>HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。</p>
<h2 id="服务器推送到底是什么？"><a href="#服务器推送到底是什么？" class="headerlink" title="服务器推送到底是什么？"></a>服务器推送到底是什么？</h2><p>服务端推送能把客户端所需要的资源伴随着 <code>index.html</code> 一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。具体如下：</p>
<ul>
<li>普通的客户端请求过程：<img src="http://cdn.tuwenbin.vip/20200927235753.png" alt="135531513513">普通的客户端请求过程</li>
<li>服务端推送的过程：<img src="http://cdn.tuwenbin.vip/20200927235843.png" alt="462552542">服务端推送的过程</li>
</ul>
<h2 id="为什么需要头部-header-压缩？"><a href="#为什么需要头部-header-压缩？" class="headerlink" title="为什么需要头部(header)压缩？"></a>为什么需要头部(header)压缩？</h2><p>假定一个页面有 100 个资源需要加载（这个数量对于今天的 Web 而言还是挺保守的），而每一次请求都有 1kb 的消息头（这同样也并不少见，因为  Cookie 和引用等东西的存在），则至少需要多消耗 100kb 来获取这些消息头。HTTP2.0 可以维护一个字典，差量更新 HTTP  头部，大大降低因头部传输产生的流量。</p>
<p>具体参考：<a href="https://link.jianshu.com/?t=https://imququ.com/post/header-compression-in-http2.html">《HTTP/2 头部压缩技术介绍》</a> 文章。</p>
<ul>
<li>维护一份相同的静态字典（Static Table），包含常见的头部名称，以及特别常见的头部名称与值的组合。</li>
<li>维护一份相同的动态字典（Dynamic Table），可以动态地添加内容。</li>
<li>支持基于静态哈夫曼码表的哈夫曼编码（Huffman Coding）。</li>
</ul>
<h1 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h1><p>感觉，大学丢掉的网络知识，又一次回到我的脑子中了。好开心，又可以遗忘一轮啦，哈哈哈哈。</p>
<p>参考与推荐如下文章：</p>
<ul>
<li><a href="https://blog.csdn.net/duanbokan/article/details/50847612">《Https 单向认证和双向认证》</a></li>
<li><a href="https://blog.csdn.net/Maybe_ch/article/details/82598782">《【网络协议】ping 的工作原理》</a></li>
<li><a href="https://www.jianshu.com/p/be29d679cbff">《HTTP1.0、HTTP1.1 和 HTTP2.0 的区别》</a></li>
<li><a href="https://segmentfault.com/a/1190000010819141">《计算机网络常见面试题》</a></li>
<li><a href="https://www.jianshu.com/p/a1f5daf7ada5">《总结的网络面试题》</a></li>
<li><a href="https://blog.csdn.net/justloveyou_/article/details/78303617">《面试/笔试第一弹 —— 计算机网络面试问题集锦》</a></li>
<li><a href="https://github.com/jawil/blog/issues/14">《通俗大白话来理解 TCP 协议的三次握手和四次挥手》</a></li>
<li><a href="https://www.jianshu.com/p/b71ec62b6eb5">《TCP 数据的传输过程》</a></li>
<li><a href="https://juejin.im/post/5b7be0b2e51d4538db34a51e">《搞定计算机网络面试，看这篇就够了（补充版）》</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>精尽 Java【并发】面试题</title>
    <url>/2016/10/12/%E7%B2%BE%E5%B0%BD%20Java%E3%80%90%E5%B9%B6%E5%8F%91%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="精尽-Java【并发】面试题"><a href="#精尽-Java【并发】面试题" class="headerlink" title="精尽 Java【并发】面试题"></a>精尽 Java【并发】面试题</h1><p>以下面试题，基于网络整理，和自己编辑。具体参考的文章，会在文末给出所有的链接。</p>
<p>如果胖友有自己的疑问，欢迎在星球提问，我们一起整理吊吊的 Java【并发】面试题的大保健。</p>
<p>而题目的难度，艿艿尽量按照从容易到困难的顺序，逐步下去。</p>
<p>因为 Java 并发涉及到的内容会非常多，本面试题可能很难覆盖到所有的知识点，所以推荐 <a href="https://u.jd.com/gpkonU">《Java并发编程的艺术》</a> 。并且，本文会将面试题和该书的章节，大体保持一致。嘻嘻~</p>
<p>另外，本文涉及的面试题会超级超级超级多，所以艿艿已经分了小节，胖友要注意哟。</p>
<h1 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h1><ul>
<li><a href="http://static2.iocoder.cn/89bf0392f832b459ed62efb31af4461e"><img src="http://cdn.tuwenbin.vip/20201005171159" alt="线程"></a>线程</li>
<li><a href="http://static2.iocoder.cn/b2647746fcfbc58730dc7d34bf0a70e9"><img src="http://cdn.tuwenbin.vip/20201005171207" alt="通知 + 等待"></a>通知 + 等待</li>
<li><a href="http://static2.iocoder.cn/d07d3538b177da26feef167d4a8c7080"><img src="http://cdn.tuwenbin.vip/20201005171211" alt="线程通信"></a>线程通信</li>
<li><a href="http://static2.iocoder.cn/3f43df826320de201b726e7f20c97868"><img src="http://cdn.tuwenbin.vip/20201005171218" alt="常见问题"></a>常见问题</li>
</ul>
<h2 id="简述线程、进程、程序的基本概念？"><a href="#简述线程、进程、程序的基本概念？" class="headerlink" title="简述线程、进程、程序的基本概念？"></a>简述线程、进程、程序的基本概念？</h2><p>🦅 <strong>程序</strong></p>
<p>程序，是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>
<p>🦅 <strong>进程</strong></p>
<p>进程，是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。</p>
<p>🦅 <strong>线程</strong></p>
<p>线程，与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<blockquote>
<p>艿艿：如下是可选内容。</p>
<p>另外，Java 线程是重量级的，每个线程默认使用 1024KB 的内存，所以一个 Java 进程是无法开启大量线程的。感兴趣的胖友，可以看 <a href="http://landcareweb.com/questions/33900/javazhong-de-qing-liang-ji-xian-cheng">《Java 中的轻量级线程？》</a> 的讨论，没准未来 Java 也有内置的协程（Coroutine）。</p>
</blockquote>
<p>🦅 <strong>三者之间的关系</strong></p>
<ul>
<li>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。</li>
<li>从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</li>
</ul>
<p>🦅 <strong>线程有什么优缺点？</strong></p>
<p>1）好处</p>
<ul>
<li>使用多线程可以把程序中占据时间长的任务放到后台去处理，如图片、视屏的下载。</li>
<li>发挥多核处理器的优势，并发执行让系统运行的更快、更流畅，用户体验更好。</li>
</ul>
<p>2）坏处</p>
<ul>
<li>大量的线程降低代码的可读性。</li>
<li>更多的线程需要更多的内存空间。</li>
<li>当多个线程对同一个资源出现争夺时候要注意线程安全的问题。</li>
</ul>
<p>🦅 <strong>你了解守护线程吗？它和非守护线程有什么区别？</strong></p>
<p>Java 中的线程分为两种：守护线程（Daemon）和用户线程（User）。</p>
<ul>
<li>任何线程都可以设置为守护线程和用户线程，通过方法<code>Thread#setDaemon(boolean on)</code> 设置。<code>true</code> 则把该线程设置为守护线程，反之则为用户线程。</li>
<li><code>Thread#setDaemon(boolean on)</code> 方法，必须在<code>Thread#start()</code> 方法之前调用，否则运行时会抛出异常。</li>
</ul>
<p>唯一的区别是：</p>
<blockquote>
<p>程序运行完毕，JVM 会等待非守护线程完成后关闭，但是 JVM 不会等待守护线程。</p>
</blockquote>
<ul>
<li>判断虚拟机(JVM)何时离开，Daemon 是为其他线程提供服务，如果全部的 User Thread 已经撤离，Daemon 没有可服务的线程，JVM 撤离。</li>
<li>也可以理解为守护线程是 JVM 自动创建的线程（但不一定），用户线程是程序创建的线程。比如，JVM  的垃圾回收线程是一个守护线程，当所有线程已经撤离，不再产生垃圾，守护线程自然就没事可干了，当垃圾回收线程是 Java  虚拟机上仅剩的线程时，Java 虚拟机会自动离开。</li>
</ul>
<p>扩展：Thread Dump 打印出来的线程信息，含有 daemon  字样的线程即为守护进程。可能会有：服务守护进程、编译守护进程、Windows 下的监听 Ctrl + break 的守护进程、Finalizer 守护进程、引用处理守护进程、GC 守护进程。</p>
<p>关于守护线程的各种骚操作，可以看看 <a href="https://blog.csdn.net/u013256816/article/details/50392298">《Java 守护线程概述》</a> 。</p>
<p>🦅 <strong>什么是线程组，为什么在 Java 中不推荐使用？</strong></p>
<blockquote>
<p>艿艿：这是个小众知识，了解即可。貌似，艿艿也重来没使用过这个类。</p>
</blockquote>
<p>ThreadGroup 类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。</p>
<blockquote>
<p>简单的说，ThreadGroup 为了方便线程的管理。</p>
</blockquote>
<p>为什么不推荐使用？ThreadGroup API 比较薄弱，它并没有比 Thread  提供了更多的功能。它有两个主要的功能：一是获取线程组中处于活跃状态线程的列表；二是设置为线程设置未捕获异常处理器(uncaught  exception handler)。但在 Java5 中 Thread 类也添加了 <code>#setUncaughtExceptionHandler(UncaughtExceptionHandler eh)</code> 方法，所以 ThreadGroup 是已经过时的，不建议继续使用。</p>
<h2 id="什么是多线程上下文切换？"><a href="#什么是多线程上下文切换？" class="headerlink" title="什么是多线程上下文切换？"></a>什么是多线程上下文切换？</h2><p>多线程会共同使用一组计算机上的 CPU ，而线程数大于给程序分配的 CPU 数量时，为了让各个线程都有执行的机会，就需要轮转使用 CPU 。</p>
<p>不同的线程切换使用 CPU 发生的切换数据等，就是上下文切换。</p>
<ul>
<li>在上下文切换过程中，CPU  会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。从这个角度来看，上下文切换有点像我们同时阅读几本书，在来回切换书本的同时我们需要记住每本书当前读到的页码。在程序中，上下文切换过程中的“页码”信息是保存在进程控制块（PCB）中的。PCB还经常被称作“切换桢”（switchframe）。“页码”信息会一直保存到CPU的内存中，直到他们被再次使用。</li>
<li>上下文切换是存储和恢复 CPU 状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。</li>
</ul>
<p>🦅 <strong>Java 中用到的线程调度算法是什么？</strong></p>
<p>假设计算机只有一个 CPU ，则在任意时刻只能执行一条机器指令，每个线程只有获得 CPU 的使用权才能执行指令。</p>
<ul>
<li>所谓多线程的并发运行，其实是指从宏观上看，各个线程轮流获得 CPU 的使用权，分别执行各自的任务。</li>
<li>在运行池中，会有多个处于就绪状态的线程在等待 CPU ，Java 虚拟机的一项任务就是负责线程的调度，线程调度是指按照特定机制为多个线程分配 CPU 的使用权。</li>
</ul>
<p>有两种调度模型：分时调度模型和抢占式调度模型。</p>
<ul>
<li><p>分时调度模型是指让所有的线程轮流获得 CPU 的使用权,并且平均分配每个线程占用的 CPU 的时间片这个也比较好理解。</p>
</li>
<li><p>Java 虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用  CPU ，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用 CPU 。处于运行状态的线程会一直运行，直至它不得不放弃 CPU 。</p>
<blockquote>
<p>如非特别需要，尽量不要用，防止线程饥饿。</p>
</blockquote>
</li>
</ul>
<p>🦅 <strong>什么是线程饥饿？</strong></p>
<p>饥饿，一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。</p>
<p>Java 中导致饥饿的原因：</p>
<ul>
<li>高优先级线程吞噬所有的低优先级线程的 CPU 时间。</li>
<li>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。</li>
<li>线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方法)，因为其他线程总是被持续地获得唤醒。</li>
</ul>
<p>🦅 <strong>你对线程优先级的理解是什么？</strong></p>
<p>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。</p>
<ul>
<li>我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个 int 变量(从1-10)，1 代表最低优先级，10 代表最高优先级。</li>
<li>Java 的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。</li>
</ul>
<h2 id="线程的生命周期？"><a href="#线程的生命周期？" class="headerlink" title="线程的生命周期？"></a>线程的生命周期？</h2><p>线程一共有五个状态，分别如下：</p>
<ul>
<li><p>新建(new)：当创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。例如：<code>Thread t1 = new Thread()</code> 。</p>
</li>
<li><p>可运行(runnable)：线程对象创建后，其他线程(比如 main 线程）调用了该对象的 start 方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 cpu 的使用权。例如：<code>t1.start()</code> 。</p>
<blockquote>
<p>有些文章，会称可运行(runnable)为就绪，意思是一样的。</p>
</blockquote>
</li>
<li><p>运行(running)：线程获得 CPU 资源正在执行任务（<code>#run()</code> 方法），此时除非此线程自动放弃 CPU 资源或者有优先级更高的线程进入，线程将一直运行到结束。</p>
</li>
<li><p>死亡(dead)：当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。</p>
<ul>
<li>自然终止：正常运行完 <code>#run()</code>方法，终止。</li>
<li>异常终止：调用 <code>#stop()</code> 方法，让一个线程终止运行。</li>
</ul>
</li>
<li><p>堵塞(blocked)：由于某种原因导致正在运行的线程让出 CPU 并暂停自己的执行，即进入堵塞状态。直到线程进入可运行(runnable)状态，才有机会再次获得 CPU 资源，转到运行(running)状态。阻塞的情况有三种：</p>
<ul>
<li><p>正在睡眠：调用 <code>#sleep(long t)</code> 方法，可使线程进入睡眠方式。</p>
<blockquote>
<p>一个睡眠着的线程在指定的时间过去可进入可运行(runnable)状态。</p>
</blockquote>
</li>
<li><p>正在等待：调用 <code>#wait()</code> 方法。</p>
<blockquote>
<p>调用 <code>notify()</code> 方法，回到就绪状态。</p>
</blockquote>
</li>
<li><p>被另一个线程所阻塞：调用 <code>#suspend()</code> 方法。</p>
<blockquote>
<p>调用 <code>#resume()</code> 方法，就可以恢复。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>整体如下图所示：<a href="http://static2.iocoder.cn/04a277229fd3b24e058417f9c571681c"><img src="http://cdn.tuwenbin.vip/20201005171228" alt="Thread 的线程状态"></a>Thread 的线程状态</p>
<ul>
<li>中间一行是线程的顺畅的执行过程的四个状态。其上下两侧，是存在对应的情况，达到阻塞状态和恢复执行的过程。</li>
<li>有一点要注意，新建(new)和死亡(dead)是单向的状态，不可重复。****</li>
<li>理解线程的状态，可以用早起坐地铁来比喻这个过程：<ul>
<li>还没起床：sleeping 。</li>
<li>起床收拾好了，随时可以坐地铁出发：Runnable 。</li>
<li>等地铁来：Waiting 。</li>
<li>地铁来了，但要排队上地铁：I/O 阻塞 。</li>
<li>上了地铁，发现暂时没座位：synchronized 阻塞。</li>
<li>地铁上找到座位：Running 。</li>
<li>到达目的地：Dead 。</li>
</ul>
</li>
</ul>
<p>如下是另外一个图，把阻塞的情况，放在了一起，也可以作为参考：<a href="http://static2.iocoder.cn/3281138331173cdd53d1364f9c56d594"><img src="http://cdn.tuwenbin.vip/20201005171233" alt="Thread 的线程状态"></a>Thread 的线程状态</p>
<p>无意中，又看到一张画的更牛逼的，如下图：</p>
<p><a href="http://static2.iocoder.cn/5eeec5f68f4fc412246efd4111d6fdec"><img src="http://cdn.tuwenbin.vip/20201005171237" alt="Thread 的线程状态"></a>Thread 的线程状态</p>
<p>🦅 <strong>如何结束一个一直运行的线程？</strong></p>
<p>一般来说，有两种方式：</p>
<ul>
<li><p>方式一，使用退出标志，这个 flag 变量要多线程可见。</p>
<blockquote>
<p>在这种方式中，之所以引入共享变量，是因为该变量可以被多个执行相同任务的线程用来作为是否中断的信号，通知中断线程的执行。</p>
</blockquote>
</li>
<li><p>方式二，使用 interrupt 方法，结合 isInterrupted 方法一起使用。</p>
<blockquote>
<p>如果一个线程由于等待某些事件的发生而被阻塞，又该怎样停止该线程呢？这种情况经常会发生，比如当一个线程由于需要等候键盘输入而被阻塞，或者调用 <code>Thread#join()</code> 方法，或者 <code>Thread#sleep(...)</code> 方法，在网络中调用<code>ServerSocket#accept()</code> 方法，或者调用了<code>DatagramSocket#receive()</code> 方法时，都有可能导致线程阻塞，使线程处于处于不可运行状态时。即使主程序中将该线程的共享变量设置为 <code>true</code> ，但该线程此时根本无法检查循环标志，当然也就无法立即中断。</p>
<p>这里我们给出的建议是，不要使用 <code>Thread#stop()· 方法，而是使用 Thread 提供的</code>#interrupt()` 方法，因为该方法虽然不会中断一个正在运行的线程，但是它可以使一个被阻塞的线程抛出一个中断异常，从而使线程提前结束阻塞状态，退出堵塞代码。</p>
</blockquote>
</li>
</ul>
<p>所以，方式一和方式二，并不是冲突的两种方式，而是可能根据实际场景下，进行结合。</p>
<p>🦅 <strong>一个线程如果出现了运行时异常会怎么样?</strong></p>
<p>如果这个异常没有被捕获的话，这个线程就停止执行了。</p>
<p>另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放。</p>
<h2 id="创建线程的方式及实现？"><a href="#创建线程的方式及实现？" class="headerlink" title="创建线程的方式及实现？"></a>创建线程的方式及实现？</h2><p>Java 中创建线程主要有三种方式：</p>
<blockquote>
<p>具体的每种方式的代码实现，可以看看 <a href="https://blog.csdn.net/u012973218/article/details/51280044">《Java创建线程的四种方式》</a> 。</p>
<p>关于文章中的方式四，实际是基于线程池的方式，使用下面的三种方式，也是生产实践中，最为推荐和常用的方式。</p>
</blockquote>
<ul>
<li>方式一，继承 Thread 类创建线程类。</li>
<li>方式二，通过 Runnable 接口创建线程类。</li>
<li>方式三，通过 Callable 和 Future 创建线程。</li>
</ul>
<p>创建线程的三种方式的对比：</p>
<ul>
<li><p>使用方式一</p>
<ul>
<li>优点：编写简单，如果需要访问当前线程，则无需使用 <code>Thread#currentThread()</code> 方法，直接使用 <code>this</code> 即可获得当前线程。</li>
<li>缺点：线程类已经继承了 Thread 类，所以不能再继承其他父类。</li>
</ul>
</li>
<li><p>使用方式二、或方式三</p>
<ul>
<li><p>优点：</p>
<ul>
<li><p>线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</p>
</li>
<li><p>在这种方式下，多个线程可以共享同一个 <code>target</code> 对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将 CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Runnable runner &#x3D; new Runnable()&#123; ... &#125;;<br>&#x2F;&#x2F; 通过new Thread(target, name) 方法创建新线程<br>new Thread(runna,&quot;新线程1&quot;).start();<br>new Thread(runna,&quot;新线程2&quot;).start();<br></code></pre></td></tr></table></figure>

<ul>
<li>当然，实际比较少这么用。</li>
</ul>
</li>
<li><p>【最重要】<strong>可以使用线程池</strong>。</p>
</li>
</ul>
</li>
<li><p>缺点：编程稍微复杂，如果要访问当前线程，则必须使用<code>Thread#currentThread()</code> 方法。</p>
</li>
</ul>
</li>
</ul>
<p>🦅 <strong>start 和 run 方法有什么区别？</strong></p>
<ul>
<li>当你调用 start 方法时，你将创建新的线程，并且执行在 run 方法里的代码。</li>
<li>但是如果你直接调用 run 方法，它不会创建新的线程也不会执行调用线程的代码，只会把 run 方法当作普通方法去执行。</li>
</ul>
<p><strong>一个线程运行时发生异常会怎样？</strong></p>
<p>如果异常没有被捕获该线程将会停止执行。<code>Thread.UncaughtExceptionHandler</code> 是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候 JVM 会使用 <code>Thread#getUncaughtExceptionHandler()</code> 方法来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 <code>#uncaughtException(exception)</code> 方法进行处理。</p>
<p>具体的使用，可以看看 <a href="https://blog.csdn.net/u013256816/article/details/50417822">《JAVA 多线程之 UncaughtExceptionHandler —— 处理非正常的线程中止》</a> 。</p>
<h2 id="如何使用-wait-notify-实现通知机制？"><a href="#如何使用-wait-notify-实现通知机制？" class="headerlink" title="如何使用 wait + notify 实现通知机制？"></a>如何使用 wait + notify 实现通知机制？</h2><blockquote>
<p>wait + notify 对于大多数胖友，一开始理解可能会比较困难，多看多理解吧。</p>
</blockquote>
<p>在 Java 发展史上，曾经使用 suspend、resume 方法对于线程进行阻塞唤醒，但随之出现很多问题，比较典型的还是死锁问题。</p>
<p>解决方案可以使用以对象为目标的阻塞，即利用 Object 类的 wait 和 notify方法实现线程阻塞。</p>
<ul>
<li>首先，wait、notify 方法是针对对象的，调用任意对象的 wait 方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的 notify 方法则将随机解除该对象阻塞的线程，但它需要重新获取改对象的锁，直到获取成功才能往下执行。</li>
<li>其次，wait、notify 方法必须在 <code>synchronized</code> 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。</li>
</ul>
<p>具体的实现，看看 <a href="https://juejin.im/entry/5a2bb783f265da43163cff74">《Wait / Notify通知机制解析》</a> 文章。</p>
<p>通过 wait + notify 的组合，可以通知机制，不过我们也可以使用其它工具，胖友可以思考下。例如如下的每一个方式：</p>
<ul>
<li>Condition</li>
<li>CountDownLatch</li>
<li>Queue</li>
<li>Future</li>
<li>…</li>
</ul>
<blockquote>
<p>艿艿：这个问题可以衍生下，Java 如何实现多线程之间的通讯和协作？具体的可以看看 <a href="https://blog.csdn.net/zhoucheng05_13/article/details/78311179">《Java多线程——线程间协作方式总结及使用示例》</a> 文章，当然不仅限于该文章所提供的方式。😈 胖友可以认真思索下。</p>
</blockquote>
<p>🦅 <strong>Thread类的 sleep 方法和对象的 wait 方法都可以让线程暂停执行，它们有什么区别？</strong></p>
<blockquote>
<p>关于这个问题，可以结合 <a href="http://svip.iocoder.cn/Java/Concurrent/Interview/#">「线程的生命周期？」</a> 问题的图，一起瞅瞅。</p>
</blockquote>
<ul>
<li>sleep 方法，是线程类 Thread 的静态方法。调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态）</li>
<li>wait 方法，是 Object 类的方法。调用对象的 <code>#wait()</code> 方法，会导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的 <code>#notify()</code> 方法（或<code>#notifyAll()</code>方法）时，才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。</li>
</ul>
<p>🦅 <strong>请说出与线程同步以及线程调度相关的方法？</strong></p>
<ul>
<li>wait 方法，使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁。</li>
<li>sleep 方法，使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常。</li>
<li>notify 方法，唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关。</li>
<li>notityAll 方法，唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态。</li>
</ul>
<p>🦅 <strong>notify 和 notifyAll 有什么区别？</strong></p>
<p>当一个线程进入 wait 之后，就必须等其他线程 notify/notifyAll 。</p>
<ul>
<li>使用 notifyAll,可以唤醒所有处于 wait 状态的线程，使其重新进入锁的争夺队列中，而 notify 只能唤醒一个。</li>
<li>如果没把握，建议 notifyAll ，防止 notify 因为信号丢失而造成程序错误。</li>
</ul>
<p>关于 notify 的信息丢失，可以看看 <a href="https://www.jianshu.com/p/91d95bb5a4bd">《wait 和 notify 的坑》</a> 文章。</p>
<p>🦅 <strong>为什么 wait, notify 和 notifyAll 这三方法不在 Thread 类里面？</strong></p>
<p>一个很明显的原因是 Java 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。</p>
<p>由于 wait，notify 和 notifyAll 方法都是锁级别的操作，所以把它们定义在 Object 类中，因为锁属于对象。</p>
<p>🦅 <strong>为什么 wait 和 notify 方法要在同步块中调用？</strong></p>
<ul>
<li>Java API 强制要求这样做，如果你不这么做，你的代码会抛出 IllegalMonitorStateException 异常。</li>
<li>还有一个原因是为了避免 wait 和 notify 之间产生竞态条件。</li>
</ul>
<p>🦅 <strong>为什么你应该在循环中检查等待条件？</strong></p>
<p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。</p>
<p>所以，我们不能写 <code>if (condition)</code> 而应该是 <code>while (condition)</code> ，特别是 CAS 竞争的时候。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; The standard idiom for using the wait method<br>synchronized (obj) &#123;<br>    while (condition does not hold) &#123;<br>        obj.wait(); &#x2F;&#x2F; (Releases lock, and reacquires on wakeup)<br>    &#125;<br>    ... &#x2F;&#x2F; Perform action appropriate to condition<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>另外，也可以看看 <a href="https://blog.csdn.net/qq_35181209/article/details/77362297">《wait 必须放在 while 循环里面的原因探析》</a></li>
</ul>
<h2 id="sleep、join、yield-方法有什么区别？"><a href="#sleep、join、yield-方法有什么区别？" class="headerlink" title="sleep、join、yield 方法有什么区别？"></a>sleep、join、yield 方法有什么区别？</h2><p>1）sleep 方法</p>
<p>在指定的毫秒数内，让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。让其他线程有机会继续执行，但它并不释放对象锁。也就是如果有<code>synchronized</code> 同步块，其他线程仍然不能访问共享数据。注意该方法要捕获异常。</p>
<p>比如有两个线程同时执行(没有 <code>synchronized</code>)，一个线程优先级为<code>MAX_PRIORITY</code> ，另一个为 <code>MIN_PRIORITY</code> 。</p>
<ul>
<li>如果没有 sleep 方法，只有高优先级的线程执行完成后，低优先级的线程才能执行。但当高优先级的线程 <code>#sleep(5000)</code> 后，低优先级就有机会执行了。</li>
<li>总之，sleep 方法，可以使低优先级的线程得到执行的机会，当然也可以让同优先级、高优先级的线程有执行的机会。</li>
</ul>
<p>2）yield 方法</p>
<p>yield 方法和 sleep 方法类似，也不会释放“锁标志”，区别在于：</p>
<ul>
<li>它没有参数，即 yield 方法只是使当前线程重新回到可执行状态，所以执行yield 的线程有可能在进入到可执行状态后马上又被执行。</li>
<li>另外 yield 方法只能使同优先级或者高优先级的线程得到执行机会，这也和 sleep 方法不同。</li>
</ul>
<p>3）join 方法</p>
<p>Thread 的非静态方法 join ，让一个线程 B “加入”到另外一个线程 A 的尾部。在线程 A 执行完毕之前，线程 B 不能工作。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Thread t &#x3D; new MyThread();<br>t.start();<br>t.join();<br></code></pre></td></tr></table></figure>

<ul>
<li>保证当前线程停止执行，直到该线程所加入的线程 <code>t</code> 完成为止。然而，如果它加入的线程 <code>t</code> 没有存活，则当前线程不需要停止。</li>
</ul>
<p>🦅 <strong>线程的 sleep 方法和 yield 方法有什么区别？</strong></p>
<ul>
<li>sleep 方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会。yield 方法只会给相同优先级或更高优先级的线程以运行的机会。</li>
<li>线程执行 sleep 方法后转入阻塞（blocked）状态，而执行 yield 方法后转入就绪（ready）状态。</li>
<li>sleep 方法声明抛出 InterruptedException 异常，而 yield 方法没有声明任何异常。</li>
<li>sleep 方法比 yield 方法（跟操作系统 CPU 调度相关）具有更好的可移植性。</li>
</ul>
<blockquote>
<p>艿艿：实际场景下，我们很少使用 yield 方法噢。</p>
</blockquote>
<p>🦅 <strong>为什么 Thread 类的 sleep 和 yield 方法是静态的？</strong></p>
<p>Thread 类的 sleep 和 yield  方法，将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</p>
<p>🦅 <strong>sleep(0) 有什么用途？</strong></p>
<p><code>Thread#sleep(0)</code> 方法，并非是真的要线程挂起 0 毫秒，意义在于这次调用 <code>Thread#sleep(0)</code> 方法，把当前线程确实的被冻结了一下，让其他线程有机会优先执行。<code>Thread#sleep(0)</code> 方法，是你的线程暂时放弃 CPU ，也就是释放一些未用的时间片给其他线程或进程使用，就相当于一个<strong>让位动作</strong>。</p>
<p>感兴趣的胖友，可以看看 <a href="https://blog.csdn.net/qiaoquan3/article/details/56281092">《Sleep(0) 的妙用》</a> 的示例。</p>
<p>🦅 <strong>你如何确保 main 方法所在的线程是 Java 程序最后结束的线程？</strong></p>
<blockquote>
<p>考点，就是 join 方法。</p>
</blockquote>
<p>我们可以使用 Thread 类的 <code>#join()</code> 方法，来确保所有程序创建的线程在 main 方法退出前结束。</p>
<h2 id="interrupted-和-isInterrupted-方法的区别？"><a href="#interrupted-和-isInterrupted-方法的区别？" class="headerlink" title="interrupted 和 isInterrupted 方法的区别？"></a>interrupted 和 isInterrupted 方法的区别？</h2><p>1）interrupt 方法</p>
<p><code>Thread#interrupt()</code> 方法，用于中断线程。调用该方法的线程的状态为将被置为”中断”状态。</p>
<p>注意：线程中断仅仅是置线程的中断状态位，不会停止线程。需要用户自己去监视线程的状态为并做处理。支持线程中断的方法（也就是线程中断后会抛出  InterruptedException 的方法）就是在监视线程的中断状态，一旦线程的中断状态被置为“中断状态”，就会抛出中断异常。</p>
<p>2）interrupted</p>
<p><code>Thread#interrupted()</code> <strong>静态</strong>方法，查询当前线程的中断状态，并且清除原状态。如果一个线程被中断了，第一次调用 <code>#interrupted()</code> 方法则返回 <code>true</code> ，第二次和后面的就返回 <code>false</code> 了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; Thread.java<br><br>public static boolean interrupted() &#123;<br>    return currentThread().isInterrupted(true); &#x2F;&#x2F; 清理<br>&#125;<br><br>private native boolean isInterrupted(boolean ClearInterrupted);<br></code></pre></td></tr></table></figure>

<p>3）interrupted</p>
<p><code>Thread#isInterrupted()</code> 方法，查询指定线程的中断状态，不会清除原状态。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; Thread.java<br><br>public boolean isInterrupted() &#123;<br>    return isInterrupted(false); &#x2F;&#x2F; 不清楚<br>&#125;<br><br>private native boolean isInterrupted(boolean ClearInterrupted);<br></code></pre></td></tr></table></figure>

<h2 id="什么叫线程安全？"><a href="#什么叫线程安全？" class="headerlink" title="什么叫线程安全？"></a>什么叫线程安全？</h2><p>线程安全，是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。</p>
<p>🦅 <strong>Servlet 是线程安全吗？</strong></p>
<p>Servlet 不是线程安全的，Servlet 是单实例多线程的，当多个线程同时访问同一个方法，是不能保证共享变量的线程安全性的。</p>
<p>🦅 <strong>Struts2 是线程安全吗？</strong></p>
<p>Struts2 的 Action 是多实例多线程的，是线程安全的，每个请求过来都会 <code>new</code> 一个新的 Action 分配给这个请求，请求完成后销毁。</p>
<p>🦅 <strong>SpringMVC 是线程安全吗？</strong></p>
<p>不是的，和 Servlet 类似的处理流程。</p>
<p>🦅 <strong>单例模式的线程安全性?</strong></p>
<p>老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：</p>
<ul>
<li>饿汉式单例模式的写法：线程安全</li>
<li>懒汉式单例模式的写法：非线程安全</li>
<li>双检锁单例模式的写法：线程安全</li>
</ul>
<h2 id="多线程同步和互斥有几种实现方法，都是什么？"><a href="#多线程同步和互斥有几种实现方法，都是什么？" class="headerlink" title="多线程同步和互斥有几种实现方法，都是什么？"></a>多线程同步和互斥有几种实现方法，都是什么？</h2><p>1）<strong>线程同步</strong></p>
<p>线程同步，是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。</p>
<p>线程间的同步方法，大体可分为两类：用户模式和内核模式。顾名思义：</p>
<ul>
<li>内核模式，就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态。内核模式下的方法有：<ul>
<li>事件</li>
<li>信号量</li>
<li>互斥量</li>
</ul>
</li>
<li>用户模式，就是不需要切换到内核态，只在用户态完成操作。用户模式下的方法有：<ul>
<li>原子操作（例如一个单一的全局变量）</li>
<li>临界区</li>
</ul>
</li>
</ul>
<p>2）<strong>线程互斥</strong></p>
<p>线程互斥，是指对于共享的进程系统资源，在各单个线程访问时的排它性。</p>
<ul>
<li>当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。</li>
<li>线程互斥可以看成是一种特殊的线程同步。</li>
</ul>
<p>🦅 <strong>如何在两个线程间共享数据？</strong></p>
<p>在两个线程间<strong>共享变量</strong>，即可实现共享。</p>
<p>一般来说，共享变量要求变量本身是线程安全的，然后在线程内使用的时候，如果有对共享变量的复合操作，那么也得保证复合操作的线程安全性。</p>
<p>🦅 <strong>怎么检测一个线程是否拥有锁？</strong></p>
<p>调用 <code>Thread#holdsLock(Object obj)</code> <strong>静态</strong>方法，它返回 <code>true</code> 如果当且仅当当前线程拥有某个具体对象的锁。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; Thread.java<br><br>public static native boolean holdsLock(Object obj);<br></code></pre></td></tr></table></figure>

<p>🦅 <strong>10 个线程和 2 个线程的同步代码，哪个更容易写？</strong></p>
<p>从写代码的角度来说，两者的复杂度是相同的，因为同步代码与线程数量是相互独立的。</p>
<p>但是同步策略的选择依赖于线程的数量，因为越多的线程意味着更大的竞争，所以你需要利用同步技术，如锁分离，这要求更复杂的代码和专业知识。</p>
<h2 id="什么是-ThreadLocal-变量？"><a href="#什么是-ThreadLocal-变量？" class="headerlink" title="什么是 ThreadLocal 变量？"></a>什么是 ThreadLocal 变量？</h2><p>ThreadLocal ，是 Java 里一种特殊的变量。每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。</p>
<p>它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用 ThreadLocal 让 SimpleDateFormat  变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。</p>
<ul>
<li>首先，通过复用减少了代价高昂的对象的创建个数。</li>
<li>其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。</li>
</ul>
<p>😈 所以，ThreadLocal 很适合实现线程级的单例。</p>
<p>详细的，可以看看 <a href="https://www.cnblogs.com/dolphin0520/p/3920407.html">《Java并发编程：深入剖析ThreadLocal》</a> 文章。</p>
<p>关于源码，可以看看 <a href="http://www.iocoder.cn/JUC/sike/ThreadLocal/?vip">《【死磕 Java 并发】—– 深入分析 ThreadLocal》</a> 。</p>
<p>🦅 <strong>什么是 InheritableThreadLocal ？</strong></p>
<p>InheritableThreadLocal 类，是 ThreadLocal 类的子类。ThreadLocal 中每个线程拥有它自己的值，与 ThreadLocal 不同的是，<strong>InheritableThreadLocal 允许一个线程以及该线程创建的所有子线程都可以访问它保存的值</strong>。</p>
<ul>
<li>具体的实现原理，可以看看 <a href="https://blog.csdn.net/ni357103403/article/details/51970748">《Java 多线程：InheritableThreadLocal 实现原理》</a> 文章。</li>
<li>具体的使用示例，可以看看 <a href="http://blog.didispace.com/Spring-Cloud%E4%B8%ADHystrix-%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB%E5%AF%BC%E8%87%B4ThreadLocal%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1/">《Spring Cloud中Hystrix 线程隔离导致ThreadLocal数据丢失》</a> 。</li>
</ul>
<p>🦅 <strong>在多线程环境下，SimpleDateFormat 是线程安全的吗？</strong></p>
<p>不是，非常不幸，DateFormat 的所有实现，包括 SimpleDateFormat 都不是线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中使用，<strong>如将 SimpleDateFormat 限制在 ThreadLocal 中</strong>。</p>
<p>如果你不这么做，在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、时间处理的所有实践来说，我强力推荐 joda-time 库。</p>
<h2 id="如何在-Java-中获取线程堆栈？"><a href="#如何在-Java-中获取线程堆栈？" class="headerlink" title="如何在 Java 中获取线程堆栈？"></a>如何在 Java 中获取线程堆栈？</h2><ul>
<li><p><code>kill -3 [java pid]</code></p>
<p>  不会在当前终端输出，它会输出到代码执行的或指定的地方去。比如， <code>kill -3 tomcat pid</code> , 输出堆栈到 log 目录下。</p>
</li>
<li><p><code>Jstack [java pid]</code></p>
<p>  这个比较简单，在当前终端显示，也可以重定向到指定文件中。</p>
</li>
<li><p><a href="https://juejin.im/post/5a3b92def265da4319567218"><code>JVisualVM：Thread Dump</code></a></p>
<p>  不做说明，打开 JVisualVM 后，都是界面操作，过程还是很简单的。</p>
</li>
</ul>
<h2 id="什么是Java-Timer-类？"><a href="#什么是Java-Timer-类？" class="headerlink" title="什么是Java Timer 类？"></a>什么是Java Timer 类？</h2><p><code>java.util.Timer</code> ，是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer 类可以用安排一次性任务或者周期任务。</p>
<p><code>java.util.TimerTask</code> ，是一个实现了 Runnable 接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用 Timer 去安排它的执行。</p>
<p>目前有开源的 Qurtz 可以用来创建定时任务。</p>
<h2 id="你有哪些多线程开发良好的实践？"><a href="#你有哪些多线程开发良好的实践？" class="headerlink" title="你有哪些多线程开发良好的实践？"></a>你有哪些多线程开发良好的实践？</h2><ul>
<li><p>1、给线程命名。</p>
<blockquote>
<p>这样可以方便找 bug 或追踪。OrderProcessor、QuoteProcessor、TradeProcessor 这种名字比  Thread-1、Thread-2、Thread-3  好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。</p>
</blockquote>
</li>
<li><p>2、最小化同步范围。</p>
<blockquote>
<p>锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。</p>
</blockquote>
</li>
<li><p>3、优先使用 <code>volatile</code> ，而不是 <code>synchronized</code> 。</p>
</li>
<li><p>4、尽可能使用更高层次的并发工具而非 wait 和 notify 方法来实现线程通信。</p>
<blockquote>
<p>首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用 wait 和 notify 很难实现对复杂控制流的控制。</p>
<p>其次，这些类是由最好的企业编写和维护在后续的 JDK 中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。</p>
</blockquote>
</li>
<li><p>5、优先使用并发容器，而非同步容器。</p>
<blockquote>
<p>这是另外一个容易遵循且受益巨大的最佳实践，并发容器比同步容器的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到 Map ，我们应该首先想到用 ConcurrentHashMap 类。</p>
</blockquote>
</li>
<li><p>6、考虑使用线程池。</p>
</li>
</ul>
<h2 id="并发编程和并行编程有什么区别？"><a href="#并发编程和并行编程有什么区别？" class="headerlink" title="并发编程和并行编程有什么区别？"></a>并发编程和并行编程有什么区别？</h2><p>并发（Concurrency）和并行（Parallellism）是：</p>
<ul>
<li>解释一：并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。</li>
<li>解释二：并行是在不同实体上的多个事件；并发是在同一实体上的多个事件。</li>
<li>解释三：在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如 Hadoop 分布式集群。</li>
</ul>
<p>所以并发编程的目标是，充分的利用处理器的每一个核，以达到最高的处理性能。</p>
<h2 id="同步和异步有何异同，在什么情况下分别使用他们？"><a href="#同步和异步有何异同，在什么情况下分别使用他们？" class="headerlink" title="同步和异步有何异同，在什么情况下分别使用他们？"></a>同步和异步有何异同，在什么情况下分别使用他们？</h2><p>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行<strong>同步</strong>存取。</p>
<p>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用<strong>异步</strong>编程，在很多情况下采用异步途径往往更有效率。</p>
<blockquote>
<p>当然，如果我们对效率没有特别大的要求，也不一定需要使用异步编程，因为它会带来编码的复杂性。总之，合适才是正确的。</p>
</blockquote>
<h1 id="Java-锁"><a href="#Java-锁" class="headerlink" title="Java 锁"></a>Java 锁</h1><ul>
<li><code>synchronized</code><ul>
<li><a href="http://static2.iocoder.cn/b9bc9653929e5da43d8edad6e6a0d293"><img src="http://cdn.tuwenbin.vip/20201005171252" alt="synchronized-1"></a>synchronized-1</li>
<li><a href="http://static2.iocoder.cn/a79be5f48c26abb905348e43a1732d55"><img src="http://cdn.tuwenbin.vip/20201005171256" alt="synchronized-2导图"></a>synchronized-2导图</li>
</ul>
</li>
<li><code>volatile</code><ul>
<li><a href="http://static2.iocoder.cn/506052a856416414e18c7ed79d43cc5c"><img src="http://cdn.tuwenbin.vip/20201005171259" alt="volatile"></a>volatile</li>
</ul>
</li>
</ul>
<h2 id="synchronized-的原理是什么"><a href="#synchronized-的原理是什么" class="headerlink" title="synchronized 的原理是什么?"></a><code>synchronized</code> 的原理是什么?</h2><p><code>synchronized</code>是 Java 内置的关键字，它提供了一种独占的加锁方式。</p>
<ul>
<li><p><code>synchronized</code>的获取和释放锁由JVM实现，用户不需要显示的释放锁，非常方便。</p>
</li>
<li><p>然而，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">synchronized<br></code></pre></td></tr></table></figure>

<p> 也有一定的局限性。</p>
<ul>
<li>当线程尝试获取锁的时候，如果获取不到锁会一直阻塞。</li>
<li>如果获取锁的线程进入休眠或者阻塞，除非当前线程异常，否则其他线程尝试获取锁必须一直等待。</li>
</ul>
</li>
</ul>
<p>关于原理，直接阅读 <a href="http://www.iocoder.cn/JUC/sike/synchronized/?vip">《【死磕 Java 并发】—– 深入分析 synchronized 的实现原理》</a> 文章，有几个重点要注意看。</p>
<ul>
<li>实现原理</li>
<li>Java 对象头、Monitor</li>
<li>锁优化<ul>
<li>自旋锁<ul>
<li>适应自旋锁</li>
</ul>
</li>
<li>锁消除</li>
<li>锁粗化</li>
<li>锁的升级<ul>
<li>重量级锁</li>
<li>轻量级锁</li>
<li>偏向锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>🦅 <strong>当一个线程进入某个对象的一个 <code>synchronized</code> 的实例方法后，其它线程是否可进入此对象的其它方法？</strong></p>
<ul>
<li>如果其他方法没有 <code>synchronized</code> 的话，其他线程是可以进入的。</li>
<li>所以要开放一个线程安全的对象时，得保证每个方法都是线程安全的。</li>
</ul>
<p>🦅 <strong>同步方法和同步块，哪个是更好的选择？</strong></p>
<p>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</p>
<p>同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。</p>
<p>🦅 <strong>在监视器(Monitor)内部，是如何做线程同步的？</strong></p>
<p>监视器和锁在 Java 虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。<strong>线程在获取锁之前不允许执行同步代码</strong>。</p>
<p>🦅 <strong>Java 如何实现“自旋”（spin）</strong></p>
<p>参考 <a href="http://ifeve.com/java_lock_see1/">《Java 锁的种类以及辨析（一）：自旋锁》</a></p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class SpinLock &#123;<br><br>    private AtomicReference&lt;Thread&gt; sign &#x3D;new AtomicReference&lt;&gt;();<br><br>    public void lock() &#123; &#x2F;&#x2F; &lt;1&gt;<br>        Thread current &#x3D; Thread.currentThread();<br>        while(!sign .compareAndSet(null, current)) &#123;<br>            &#x2F;&#x2F; &lt;1.1&gt;<br>        &#125;<br>    &#125;<br><br>    public void unlock () &#123; &#x2F;&#x2F; &lt;2&gt;<br>        Thread current &#x3D; Thread.currentThread();<br>        sign .compareAndSet(current, null);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>&lt;1&gt;</code> 处，<code>#lock()</code> 方法，如果获得不到锁，就会“死循环”，直到或得到锁为止。考虑到“死循环”会持续占用 CPU ，可能导致其它线程无法获得到 CPU 执行，可以在 <code>&lt;1.1&gt;</code> 处增加 <code>Thread.yiead()</code> 代码段，出让下 CPU 。</li>
<li><code>&lt;2&gt;</code> 处，<code>#unlock()</code> 方法，释放锁。</li>
</ul>
<h2 id="volatile-实现原理"><a href="#volatile-实现原理" class="headerlink" title="volatile 实现原理"></a>volatile 实现原理</h2><p><code>volatile</code> 涉及的内容，其实蛮多的，所以胖友直接看：</p>
<ul>
<li><a href="http://www.iocoder.cn/JUC/sike/volatile/?vip">《【死磕 Java 并发】—– 深入分析 volatile 的实现原理》</a></li>
<li><a href="https://www.infoq.cn/article/ftf-java-volatile">聊聊并发（一）——深入分析Volatile的实现原理</a></li>
</ul>
<p>🦅 <strong><code>volatile</code> 有什么用？</strong></p>
<p><code>volatile</code> 保证内存可见性和禁止指令重排。</p>
<blockquote>
<p>同时，<code>volatile</code> 可以提供部分原子性。</p>
</blockquote>
<p>简单来说，<code>volatile</code> 用于多线程环境下的单次操作(单次读或者单次写)。</p>
<p>🦅 <strong><code>volatile</code> 变量和 atomic 变量有什么不同？</strong></p>
<ul>
<li><code>volatile</code> 变量，可以确保先行关系，即写操作会发生在后续的读操作之前，但它并不能保证原子性。例如用 <code>volatile</code> 修饰 <code>count</code> 变量，那么 <code>count++</code> 操作就不是原子性的。</li>
<li>AtomicInteger 类提供的 atomic 方法，可以让这种操作具有原子性。例如 <code>#getAndIncrement()</code> 方法，会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</li>
</ul>
<p>🦅 <strong>可以创建 <code>volatile</code> 数组吗?</strong></p>
<p>Java 中可以创建 <code>volatile</code> 类型数组，不过只是一个指向数组的引用，而不是整个数组。如果改变引用指向的数组，将会受到 <code>volatile</code> 的保护，但是如果多个线程同时改变数组的元素，<code>volatile</code> 标示符就不能起到之前的保护作用了。</p>
<p>同理，对于 Java POJO 类，使用 <code>volatile</code> 修饰，只能保证这个引用的可见性，不能保证其内部的属性。</p>
<p>🦅 <strong><code>volatile</code> 能使得一个非原子操作变成原子操作吗?</strong></p>
<p>一个典型的例子是在类中有一个 <code>long</code> 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 <code>volatile</code> 。为什么？因为 Java 中读取 <code>long</code> 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 <code>long</code> 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 <code>volatile</code> 型的 <code>long</code> 或 <code>double</code> 变量的读写是原子。</p>
<blockquote>
<p>如下的内容，可以作为上面的内容的补充。</p>
<p>一种实践是用 <code>volatile</code> 修饰 <code>long</code> 和 <code>double</code> 变量，使其能按原子类型来读写。<code>double</code> 和 <code>long</code> 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 <code>volatile</code> 型的 <code>long</code> 或 <code>double</code> 变量的读写是原子的。</p>
</blockquote>
<p>🦅 <strong><code>volatile</code> 类型变量提供什么保证？</strong></p>
<p><code>volatile</code> 主要有两方面的作用：</p>
<ol>
<li>避免指令重排</li>
<li>可见性保证</li>
</ol>
<p>例如，JVM 或者 JIT 为了获得更好的性能会对语句重排序，但是 <code>volatile</code> 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。</p>
<ul>
<li><code>volatile</code> 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。</li>
<li>某些情况下，<code>volatile</code> 还能提供原子性，如读 64 位数据类型，像 <code>long</code> 和 <code>double</code> 都不是原子的(低 32 位和高 32 位)，但 <code>volatile</code> 类型的 <code>double</code> 和 <code>long</code> 就是原子的。<strong>不过需要在 64 位的 JVM 虚拟机上</strong>。详细的分析，可以看看 <a href="https://my.oschina.net/u/1753415/blog/724242">《Java中 long 和 double 的原子性》</a> 。</li>
</ul>
<p>🦅 <strong><code>volatile</code> 和 <code>synchronized</code> 的区别？</strong></p>
<ol>
<li><code>volatile</code> 本质是在告诉 JVM 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取。<code>synchronized</code> 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li><code>volatile</code> 仅能使用在变量级别。<code>synchronized</code> 则可以使用在变量、方法、和类级别的。</li>
<li><code>volatile</code> 仅能实现变量的修改可见性，不能保证原子性。而<code>synchronized</code> 则可以保证变量的修改可见性和原子性。</li>
<li><code>volatile</code> 不会造成线程的阻塞。<code>synchronized</code> 可能会造成线程的阻塞。</li>
<li><code>volatile</code> 标记的变量不会被编译器优化。<code>synchronized</code>标记的变量可以被编译器优化。</li>
</ol>
<blockquote>
<p>另外，会有面试官会问 <code>volatile</code> 能否取代 <code>synchronized</code> 呢？答案肯定是不能，虽然说 <code>volatile</code> 被称之为轻量级锁，但是和 <code>synchronized</code> 是有本质上的区别，原因就是上面的几点落。</p>
</blockquote>
<p>🦅 <strong>什么场景下可以使用 <code>volatile</code> 替换 <code>synchronized</code> ？</strong></p>
<ol>
<li>只需要保证共享资源的可见性的时候可以使用 <code>volatile</code> 替代，<code>synchronized</code> 保证可操作的原子性一致性和可见性。</li>
<li><code>volatile</code> 适用于新值不依赖于旧值的情形。</li>
<li>1 写 N 读。</li>
<li>不与其他变量构成不变性条件时候使用 <code>volatile</code> 。</li>
</ol>
<h2 id="什么是死锁、活锁？"><a href="#什么是死锁、活锁？" class="headerlink" title="什么是死锁、活锁？"></a>什么是死锁、活锁？</h2><p>死锁，是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p>
<p>产生死锁的必要条件：</p>
<ul>
<li>互斥条件：所谓互斥就是进程在某一时间内独占资源。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<p>死锁的解决方法：</p>
<ul>
<li>撤消陷于死锁的全部进程。</li>
<li>逐个撤消陷于死锁的进程，直到死锁不存在。</li>
<li>从陷于死锁的进程中逐个强迫放弃所占用的资源，直至死锁消失。</li>
<li>从另外一些进程那里强行剥夺足够数量的资源分配给死锁进程，以解除死锁状态。</li>
</ul>
<p>🦅 <strong>什么是活锁？</strong></p>
<p>活锁，任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</p>
<p>🦅 <strong>死锁与活锁的区别？</strong></p>
<p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”，而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p>
<p>实际上，聪慧的胖友是不是已经发现，死锁就是悲观锁可能产生的结果，而活锁是乐观锁可能产生的结果。</p>
<h2 id="什么是悲观锁、乐观锁？"><a href="#什么是悲观锁、乐观锁？" class="headerlink" title="什么是悲观锁、乐观锁？"></a>什么是悲观锁、乐观锁？</h2><p>1）悲观锁</p>
<p>悲观锁，总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。</p>
<ul>
<li>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</li>
<li>再比如 Java 里面的同步原语 <code>synchronized</code> 关键字的实现也是悲观锁。</li>
</ul>
<p>2）乐观锁</p>
<p>乐观锁，顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。</p>
<ul>
<li><p>像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。</p>
<blockquote>
<p>例如，version 字段（比较跟上一次的版本号，如果一样则更新，如果失败则要重复读-比较-写的操作）</p>
</blockquote>
</li>
<li><p>在 Java 中 <code>java.util.concurrent.atomic</code> 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。</p>
</li>
</ul>
<p>乐观锁的实现方式：</p>
<ul>
<li>使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。</li>
<li>Java 中的 Compare and Swap 即 CAS ，当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</li>
</ul>
<h1 id="Java-Lock-接口"><a href="#Java-Lock-接口" class="headerlink" title="Java Lock 接口"></a>Java Lock 接口</h1><blockquote>
<p>艿艿：虽然 Lock 也翻译成锁，但是和上面的 <a href="http://svip.iocoder.cn/Java/Concurrent/Interview/#">「Java 锁」</a> 分开，它更多强调的是 <code>synchronized</code> 和 <code>volatile</code> 关键字带来的重量级和轻量级锁。而 Lock 是 Java 锁接口，提供了更多灵活的功能。</p>
</blockquote>
<p><a href="http://static2.iocoder.cn/d2cd1e16577dd6482d1e58ace2062408"><img src="http://cdn.tuwenbin.vip/20201005171307" alt="Lock"></a>Lock</p>
<h2 id="Java-AQS"><a href="#Java-AQS" class="headerlink" title="Java AQS"></a>Java AQS</h2><p><code>java.util.concurrent.locks.AbstractQueuedSynchronizer</code> 抽象类，简称 AQS ，是一个用于构建锁和同步容器的同步器。事实上<code>concurrent</code> 包内许多类都是基于 AQS 构建。例如 ReentrantLock，Semaphore，CountDownLatch，ReentrantReadWriteLock，等。AQS 解决了在实现同步容器时设计的大量细节问题。</p>
<p>AQS 使用一个 FIFO 的队列表示排队等待锁的线程，队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护一个等待状态 <code>waitStatus</code> 。</p>
<p>可能这么说，胖友会一脸懵逼，最好的方式，还是直接去撸源码，可见如下的四篇文章。</p>
<blockquote>
<p>可能胖友在阅读时，会有一定的挫败感，没关系，大家都是如此，包括艿艿，还有我认识的各种大佬。</p>
</blockquote>
<ul>
<li><a href="http://www.iocoder.cn/JUC/sike/aqs-0-intro?vip">《【死磕 Java 并发】—– J.U.C 之 AQS：AQS 简介》</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/aqs-1-clh?vip">《【死磕 Java 并发】—– J.U.C 之 AQS：CLH 同步队列》</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/aqs-2?vip">《【死磕 Java 并发】—– J.U.C 之 AQS：同步状态的获取与释放》</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/aqs-3?vip">《【死磕 Java 并发】—– J.U.C 之 AQS：阻塞和唤醒线程》</a></li>
</ul>
<h2 id="什么是-Java-Lock-接口？"><a href="#什么是-Java-Lock-接口？" class="headerlink" title="什么是 Java Lock 接口？"></a>什么是 Java Lock 接口？</h2><p><code>java.util.concurrent.locks.Lock</code> 接口，比 <code>synchronized</code> 提供更具拓展行的锁操作。它允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。它的优势有：</p>
<ul>
<li>可以使锁更公平。</li>
<li>可以使线程在等待锁的时候响应中断。</li>
<li>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间。</li>
<li>可以在不同的范围，以不同的顺序获取和释放锁。</li>
</ul>
<h2 id="什么是可重入锁（ReentrantLock）？"><a href="#什么是可重入锁（ReentrantLock）？" class="headerlink" title="什么是可重入锁（ReentrantLock）？"></a>什么是可重入锁（ReentrantLock）？</h2><p>举例来说明锁的可重入性。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class UnReentrant&#123;<br><br>    Lock lock &#x3D; new Lock();<br><br>    public void outer() &#123;<br>        lock.lock();<br>        inner();<br>        lock.unlock();<br>    &#125;<br><br>    public void inner() &#123;<br>        lock.lock();<br>        &#x2F;&#x2F;do something<br>        lock.unlock();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>#outer()</code> 方法中调用了 <code>#inner()</code> 方法，<code>#outer()</code> 方法先锁住了 <code>lock</code> ，这样 <code>#inner()</code> 就不能再获取 <code>lock</code> 。</li>
<li>其实调用 <code>#outer()</code> 方法的线程已经获取了 <code>lock</code> 锁，但是不能在 <code>#inner()</code> 方法中重复利用已经获取的锁资源，这种锁即称之为不可重入。</li>
<li>可重入就意味着：线程可以进入任何一个它已经拥有的锁所同步着的代码块。</li>
</ul>
<p><code>synchronized</code>、ReentrantLock 都是可重入的锁，可重入锁相对来说简化了并发编程的开发。</p>
<p>关于 ReentrantLock 类，详细的源码解析，可以看看 <a href="http://www.iocoder.cn/JUC/sike/ReentrantLock/?vip">《【死磕 Java 并发】—– J.U.C 之重入锁：ReentrantLock》</a> 。</p>
<blockquote>
<p>简单来说，ReenTrantLock 的实现是一种自旋锁，通过循环调用 CAS 操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。</p>
</blockquote>
<p>🦅 <strong>synchronized 和 ReentrantLock 异同？</strong></p>
<ul>
<li>相同点<ul>
<li>都实现了多线程同步和内存可见性语义。</li>
<li>都是可重入锁。</li>
</ul>
</li>
<li>不同点<ul>
<li>同步实现机制不同<ul>
<li><code>synchronized</code> 通过 Java 对象头锁标记和 Monitor 对象实现同步。</li>
<li>ReentrantLock 通过CAS、AQS（AbstractQueuedSynchronizer）和  LockSupport（用于阻塞和解除阻塞）实现同步。<br>*</li>
</ul>
</li>
<li>可见性实现机制不同<ul>
<li><code>synchronized</code> 依赖 JVM 内存模型保证包含共享变量的多线程内存可见性。</li>
<li>ReentrantLock 通过 ASQ 的 <code>volatile state</code> 保证包含共享变量的多线程内存可见性。</li>
</ul>
</li>
<li>使用方式不同<ul>
<li><code>synchronized</code> 可以修饰实例方法（锁住实例对象）、静态方法（锁住类对象）、代码块（显示指定锁对象）。</li>
<li>ReentrantLock 显示调用 tryLock 和 lock 方法，需要在 <code>finally</code> 块中释放锁。</li>
</ul>
</li>
<li>功能丰富程度不同<ul>
<li><code>synchronized</code> 不可设置等待时间、不可被中断（interrupted）。</li>
<li>ReentrantLock 提供有限时间等候锁（设置过期时间）、可中断锁（lockInterruptibly）、condition（提供 await、condition（提供 await、signal 等方法）等丰富功能</li>
</ul>
</li>
<li>锁类型不同<ul>
<li><code>synchronized</code> 只支持非公平锁。</li>
<li>ReentrantLock 提供公平锁和非公平锁实现。当然，在大部分情况下，非公平锁是高效的选择。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>在 <code>synchronized</code> 优化以前，它的性能是比 ReenTrantLock 差很多的，但是自从 <code>synchronized</code> 引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用 <code>synchronized</code> 。</p>
<p>并且，实际代码实战中，可能的优化场景是，通过读写分离，进一步性能的提升，所以使用 ReentrantReadWriteLock 。😝</p>
</blockquote>
<h2 id="ReadWriteLock-是什么？"><a href="#ReadWriteLock-是什么？" class="headerlink" title="ReadWriteLock 是什么？"></a>ReadWriteLock 是什么？</h2><p>ReadWriteLock ，读写锁是，用来提升并发程序性能的锁分离技术的 Lock 实现类。可以用于 “多读少写” 的场景，读写锁支持多个读操作并发执行，写操作只能由一个线程来操作。</p>
<p>ReadWriteLock  对向数据结构相对不频繁地写入，但是有多个任务要经常读取这个数据结构的这类情况进行了优化。ReadWriteLock  使得你可以同时有多个读取者，只要它们都不试图写入即可。如果写锁已经被其他任务持有，那么任何读取者都不能访问，直至这个写锁被释放为止。</p>
<p>ReadWriteLock 对程序性能的提高主要受制于如下几个因素：</p>
<ol>
<li>数据被读取的频率与被修改的频率相比较的结果。</li>
<li>读取和写入的时间</li>
<li>有多少线程竞争</li>
<li>是否在多处理机器上运行</li>
</ol>
<p>ReadWriteLock 的源码解析，可以看看 <a href="http://www.iocoder.cn/JUC/sike/ReentrantReadWriteLock/">《【死磕 Java 并发】—– J.U.C 之读写锁：ReentrantReadWriteLock》</a> 。</p>
<h2 id="Condition-是什么？"><a href="#Condition-是什么？" class="headerlink" title="Condition 是什么？"></a>Condition 是什么？</h2><p>在没有 Lock 之前，我们使用 <code>synchronized</code> 来控制同步，配合 Object 的 <code>#wait()</code>、<code>#notify()</code> 等一系列方法可以实现<strong>等待 / 通知模式</strong>。在 Java SE 5 后，Java 提供了 Lock 接口，相对于 <code>synchronized</code> 而言，Lock 提供了条件 Condition ，对线程的等待、唤醒操作更加详细和灵活。下图是 Condition 与 Object 的监视器方法的对比（摘自《Java并发编程的艺术》）：</p>
<p><a href="http://static2.iocoder.cn/e7e7bb0837bbe68a4364366d4ec9c5db"><img src="http://cdn.tuwenbin.vip/20201005171314" alt="Condition 与 Object 的监视器方法的对比"></a>Condition 与 Object 的监视器方法的对比</p>
<ul>
<li>Condition 的使用，可以看看 <a href="http://www.importnew.com/9281.html">《怎么理解 Condition》</a></li>
<li>Condition 的源码，可以看看 <a href="http://www.iocoder.cn/JUC/sike/Condition/">《【死磕 Java 并发】—– J.U.C 之 Condition》</a> 。</li>
</ul>
<p>🦅 <strong>用三个线程按顺序循环打印 abc 三个字母，比如 abcabcabc ？</strong></p>
<ul>
<li>使用 Lock + Condition 来实现。具体代码，参看 <a href="https://blog.csdn.net/Big_Blogger/article/details/65629204">《用三个线程按顺序循环打印 abc 三个字母，比如 abcabcabc》</a> 。</li>
<li>使用 <code>synchronized</code> + await/notifyAll 来实现，参看 <a href="https://blog.csdn.net/weixin_41704428/article/details/80482928">《Java用三个线程按顺序循环打印 abc 三个字母,比如 abcabcabc》</a> 。</li>
</ul>
<h2 id="LockSupport-是什么？"><a href="#LockSupport-是什么？" class="headerlink" title="LockSupport 是什么？"></a>LockSupport 是什么？</h2><p>LockSupport 是 JDK 中比较底层的类，用来创建锁和其他同步工具类的基本线程阻塞。</p>
<ul>
<li>Java 锁和同步器框架的核心 AQS(AbstractQueuedSynchronizer)，就是通过调用 <code>LockSupport#park()</code>和 <code>LockSupport#unpark()</code> 方法，来实现线程的阻塞和唤醒的。</li>
<li>LockSupport 很类似于二元信号量(只有 1 个许可证可供使用)，如果这个许可还没有被占用，当前线程获取许可并继续执行；如果许可已经被占用，当前线程阻塞，等待获取许可。</li>
</ul>
<p>对于 LockSupport 了解即可，面试一般问的不多。感兴趣的胖友，可以看看如下文章：</p>
<ul>
<li><a href="https://www.cnblogs.com/hvicen/p/6217303.html">《多线程同步工具 —— LockSupport》</a></li>
<li><a href="http://www.tianshouzhi.com/api/tutorials/mutithread/303">《Java 并发编程 —— LockSupport》</a> 带部分源码解析。</li>
</ul>
<h1 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h1><p>关于 Java 内存模型，涉及的内容会很多，所以建议胖友看如下的 <a href="https://files-cdn.cnblogs.com/files/skywang12345/%E6%B7%B1%E5%85%A5Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.pdf">《深入Java内存模型.pdf》</a> 这本小书。</p>
<p>然后，看完之后你肯定会忘记，就可以靠 <a href="http://www.iocoder.cn/JUC/zhisheng/Java-Memory-Model?vip">《《深入理解 Java 内存模型》读书笔记》</a> 来补刀。</p>
<p>再另外，<a href="http://gk.link/a/100kc">《深入拆解 Java 虚拟机》</a> 的 <a href="http://svip.iocoder.cn/Java/Concurrent/Interview/#">「第五部分 高效并发」</a> 也推荐阅读。</p>
<h2 id="什么是-Java-内存模型？"><a href="#什么是-Java-内存模型？" class="headerlink" title="什么是 Java 内存模型？"></a>什么是 Java 内存模型？</h2><p>Java 虚拟机规范中试图定义一种 Java 内存模型（Java Memory Model，JMM）来屏蔽掉各层硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p>
<p>Java 内存模型规定了所有的变量都存储在主内存（Main Memory）中。每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在<strong>工作内存</strong>中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间的变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的关系如下图：</p>
<p><a href="http://static2.iocoder.cn/images/JDK/2020_02_07/01.png"><img src="http://cdn.tuwenbin.vip/20201005171319.png" alt="线程、主内存、工作内存"></a>线程、主内存、工作内存</p>
<blockquote>
<p>艿艿：当然，有个面试官会把 Java 内存模型，和 JVM 内存结构搞混淆。所以，在回答之前，可以先和面试官确认下说的是哪个。</p>
<p>关于 JVM 内存结构的面试题，我们在 <a href="http://svip.iocoder.cn/Java/VirtualMachine/Interview">《精尽 Java【虚拟机】面试题》</a> 中在详细分享。</p>
</blockquote>
<h2 id="两个线程之间是如何通信的呢？"><a href="#两个线程之间是如何通信的呢？" class="headerlink" title="两个线程之间是如何通信的呢？"></a>两个线程之间是如何通信的呢？</h2><p>线程之间的通信方式，目前有共享内存和消息传递两种。</p>
<p><strong>1）共享内存</strong></p>
<p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。典型的共享内存通信方式，就是通过共享对象进行通信。</p>
<p><a href="http://static2.iocoder.cn/images/JDK/2020_02_07/02.png"><img src="http://cdn.tuwenbin.vip/20201005171322.png" alt="共享内存"></a>共享内存</p>
<p>例如上图线程 A 与 线程 B 之间如果要通信的话，那么就必须经历下面两个步骤：</p>
<ol>
<li>首先，线程 A 把本地内存 A 更新过得共享变量刷新到主内存中去。</li>
<li>然后，线程 B 到主内存中去读取线程 A 之前更新过的共享变量。</li>
</ol>
<p><strong>2）消息传递</strong></p>
<p>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。在 Java 中典型的消息传递方式，就是 <code>#wait()</code> 和 <code>#notify()</code> ，或者 BlockingQueue 。</p>
<p><a href="http://static2.iocoder.cn/images/JDK/2020_02_07/03.png"><img src="http://cdn.tuwenbin.vip/20201005171326.png" alt="消息传递"></a>消息传递</p>
<h2 id="为什么代码会重排序？"><a href="#为什么代码会重排序？" class="headerlink" title="为什么代码会重排序？"></a>为什么代码会重排序？</h2><p>在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：</p>
<ul>
<li>在单线程环境下不能改变程序运行的结果。</li>
<li>存在数据依赖关系的不允许重排序</li>
</ul>
<p><strong>需要注意的是：重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义</strong>。</p>
<h2 id="什么是内存模型的-happens-before-呢？"><a href="#什么是内存模型的-happens-before-呢？" class="headerlink" title="什么是内存模型的 happens-before 呢？"></a>什么是内存模型的 happens-before 呢？</h2><p>详细看 <a href="http://www.iocoder.cn/JUC/sike/happens-before/?vip">《【死磕 Java 并发】—– Java 内存模型之 happens-before》</a> 文章。</p>
<h2 id="什么是内存屏障？"><a href="#什么是内存屏障？" class="headerlink" title="什么是内存屏障？"></a>什么是内存屏障？</h2><p>内存屏障，又称内存栅栏，是一组处理器指令，用于实现对内存操作的顺序限制。</p>
<p>🦅 <strong>内存屏障为何重要？</strong></p>
<p>对主存的一次访问一般花费硬件的数百次时钟周期。处理器通过缓存（caching）能够从数量级上降低内存延迟的成本这些缓存为了性能重新排列待定内存操作的顺序。也就是说，程序的读写操作不一定会按照它要求处理器的顺序执行。当数据是不可变的，同时/或者数据限制在线程范围内，这些优化是无害的。如果把这些优化与对称多处理（symmetric multi-processing）和共享可变状态（shared mutable state）结合，那么就是一场噩梦。</p>
<p>当基于共享可变状态的内存操作被重新排序时，程序可能行为不定。一个线程写入的数据可能被其他线程可见，原因是数据写入的顺序不一致。适当的放置内存屏障，通过强制处理器顺序执行待定的内存操作来避免这个问题。</p>
<h1 id="Java-并发容器"><a href="#Java-并发容器" class="headerlink" title="Java 并发容器"></a>Java 并发容器</h1><h2 id="什么是并发容器的实现？"><a href="#什么是并发容器的实现？" class="headerlink" title="什么是并发容器的实现？"></a>什么是并发容器的实现？</h2><p>何为同步容器？可以简单地理解为通过 <code>synchronized</code>来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。</p>
<ul>
<li>比如 Vector，Hashtable，以及 <code>Collections#synchronizedSet()</code>，<code>Collections#synchronizedList()</code> 等方法返回的容器。</li>
<li>可以通过查看 Vector，Hashtable 等这些同步容器的实现代码，可以看到这些容器实现线程安全的方式就是将它们的状态封装起来，并在需要同步的方法上加上关键字 <code>synchronized</code> 。</li>
</ul>
<p>并发容器，使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性。</p>
<ul>
<li>例如在 ConcurrentHashMap  中采用了一种粒度更细的加锁机制，可以称为分段锁。在这种锁机制下，允许任意数量的读线程并发地访问 map  ，并且执行读操作的线程和写操作的线程也可以并发的访问 map ，同时允许一定数量的写操作线程并发地修改 map  ，所以它可以在并发环境下实现更高的吞吐量。</li>
<li>再例如，CopyOnWriteArrayList 。</li>
</ul>
<h2 id="SynchronizedMap-和-ConcurrentHashMap-有什么区别？"><a href="#SynchronizedMap-和-ConcurrentHashMap-有什么区别？" class="headerlink" title="SynchronizedMap 和 ConcurrentHashMap 有什么区别？"></a>SynchronizedMap 和 ConcurrentHashMap 有什么区别？</h2><ul>
<li>SynchronizedMap<ul>
<li>一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为 map 。</li>
</ul>
</li>
<li>ConcurrentHashMap<ul>
<li>使用分段锁来保证在多线程下的性能。ConcurrentHashMap 中则是一次锁住一个桶。ConcurrentHashMap 默认将  hash 表分为 16 个桶，诸如 get,put,remove 等常用操作只锁当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有  16 个写线程执行，并发性能的提升是显而易见的。【注意，这块是 JDK7 的实现。在 JDK8 中，具体的实现已经改变】</li>
<li>另外 ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中，当 iterator 被创建后集合再发生改变就不再是抛出 ConcurrentModificationException 异常，取而代之的是在改变时 <code>new</code> 新的数据从而不影响原有的数据，iterator 完成后再将头指针替换为新的数据 ，这样 iterator 线程可以使用原来老的数据，而写线程也可以并发的完成改变。</li>
</ul>
</li>
</ul>
<p>关于 ConcurrentHashMap 的源码解析，推荐胖友看看如下两篇文章：</p>
<ul>
<li><a href="http://www.iocoder.cn/JUC/sike/ConcurrentHashMap/?vip">《【死磕 Java 并发】—– J.U.C 之 Java并发容器：ConcurrentHashMap》</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/ConcurrentHashMap-red-black-tree/?vip">《【死磕 Java 并发】—– J.U.C 之 ConcurrentHashMap 红黑树转换分析》</a></li>
</ul>
<p>🦅 <strong>Java 中 ConcurrentHashMap 的并发度是什么？</strong></p>
<p>在 JDK8 前，ConcurrentHashMap 把实际 map  划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是 ConcurrentHashMap  类构造函数的一个可选参数，默认值为 16 ，这样在多线程情况下就能避免争用。</p>
<p>在 JDK8 后，它摒弃了 Segment（锁段）的概念，而是启用了一种全新的方式实现，利用 CAS 算法。同时加入了更多的辅助变量来提高并发度，具体内容还是查看源码吧。</p>
<p>🦅 <strong>ConcurrentHashMap 为何读不用加锁？</strong></p>
<p>在 JDK7 以及以前</p>
<ul>
<li><p>HashEntry 中的 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">key<br></code></pre></td></tr></table></figure>

<p>、</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">hash<br></code></pre></td></tr></table></figure>

<p>、</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">next<br></code></pre></td></tr></table></figure>

<p> 均为 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">final<br></code></pre></td></tr></table></figure>

<p> 型，只能表头插入、删除结点。</p>
<ul>
<li>HashEntry 类的 <code>value</code> 域被声明为 <code>volatile</code> 型。</li>
<li>不允许用 <code>null</code> 作为键和值，当读线程读到某个 HashEntry 的 <code>value</code> 域的值为 <code>null</code> 时，便知道产生了冲突——发生了重排序现象（put 方法设置新 <code>value</code> 对象的字节码指令重排序），需要加锁后重新读入这个 <code>value</code> 值。</li>
</ul>
</li>
<li><p><code>volatile</code> 变量 <code>count</code> 协调读写线程之间的内存可见性，写操作后修改 <code>count</code> ，读操作先读 <code>count</code>，根据 happen-before 传递性原则写操作的修改读操作能够看到。</p>
</li>
</ul>
<p>在 JDK8 开始</p>
<ul>
<li>Node 的 <code>val</code> 和 <code>next</code> 均为 <code>volatile</code> 型。</li>
<li><code>#tabAt(..,)</code> 和 <code>#casTabAt(...)</code> 对应的 Unsafe 操作实现了 <code>volatile</code> 语义。</li>
</ul>
<h2 id="CopyOnWriteArrayList-可以用于什么应用场景？"><a href="#CopyOnWriteArrayList-可以用于什么应用场景？" class="headerlink" title="CopyOnWriteArrayList 可以用于什么应用场景？"></a>CopyOnWriteArrayList 可以用于什么应用场景？</h2><p>CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出ConcurrentModificationException 异常。在 CopyOnWriteArrayList  中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。</p>
<ul>
<li>由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致 ygc 或者 fgc 。</li>
<li>不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个 set 操作后，读取到数据可能还是旧的,虽然 CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求。</li>
</ul>
<p>CopyOnWriteArrayList 透露的思想：</p>
<ul>
<li>读写分离，读和写分开</li>
<li>最终一致性</li>
<li>使用另外开辟空间的思路，来解决并发冲突</li>
</ul>
<p>CopyOnWriteArrayList 适用于读操作远远多于写操作的场景。例如，缓存。</p>
<p>关于 CopyOnWriteArrayList 的源码，可以看看 <a href="http://www.importnew.com/12773.html">《CopyOnWriteArrayList 实现原理及源码分析》</a> 文章。</p>
<h1 id="Java-阻塞队列"><a href="#Java-阻塞队列" class="headerlink" title="Java 阻塞队列"></a>Java 阻塞队列</h1><h2 id="什么是阻塞队列？有什么适用场景？"><a href="#什么是阻塞队列？有什么适用场景？" class="headerlink" title="什么是阻塞队列？有什么适用场景？"></a>什么是阻塞队列？有什么适用场景？</h2><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：</p>
<ul>
<li>在队列为空时，获取元素的线程会等待队列变为非空。</li>
<li>当队列满时，存储元素的线程会等待队列可用。</li>
</ul>
<p>阻塞队列常用于生产者和消费者的场景：</p>
<ul>
<li>生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程</li>
<li>阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</li>
</ul>
<blockquote>
<p>艿艿：如下的内容，和上面是相对重复的，或者是换一个说法，重新描述。</p>
</blockquote>
<p>BlockingQueue 接口，是 Queue 的子接口，它的主要用途并不是作为容器，而是作为线程同步的的工具，因此他具有一个很明显的特性：</p>
<ul>
<li>当生产者线程试图向 BlockingQueue 放入元素时，如果队列已满，则线程被阻塞。</li>
<li>当消费者线程试图从中取出一个元素时，如果队列为空，则该线程会被阻塞。</li>
<li>正是因为它所具有这个特性，所以在程序中多个线程交替向BlockingQueue中 放入元素，取出元素，它可以很好的控制线程之间的通信。</li>
</ul>
<p>阻塞队列使用最经典的场景，就是 Socket 客户端数据的读取和解析：</p>
<ul>
<li>读取数据的线程不断将数据放入队列。</li>
<li>然后，解析线程不断从队列取数据解析。</li>
</ul>
<h2 id="Java-提供了哪些阻塞队列的实现？"><a href="#Java-提供了哪些阻塞队列的实现？" class="headerlink" title="Java 提供了哪些阻塞队列的实现？"></a>Java 提供了哪些阻塞队列的实现？</h2><p>JDK7 提供了 7 个阻塞队列。分别是：</p>
<blockquote>
<p>Java5 之前实现同步存取时，可以使用普通的一个集合，然后在使用线程的协作和线程同步可以实现生产者，消费者模式，主要的技术就是用好 wait、notify、notifyAll、<code>sychronized</code> 这些关键字。</p>
<p>而在 Java5 之后，可以使用阻塞队列来实现，此方式大大简少了代码量，使得多线程编程更加容易，安全方面也有保障。</p>
</blockquote>
<ul>
<li><p>【最常用】ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</p>
<blockquote>
<p>此队列按照先进先出（FIFO）的原则对元素进行排序，但是默认情况下不保证线程公平的访问队列，即如果队列满了，那么被阻塞在外面的线程对队列访问的顺序是不能保证线程公平（即先阻塞，先插入）的。</p>
</blockquote>
</li>
<li><p>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</p>
<blockquote>
<p>此队列按照先出先进的原则对元素进行排序</p>
</blockquote>
</li>
<li><p>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</p>
</li>
<li><p>DelayQueue：支持延时获取元素的无界阻塞队列，即可以指定多久才能从队列中获取当前元素。</p>
</li>
<li><p>SynchronousQueue：一个不存储元素的阻塞队列。</p>
<blockquote>
<p>每一个 put 必须等待一个 take 操作，否则不能继续添加元素。并且他支持公平访问队列。</p>
</blockquote>
</li>
<li><p>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</p>
<blockquote>
<p>相对于其他阻塞队列，多了 tryTransfer 和 transfer 方法。</p>
<ul>
<li>transfer 方法：如果当前有消费者正在等待接收元素（take 或者待时间限制的 poll 方法），transfer  可以把生产者传入的元素立刻传给消费者。如果没有消费者等待接收元素，则将元素放在队列的 tail 节点，并等到该元素被消费者消费了才返回。</li>
<li>tryTransfer 方法：用来试探生产者传入的元素能否直接传给消费者。如果没有消费者在等待，则返回 false 。和上述方法的区别是该方法无论消费者是否接收，方法立即返回。而 transfer 方法是必须等到消费者消费了才返回。</li>
</ul>
</blockquote>
</li>
<li><p>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p>
<blockquote>
<p>优势在于多线程入队时，减少一半的竞争。</p>
</blockquote>
</li>
</ul>
<p>具体的源码解析，可以看看如下文章：</p>
<ul>
<li><a href="http://www.iocoder.cn/JUC/sike/ArrayBlockingQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：ArrayBlockingQueue》</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/PriorityBlockingQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：PriorityBlockingQueue》</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/DelayQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：DelayQueue》</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/SynchronousQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：SynchronousQueue》</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/LinkedTransferQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：LinkedTransferQueue》</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/LinkedBlockingDeque?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：LinkedBlockingDeque》</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/BlockingQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：BlockingQueue 总结》</a></li>
</ul>
<p>🦅 <strong>阻塞队列提供哪些重要方法？</strong></p>
<table>
<thead>
<tr>
<th>方法处理方式</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody><tr>
<td>插入方法</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e, time, unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time, unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td>element()</td>
<td>peek()</td>
<td>不可用</td>
<td>不可用</td>
</tr>
</tbody></table>
<p>🦅 <strong>ArrayBlockingQueue 与 LinkedBlockingQueue 的区别？</strong></p>
<table>
<thead>
<tr>
<th>Queue</th>
<th>阻塞与否</th>
<th>是否有界</th>
<th>线程安全保障</th>
<th>适用场景</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayBlockingQueue</td>
<td>阻塞</td>
<td>有界</td>
<td>一把全局锁</td>
<td>生产消费模型，平衡两边处理速度</td>
<td>用于存储队列元素的存储空间是预先分配的，使用过程中内存开销较小（无须动态申请存储空间）</td>
</tr>
<tr>
<td>LinkedBlockingQueue</td>
<td>阻塞</td>
<td>可配置</td>
<td>存取采用 2 把锁</td>
<td>生产消费模型，平衡两边处理速度</td>
<td>无界的时候注意内存溢出问题，用于存储队列元素的存储空间是在其使用过程中动态分配的，因此它可能会增加 JVM 垃圾回收的负担。</td>
</tr>
</tbody></table>
<p>感兴趣的胖友，可以看看如下两篇文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/5b85c1794351">《ArrayBlockingQueue 与 LinkedBlockingQueue》</a></li>
<li><a href="http://hellojava.info/?p=464">《从一个故障说说 Java 的三个 BlockingQueue》</a></li>
</ul>
<h2 id="什么是双端队列？"><a href="#什么是双端队列？" class="headerlink" title="什么是双端队列？"></a>什么是双端队列？</h2><p>在上面，我们看到的 LinkedBlockingQueue、ArrayBlockingQueue、PriorityBlockingQueue、SynchronousQueue 等，都是阻塞队列。</p>
<p>而 ArrayDeque、LinkedBlockingDeque 就是双端队列，类名以 Deque 结尾。</p>
<ul>
<li><p>正如阻塞队列适用于生产者消费者模式，双端队列同样适用与另一种模式，即</p>
<p>工作密取</p>
<p>。在生产者-消费者设计中，所有消费者共享一个工作队列，而在工作密取中，每个消费者都有各自的双端队列。</p>
<ul>
<li>如果一个消费者完成了自己双端队列中的全部工作，那么他就可以从其他消费者的双端队列末尾秘密的获取工作。具有更好的可伸缩性，这是因为工作者线程不会在单个共享的任务队列上发生竞争。</li>
<li>在大多数时候，他们都只是访问自己的双端队列，从而极大的减少了竞争。当工作者线程需要访问另一个队列时，它会从队列的尾部而不是头部获取工作，因此进一步降低了队列上的竞争。</li>
</ul>
</li>
<li><p>适用于：网页爬虫等任务中</p>
</li>
</ul>
<blockquote>
<p>😈 实际场景下，双端队列，我们使用比较少。艿艿根本没用过。</p>
</blockquote>
<h2 id="延迟队列的实现方式，DelayQueue-和时间轮算法的异同？"><a href="#延迟队列的实现方式，DelayQueue-和时间轮算法的异同？" class="headerlink" title="延迟队列的实现方式，DelayQueue 和时间轮算法的异同？"></a>延迟队列的实现方式，DelayQueue 和时间轮算法的异同？</h2><p>JDK 的 Timer 和 DelayQueue 插入和删除操作的平均时间复杂度为 <code>O(nlog(n))</code> ，而基于时间轮可以将插入和删除操作的时间复杂度都降为 <code>O(1)</code> 。</p>
<ul>
<li>关于 DelayQueue 的实现方式，在 <a href="http://www.iocoder.cn/JUC/sike/DelayQueue?vip">《【死磕 Java 并发】—– J.U.C 之阻塞队列：DelayQueue》》</a> 。</li>
<li>关于实践论的实现方法，在 <a href="https://blog.csdn.net/u013256816/article/details/80697456">《Kafka解惑之时间轮（TimingWheel）》</a> 。</li>
</ul>
<h2 id="简述-ConcurrentLinkedQueue-和-LinkedBlockingQueue-的用处和不同之处？"><a href="#简述-ConcurrentLinkedQueue-和-LinkedBlockingQueue-的用处和不同之处？" class="headerlink" title="简述 ConcurrentLinkedQueue 和 LinkedBlockingQueue 的用处和不同之处？"></a>简述 ConcurrentLinkedQueue 和 LinkedBlockingQueue 的用处和不同之处？</h2><p>参考 <a href="https://www.jianshu.com/p/1a49293294aa">《LinkedBlockingQueue 和 ConcurrentLinkedQueue的用法及区别》</a> 。</p>
<p>在 Java 多线程应用中，队列的使用率很高，多数生产消费模型的首选数据结构就是队列(先进先出)。</p>
<p>Java 提供的线程安全的 Queue 可以分为</p>
<ul>
<li><p>阻塞队列，典型例子是  LinkedBlockingQueue 。</p>
<blockquote>
<p>适用阻塞队列的好处：多线程操作共同的队列时不需要额外的同步，另外就是队列会自动平衡负载，即那边（生产与消费两边）处理快了就会被阻塞掉，从而减少两边的处理速度差距。</p>
</blockquote>
</li>
<li><p>非阻塞队列，典型例子是 ConcurrentLinkedQueue 。</p>
<blockquote>
<p>当许多线程共享访问一个公共集合时，<code>ConcurrentLinkedQueue</code> 是一个恰当的选择。</p>
</blockquote>
</li>
</ul>
<p>具体的选择，如下：</p>
<ul>
<li>LinkedBlockingQueue 多用于任务队列。<ul>
<li>单生产者，单消费者</li>
<li>多生产者，单消费者</li>
</ul>
</li>
<li>ConcurrentLinkedQueue 多用于消息队列。<ul>
<li>单生产者，多消费者</li>
<li>多生产者，多消费者</li>
</ul>
</li>
</ul>
<h1 id="Java-原子操作类"><a href="#Java-原子操作类" class="headerlink" title="Java 原子操作类"></a>Java 原子操作类</h1><h2 id="什么是原子操作？"><a href="#什么是原子操作？" class="headerlink" title="什么是原子操作？"></a>什么是原子操作？</h2><p>原子操作（Atomic Operation），意为”不可被中断的一个或一系列操作”。</p>
<ul>
<li>处理器使用基于对缓存加锁或总线加锁的方式，来实现多处理器之间的原子操作。</li>
<li>在 Java 中，可以通过锁和循环 CAS 的方式来实现原子操作。CAS操作 —— Compare &amp; Set ，或是 Compare &amp; Swap ，现在几乎所有的 CPU 指令都支持 CAS 的原子操作。</li>
</ul>
<p>原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。</p>
<ul>
<li><code>int++</code> 并不是一个原子操作，所以当一个线程读取它的值并加 1 时，另外一个线程有可能会读到之前的值，这就会引发错误。</li>
<li>为了解决这个问题，必须保证增加操作是原子的，在 JDK5 之前我们可以使用同步技术来做到这一点。到 JDK5 后，<code>java.util.concurrent.atomic</code> 包提供了 <code>int</code> 和 <code>long</code> 类型的原子包装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。</li>
</ul>
<p><code>java.util.concurrent</code>  这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。</p>
<ul>
<li>原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference 。</li>
<li>原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray 。</li>
<li>原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater 。</li>
<li>解决 ABA 问题的原子类：AtomicMarkableReference（通过引入一个<code>boolean</code> 来反映中间有没有变过），AtomicStampedReference（通过引入一个 <code>int</code> 来累加来反映中间有没有变过）。</li>
</ul>
<p>关于 CAS 的内容，建议胖友在看看 <a href="http://www.iocoder.cn/JUC/sike/CAS/">《【死磕 Java 并发】—- 深入分析 CAS》</a> 。</p>
<h2 id="CAS-操作有什么缺点？"><a href="#CAS-操作有什么缺点？" class="headerlink" title="CAS 操作有什么缺点？"></a>CAS 操作有什么缺点？</h2><p>1）<strong>ABA 问题</strong></p>
<p>比如说一个线程 one 从内存位置 V 中取出 A ，这时候另一个线程 two 也从内存中取出 A ，并且 two 进行了一些操作变成了 B ，然后 two 又将 V 位置的数据变成 A ，这时候线程 one 进行 CAS 操作发现内存中仍然是 A ，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。</p>
<p>从 Java5 开始 JDK 的 <code>atomic</code>包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。</p>
<p>2）<strong>循环时间长开销大</strong></p>
<p>对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 <code>synchronized</code> 。</p>
<p>3）<strong>只能保证一个共享变量的原子操作</strong></p>
<p>当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。</p>
<h1 id="Java-并发工具类"><a href="#Java-并发工具类" class="headerlink" title="Java 并发工具类"></a>Java 并发工具类</h1><h2 id="Semaphore-是什么？"><a href="#Semaphore-是什么？" class="headerlink" title="Semaphore 是什么？"></a>Semaphore 是什么？</h2><p>Semaphore ，是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。</p>
<ul>
<li>如有必要，在许可可用前会阻塞每一个 <code>#acquire()</code> 方法，然后再获取该许可。</li>
<li>每个 <code>#release()</code> 方法，添加一个许可，从而可能释放一个正在阻塞的获取者。</li>
<li>但是，不使用实际的许可对象，Semaphore 只对可用许可的数量进行计数，并采取相应的行动。</li>
</ul>
<p>信号量常常用于多线程的代码中，比如数据库连接池。</p>
<ul>
<li>使用方式，可以看看 <a href="https://my.oschina.net/cloudcoder/blog/362974">《JAVA多线程 – 信号量(Semaphore)》</a> 。</li>
<li>源码解析，可以看看 <a href="http://www.iocoder.cn/JUC/sike/Semaphore/">《【死磕 Java 并发】—– J.U.C 之并发工具类：Semaphore》</a> 。</li>
</ul>
<h2 id="说说-CountDownLatch-原理"><a href="#说说-CountDownLatch-原理" class="headerlink" title="说说 CountDownLatch 原理"></a>说说 CountDownLatch 原理</h2><p>CountDownLatch ，字面意思是减小计数（CountDown）的门闩（Latch）。它要做的事情是，等待指定数量的计数被减少，意味着门闩被打开，然后进行执行。</p>
<p>CountDownLatch 默认的构造方法是 <code>CountDownLatch(int count)</code> ，其参数表示需要减少的计数，主线程调用 <code>#await()</code> 方法告诉 CountDownLatch 阻塞等待指定数量的计数被减少，然后其它线程调用 CountDownLatch 的 <code>#countDown()</code> 方法，减小计数(不会阻塞)。等待计数被减少到零，主线程结束阻塞等待，继续往下执行。</p>
<ul>
<li>CountDownLatch 的使用示例，请看 <a href="https://zk1878.iteye.com/blog/1002652">《Java 多线程  CountDownLatch 用法》</a> 。</li>
<li>CountDownLatch 的源码解析，请看 <a href="http://www.iocoder.cn/JUC/sike/CountDownLatch/?vip">《【死磕 Java 并发】—– J.U.C 之并发工具类：CountDownLatch》</a></li>
</ul>
<h2 id="说说-CyclicBarrier-原理"><a href="#说说-CyclicBarrier-原理" class="headerlink" title="说说 CyclicBarrier 原理"></a>说说 CyclicBarrier 原理</h2><p>CyclicBarrier ，字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</p>
<p>CyclicBarrier 默认的构造方法是 <code>CyclicBarrier(int parties)</code> ，其参数表示屏障拦截的线程数量，每个线程调用 <code>#await()</code> 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞，直到 <code>parties</code> 个线程到达，结束阻塞。</p>
<ul>
<li>CyclicBarrier 的使用示例，请看 <a href="https://www.cnblogs.com/liuling/p/2013-8-21-01.html">《CyclicBarrier 的用法》</a></li>
<li>CyclicBarrier 的源码解析，请看 <a href="http://www.iocoder.cn/JUC/sike/CyclicBarrier/?vip">《【死磕 Java 并发】—- J.U.C 之并发工具类：CyclicBarrier》</a> 。</li>
</ul>
<h2 id="说说-Exchanger-原理"><a href="#说说-Exchanger-原理" class="headerlink" title="说说 Exchanger 原理"></a>说说 Exchanger 原理</h2><p>实际场景下，问了一圈朋友，Exchanger 基本没在业务中使用过。</p>
<ul>
<li>Exchanger 的使用示例，请看 <a href="https://blog.csdn.net/eson_15/article/details/51581842">《【Java并发】线程同步工具Exchanger的使用》</a> 。</li>
<li>Exchanger 的源码解析，请看 <a href="http://www.iocoder.cn/JUC/sike/Exchanger/">《【死磕 Java 并发】—– J.U.C 之并发工具类：Exchanger》</a></li>
</ul>
<h2 id="CyclicBarrier-和-CountdownLatch-有什么区别？"><a href="#CyclicBarrier-和-CountdownLatch-有什么区别？" class="headerlink" title="CyclicBarrier 和 CountdownLatch 有什么区别？"></a>CyclicBarrier 和 CountdownLatch 有什么区别？</h2><p>CyclicBarrier 可以重复使用，而 CountdownLatch 不能重复使用。</p>
<ul>
<li>CountDownLatch 其实可以把它看作一个计数器，只不过这个计数器的操作是原子操作。<ul>
<li>你可以向 CountDownLatch 对象设置一个初始的数字作为计数值，任何调用这个对象上的 <code>#await()</code> 方法都会阻塞，直到这个计数器的计数值被其他的线程减为 0 为止。所以在当前计数到达零之前，await  方法会一直受阻塞。之后，会释放所有等待的线程，await  的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。如果需要重置计数，请考虑使用 CyclicBarrier 。</li>
<li>CountDownLatch 的一个非常典型的应用场景是：有一个任务想要往下执行，但必须要等到其他的任务执行完毕后才可以继续往下执行。假如我们这个想要继续往下执行的任务调用一个 CountDownLatch 对象的 <code>#await()</code> 方法，其他的任务执行完自己的任务后调用同一个 CountDownLatch 对象上的 <code>#countDown()</code> 方法，这个调用 <code>#await()</code> 方法的任务将一直阻塞等待，直到这个 CountDownLatch 对象的计数值减到 0 为止。</li>
</ul>
</li>
<li>CyclicBarrier 一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier  point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier  在释放等待线程后可以重用，所以称它为循环的 barrier 。</li>
</ul>
<p>整理表格如下：</p>
<table>
<thead>
<tr>
<th>CountDownLatch</th>
<th>CyclicBarrier</th>
</tr>
</thead>
<tbody><tr>
<td>减计数方式</td>
<td>加计数方式</td>
</tr>
<tr>
<td>计算为 0 时释放所有等待的线程</td>
<td>计数达到指定值时释放所有等待线程</td>
</tr>
<tr>
<td>计数为 0 时，无法重置</td>
<td>计数达到指定值时，计数置为 0 重新开始</td>
</tr>
<tr>
<td>调用 <code>#countDown()</code> 方法计数减一，调用 <code>#await()</code> 方法只进行阻塞，对计数没任何影响</td>
<td>调用 <code>#await()</code> 方法计数加 1 ，若加 1 后的值不等于构造方法的值，则线程阻塞</td>
</tr>
<tr>
<td>不可重复利用</td>
<td>可重复利用</td>
</tr>
</tbody></table>
<h1 id="Java-线程池"><a href="#Java-线程池" class="headerlink" title="Java 线程池"></a>Java 线程池</h1><p><a href="http://static2.iocoder.cn/346a78f2c213423bcce456102006f4b3"><img src="http://cdn.tuwenbin.vip/20201005171342" alt="线程池"></a>线程池</p>
<h2 id="什么是-Executor-框架？"><a href="#什么是-Executor-框架？" class="headerlink" title="什么是 Executor 框架？"></a>什么是 Executor 框架？</h2><p>Executor 框架，是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。</p>
<p>无限制的创建线程，会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用 Executor 框架，可以非常方便的创建一个线程池。</p>
<p>🦅 <strong>为什么使用 Executor 框架？</strong></p>
<ol>
<li>每次执行任务创建线程 <code>new Thread()</code> 比较消耗性能，创建一个线程是比较耗时、耗资源的。</li>
<li>调用 <code>new Thread()</code> 创建的线程缺乏管理，被称为野线程，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。</li>
<li>接使用 <code>new Thread()</code> 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。</li>
</ol>
<p>🦅 <strong>在 Java 中 Executor 和 Executors 的区别？</strong></p>
<ul>
<li>Executors 是 Executor 的工具类，不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。</li>
<li>Executor 接口对象，能执行我们的线程任务。<ul>
<li>ExecutorService 接口，继承了 Executor 接口，并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。<ul>
<li>使用 ThreadPoolExecutor ，可以创建自定义线程池。</li>
</ul>
</li>
<li>Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用 <code>#get()</code> 方法，获取计算的结果。</li>
</ul>
</li>
</ul>
<h2 id="讲讲线程池的实现原理"><a href="#讲讲线程池的实现原理" class="headerlink" title="讲讲线程池的实现原理"></a>讲讲线程池的实现原理</h2><ul>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3932921.html">《Java并发编程：线程池的使用》</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/ThreadPool-core/?vip">《【死磕 Java 并发】—– J.U.C 之线程池：线程池的基础架构》</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/ThreadPoolExecutor/?vip">《【死磕 Java 并发】—– J.U.C 之线程池：ThreadPoolExecutor》</a></li>
<li><a href="http://www.iocoder.cn/JUC/sike/ScheduledThreadPoolExecutor/?vip">《【死磕 Java 并发】—– J.U.C 之线程池：ScheduledThreadPoolExecutor》</a></li>
</ul>
<h2 id="创建线程池的几种方式？"><a href="#创建线程池的几种方式？" class="headerlink" title="创建线程池的几种方式？"></a>创建线程池的几种方式？</h2><p>Java 类库提供一个灵活的线程池以及一些有用的默认配置，我们可以通过Executors 的静态方法来创建线程池。</p>
<blockquote>
<p>Executors 创建的线程池，分成普通任务线程池，和定时任务线程池。</p>
</blockquote>
<ul>
<li><p>普通任务线程池</p>
<ul>
<li><p>1、</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#newFixedThreadPool(int nThreads)<br></code></pre></td></tr></table></figure>

<p> 方法，创建一个固定长度的线程池。</p>
<ul>
<li>每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化。</li>
<li>当线程发生未预期的错误而结束时，线程池会补充一个新的线程。</li>
</ul>
</li>
<li><p>2、</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#newCachedThreadPool()<br></code></pre></td></tr></table></figure>

<p> 方法，创建一个可缓存的线程池。</p>
<ul>
<li>如果线程池的规模超过了处理需求，将自动回收空闲线程。</li>
<li>当需求增加时，则可以自动添加新线程。线程池的规模不存在任何限制。</li>
</ul>
</li>
<li><p>3、</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">#newSingleThreadExecutor()<br></code></pre></td></tr></table></figure>

<p> 方法，创建一个单线程的线程池。</p>
<ul>
<li>它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它。</li>
<li>它的特点是，能确保依照任务在队列中的顺序来串行执行。</li>
</ul>
</li>
</ul>
</li>
<li><p>定时任务线程池</p>
<ul>
<li>4、<code>#newScheduledThreadPool(int corePoolSize)</code> 方法，创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似 Timer 。</li>
<li>5、<code>#newSingleThreadExecutor()</code> 方法，创建了一个固定长度为 1 的线程池，而且以延迟或定时的方式来执行任务，类似 Timer 。</li>
</ul>
</li>
</ul>
<p>🦅  <strong>如何使用 ThreadPoolExecutor 创建线程池？</strong></p>
<p>Executors 提供了创建线程池的常用模板，实际场景下，我们可能需要自动以更灵活的线程池，此时就需要使用 ThreadPoolExecutor 类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; ThreadPoolExecutor.java<br><br>public ThreadPoolExecutor(int corePoolSize,<br>                          int maximumPoolSize,<br>                          long keepAliveTime,<br>                          TimeUnit unit,<br>                          BlockingQueue&lt;Runnable&gt; workQueue,<br>                          ThreadFactory threadFactory,<br>                          RejectedExecutionHandler handler) &#123;<br>    if (corePoolSize &lt; 0 ||<br>        maximumPoolSize &lt;&#x3D; 0 ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; 0)<br>        throw new IllegalArgumentException();<br>    if (workQueue &#x3D;&#x3D; null || threadFactory &#x3D;&#x3D; null || handler &#x3D;&#x3D; null)<br>        throw new NullPointerException();<br>    this.corePoolSize &#x3D; corePoolSize;<br>    this.maximumPoolSize &#x3D; maximumPoolSize;<br>    this.workQueue &#x3D; workQueue;<br>    this.keepAliveTime &#x3D; unit.toNanos(keepAliveTime);<br>    this.threadFactory &#x3D; threadFactory;<br>    this.handler &#x3D; handler;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>corePoolSize</code> 参数，核心线程数大小，当线程数 &lt; corePoolSize ，会创建线程执行任务。</p>
</li>
<li><pre><code>maximumPoolSize
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>参数，最大线程数， 当线程数 &gt;&#x3D; corePoolSize 的时候，会把任务放入 <br><br></code></pre></td></tr></table></figure>
workQueue
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>   队列中。<br><br>  - &#96;keepAliveTime&#96; 参数，保持存活时间，当线程数大于 &#96;corePoolSize&#96; 的空闲线程能保持的最大时间。<br>  - &#96;unit&#96; 参数，时间单位。<br><br>- &#96;&#96;&#96;<br>  workQueue<br></code></pre></td></tr></table></figure>

 参数，保存任务的阻塞队列。

- `handler` 参数，超过阻塞队列的大小时，使用的拒绝策略。</code></pre>
</li>
<li><p><code>threadFactory</code> 参数，创建线程的工厂。</p>
</li>
</ul>
<p>🦅 <strong>ThreadPoolExecutor 有哪些拒绝策略？</strong></p>
<p>ThreadPoolExecutor 默认有四个拒绝策略：</p>
<ul>
<li><code>ThreadPoolExecutor.AbortPolicy()</code> ，直接抛出异常 RejectedExecutionException 。</li>
<li><code>ThreadPoolExecutor.CallerRunsPolicy()</code> ，直接调用 run 方法并且阻塞执行。</li>
<li><code>ThreadPoolExecutor.DiscardPolicy()</code> ，直接丢弃后来的任务。</li>
<li><code>ThreadPoolExecutor.DiscardOldestPolicy()</code> ，丢弃在队列中队首的任务。</li>
</ul>
<p>如果我们有需要，可以自己实现 RejectedExecutionHandler 接口，实现自定义的拒绝逻辑。当然，绝大多数是不需要的。</p>
<p>🦅 ****</p>
<h2 id="线程池的关闭方式有几种？"><a href="#线程池的关闭方式有几种？" class="headerlink" title="线程池的关闭方式有几种？"></a>线程池的关闭方式有几种？</h2><p>ThreadPoolExecutor 提供了两个方法，用于线程池的关闭，分别是：</p>
<ul>
<li><code>#shutdown()</code> 方法，不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务。</li>
<li><code>#shutdownNow()</code> 方法，立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务。</li>
</ul>
<p>实际场景下，一般会结合这两个方法，一起实现线程池的优雅关闭。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">void shutdownAndAwaitTermination(ExecutorService pool) &#123;<br>  pool.shutdown(); &#x2F;&#x2F; Disable new tasks from being submitted<br>  try &#123;<br>    &#x2F;&#x2F; Wait a while for existing tasks to terminate<br>    if (!pool.awaitTermination(60, TimeUnit.SECONDS)) &#123;<br>      pool.shutdownNow(); &#x2F;&#x2F; Cancel currently executing tasks<br>      &#x2F;&#x2F; Wait a while for tasks to respond to being cancelled<br>      if (!pool.awaitTermination(60, TimeUnit.SECONDS))<br>          System.err.println(&quot;Pool did not terminate&quot;);<br>      &#125;<br>    &#125;<br>  &#125; catch (InterruptedException ie) &#123;<br>    &#x2F;&#x2F; (Re-)Cancel if current thread also interrupted<br>    pool.shutdownNow();<br>    &#x2F;&#x2F; Preserve interrupt status<br>    Thread.currentThread().interrupt();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Java-线程池大小为何会大多被设置成-CPU-核心数-1-？"><a href="#Java-线程池大小为何会大多被设置成-CPU-核心数-1-？" class="headerlink" title="Java 线程池大小为何会大多被设置成 CPU 核心数 +1 ？"></a>Java 线程池大小为何会大多被设置成 CPU 核心数 +1 ？</h2><p>详细的可以看看 <a href="http://ifeve.com/how-to-calculate-threadpool-size/">《如何合理地估算线程池大小？》</a> 。如下是简单的总结和整理：</p>
<p>一般说来，大家认为线程池的大小经验值应该这样设置：（其中 N 为CPU的个数）</p>
<ul>
<li><p>如果是 CPU 密集型应用，则线程池大小设置为 N+1</p>
<blockquote>
<p>因为 CPU 密集型任务使得 CPU 使用率很高，若开过多的线程数，只能增加上下文切换的次数，因此会带来额外的开销。</p>
</blockquote>
</li>
<li><p>如果是 IO 密集型应用，则线程池大小设置为 2N+1</p>
<blockquote>
<p>IO密 集型任务 CPU 使用率并不高，因此可以让 CPU 在等待 IO 的时候去处理别的任务，充分利用 CPU 时间。</p>
</blockquote>
</li>
<li><p>如果是混合型应用，那么分别创建线程池</p>
<blockquote>
<p>可以将任务分成 IO 密集型和 CPU 密集型任务，然后分别用不同的线程池去处理。 只要分完之后两个任务的执行时间相差不大，那么就会比串行执行来的高效。</p>
<p>因为如果划分之后两个任务执行时间相差甚远，那么先执行完的任务就要等后执行完的任务，最终的时间仍然取决于后执行完的任务，而且还要加上任务拆分与合并的开销，得不偿失。</p>
</blockquote>
</li>
</ul>
<p>如果一台服务器上只部署这一个应用并且只有这一个线程池，那么这种估算或许合理，具体还需自行测试验证。</p>
<p>但是，IO 优化中，这样的估算公式可能更适合：最佳线程数目 = （（线程等待时间 + 线程 CPU 时间）/ 线程 CPU 时间 ）* CPU 数目<br><strong>因为很显然，线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。</strong></p>
<p>下面举个例子：比如平均每个线程 CPU 运行时间为 0.5s ，而线程等待时间（非 CPU 运行时间，比如 IO）为 1.5s ，CPU 核心数为 8 。<br>那么根据上面这个公式估算得到：<code>((0.5 + 1.5) / 0.5) * 8 = 32</code>。这个公式进一步转化为：最佳线程数目 = （线程等待时间与线程 CPU 时间之比 + 1）* CPU数目。</p>
<p>🦅 <strong>线程池容量的动态调整？</strong></p>
<p>ThreadPoolExecutor 提供了动态调整线程池容量大小的方法：</p>
<ul>
<li>setCorePoolSize：设置核心池大小。</li>
<li>setMaximumPoolSize：设置线程池最大能创建的线程数目大小。</li>
</ul>
<p>当上述参数从小变大时，ThreadPoolExecutor 进行线程赋值，还可能立即创建新的线程来执行任务。</p>
<h2 id="什么是-Callable、Future、FutureTask-？"><a href="#什么是-Callable、Future、FutureTask-？" class="headerlink" title="什么是 Callable、Future、FutureTask ？"></a>什么是 Callable、Future、FutureTask ？</h2><p>1）<strong>Callable</strong></p>
<p>Callable 接口，类似于 Runnable ，从名字就可以看出来了，但是Runnable  不会返回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future  拿到，也就是说，Future 可以拿到异步执行任务的返回值。</p>
<blockquote>
<p>简单来说，可以认为是带有回调的 Runnable 。</p>
</blockquote>
<p>2）<strong>Future</strong></p>
<p>Future 接口，表示异步任务，是还没有完成的任务给出的未来结果。所以说 Callable 用于产生结果，Future 用于获取结果。</p>
<p>3）<strong>FutureTask</strong></p>
<p>在 Java 并发程序中，FutureTask 表示一个可以取消的异步运算。</p>
<ul>
<li>它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成 get 方法将会阻塞。</li>
<li>一个 FutureTask 对象，可以对调用了 Callable 和 Runnable 的对象进行包装，由于 FutureTask 也是继承了 Runnable 接口，所以它可以提交给 Executor 来执行。</li>
</ul>
<h2 id="线程池执行任务的过程？"><a href="#线程池执行任务的过程？" class="headerlink" title="线程池执行任务的过程？"></a>线程池执行任务的过程？</h2><p>刚创建时，里面没有线程调用 execute() 方法，添加任务时：</p>
<ol>
<li><p>如果正在运行的线程数量小于核心参数 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">corePoolSize<br></code></pre></td></tr></table></figure>

<p> ，继续创建线程运行这个任务</p>
<ul>
<li>否则，如果正在运行的线程数量大于或等于 <code>corePoolSize</code> ，将任务加入到阻塞队列中。</li>
<li>否则，如果队列已满，同时正在运行的线程数量小于核心参数 <code>maximumPoolSize</code> ，继续创建线程运行这个任务。</li>
<li>否则，如果队列已满，同时正在运行的线程数量大于或等于 <code>maximumPoolSize</code> ，根据设置的拒绝策略处理。</li>
</ul>
</li>
<li><p>完成一个任务，继续取下一个任务处理。</p>
<ul>
<li>没有任务继续处理，线程被中断或者线程池被关闭时，线程退出执行，如果线程池被关闭，线程结束。</li>
<li>否则，判断线程池正在运行的线程数量是否大于核心线程数，如果是，线程结束，否则线程阻塞。因此线程池任务全部执行完成后，继续留存的线程池大小为 <code>corePoolSize</code> 。</li>
</ul>
</li>
</ol>
<p>🦅 <strong>线程池中 submit 和 execute 方法有什么区别？</strong></p>
<p>两个方法都可以向线程池提交任务。</p>
<ul>
<li><code>#execute(...)</code> 方法，返回类型是 <code>void</code> ，它定义在 Executor 接口中。</li>
<li><code>#submit(...)</code> 方法，可以返回持有计算结果的 Future 对象，它定义在  ExecutorService 接口中，它扩展了 Executor 接口，其它线程池类像 ThreadPoolExecutor 和  ScheduledThreadPoolExecutor 都有这些方法。</li>
</ul>
<p>🦅 <strong>如果你提交任务时，线程池队列已满，这时会发生什么？</strong></p>
<blockquote>
<p>艿艿：重点在于线程池的队列是有界还是无界的。</p>
</blockquote>
<ul>
<li>如果你使用的 LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务。</li>
<li>如果你使用的是有界队列比方说 ArrayBlockingQueue 的话，任务首先会被添加到 ArrayBlockingQueue  中，ArrayBlockingQueue满了，则会使用拒绝策略 RejectedExecutionHandler 处理满了的任务，默认是  AbortPolicy 。</li>
</ul>
<h2 id="Fork-Join-框架是什么？"><a href="#Fork-Join-框架是什么？" class="headerlink" title="Fork/Join 框架是什么？"></a>Fork/Join 框架是什么？</h2><blockquote>
<p>艿艿：这是，可能了解的人不多，我也是。大体知道就好。</p>
</blockquote>
<p>Oracle 的官方给出的定义是：Fork/Join 框架是一个实现了 ExecutorService接口 的多线程处理器。它可以把一个大的任务划分为若干个小的任务并发执行，充分利用可用的资源，进而提高应用的执行效率。</p>
<p>我们再通过 Fork 和 Join 这两个单词来理解下 Fork/Join 框架。</p>
<ul>
<li>Fork 就是把一个大任务切分为若干子任务并行的执行，Join 就是合并这些子任务的执行结果，最后得到这个大任务的结果。</li>
<li>比如计算 <code>1+2+...＋10000</code> ，可以分割成 10 个子任务，每个子任务分别对 1000 个数进行求和，最终汇总这 10 个子任务的结果。</li>
</ul>
<p>感兴趣的胖友，可以看看如下文章：</p>
<ul>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-forkjoin/index.html">《JDK 7 中的 Fork/Join 模式》</a></li>
<li><a href="https://www.infoq.cn/article/fork-join-introduction">《聊聊并发（八） —— Fork/Join 框架介绍》</a></li>
</ul>
<h2 id="如何让一段程序并发的执行，并最终汇总结果？"><a href="#如何让一段程序并发的执行，并最终汇总结果？" class="headerlink" title="如何让一段程序并发的执行，并最终汇总结果？"></a>如何让一段程序并发的执行，并最终汇总结果？</h2><ul>
<li><p>1、CountDownLatch：允许一个或者多个线程等待前面的一个或多个线程完成，构造一个 CountDownLatch 时指定需要  countDown 的点的数量，每完成一点就 countDown 一下。当所有点都完成，CountDownLatch 的 <code>#await()</code> 就解除阻塞。</p>
</li>
<li><p>2、CyclicBarrier：可循环使用的 Barrier ，它的作用是让一组线程到达一个 Barrier 后阻塞，直到所有线程都到达 Barrier 后才能继续执行。</p>
<blockquote>
<p>CountDownLatch 的计数值只能使用一次，CyclicBarrier 可以通过使用 reset 重置，还可以指定到达栅栏后优先执行的任务。</p>
</blockquote>
</li>
<li><p>3、Fork/Join 框架，fork 把大任务分解成多个小任务，然后汇总多个小任务的结果得到最终结果。使用一个双端队列，当线程空闲时从双端队列的另一端领取任务。</p>
</li>
</ul>
<h1 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h1><p>真多，真多，好他喵的多！耐心看。</p>
<p>哈哈哈，实际面试吧，也不会问这么多。嘻嘻~</p>
<p>参考与推荐如下文章：</p>
<ul>
<li><a href="https://coolshell.cn/articles/8239.html">《无锁队列的实现》</a></li>
<li><a href="https://blog.csdn.net/qq_34039315/article/details/7854931">《Java并发编程 73 道面试题及答案》</a></li>
<li><a href="https://blog.csdn.net/linzhiqiang0316/article/details/80473906">《史上最全 Java 面试题（带全部答案）》</a></li>
<li><a href="http://www.importnew.com/17232.html">《最近 5 年 133 个 Java 面试问题列表》</a></li>
<li><a href="https://github.com/Snailclimb/JavaGuide/blob/3dc5234d3a77d134e4768b17cc864c4cc1030e41/Java%E7%9B%B8%E5%85%B3/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md">《Java 基础知识》</a></li>
<li><a href="https://blog.csdn.net/column/details/20860.html">《Java并发编程指南》</a></li>
<li><a href="https://www.zhihu.com/question/38128980">《Java 线程池大小为何会大多被设置成 CPU 核心数 +1？》</a></li>
<li><a href="http://www.importnew.com/12773.html">《Java线程面试题 Top 50》</a></li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>并发</tag>
      </tags>
  </entry>
</search>
