<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>11</title>
    <url>/2016/10/12/11/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>10</title>
    <url>/2016/10/12/10/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>12</title>
    <url>/2016/10/12/12/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>13</title>
    <url>/2016/10/12/13/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>14</title>
    <url>/2016/10/12/14/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>15</title>
    <url>/2016/10/12/15/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>16</title>
    <url>/2016/10/12/16/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>17</title>
    <url>/2016/10/12/17/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>18</title>
    <url>/2016/10/12/18/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>20</title>
    <url>/2016/10/12/20/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>19</title>
    <url>/2016/10/12/19/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>21</title>
    <url>/2016/10/12/21/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>23</title>
    <url>/2016/10/12/23/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>24</title>
    <url>/2016/10/12/24/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>22</title>
    <url>/2016/10/12/22/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>25</title>
    <url>/2016/10/12/25/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>26</title>
    <url>/2016/10/12/26/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>27</title>
    <url>/2016/10/12/27/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>29</title>
    <url>/2016/10/12/29/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>28</title>
    <url>/2016/10/12/28/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>30</title>
    <url>/2016/10/12/30/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>32</title>
    <url>/2016/10/12/32/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>31</title>
    <url>/2016/10/12/31/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>33</title>
    <url>/2016/10/12/33/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>34</title>
    <url>/2016/10/12/34/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>35</title>
    <url>/2016/10/12/35/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>36</title>
    <url>/2016/10/12/36/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>37</title>
    <url>/2016/10/12/37/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>38</title>
    <url>/2016/10/12/38/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>39</title>
    <url>/2016/10/12/39/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>40</title>
    <url>/2016/10/12/40/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/41/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/43/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/42/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/44/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/45/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/46/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/48/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/47/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/49/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>50</title>
    <url>/2016/10/12/50/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>51</title>
    <url>/2016/10/12/51/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>52</title>
    <url>/2016/10/12/52/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>53</title>
    <url>/2016/10/12/53/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>54</title>
    <url>/2016/10/12/54/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>55</title>
    <url>/2016/10/12/55/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>56</title>
    <url>/2016/10/12/56/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>57</title>
    <url>/2016/10/12/57/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>58</title>
    <url>/2016/10/12/58/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>59</title>
    <url>/2016/10/12/59/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>60</title>
    <url>/2016/10/12/60/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>9</title>
    <url>/2016/10/12/9/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>精尽 Spring MVC 面试题</title>
    <url>/2018/10/12/%E7%B2%BE%E5%B0%BD%20Spring%20MVC%20%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="精尽-Spring-MVC-面试题"><a href="#精尽-Spring-MVC-面试题" class="headerlink" title="精尽 Spring MVC 面试题"></a>精尽 Spring MVC 面试题</h1><p>以下面试题，基于网络整理，和自己编辑。具体参考的文章，会在文末给出所有的链接。</p>
<p>如果胖友有自己的疑问，欢迎在星球提问，我们一起整理吊吊的 Spring MVC 面试题的大保健。</p>
<p>而题目的难度，艿艿尽量按照从容易到困难的顺序，逐步下去。</p>
<p>当然，艿艿还是非常推荐胖友去撸一撸 Spring MVC 的源码，特别是如下两篇：</p>
<ul>
<li><a href="http://svip.iocoder.cn/Spring-MVC/Components-intro/">《精尽 Spring MVC 源码分析 —— 组件一览》</a></li>
<li><a href="http://svip.iocoder.cn/Spring-MVC/DispatcherServlet-process-request-intro/">《精尽 Spring MVC 源码分析 —— 请求处理一览》</a></li>
</ul>
<p>考虑到 Spring MVC 和 Rest 关系比较大，所以本文一共分成两大块：</p>
<ul>
<li>Spring MVC</li>
<li>REST</li>
</ul>
<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="Spring-MVC-框架有什么用？"><a href="#Spring-MVC-框架有什么用？" class="headerlink" title="Spring MVC 框架有什么用？"></a>Spring MVC 框架有什么用？</h2><p>Spring Web MVC 框架提供”模型-视图-控制器”( Model-View-Controller )架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。</p>
<p>MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。</p>
<h2 id="介绍下-Spring-MVC-的核心组件？"><a href="#介绍下-Spring-MVC-的核心组件？" class="headerlink" title="介绍下 Spring MVC 的核心组件？"></a>介绍下 Spring MVC 的核心组件？</h2><p>Spring MVC 一共有九大核心组件，分别是：</p>
<ul>
<li>MultipartResolver</li>
<li>LocaleResolver</li>
<li>ThemeResolver</li>
<li>HandlerMapping</li>
<li>HandlerAdapter</li>
<li>HandlerExceptionResolver</li>
<li>RequestToViewNameTranslator</li>
<li>ViewResolver</li>
<li>FlashMapManager</li>
</ul>
<p>虽然很多，但是在前后端分离的架构中，在 <a href="http://svip.iocoder.cn/Spring-MVC/Interview/#">「描述一下 DispatcherServlet 的工作流程？」</a> 问题中，我们会明白，最关键的只有 HandlerMapping + HandlerAdapter + HandlerExceptionResolver 。</p>
<p>关于每个组件的说明，直接看 <a href="http://svip.iocoder.cn/Spring-MVC/Components-intro/">《精尽 Spring MVC 源码分析 —— 组件一览》</a> 。</p>
<h2 id="描述一下-DispatcherServlet-的工作流程？"><a href="#描述一下-DispatcherServlet-的工作流程？" class="headerlink" title="描述一下 DispatcherServlet 的工作流程？"></a>描述一下 DispatcherServlet 的工作流程？</h2><p>DispatcherServlet 的工作流程可以用一幅图来说明：</p>
<p><a href="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15300766829012.jpg"><img src="http://cdn.tuwenbin.vip/15300766829012.jpg" alt="DispatcherServlet 的工作流程"></a>DispatcherServlet 的工作流程</p>
<p>① <strong>发送请求</strong></p>
<p>用户向服务器发送 HTTP 请求，请求被 Spring MVC 的调度控制器  DispatcherServlet 捕获。</p>
<p>② <strong>映射处理器</strong></p>
<p>DispatcherServlet 根据请求 URL ，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 <strong>Handler</strong> 对象以及 Handler 对象对应的<strong>拦截器</strong>），最后以 HandlerExecutionChain 对象的形式返回。</p>
<ul>
<li>即 HandlerExecutionChain 中，包含对应的 <strong>Handler</strong> 对象和<strong>拦截器</strong>们。</li>
</ul>
<blockquote>
<p>此处，对应的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; &#x2F;&#x2F; HandlerMapping.java<br>&gt; <br>&gt; @Nullable<br>&gt; HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;<br>&gt;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>③ <strong>处理器适配</strong></p>
<p>DispatcherServlet 根据获得的 Handler，选择一个合适的HandlerAdapter 。（附注：如果成功获得 HandlerAdapter 后，此时将开始执行拦截器的 <code>#preHandler(...)</code> 方法）。</p>
<p>提取请求 Request 中的模型数据，填充 Handler 入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：</p>
<ul>
<li>HttpMessageConverter ：会将请求消息（如 JSON、XML 等数据）转换成一个对象。</li>
<li>数据转换：对请求消息进行数据转换。如 String 转换成 Integer、Double 等。</li>
<li>数据格式化：对请求消息进行数据格式化。如将字符串转换成格式化数字或格式化日期等。</li>
<li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到 BindingResult 或 Error 中。</li>
</ul>
<p>Handler(Controller) 执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象。</p>
<blockquote>
<p>此处，对应的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; &#x2F;&#x2F; HandlerAdapter.java<br>&gt; <br>&gt; @Nullable<br>&gt; ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;<br>&gt;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>.</p>
<blockquote>
<p>图中没有 ④ 。</p>
</blockquote>
<p>⑤ <strong>解析视图</strong></p>
<p>根据返回的 ModelAndView ，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的 ViewResolver)，解析出 View 对象，然后返回给 DispatcherServlet。</p>
<blockquote>
<p>此处，对应的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; &#x2F;&#x2F; ViewResolver.java<br>&gt; <br>&gt; @Nullable<br>&gt; View resolveViewName(String viewName, Locale locale) throws Exception;<br>&gt;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>⑥ ⑦ <strong>渲染视图</strong> + <strong>响应请求</strong></p>
<p>ViewResolver 结合 Model 和 View，来渲染视图，并写回给用户( 浏览器 )。</p>
<blockquote>
<p>此处，对应的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; &#x2F;&#x2F; View.java<br>&gt; <br>&gt; void render(@Nullable Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception;<br>&gt;<br></code></pre></td></tr></table></figure>
</blockquote>
<hr>
<p>这样一看，胖友可能有点懵逼，所以还是推荐看看：</p>
<ul>
<li><a href="http://svip.iocoder.cn/Spring-MVC/Components-intro/">《精尽 Spring MVC 源码分析 —— 组件一览》</a></li>
<li><a href="http://svip.iocoder.cn/Spring-MVC/DispatcherServlet-process-request-intro/">《精尽 Spring MVC 源码分析 —— 请求处理一览》</a></li>
</ul>
<p><strong>但是 Spring MVC 的流程真的一定是酱紫么</strong>？</p>
<p>既然这么问，答案当然不是。对于目前主流的架构，前后端已经进行分离了，所以 Spring MVC 只负责 <strong>M</strong>odel 和 <strong>C</strong>ontroller 两块，而将 <strong>V</strong>iew 移交给了前端。所以，在上图中的步骤 ⑤ 和 ⑥ 两步，已经不在需要。</p>
<p>那么变成什么样了呢？在步骤 ③ 中，如果 Handler(Controller) 执行完后，如果判断方法有 <code>@ResponseBody</code> 注解，则直接将结果写回给用户( 浏览器 )。</p>
<p>但是 HTTP 是不支持返回 Java POJO 对象的，所以需要将结果使用 <a href="http://svip.iocoder.cn/Spring-MVC/HandlerAdapter-5-HttpMessageConverter/">HttpMessageConverter</a> 进行转换后，才能返回。例如说，大家所熟悉的 <a href="https://github.com/alibaba/fastjson/wiki/%E5%9C%A8-Spring-%E4%B8%AD%E9%9B%86%E6%88%90-Fastjson">FastJsonHttpMessageConverter</a> ，将 POJO 转换成 JSON 字符串返回。</p>
<p>😈 是不是略微有点复杂，还是那句话，撸下源码，捅破这个窗口。当然，如果胖友精力有限，只要看整体流程的几篇即可。 </p>
<hr>
<p>嘻嘻，再来补充两个图，这真的是 Spring MVC 非常关键的问题，所以要用心理解。</p>
<blockquote>
<p>FROM <a href="https://blog.csdn.net/J080624/article/details/77990164">《SpringMVC - 运行流程图及原理分析》</a></p>
<p><strong>流程示意图</strong>：</p>
<p><a href="http://static2.iocoder.cn/images/Spring/2022-02-21/01.png"><img src="http://cdn.tuwenbin.vip/01.png" alt="流程示意图"></a>流程示意图</p>
<p><strong>代码序列图</strong>：</p>
<p><a href="http://static2.iocoder.cn/images/Spring/2022-02-21/02.png"><img src="http://cdn.tuwenbin.vip/02.png" alt="代码序列图"></a>代码序列图</p>
<hr>
<p>FROM <a href="https://item.jd.com/11807414.html">《看透 Spring MVC：源代码分析与实践》</a> P123</p>
<p><strong>流程示意图</strong>：</p>
<p><a href="http://static2.iocoder.cn/images/Spring/2022-02-21/03.png"><img src="http://cdn.tuwenbin.vip/03.png" alt="《流程示意图》"></a>《流程示意图》</p>
</blockquote>
<h2 id="Controller-注解有什么用？"><a href="#Controller-注解有什么用？" class="headerlink" title="@Controller 注解有什么用？"></a>@Controller 注解有什么用？</h2><p><code>@Controller</code> 注解，它将一个类标记为 Spring Web MVC <strong>控制器</strong> Controller 。</p>
<h2 id="RestController-和-Controller-有什么区别？"><a href="#RestController-和-Controller-有什么区别？" class="headerlink" title="@RestController 和 @Controller 有什么区别？"></a>@RestController 和 @Controller 有什么区别？</h2><p><code>@RestController</code> 注解，在 <code>@Controller</code> 基础上，增加了 <code>@ResponseBody</code> 注解，更加适合目前前后端分离的架构下，提供 Restful API ，返回例如 JSON 数据格式。当然，返回什么样的数据格式，根据客户端的 <code>&quot;ACCEPT&quot;</code> 请求头来决定。</p>
<h2 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h2><p><code>@RequestMapping</code> 注解，用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：</p>
<ul>
<li>类级别：映射请求的 URL。</li>
<li>方法级别：映射 URL 以及 HTTP 请求方法。</li>
</ul>
<h2 id="RequestMapping-和-GetMapping-注解的不同之处在哪里？"><a href="#RequestMapping-和-GetMapping-注解的不同之处在哪里？" class="headerlink" title="@RequestMapping 和 @GetMapping 注解的不同之处在哪里？"></a>@RequestMapping 和 @GetMapping 注解的不同之处在哪里？</h2><ul>
<li><code>@RequestMapping</code> 可注解在类和方法上；<code>@GetMapping</code> 仅可注册在方法上。</li>
<li><code>@RequestMapping</code> 可进行 GET、POST、PUT、DELETE 等请求方法；<code>@GetMapping</code> 是 <code>@RequestMapping</code> 的 GET 请求方法的特例，目的是为了提高清晰度。</li>
</ul>
<h2 id="返回-JSON-格式使用什么注解？"><a href="#返回-JSON-格式使用什么注解？" class="headerlink" title="返回 JSON 格式使用什么注解？"></a>返回 JSON 格式使用什么注解？</h2><p>可以使用 <strong><code>@ResponseBody</code></strong> 注解，或者使用包含 <code>@ResponseBody</code> 注解的 <strong><code>@RestController</code></strong> 注解。</p>
<p>当然，还是需要配合相应的支持 JSON 格式化的 HttpMessageConverter 实现类。例如，Spring MVC 默认使用 MappingJackson2HttpMessageConverter 。</p>
<h2 id="介绍一下-WebApplicationContext-？"><a href="#介绍一下-WebApplicationContext-？" class="headerlink" title="介绍一下 WebApplicationContext ？"></a>介绍一下 WebApplicationContext ？</h2><p>WebApplicationContext 是实现ApplicationContext接口的子类，专门为 WEB 应用准备的。</p>
<ul>
<li>它允许从相对于 Web 根目录的路径中<strong>加载配置文件</strong>，<strong>完成初始化 Spring MVC 组件的工作</strong>。</li>
<li>从 WebApplicationContext 中，可以获取 ServletContext 引用，整个 Web 应用上下文对象将作为属性放置在 ServletContext 中，以便 Web 应用环境可以访问 Spring 上下文。</li>
</ul>
<p>关于这一块，如果想要详细了解，可以看看如下两篇文章：</p>
<ul>
<li><a href="http://svip.iocoder.cn/Spring-MVC/context-init-Root-WebApplicationContext/">《精尽 Spring MVC 源码分析 —— 容器的初始化（一）之 Root WebApplicationContext 容器》</a></li>
<li><a href="http://svip.iocoder.cn/Spring-MVC/context-init-Servlet-WebApplicationContext/">《精尽 Spring MVC 源码分析 —— 容器的初始化（二）之 Servlet WebApplicationContext 容器》</a></li>
</ul>
<h2 id="Spring-MVC-的异常处理？"><a href="#Spring-MVC-的异常处理？" class="headerlink" title="Spring MVC 的异常处理？"></a>Spring MVC 的异常处理？</h2><p>Spring MVC 提供了异常解析器 HandlerExceptionResolver 接口，将处理器( <code>handler</code> )执行时发生的异常，解析( 转换 )成对应的 ModelAndView 结果。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; HandlerExceptionResolver.java<br><br>public interface HandlerExceptionResolver &#123;<br><br>    &#x2F;**<br>     * 解析异常，转换成对应的 ModelAndView 结果<br>     *&#x2F;<br>    @Nullable<br>    ModelAndView resolveException(<br>            HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex);<br><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>也就是说，如果异常被解析成功，则会返回 ModelAndView 对象。</li>
<li>详细的源码解析，见 <a href="http://svip.iocoder.cn/Spring-MVC/HandlerExceptionResolver/">《精尽 Spring MVC 源码解析 —— HandlerExceptionResolver 组件》</a> 。</li>
</ul>
<p>一般情况下，我们使用 <code>@ExceptionHandler</code> 注解来实现过异常的处理，可以先看看 <a href="https://www.jianshu.com/p/12e1a752974d">《Spring 异常处理 ExceptionHandler 的使用》</a> 。</p>
<ul>
<li>一般情况下，艿艿喜欢使用<strong>第三种</strong>。</li>
</ul>
<h2 id="Spring-MVC-有什么优点？"><a href="#Spring-MVC-有什么优点？" class="headerlink" title="Spring MVC 有什么优点？"></a>Spring MVC 有什么优点？</h2><ol>
<li>使用真的真的真的非常<strong>方便</strong>，无论是添加 HTTP 请求方法映射的方法，还是不同数据格式的响应。</li>
<li>提供<strong>拦截器机制</strong>，可以方便的对请求进行拦截处理。</li>
<li>提供<strong>异常机制</strong>，可以方便的对异常做统一处理。</li>
<li>可以任意使用各种<strong>视图</strong>技术，而不仅仅局限于 JSP ，例如 Freemarker、Thymeleaf 等等。</li>
<li>不依赖于 Servlet API (目标虽是如此，但是在实现的时候确实是依赖于 Servlet 的，当然仅仅依赖 Servlet ，而不依赖 Filter、Listener )。</li>
</ol>
<h2 id="Spring-MVC-怎样设定重定向和转发-？"><a href="#Spring-MVC-怎样设定重定向和转发-？" class="headerlink" title="Spring MVC 怎样设定重定向和转发 ？"></a>Spring MVC 怎样设定重定向和转发 ？</h2><ul>
<li>结果转发：在返回值的前面加 <code>&quot;forward:/&quot;</code> 。</li>
<li>重定向：在返回值的前面加上 <code>&quot;redirect:/&quot;</code> 。</li>
</ul>
<p>当然，目前前后端分离之后，我们作为后端开发，已经很少有机会用上这个功能了。</p>
<h2 id="Spring-MVC-的-Controller-是不是单例？"><a href="#Spring-MVC-的-Controller-是不是单例？" class="headerlink" title="Spring MVC 的 Controller 是不是单例？"></a>Spring MVC 的 Controller 是不是单例？</h2><p>绝绝绝大多数情况下，Controller 是<strong>单例</strong>。</p>
<p>那么，Controller 里一般不建议存在<strong>共享的变量</strong>。实际场景下，艿艿也没碰到需要使用共享变量的情况。</p>
<h2 id="Spring-MVC-和-Struts2-的异同？"><a href="#Spring-MVC-和-Struts2-的异同？" class="headerlink" title="Spring MVC 和 Struts2 的异同？"></a>Spring MVC 和 Struts2 的异同？</h2><ol>
<li><p>入口</p>
<p>不同</p>
<ul>
<li>Spring MVC 的入门是一个 Servlet <strong>控制器</strong>。</li>
<li>Struts2 入门是一个 Filter <strong>过滤器</strong>。</li>
</ul>
</li>
<li><p>配置映射</p>
<p>不同，</p>
<ul>
<li>Spring MVC 是基于<strong>方法</strong>开发，传递参数是通过<strong>方法形参</strong>，一般设置为<strong>单例</strong>。</li>
<li>Struts2 是基于<strong>类</strong>开发，传递参数是通过<strong>类的属性</strong>，只能设计为<strong>多例</strong>。 </li>
</ul>
</li>
</ol>
<ul>
<li><p>视图</p>
<p>不同</p>
<ul>
<li>Spring MVC 通过参数解析器是将 Request 对象内容进行解析成方法形参，将响应数据和页面封装成 <strong>ModelAndView</strong> 对象，最后又将模型数据通过 <strong>Request</strong> 对象传输到页面。其中，如果视图使用 JSP 时，默认使用 <strong>JSTL</strong> 。</li>
<li>Struts2 采用<strong>值栈</strong>存储请求和响应的数据，通过 <strong>OGNL</strong> 存取数据。</li>
</ul>
</li>
</ul>
<p>当然，更详细的也可以看看 <a href="http://www.voidcn.com/article/p-ylualwcj-c.html">《面试题：Spring MVC 和 Struts2 的区别》</a> 一文。</p>
<h2 id="详细介绍下-Spring-MVC-拦截器？"><a href="#详细介绍下-Spring-MVC-拦截器？" class="headerlink" title="详细介绍下 Spring MVC 拦截器？"></a>详细介绍下 Spring MVC 拦截器？</h2><p><code>org.springframework.web.servlet.HandlerInterceptor</code> ，拦截器接口。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; HandlerInterceptor.java<br><br>&#x2F;**<br> * 拦截处理器，在 &#123;@link HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行之前<br> *&#x2F;<br>default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)<br>		throws Exception &#123;<br>	return true;<br>&#125;<br><br>&#x2F;**<br> * 拦截处理器，在 &#123;@link HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行成功之后<br> *&#x2F;<br>default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,<br>		@Nullable ModelAndView modelAndView) throws Exception &#123;<br>&#125;<br><br>&#x2F;**<br> * 拦截处理器，在 &#123;@link HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行完之后，无论成功还是失败<br> *<br> * 并且，只有该处理器 &#123;@link #preHandle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行成功之后，才会被执行<br> *&#x2F;<br>default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,<br>		@Nullable Exception ex) throws Exception &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>一共有三个方法，分别为：</p>
<ul>
<li><p><code>#preHandle(...)</code> 方法，调用 Controller 方法之<strong>前</strong>执行。 </p>
</li>
<li><p><code>#postHandle(...)</code> 方法，调用 Controller 方法之<strong>后</strong>执行。</p>
</li>
<li><pre><code>#afterCompletion(...)</code></pre>
<p> 方法，处理完 Controller 方法返回结果之</p>
<p>后</p>
<p>执行。</p>
<ul>
<li>例如，页面渲染后。</li>
<li><strong>当然，要注意，无论调用 Controller 方法是否成功，都会执行</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>举个例子：</p>
<ul>
<li>当俩个拦截器都实现放行操作时，执行顺序为 <code>preHandle[1] =&gt;  preHandle[2] =&gt; postHandle[2] =&gt; postHandle[1] =&gt; afterCompletion[2] =&gt; afterCompletion[1]</code> 。</li>
<li>当第一个拦截器 <code>#preHandle(...)</code> 方法返回 <code>false</code> ，也就是对其进行拦截时，第二个拦截器是完全不执行的，第一个拦截器只执行 <code>#preHandle(...)</code> 部分。</li>
<li>当第一个拦截器 <code>#preHandle(...)</code> 方法返回 <code>true</code> ，第二个拦截器 <code>#preHandle(...)</code> 返回 <code>false</code> ，执行顺序为 <code>preHandle[1] =&gt; preHandle[2] =&gt; afterCompletion[1]</code> 。</li>
</ul>
</li>
<li><p>总结来说：</p>
<ul>
<li><code>#preHandle(...)</code> 方法，按拦截器定义<strong>顺序</strong>调用。若任一拦截器返回 <code>false</code> ，则 Controller 方法不再调用。</li>
<li><code>#postHandle(...)</code> 和 <code>#afterCompletion(...)</code> 方法，按拦截器定义<strong>逆序</strong>调用。</li>
<li><code>#postHandler(...)</code> 方法，在调用 Controller 方法之<strong>后</strong>执行。</li>
<li><code>#afterCompletion(...)</code> 方法，只有该拦截器在 <code>#preHandle(...)</code> 方法返回 <code>true</code> 时，才能够被调用，且一定会被调用。为什么“且一定会被调用”呢？即使 <code>#afterCompletion(...)</code> 方法，按拦截器定义<strong>逆序</strong>调用时，前面的拦截器发生异常，后面的拦截器还能够调用，<strong>即无视异常</strong>。</li>
</ul>
</li>
</ul>
<hr>
<p>关于这块，可以看看如下两篇文章：</p>
<ul>
<li><a href="https://blog.csdn.net/amaxiaochen/article/details/77210880">《Spring MVC 多个拦截器执行顺序及拦截器使用方法》</a> 文章，通过<strong>实践</strong>更加理解。</li>
<li><a href="http://svip.iocoder.cn/Spring-MVC/HandlerMapping-2-HandlerInterceptor/">《精尽 Spring MVC 源码分析 —— HandlerMapping 组件（二）之 HandlerInterceptor》</a> 文章，通过<strong>源码</strong>更加理解。</li>
</ul>
<h2 id="Spring-MVC-的拦截器可以做哪些事情？"><a href="#Spring-MVC-的拦截器可以做哪些事情？" class="headerlink" title="Spring MVC 的拦截器可以做哪些事情？"></a>Spring MVC 的拦截器可以做哪些事情？</h2><p>拦截器能做的事情非常非常非常多，例如：</p>
<ul>
<li>记录访问日志。</li>
<li>记录异常日志。</li>
<li>需要登陆的请求操作，拦截未登陆的用户。</li>
<li>…</li>
</ul>
<h2 id="Spring-MVC-的拦截器和-Filter-过滤器有什么差别？"><a href="#Spring-MVC-的拦截器和-Filter-过滤器有什么差别？" class="headerlink" title="Spring MVC 的拦截器和 Filter 过滤器有什么差别？"></a>Spring MVC 的拦截器和 Filter 过滤器有什么差别？</h2><p>看了文章 <a href="https://blog.csdn.net/xiaodanjava/article/details/32125687">《过滤器( Filter )和拦截器( Interceptor )的区别》</a> ，感觉对比的怪怪的。艿艿觉得主要几个点吧：</p>
<ul>
<li><strong>功能相同</strong>：拦截器和 Filter都能实现相应的功能，谁也不比谁强。</li>
<li><strong>容器不同</strong>：拦截器构建在 Spring MVC 体系中；Filter 构建在 Servlet 容器之上。</li>
<li><strong>使用便利性不同</strong>：拦截器提供了三个方法，分别在不同的时机执行；过滤器仅提供一个方法，当然也能实现拦截器的执行时机的效果，就是麻烦一些。</li>
</ul>
<p>另外，😈 再补充一点小知识。我们会发现，拓展性好的框架，都会提供相应的拦截器或过滤器机制，方便的我们做一些拓展。例如：</p>
<ul>
<li>Dubbo 的 Filter 机制。</li>
<li>Spring Cloud Gateway 的 Filter 机制。</li>
<li>Struts2 的拦截器机制。</li>
</ul>
<h1 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h1><p>本小节的内容，基本是基于 <a href="http://www.spring4all.com/article/1445">《排名前 20 的 REST 和 Spring MVC 面试题》</a> 之上，做增补。</p>
<h2 id="REST-代表着什么"><a href="#REST-代表着什么" class="headerlink" title="REST 代表着什么?"></a>REST 代表着什么?</h2><p>REST 代表着抽象状态转移，它是根据 HTTP 协议从客户端发送数据到服务端，例如：服务端的一本书可以以 XML 或 JSON 格式传递到客户端。</p>
<p>然而，假如你不熟悉REST，我建议你先看看 <a href="http://bit.ly/2zIGzWK">REST API design and development</a> 这篇文章来更好的了解它。不过对于大多数胖友的英语，可能不太好，所以也可以阅读知乎上的 <a href="https://www.zhihu.com/question/28557115">《怎样用通俗的语言解释 REST，以及 RESTful？》</a> 讨论。</p>
<h2 id="资源是什么"><a href="#资源是什么" class="headerlink" title="资源是什么?"></a>资源是什么?</h2><p>资源是指数据在 REST 架构中如何显示的。将实体作为资源公开 ，它允许客户端通过 HTTP 方法如：<a href="http://javarevisited.blogspot.sg/2012/03/get-post-method-in-http-and-https.html">GET</a>, <a href="http://www.java67.com/2014/08/difference-between-post-and-get-request.html">POST</a>,<a href="http://www.java67.com/2016/09/when-to-use-put-or-post-in-restful-web-services.html">PUT</a>, DELETE 等读，写，修改和创建资源。</p>
<h2 id="什么是安全的-REST-操作"><a href="#什么是安全的-REST-操作" class="headerlink" title="什么是安全的 REST 操作?"></a>什么是安全的 REST 操作?</h2><p>REST 接口是通过 HTTP 方法完成操作。</p>
<ul>
<li>一些HTTP操作是安全的，如 GET 和 HEAD ，它不能在服务端修改资源</li>
<li>换句话说，PUT,POST 和 DELETE 是不安全的，因为他们能修改服务端的资源。</li>
</ul>
<p>所以，是否安全的界限，在于<strong>是否修改</strong>服务端的资源。</p>
<h2 id="什么是幂等操作-为什么幂等操作如此重要"><a href="#什么是幂等操作-为什么幂等操作如此重要" class="headerlink" title="什么是幂等操作? 为什么幂等操作如此重要?"></a>什么是幂等操作? 为什么幂等操作如此重要?</h2><p>有一些HTTP方法，如：GET，不管你使用多少次它都能产生相同的结果，在没有任何一边影响的情况下，发送多个 GET 请求到相同的<a href="http://www.java67.com/2013/01/difference-between-url-uri-and-urn.html">URI</a> 将会产生相同的响应结果。因此，这就是所谓<strong>幂等</strong>操作。</p>
<p>换句话说，<a href="http://javarevisited.blogspot.sg/2016/05/what-are-idempotent-and-safe-methods-of-HTTP-and-REST.html">POST方法不是幂等操作</a> ，因为如果发送多个 POST 请求，它将在服务端创建不同的资源。但是，假如你用PUT更新资源，它将是幂等操作。</p>
<p>甚至多个 PUT 请求被用来更新服务端资源，将得到相同的结果。你可以通过 Pluralsight 学习 <a href="http://pluralsight.pxf.io/c/1193463/424552/7490?u=https://www.pluralsight.com/courses/xhttp-fund">HTTP Fundamentals</a> 课程来了解 HTTP 协议和一般的 HTTP 的更多幂等操作。</p>
<h2 id="REST-是可扩展的或说是协同的吗"><a href="#REST-是可扩展的或说是协同的吗" class="headerlink" title="REST 是可扩展的或说是协同的吗?"></a>REST 是可扩展的或说是协同的吗?</h2><p>是的，<a href="http://javarevisited.blogspot.sg/2015/08/difference-between-soap-and-restfull-webservice-java.html">REST</a> 是可扩展的和可协作的。它既不托管一种特定的技术选择，也不定在客户端或者服务端。你可以用 <a href="http://javarevisited.blogspot.sg/2017/11/top-5-free-java-courses-for-beginners.html">Java</a>, <a href="http://www.java67.com/2018/02/5-free-cpp-courses-to-learn-programming.html">C++</a>, <a href="http://www.java67.com/2018/02/5-free-python-online-courses-for-beginners.html">Python</a>, 或 <a href="http://www.java67.com/2018/04/top-5-free-javascript-courses-to-learn.html">JavaScript</a> 来创建 RESTful Web 服务，也可以在客户端使用它们。</p>
<p>我建议你读一本关于REST接口的书来了解更多，如：<a href="http://javarevisited.blogspot.sg/2017/02/top-5-books-to-learn-rest-and-restful-web-services-in-java.html">RESTful Web Services</a> 。</p>
<blockquote>
<p>艿艿：所以这里的“可拓展”、“协同”对应到我们平时常说的，“跨语言”、“语言无关”。</p>
</blockquote>
<h2 id="REST-用哪种-HTTP-方法呢"><a href="#REST-用哪种-HTTP-方法呢" class="headerlink" title="REST 用哪种 HTTP 方法呢?"></a>REST 用哪种 HTTP 方法呢?</h2><p>REST 能用任何的 HTTP 方法，但是，最受欢迎的是：</p>
<ul>
<li>用 GET 来检索服务端资源</li>
<li>用 POST 来创建服务端资源</li>
<li><a href="http://javarevisited.blogspot.sg/2016/04/what-is-purpose-of-http-request-types-in-RESTful-web-service.html#axzz56WGunSwy">用 PUT 来更新服务端资源</a> </li>
<li>用 DELETE 来删除服务端资源。</li>
</ul>
<p>恰好，这四个操作，对上我们日常逻辑的 CRUD 操作。</p>
<blockquote>
<p>艿艿：经常能听到胖友抱怨自己做的都是 CRUD 的功能。看了这个面试题，有没觉得原来 CRUD 也能玩的稍微高级一点？！</p>
<p>实际上，每个 CRUD 也是可以通过不断的打磨，玩的很高级。例如说 DDD 领域驱动，完整的单元测试，可扩展的设计。</p>
</blockquote>
<h2 id="删除的-HTTP-状态返回码是什么"><a href="#删除的-HTTP-状态返回码是什么" class="headerlink" title="删除的 HTTP 状态返回码是什么 ?"></a>删除的 HTTP 状态返回码是什么 ?</h2><p>在删除成功之后，您的 REST API 应该返回什么状态代码，并没有严格的规则。它可以返回 200 或 204 没有内容。</p>
<ul>
<li>一般来说，如果删除操作成功，响应主体为空，返回 <a href="http://www.netingcn.com/http-status-204.html">204</a> 。</li>
<li>如果删除请求成功且响应体不是空的，则返回 200 。</li>
</ul>
<h2 id="REST-API-是无状态的吗"><a href="#REST-API-是无状态的吗" class="headerlink" title="REST API 是无状态的吗?"></a>REST API 是无状态的吗?</h2><p><strong>是的</strong>，REST API 应该是无状态的，因为它是基于 HTTP 的，它也是无状态的。</p>
<p>REST API 中的请求应该包含处理它所需的所有细节。它<strong>不应该</strong>依赖于以前或下一个请求或服务器端维护的一些数据，例如会话。</p>
<p><strong>REST 规范为使其无状态设置了一个约束，在设计 REST API 时，您应该记住这一点</strong>。</p>
<h2 id="REST安全吗-你能做什么来保护它"><a href="#REST安全吗-你能做什么来保护它" class="headerlink" title="REST安全吗? 你能做什么来保护它?"></a>REST安全吗? 你能做什么来保护它?</h2><p>安全是一个宽泛的术语。它可能意味着消息的安全性，这是通过认证和授权提供的加密或访问限制提供的。</p>
<p>REST 通常不是安全的，但是您可以通过使用 Spring Security 来保护它。</p>
<ul>
<li>至少，你可以通过在 Spring Security 配置文件中使用 HTTP 来启用 HTTP Basic Auth 基本认证。</li>
<li>类似地，如果底层服务器支持 HTTPS ，你可以使用 HTTPS 公开 REST API 。</li>
</ul>
<h2 id="RestTemplate-的优势是什么"><a href="#RestTemplate-的优势是什么" class="headerlink" title="RestTemplate 的优势是什么?"></a>RestTemplate 的优势是什么?</h2><p>在 Spring Framework 中，RestTemplate 类是 <a href="http://www.java67.com/2012/09/top-10-java-design-pattern-interview-question-answer.html">模板方法模式</a> 的实现。跟其他主流的模板类相似，如 JdbcTemplate 或 JmsTempalte ，它将在客户端简化跟 RESTful Web  服务的集成。正如在 RestTemplate 例子中显示的一样，你能非常容易地用它来调用 RESTful Web 服务。</p>
<blockquote>
<p>艿艿：当然，实际场景我还是更喜欢使用 <a href="http://square.github.io/okhttp/">OkHttp</a> 作为 HTTP 库，因为更好的性能，使用也便捷，并且无需依赖 Spring 库。</p>
</blockquote>
<h2 id="HttpMessageConverter-在-Spring-REST-中代表什么"><a href="#HttpMessageConverter-在-Spring-REST-中代表什么" class="headerlink" title="HttpMessageConverter 在 Spring REST 中代表什么?"></a>HttpMessageConverter 在 Spring REST 中代表什么?</h2><p>HttpMessageConverter 是一种<a href="http://www.java67.com/2014/12/strategy-pattern-in-java-with-example.html">策略接口</a> ，它指定了一个转换器，它可以转换 HTTP 请求和响应。Spring REST 用这个接口转换 HTTP 响应到多种格式，例如：JSON 或 XML 。</p>
<p>每个 HttpMessageConverter 实现都有一种或几种相关联的MIME协议。Spring 使用 <code>&quot;Accept&quot;</code> 的标头来确定客户端所期待的内容类型。</p>
<p>然后，它将尝试找到一个注册的 HTTPMessageConverter ，它能够处理特定的内容类型，并使用它将响应转换成这种格式，然后再将其发送给客户端。</p>
<p>如果胖友对 HttpMessageConverter 不了解，可以看看 <a href="https://leokongwq.github.io/2017/06/14/spring-MessageConverter.html">《Spring 中 HttpMessageConverter 详解》</a> 。</p>
<h2 id="如何创建-HttpMessageConverter-的自定义实现来支持一种新的请求-响应？"><a href="#如何创建-HttpMessageConverter-的自定义实现来支持一种新的请求-响应？" class="headerlink" title="如何创建 HttpMessageConverter 的自定义实现来支持一种新的请求/响应？"></a>如何创建 HttpMessageConverter 的自定义实现来支持一种新的请求/响应？</h2><p>我们仅需要创建自定义的 AbstractHttpMessageConverter 的实现，并使用 WebMvcConfigurerAdapter 的 <code>#extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</code> 方法注中册它，该方法可以生成一种新的请求 / 响应类型。</p>
<p>具体的示例，可以学习 <a href="https://github.com/alibaba/fastjson/wiki/%E5%9C%A8-Spring-%E4%B8%AD%E9%9B%86%E6%88%90-Fastjson">《在 Spring 中集成 Fastjson》</a> 文章。</p>
<h2 id="PathVariable-注解，在-Spring-MVC-做了什么-为什么-REST-在-Spring-中如此有用？"><a href="#PathVariable-注解，在-Spring-MVC-做了什么-为什么-REST-在-Spring-中如此有用？" class="headerlink" title="@PathVariable 注解，在 Spring MVC 做了什么? 为什么 REST 在 Spring 中如此有用？"></a>@PathVariable 注解，在 Spring MVC 做了什么? 为什么 REST 在 Spring 中如此有用？</h2><p><code>@PathVariable</code> 注解，是 Spring MVC 中有用的注解之一，它允许您从 URI 读取值，比如查询参数。它在使用 Spring 创建 RESTful Web 服务时特别有用，因为在 REST 中，资源标识符是 URI 的一部分。</p>
<p>具体的使用示例，胖友如果不熟悉，可以看看 <a href="https://blog.csdn.net/cx361006796/article/details/52829759">《Spring MVC 的 @RequestParam 注解和 @PathVariable 注解的区别》</a> 。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>文末的文末，艿艿还是那句话！！！！还是非常推荐胖友去撸一撸 Spring MVC 的源码，特别是如下两篇：</p>
<ul>
<li><a href="http://svip.iocoder.cn/Spring-MVC/Components-intro/">《精尽 Spring MVC 源码分析 —— 组件一览》</a></li>
<li><a href="http://svip.iocoder.cn/Spring-MVC/DispatcherServlet-process-request-intro/">《精尽 Spring MVC 源码分析 —— 请求处理一览》</a></li>
</ul>
<p>参考和推荐如下文章：</p>
<ul>
<li><a href="http://www.spring4all.com/article/1445">《排名前 20 的 REST 和 Spring MVC 面试题》</a></li>
<li><a href="http://www.iocoder.cn/Fight/Learn-Restful-HTTP-API-design-from-Github/">《跟着 Github 学习 Restful HTTP API 的优雅设计》</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring MVC</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>精尽 Java【基础】面试题</title>
    <url>/2016/10/12/%E7%B2%BE%E5%B0%BD%20Java%E3%80%90%E5%9F%BA%E7%A1%80%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="精尽-Java【基础】面试题"><a href="#精尽-Java【基础】面试题" class="headerlink" title="精尽 Java【基础】面试题"></a>精尽 Java【基础】面试题</h1><p>以下面试题，基于网络整理，和自己编辑。具体参考的文章，会在文末给出所有的链接。</p>
<p>如果胖友有自己的疑问，欢迎在星球提问，我们一起整理吊吊的 Java【基础】面试题的大保健。</p>
<p>而题目的难度，艿艿尽量按照从容易到困难的顺序，逐步下去。</p>
<p>考虑到 Java 涉及的知识点非常非常非常之多，所以我们会分成五大篇来分享，分别是：</p>
<ul>
<li><p>Java【基础】</p>
<blockquote>
<p>本文。😈 分不到其它类别里的，都会放到本文。</p>
</blockquote>
</li>
<li><p>Java【集合】</p>
</li>
<li><p>Java【并发】</p>
</li>
<li><p>Java【网络】</p>
<blockquote>
<p>因为 Java 网络编程大多使用 Netty ，所以面试题统一整理到 <a href="http://svip.iocoder.cn/Netty/Interview">《精尽 Netty 面试题》</a> 中，避免重复。</p>
</blockquote>
</li>
<li><p>Java【虚拟机】</p>
</li>
</ul>
<h2 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h2><p>面向对象是一种思想，世间万物都可以看做一个对象，这里只讨论面向对象编程（OOP），Java 是一个支持并发、基于类和面向对象的计算机编程语言。面向对象软件开发具有以下优点：</p>
<ul>
<li>代码开发模块化，更易维护和修改。</li>
<li>代码复用性强。</li>
<li>增强代码的可靠性和灵活性。</li>
<li>增加代码的可读性。</li>
</ul>
<p>🦅 <strong>请说说面向对象的特征？</strong></p>
<p>四点：<strong>封装</strong>、<strong>继承</strong>、<strong>多态</strong>、<strong>抽象</strong>。</p>
<blockquote>
<p>艿艿：这个题目，能说出上述四点就好了。</p>
</blockquote>
<p>1）封装</p>
<p>封装，给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在 Java 当中，有 4 种修饰符： <code>default</code>、<code>public</code>、<code>private</code> 和 <code>protected</code> 。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。</p>
<p>下面列出了使用封装的一些好处：</p>
<ul>
<li>通过隐藏对象的属性来保护对象内部的状态。</li>
<li>提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。</li>
<li>禁止对象之间的不良交互提高模块化。</li>
</ul>
<p>2）继承</p>
<p>继承，给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。</p>
<p>3）多态</p>
<p>多态，是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作，可以应用到其他类型的值上面。</p>
<p>4）抽象</p>
<p>抽象，是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。</p>
<p>Java 支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。</p>
<p>🦅 <strong>面向对象和面向过程的区别？</strong></p>
<ul>
<li>面向过程<ul>
<li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源。比如，单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发，性能是最重要的因素。</li>
<li>缺点：没有面向对象易维护、易复用、易扩展。</li>
</ul>
</li>
<li>面向对象<ul>
<li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。</li>
<li>缺点：性能比面向过程低。</li>
</ul>
</li>
</ul>
<p>🦅 <strong>重载和重写的区别？</strong></p>
<p>1）重写 <code>override</code></p>
<ul>
<li>方法名、参数、返回值相同。</li>
<li>子类方法不能缩小父类方法的访问权限。</li>
<li>子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。</li>
<li>存在于父类和子类之间。</li>
<li>方法被定义为 <code>final</code> 不能被重写。</li>
</ul>
<p>2）重载 <code>overload</code></p>
<ul>
<li>参数类型、个数、顺序至少有一个不相同。</li>
<li>不能重载只有返回值不同的方法名。</li>
<li>存在于父类和子类、同类中。</li>
</ul>
<p>🦅 <strong>对比图</strong></p>
<p><a href="https://user-gold-cdn.xitu.io/2018/5/9/16342c734014a933?imageView2/0/w/1280/h/960/format/jpeg/ignore-error/1">对比图</a></p>
<p>🦅 <strong>Java 中，什么是构造方法？什么是构造方法重载？什么是拷贝构造方法？</strong></p>
<p>1）构造方法</p>
<p>当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java 编译器会为这个类创建一个默认的构造方法。</p>
<p>2）构造方法重载</p>
<p>Java 中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。</p>
<p>3）拷贝构造方法</p>
<p>Java 不支持像 C++ 中那样的<a href="http://www.runoob.com/cplusplus/cpp-copy-constructor.html">拷贝构造方法</a>，这个不同点是因为如果你不自己写构造方法的情况下，Java 不会创建默认的拷贝构造方法。</p>
<h2 id="JDK、JRE、JVM-分别是什么关系？"><a href="#JDK、JRE、JVM-分别是什么关系？" class="headerlink" title="JDK、JRE、JVM 分别是什么关系？"></a>JDK、JRE、JVM 分别是什么关系？</h2><p>🦅 <strong>JDK</strong></p>
<p>JDK 即为 Java 开发工具包，包含编写 Java 程序所必须的编译、运行等开发工具以及 JRE。开发工具如：</p>
<ul>
<li>用于编译 Java 程序的 javac 命令。</li>
<li>用于启动 JVM 运行 Java 程序的 Java 命令。</li>
<li>用于生成文档的 Javadoc 命令。</li>
<li>用于打包的 jar 命令等等。</li>
</ul>
<blockquote>
<p>简单说，就是 JDK 包含 JRE 包含 JVM。</p>
</blockquote>
<p>🦅 <strong>JRE</strong></p>
<p>JRE 即为 Java 运行环境，提供了运行 Java 应用程序所必须的软件环境，包含有 Java 虚拟机（JVM）和丰富的系统类库。系统类库即为 Java 提前封装好的功能类，只需拿来直接使用即可，可以大大的提高开发效率。</p>
<blockquote>
<p>简单说，就是 JRE 包含 JVM。</p>
</blockquote>
<p>🦅 <strong>JVM</strong></p>
<p>JVM 即为 Java 虚拟机，提供了字节码文件(<code>.class</code>)的运行环境支持。</p>
<blockquote>
<p><img src="http://cdn.tuwenbin.vip/57u4a9gq.bmp" alt="57u4a9gq">JDK &gt; JRE &gt; JVM</p>
</blockquote>
<p>🦅 <strong>为什么 Java 被称作是“平台无关的编程语言”？</strong></p>
<p>Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。</p>
<ul>
<li>Java 源文件( <code>.java</code> )被编译成能被 Java 虚拟机执行的字节码文件( <code>.class</code> )。</li>
<li>Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</li>
</ul>
<p>🦅 <strong>JDK 各版本的新特性？</strong></p>
<ul>
<li>JDK5 ~ JDK10 ，看 <a href="https://www.jianshu.com/p/37b52f1ebd4a">https://www.jianshu.com/p/37b52f1ebd4a</a> 。</li>
<li>JDK11 ，看 <a href="https://www.jianshu.com/p/81b65eded96c">https://www.jianshu.com/p/81b65eded96c</a> 。</li>
</ul>
<p>对于大多数面试官，肯定不会问你 JDK 各版本的新特性，更多的会问 JDK8 引入了什么重要的特性？一般上，关键的回答是Lambda 表达式和集合之流式操作，然后说说你在项目中怎么使用的。</p>
<p>🦅 <strong>Java 和 C++ 的区别？</strong></p>
<ul>
<li>都是面向对象的语言，都支持封装、继承和多态。</li>
<li>Java 不提供指针来直接访问内存，程序内存更加安全。</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>
<li>【重要】Java 有自动内存管理机制，不需要程序员手动释放无用内存。</li>
</ul>
<h2 id="什么是字节码？采用字节码的最大好处是什么？"><a href="#什么是字节码？采用字节码的最大好处是什么？" class="headerlink" title="什么是字节码？采用字节码的最大好处是什么？"></a>什么是字节码？采用字节码的最大好处是什么？</h2><p>🦅 <strong>什么是字节码？</strong></p>
<blockquote>
<p>这个问题，面试官可以衍生提问，Java 是编译执行的语言，还是解释执行的语言。</p>
</blockquote>
<p>Java 中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟的机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。</p>
<p>编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在 Java 中，这种供虚拟机理解的代码叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。</p>
<p>每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java 源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行。<strong>这也就是解释了 Java 的编译与解释并存的特点</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Java 源代码<br>&#x3D;&gt; 编译器 &#x3D;&gt; JVM 可执行的 Java 字节码(即虚拟指令)<br>&#x3D;&gt; JVM &#x3D;&gt; JVM 中解释器 &#x3D;&gt; 机器可执行的二进制机器码 &#x3D;&gt; 程序运行<br></code></pre></td></tr></table></figure>

<p>🦅 <strong>采用字节码的好处？</strong></p>
<p>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。</p>
<blockquote>
<p>解释型语言：解释型语言，是在运行的时候将程序翻译成机器语言。解释型语言的程序不需要在运行前编译，在运行程序的时候才翻译，专门的解释器负责在每个语句执行的时候解释程序代码。这样解释型语言每执行一次就要翻译一次，效率比较低。——百度百科</p>
<p>例如：Python、PHP 。</p>
</blockquote>
<h2 id="Java-中的几种基本数据类型是什么？各自占用多少字节？"><a href="#Java-中的几种基本数据类型是什么？各自占用多少字节？" class="headerlink" title="Java 中的几种基本数据类型是什么？各自占用多少字节？"></a>Java 中的几种基本数据类型是什么？各自占用多少字节？</h2><p>Java 支持的数据类型包括基本数据类型和引用类型。</p>
<p><strong>基本数据</strong>类型如下：</p>
<ul>
<li>整数值型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>
<li>字符型：<code>char</code></li>
<li>浮点类型：<code>float</code>、<code>double</code></li>
<li>布尔型：<code>boolean</code></li>
<li>整数型：默认 <code>int</code> 型，小数默认是 <code>double</code> 型。Float 和 Long 类型的必须加后缀。比如：<code>float f = 100f</code> 。</li>
</ul>
<p><strong>引用类型</strong>声明的变量是指该变量在内存中实际存储的是一个引用地址，实体在堆中。</p>
<ul>
<li>引用类型包括类、接口、数组等。</li>
<li>特别注意，String 是引用类型不是基本类型。</li>
</ul>
<p>🦅 <strong>什么是值传递和引用传递？</strong></p>
<ul>
<li>值传递，是对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。</li>
<li>引用传递，一般是对于对象型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身。</li>
</ul>
<p>一般认为，Java 内的传递都是值传递，Java 中实例对象的传递是引用传递。</p>
<p>🦅 <strong>是否可以在 static 环境中访问非 static 变量？</strong></p>
<p><code>static</code> 变量在 Java 中是属于类的，它在所有的实例中的值是一样的。当类被 Java 虚拟机载入的时候，会对 <code>static</code> 变量进行初始化。</p>
<p>如果你的代码尝试不用实例来访问非 <code>static</code> 的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p>
<p>🦅 <strong>char 型变量中能不能存贮一个中文汉字？为什么？</strong></p>
<ul>
<li>在 C 语言中，char 类型占 1 个字节，而汉字占 2 个字节，所以不能存储。</li>
<li>在 Java 语言中，char 类型占 2 个字节，而且 Java 默认采用 Unicode 编码，一个 Unicode 码是 16  位，所以一个 Unicode 码占两个字节，Java 中无论汉字还是英文字母，都是用 Unicode 编码来表示的。所以，在 Java  中，char 类型变量可以存储一个中文汉字。</li>
</ul>
<h2 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h2><p>Java 平台提供了两种类型的字符串：String 和 StringBuffer/StringBuilder，它们可以储存和操作字符串。</p>
<ul>
<li><p>String ，是只读字符串，也就意味着 String 引用的字符串内容是不能被改变的。</p>
<blockquote>
<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。</p>
</blockquote>
</li>
<li><p>StringBuffer/StringBuilder 类，表示的字符串对象可以直接进行修改。StringBuilder 是 Java 5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被 <code>synchronized</code> 修饰，因此它的效率也比 StringBuffer 要高。</p>
<blockquote>
<p>StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。</p>
<p>相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
</blockquote>
</li>
</ul>
<p>🦅 <strong>对于三者使用的总结？</strong></p>
<ul>
<li><p>操作少量的数据 = String 。</p>
<blockquote>
<p>这个也是实际编码较为经常使用的方式。</p>
</blockquote>
</li>
<li><p>单线程操作字符串缓冲区下操作大量数据 = StringBuilder 。</p>
<blockquote>
<p>甚至有时，我们为了避免每个线程重复创建 StringBuilder 对象，会通过 ThreadLocal + StringBuilder 的方式，进行对 StringBuilder 的重用。具体可以参考 <a href="http://nathanchen.github.io/14596982516208.html">《StringBuilder 在高性能场景下的正确用法》</a> 文章。</p>
</blockquote>
</li>
<li><p>多线程操作字符串缓冲区下操作大量数据 = StringBuffer</p>
<blockquote>
<p>实际场景下，我们基本不太会出现，多线程操作同一个 StringBuffer 对象。</p>
</blockquote>
</li>
</ul>
<p>🦅 <strong><code>String s = new String(&quot;xyz&quot;)</code> 会创建几个对象？</strong></p>
<ul>
<li>首先，在 String 池内找，找到 <code>&quot;xyz&quot;</code> 字符串，不创建 <code>&quot;xyz&quot;</code> 对应的 String 对象，否则创建一个对象。</li>
<li>然后，遇到 <code>new</code> 关键字，在内存上创建 String 对象，并将其返回给 <code>s</code> ，又一个对象。</li>
</ul>
<p>所以，总共是 1 个或者 2 个对象。</p>
<p>具体的，可以看看 <a href="https://blog.csdn.net/tzs_1041218129/article/details/69367423">《关于String s = new String(“xyz”); 创建几个对象的问题》</a> 文章的测试代码。</p>
<p>🦅 <strong>String 为什么是不可变的？</strong></p>
<p>简单的来说，String 类中使用 <code>final</code> 关键字字符数组保存字符串。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; String.java<br><br>private final char[] value;<br></code></pre></td></tr></table></figure>

<ul>
<li>所以 String 对象是不可变的。</li>
</ul>
<p>而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串 <code>char[] value</code> ，但是没有用 <code>final</code> 关键字修饰。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; AbstractStringBuilder.java<br><br>char[] value;<br></code></pre></td></tr></table></figure>

<ul>
<li>所以这两种对象都是可变的。</li>
</ul>
<p>🦅 <strong>StringTokenizer 是什么？</strong></p>
<p>StringTokenizer ，是一个用来分割字符串的工具类。</p>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">StringTokenizer st &#x3D; new StringTokenizer(”Hello World”);<br>while (st.hasMoreTokens()) &#123;<br>    System.out.println(st.nextToken());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Hello<br>World<br></code></pre></td></tr></table></figure>

<h2 id="什么是自动拆装箱？"><a href="#什么是自动拆装箱？" class="headerlink" title="什么是自动拆装箱？"></a>什么是自动拆装箱？</h2><p>自动装箱和拆箱，就是基本类型和引用类型之间的转换。</p>
<p>🦅 <strong>为什么要转换？</strong></p>
<p>如果你在 Java5 下进行过编程的话，你一定不会陌生这一点，你不能直接地向集合( Collection )中放入原始类型值，因为集合只接收对象。</p>
<ul>
<li>通常这种情况下你的做法是，将这些原始类型的值转换成对象，然后将这些转换的对象放入集合中。使用 Integer、Double、Boolean 等这些类，我们可以将原始类型值转换成对应的对象，但是从某些程度可能使得代码不是那么简洁精炼。</li>
<li>为了让代码简练，Java5 引入了具有在原始类型和对象类型自动转换的装箱和拆箱机制。</li>
<li>但是自动装箱和拆箱并非完美，在使用时需要有一些注意事项，如果没有搞明白自动装箱和拆箱，可能会引起难以察觉的 Bug 。</li>
</ul>
<p>🦅 <strong>int 和 Integer 有什么区别？</strong></p>
<ul>
<li><code>int</code> 是基本数据类型。</li>
<li>Integer 是其包装类，注意是一个类。</li>
</ul>
<p>当然，要注意下 Integer 的缓存策略，可以看看 <a href="http://www.importnew.com/18884.html">《理解Java Integer 的缓存策略》</a> 文章。</p>
<h2 id="equals-与-的区别？"><a href="#equals-与-的区别？" class="headerlink" title="equals 与 == 的区别？"></a>equals 与 == 的区别？</h2><ul>
<li><p>值类型（<code>int</code>,<code>char</code>,<code>long</code>,<code>boolean</code>等）的话</p>
<ul>
<li>都是用 == 判断相等性。</li>
</ul>
</li>
<li><p>对象引用的话</p>
<ul>
<li><p>== 判断引用所指的对象是否是同一个。</p>
</li>
<li><p>equals 方法，是 Object 的成员函数，有些类会覆盖(<code>override</code>) 这个方法，用于判断对象的等价性。</p>
<blockquote>
<p>例如 String 类，两个引用所指向的 String 都是 <code>&quot;abc&quot;</code> ，但可能出现他们实际对应的对象并不是同一个（和 JVM 实现方式有关），因此用 == 判断他们可能不相等，但用 equals 方法判断一定是相等的。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>🦅 <strong>如何在父类中为子类自动完成所有的 hashCode 和 equals 实现？这么做有何优劣？</strong></p>
<p>父类的 equals ，一般情况下是无法满足子类的 equals 的需求。</p>
<ul>
<li>比如所有的对象都继承 Object ，默认使用的是 Object 的 equals  方法，在比较两个对象的时候，是看他们是否指向同一个地址。但是我们的需求是对象的某个属性相同，就相等了，而默认的 equals  方法满足不了当前的需求，所以我们要重写 equals 方法。</li>
<li>如果重写了 equals 方法，就必须重写 hashCode 方法，否则就会降低 Map 等集合的索引速度。</li>
</ul>
<p>🦅 <strong>说一说你对 <code>java.lang.Object</code> 对象中 hashCode 和 equals 方法的理解。在什么场景下需要重新实现这两个方法?</strong></p>
<p>这个问题，和上个 <a href="http://svip.iocoder.cn/Java/Core/Interview/#">「如何在父类中为子类自动完成所有的 hashCode 和 equals 实现？这么做有何优劣？」</a> 一样的答案。</p>
<p>🦅 <strong>这样的 a.hashCode() 有什么用，与 a.equals(b) 有什么关系?</strong></p>
<blockquote>
<p>这个问题，和上述问题，就是换个姿势，差不了太多。</p>
</blockquote>
<ol>
<li><p>equals 方法，用于比较对象的内容是否相等。</p>
<blockquote>
<p>当覆盖了 equals 方法时，比较对象是否相等将通过覆盖后的 equals 方法进行比较（判断对象的内容是否相等）。</p>
</blockquote>
</li>
<li><p>hashCode 方法，大多在集合中用到。</p>
<blockquote>
<p>将对象放入到集合中时，首先判断要放入对象的 hashCode 值与集合中的任意一个元素的 hashCode 值是否相等，如果不相等直接将该对象放入集合中。</p>
<p>如果 hashCode 值相等，然后再通过 equals 方法判断要放入对象与集合中的任意一个对象是否相等，如果 equals 判断不相等，直接将该元素放入到集合中，否则不放入。</p>
</blockquote>
</li>
</ol>
<p>🦅 <strong>有没有可能 2 个不相等的对象有相同的 hashCode？</strong></p>
<p>可能会发生，这个被称为<strong>哈希碰撞</strong>。当然，相等的对象，即我们重写了 equals 方法，一定也要重写 hashCode 方法，否则将出现我们在 HashMap 中，相等的对象作为 key ，将找不到对应的 value 。</p>
<p>所以说，equals 和 hashCode 的关系会是：</p>
<ul>
<li>equals 不相等，hashCode 可能相等。</li>
<li>equals 相等，请重写 hashCode 方法，保证 hashCode 相等。</li>
</ul>
<p>一般来说，hashCode 方法的重写，可以看看 <a href="https://segmentfault.com/a/1190000010799123">《科普：为什么 String hashCode 方法选择数字31作为乘子》</a> 方法。</p>
<h2 id="final、finally、finalize-的区别？"><a href="#final、finally、finalize-的区别？" class="headerlink" title="final、finally、finalize 的区别？"></a>final、finally、finalize 的区别？</h2><p>1）final</p>
<p><code>final</code> ，是修饰符关键字。</p>
<ul>
<li>如果一个类被声明为 <code>final</code> ，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 <code>abstract</code> 的，又被声明为 <code>final</code> 的。</li>
<li>将变量或方法声明为 <code>final</code> ，可以保证它们在使用中不被改变。被声明为 final 的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为 <code>final</code> 的方法也同样只能使用，不能重写。</li>
</ul>
<blockquote>
<p>另外，在早期的 Java 实现版本中，会将 <code>final</code> 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 <code>final</code> 方法进行这些优化了）。类中所有的<code>private</code> 方法都隐式地指定为 <code>final</code> 。</p>
</blockquote>
<p>2）finally</p>
<p>在异常处理时提供 <code>finally</code> 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 <code>catch</code> 子句就会执行，然后控制就会进入 <code>finally</code> 块（如果有的话）。</p>
<p>在以下 4 种特殊情况下，finally块不会被执行：</p>
<ul>
<li>在 <code>finally</code> 语句块中发生了异常。</li>
<li>在前面的代码中用了 <code>System.exit()</code> 退出程序。</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU 。</li>
</ul>
<p>3）finalize</p>
<p><code>finalize</code> ，是方法名。</p>
<p>Java 允许使用 <code>#finalize()</code> 方法，在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。</p>
<ul>
<li>它是在 Object 类中定义的，因此所有的类都继承了它。</li>
<li>子类覆盖 <code>finalize()</code> 方法，以整理系统资源或者执行其他清理工作。</li>
<li><code>#finalize()</code> 方法，是在垃圾收集器删除对象之前对这个对象调用的。</li>
</ul>
<p>一般情况下，我们在业务中不会自己实现这个方法，更多是在一些框架中使用，例如 <a href="https://github.com/netty/netty/issues/4145">《Netty Using finalize() to release ByteBufs》</a> 。</p>
<p>🦅 <strong>String 类能被继承吗，为什么？</strong></p>
<p>不能，因为 String 是 <code>final</code> 修饰。</p>
<h2 id="抽象类和接口有什么区别？"><a href="#抽象类和接口有什么区别？" class="headerlink" title="抽象类和接口有什么区别？"></a>抽象类和接口有什么区别？</h2><p>从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</p>
<ul>
<li>Java 提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：接口中所有的方法隐含的都是抽象的，而抽象类则可以同时包含抽象和非抽象的方法。</li>
<li>类可以实现很多个接口，但是只能继承一个抽象类。类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</li>
<li>抽象类可以在不提供接口方法实现的情况下实现接口。</li>
<li>Java 接口中声明的变量默认都是 <code>final</code> 的。抽象类可以包含非 <code>final</code> 的变量。</li>
<li>Java 接口中的成员函数默认是 <code>public</code> 的。抽象类的成员函数可以是 <code>private</code>，<code>protected</code> 或者是 <code>public</code> 。</li>
<li>接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含 <code>#main(String[] args)</code> 方法的话是可以被调用的。</li>
</ul>
<p>🦅 <strong>继承和组合的区别在哪？</strong></p>
<ul>
<li>继承：指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系。在 Java 中，此类关系通过关键字 <code>extends</code> 明确标识，在设计时一般没有争议性。</li>
<li>组合：组合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即 has-a 的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。<ul>
<li>比如，计算机与 CPU 、公司与员工的关系等。</li>
<li>表现在代码层面，和关联关系是一致的，只能从语义级别来区分。</li>
</ul>
</li>
</ul>
<p>因为组合能带来比继承更好的灵活性，所以有句话叫做“组合优于继承”。感兴趣的胖友，可以看看 <a href="https://www.zhihu.com/question/21862257">《怎样理解“组合优于继承”以及“OO的反模块化”，在这些方面FP具体来说有什么优势？》</a> 文章。</p>
<p>🦅 <strong>请详细讲述一下 RandomAccess 接口有什么作用？</strong></p>
<p>RandomAccess 用来当标记的，是一种<strong>标记</strong>接口，接口的非典型用法。意思是，随机访问任意下标元素都比较快。</p>
<p>用处，当要实现某些算法时，会判断当前类是否实现了 RandomAccess 接口，会根据结果选择不同的算法。</p>
<h2 id="讲讲类的实例化顺序？"><a href="#讲讲类的实例化顺序？" class="headerlink" title="讲讲类的实例化顺序？"></a>讲讲类的实例化顺序？</h2><p>初始化顺序如下：</p>
<ul>
<li>父类静态变量</li>
<li>父类静态代码块</li>
<li>子类静态变量、</li>
<li>子类静态代码块</li>
<li>父类非静态变量（父类实例成员变量）</li>
<li>父类构造函数</li>
<li>子类非静态变量（子类实例成员变量）</li>
<li>子类构造函数</li>
</ul>
<p>感兴趣的胖友，可以详细看看 <a href="https://blog.csdn.net/Vencc__/article/details/52222628">《Java 类的实例化顺序》</a> 文章，提供的示例。</p>
<h2 id="什么是内部类？"><a href="#什么是内部类？" class="headerlink" title="什么是内部类？"></a>什么是内部类？</h2><p>简单的说，就是在一个类、接口或者方法的内部创建另一个类。这样理解的话，创建内部类的方法就很明确了。当然，详细的可以看看 <a href="https://blog.csdn.net/hikvision_java_gyh/article/details/8964155">《Java 内部类总结（吐血之作）》</a> 文章。</p>
<p>🦅 <strong>内部类的作用是什么？</strong></p>
<p>内部类提供了更好的封装，除了该外围类，其他类都不能访问。</p>
<p>🦅 <strong>Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？</strong></p>
<p>可以继承其他类或实现其他接口，在 Java 集合的流式操作中，我们常常这么干。</p>
<p>🦅 <strong>内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</strong></p>
<p>一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。</p>
<h2 id="什么是-Java-IO-？"><a href="#什么是-Java-IO-？" class="headerlink" title="什么是 Java IO ？"></a>什么是 Java IO ？</h2><p>Java IO 相关的类，在 <code>java.io</code> 包下，具体操作分成面向字节(Byte)和面向字符(Character)两种方式。如下图所示：</p>
<p><img src="http://cdn.tuwenbin.vip/ne9xds34.bmp" alt="ne9xds34">类图</p>
<h2 id="什么是-Java-序列化？"><a href="#什么是-Java-序列化？" class="headerlink" title="什么是 Java 序列化？"></a>什么是 Java 序列化？</h2><p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。</p>
<ul>
<li>可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。</li>
<li>序列化是为了解决在对对象流进行读写操作时所引发的问题。</li>
</ul>
<p>反序列化的过程，则是和序列化相反的过程。</p>
<blockquote>
<p>另外，我们不能将序列化局限在 Java 对象转换成二进制数组，例如说，我们将一个 Java 对象，转换成 JSON 字符串，或者 XML 字符串，这也可以理解为是序列化。</p>
</blockquote>
<p>🦅 <strong>如何实现 Java 序列化？</strong></p>
<blockquote>
<p>如下的方式，就是 Java 内置的序列化方案，实际场景下，我们可以自定义序列化的方案，例如说 Google Protobuf 。</p>
</blockquote>
<p>将需要被序列化的类，实现 Serializable 接口，该接口没有需要实现的方法，<code>implements Serializable</code> 只是为了标注该对象是可被序列化的。</p>
<ul>
<li>序列化<ul>
<li>然后，使用一个输出流(如：FileOutputStream)来构造一个 ObjectOutputStream(对象流)对象</li>
<li>接着，使用 ObjectOutputStream 对象的 <code>#writeObject(Object obj)</code> 方法，就可以将参数为 <code>obj</code> 的对象写出(即保存其状态)。</li>
</ul>
</li>
<li>反序列化<ul>
<li>要恢复的话则用输入流。</li>
</ul>
</li>
</ul>
<p>🦅 <strong>Java 序列话中，如果有些字段不想进行序列化怎么办？</strong></p>
<p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p>
<ul>
<li>当对象被序列化时，阻止实例中那些用此关键字修饰的的变量序列化。</li>
<li>当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</li>
<li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li>
</ul>
<h2 id="如何实现对象克隆？"><a href="#如何实现对象克隆？" class="headerlink" title="如何实现对象克隆？"></a>如何实现对象克隆？</h2><p>一般来说，有两种方式：</p>
<ul>
<li>1、实现 Cloneable 接口，并重写 Object 类中的 <code>#clone()</code> 方法。可以实现<strong>浅克隆</strong>，也可以实现<strong>深克隆</strong>。</li>
<li>2、实现 Serializable 接口，通过对象的序列化和反序列化实现克隆。可以实现真正的<strong>深克隆</strong>。</li>
</ul>
<blockquote>
<p>艿艿：这个问题，也可以变种来问，什么是<strong>浅克隆</strong>和<strong>深克隆</strong>。</p>
</blockquote>
<p>具体的代码实现，可以看看 <a href="https://blog.csdn.net/caomiao2006/article/details/52590622">《Java 对象的浅克隆和深克隆》</a> 文章。</p>
<p>实际场景下，我们使用的克隆比较少，更多是对象之间的属性克隆。例如说，将 DO 的属性复制到 DTO 中，又或者将 DTO 的属性复制到 VO 中。此时，我们一般使用 BeanUtils 工具类。具体的使用，看看 <a href="https://www.cnblogs.com/tison/p/7840647.html">《浅谈 BeanUtils 的拷贝，深度克隆》</a> 文章。</p>
<h2 id="error-和-exception-有什么区别？CheckedException-和-RuntimeException-有什么区别？"><a href="#error-和-exception-有什么区别？CheckedException-和-RuntimeException-有什么区别？" class="headerlink" title="error 和 exception 有什么区别？CheckedException 和 RuntimeException 有什么区别？"></a>error 和 exception 有什么区别？CheckedException 和 RuntimeException 有什么区别？</h2><p>Java 的异常体系，基于共同的祖先 <code>java.lang.Throwable</code> 类。如下图所示：</p>
<p><img src="http://cdn.tuwenbin.vip/9dx75n14.bmp" alt="9dx75n14">Throwable 类图</p>
<blockquote>
<p>感谢【贾鹤鸣】胖友指出的问题。图有点问题：</p>
<ol>
<li>图中的 ArrithmeticException 异常，多了一个 r ，正确拼写是 ArithmeticException 。</li>
<li>图中 ClassNotFoundException 异常，父类是 <code>ReflectiveOperationException =&gt; Exception</code> ，不属于 RunTimeException 。</li>
</ol>
</blockquote>
<ul>
<li>Error（错误），表示系统级的错误和程序不必处理的异常，是 Java 运行环境中的内部错误或者硬件问题。<ul>
<li>例如：内存资源不足等。</li>
<li>对于这种错误，程序基本无能为力，除了退出运行外别无选择，它是由 Java 虚拟机抛出的。</li>
</ul>
</li>
<li>Exception（异常），表示需要捕捉或者需要程序进行处理的异常，它处理的是因为程序设计的瑕疵而引起的问题或者在外的输入等引起的一般性问题，是程序必须处理的。Exception 又分为运行时异常，受检查异常。<ul>
<li>RuntimeException(运行时异常)，表示无法让程序恢复的异常，导致的原因通常是因为执行了错误的操作，建议终止逻辑，因此，编译器不检查这些异常。</li>
<li>CheckedException(受检查异常)，是表示程序可以处理的异常，也即表示程序可以修复（由程序自己接受异常并且做出处理），所以称之为受检查异常。</li>
</ul>
</li>
</ul>
<p>🦅 <strong>异常的使用的注意地方？</strong></p>
<p>神作《Effective Java》中对异常的使用给出了以下指导原则：</p>
<blockquote>
<p>艿艿：该书，十分推荐去阅读。</p>
</blockquote>
<ul>
<li>不要将异常处理用于正常的控制流（设计良好的 API 不应该强迫它的调用者为了正常的控制流而使用异常）。</li>
<li>对可以恢复的情况使用受检异常，对编程错误使用运行时异常。</li>
<li>避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）。</li>
<li>优先使用标准的异常。</li>
<li>每个方法抛出的异常都要有文档。</li>
<li>保持异常的原子性</li>
<li>不要在 <code>catch</code> 中忽略掉捕获到的异常。</li>
</ul>
<p>🦅 <strong>Throwable 类常用方法？</strong></p>
<ul>
<li><code>#getMessage()</code> 方法：返回异常发生时的详细信息。</li>
<li><code>#getCause()</code> 方法：获得导致当前 Throwable 异常的 Throwable 异常。</li>
<li><code>#getStackTrace()</code>方法：获得 Throwable 对象封装的异常信息。<ul>
<li><code>#printStackTrace()</code> 方法：在控制台上打印。</li>
</ul>
</li>
</ul>
<p>🦅 <strong>请列出 5 个运行时异常？</strong></p>
<ul>
<li>NullPointerException</li>
<li>IndexOutOfBoundsException</li>
<li>ClassCastException</li>
<li>ArrayStoreException</li>
<li>BufferOverflowException</li>
</ul>
<p>🦅 <strong><code>throw</code> 与 <code>throws</code> 的区别 ？</strong></p>
<ul>
<li><code>throw</code> ，用于在程序中显式地抛出一个异常。</li>
<li><code>throws</code> ，用于指出在该方法中没有处理的异常。<strong>每个方法必须显式指明哪些异常没有处理，以便该方法的调用者可以预防可能发生的异常</strong>。最后，多个异常用逗号分隔。</li>
</ul>
<p>🦅 <strong>异常处理中 <code>finally</code> 语句块的重要性?</strong></p>
<p>不管程序是否发生了异常, <code>finally</code> 语句块都会被执行，甚至当没有<code>catch</code> 声明但抛出了一个异常时, <code>finally</code> 语句块也会被执行。</p>
<p><code>finally</code> 语句块通常用于释放资源, 如 I/O 缓冲区, 数据库连接等等。</p>
<p>🦅 <strong>异常被处理后异常对象会发生什么?</strong></p>
<blockquote>
<p>艿艿：这个问题有点奇怪，从网上找来的…</p>
</blockquote>
<p>异常对象会在下次 GC 执行时被回收。</p>
<h2 id="说说反射的用途及实现？"><a href="#说说反射的用途及实现？" class="headerlink" title="说说反射的用途及实现？"></a>说说反射的用途及实现？</h2><p>Java 反射机制主要提供了以下功能：</p>
<ul>
<li>在运行时构造一个类的对象。</li>
<li>判断一个类所具有的成员变量和方法。</li>
<li>调用一个对象的方法。</li>
<li>生成动态代理。</li>
</ul>
<p>反射的应用很多，很多框架都有用到：</p>
<ul>
<li>Spring 框架的 IoC 基于反射创建对象和设置依赖属性。</li>
<li>Spring MVC 的请求调用对应方法，也是通过反射。</li>
<li>JDBC 的 <code>Class#forName(String className)</code> 方法，也是使用反射。</li>
</ul>
<p>不了解 Java 反射的同学，可以看看 <a href="http://www.cnblogs.com/zhaopei/p/reflection.html">《什么是反射、反射可以做些什么》</a> 。</p>
<blockquote>
<p>对于大多数 Java 萌新，包括艿艿在内。不过后来发现，再难的 Java 知识，未来都需要变成我们的基础知识，嘻嘻。</p>
</blockquote>
<p>🦅 <strong>反射中，Class.forName 和 ClassLoader 区别？</strong></p>
<p>这两者，都可用来对类进行加载。差别在于：</p>
<ul>
<li><p><code>Class#forName(...)</code> 方法，除了将类的 <code>.class</code> 文件加载到JVM 中之外，还会对类进行解释，执行类中的 <code>static</code> 块。</p>
</li>
<li><p>ClassLoader 只干一件事情，就是将 <code>.class</code> 文件加载到 JVM 中，不会执行 <code>static</code> 中的内容，只有在 newInstance 才会去执行 <code>static</code> 块。</p>
<blockquote>
<p><code>Class#forName(name, initialize, loader)</code> 方法，带参函数也可控制是否加载 <code>static</code> 块，并且只有调用了newInstance 方法采用调用构造函数，创建类的对象。</p>
</blockquote>
</li>
</ul>
<p>详细的测试，可以看看 <a href="https://blog.csdn.net/qq_27093465/article/details/52262340">《Java 反射中，Class.forName 和ClassLoader 的区别(代码说话)》</a> 文章。</p>
<p>🦅 <strong>UnsupportedOperationException 是什么？</strong></p>
<p>UnsupportedOperationException ，是用于表明操作不支持的异常。</p>
<p>在 JDK 类中已被大量运用，在集合框架<code>java.util.Collections.UnmodifiableCollection</code> 将会在所有 add 和 remove 操作中抛出这个异常。</p>
<h2 id="什么是注解？"><a href="#什么是注解？" class="headerlink" title="什么是注解？"></a>什么是注解？</h2><p>直接看 <a href="https://www.jianshu.com/p/5cac4cb9be54">《深入浅出 Java 注解》</a> 。</p>
<p>如果胖友没有自己实现自定义的注解，千万一定马上去尝试写下。酱紫，我们会对注解，有更好且清晰的认识。</p>
<h2 id="什么时候用断言（assert）？"><a href="#什么时候用断言（assert）？" class="headerlink" title="什么时候用断言（assert）？"></a>什么时候用断言（<code>assert</code>）？</h2><p>断言，在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。</p>
<ul>
<li><p>一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。</p>
</li>
<li><p>断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为<code>true</code>；如果表达式的值为 <code>false</code> ，那么系统会报告一个AssertionError 错误。断言的使用如下面的代码所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">assert(a &gt; 0); &#x2F;&#x2F; throws an AssertionError if a &lt;&#x3D; 0<br></code></pre></td></tr></table></figure>

<ul>
<li>断言可以有两种形式：<ul>
<li><code>assert Expression1;</code> 。</li>
<li><code>assert Expression1 : Expression2;</code> 。</li>
<li>Expression1 应该总是产生一个布尔值。</li>
<li>Expression2 可以是得出一个值的任意表达式；这个值用于生成显示更多调试信息的字符串消息。</li>
</ul>
</li>
</ul>
</li>
<li><p>要在运行时启用断言，可以在启动 JVM 时使用 <code>-enableassertions</code> 或者 <code>-ea</code> 标记。要在运行时选择禁用断言，可以在启动 JVM 时使用 <code>-da</code> 或者 <code>-disableassertions</code> 标记。要在系统类中启用或禁用断言，可使用 <code>-esa</code> 或 <code>-dsa</code> 标记。还可以在包的基础上启用或者禁用断言。</p>
</li>
</ul>
<p>当然，实际场景下，我们会在 Spring 的源码中看到，它自己封装了 Assert 类，实现更方便的断言功能，并且，在生产环境下也启用。</p>
<p>另外，在单元测试中，也会使用自己封装的断言类，判断执行结果的正确与错误。</p>
<h2 id="Java-对象创建的方式？"><a href="#Java-对象创建的方式？" class="headerlink" title="Java 对象创建的方式？"></a>Java 对象创建的方式？</h2><ol>
<li>使用 <code>new</code> 关键字创建对象。</li>
<li>使用 Class 类的 newInstance 方法(反射机制)。</li>
<li>使用 Constructor 类的 newInstance 方法(反射机制)。</li>
<li>使用 clone 方法创建对象。</li>
<li>使用(反)序列化机制创建对象。</li>
</ol>
<h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>一写到 Java 基础，怎么说呢？就觉着概念挺多的，有点无从下手。实际情况下呢，艿艿自己面试的时候，很多问题可能都不太会问。那么，就把本文当成一种复习的文章吧，哈哈哈哈。</p>
<p>参考与推荐如下文章：</p>
<ul>
<li><a href="https://juejin.im/entry/5af2557c6fb9a07aa83eb59c">《2018 年最新 Java 面试题及答案整理》</a></li>
<li><a href="http://www.ituring.com.cn/article/507089">《32 道常见的 Java 基础面试题》</a></li>
<li><a href="http://www.n35n.com/2017/07/JAVA%E6%80%BB%E7%BB%93/">《Java 总结》</a></li>
<li><a href="https://github.com/Snailclimb/JavaGuide/blob/3dc5234d3a77d134e4768b17cc864c4cc1030e41/Java%E7%9B%B8%E5%85%B3/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md">《Java 基础知识》</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/java-interview-bible/basic-concept.html">Java 面试宝典</a></li>
</ul>
]]></content>
      <categories>
        <category>Java【基础】</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Java【基础】</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis 面试题</title>
    <url>/2016/10/12/%E7%B2%BE%E5%B0%BD%20MyBatis%20%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="精尽-MyBatis-面试题"><a href="#精尽-MyBatis-面试题" class="headerlink" title="精尽 MyBatis 面试题"></a>精尽 MyBatis 面试题</h1><p>以下面试题，基于网络整理，和自己编辑。具体参考的文章，会在文末给出所有的链接。</p>
<p>如果胖友有自己的疑问，欢迎在星球提问，我们一起整理吊吊的 MyBatis 面试题的大保健。</p>
<p>而题目的难度，艿艿尽量按照从容易到困难的顺序，逐步下去。</p>
<h2 id="MyBatis-编程步骤"><a href="#MyBatis-编程步骤" class="headerlink" title="MyBatis 编程步骤"></a>MyBatis 编程步骤</h2><ol>
<li>创建 SqlSessionFactory 对象。</li>
<li>通过 SqlSessionFactory 获取 SqlSession 对象。</li>
<li>通过 SqlSession 获得 Mapper 代理对象。</li>
<li>通过 Mapper 代理对象，执行数据库操作。</li>
<li>执行成功，则使用 SqlSession 提交事务。</li>
<li>执行失败，则使用 SqlSession 回滚事务。</li>
<li>最终，关闭会话。</li>
</ol>
<h2 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{} 和 ${} 的区别是什么？"></a><code>#&#123;&#125;</code> 和 <code>$&#123;&#125;</code> 的区别是什么？</h2><p><code>$&#123;&#125;</code> 是 Properties 文件中的变量占位符，它可以用于 XML 标签属性值和 SQL 内部，属于<strong>字符串替换</strong>。例如将 <code>$&#123;driver&#125;</code> 会被静态替换为 <code>com.mysql.jdbc.Driver</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dataSource type&#x3D;&quot;UNPOOLED&quot;&gt;<br>    &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;<br>    &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;<br>    &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;<br>&lt;&#x2F;dataSource&gt;<br></code></pre></td></tr></table></figure>

<p><code>$&#123;&#125;</code> 也可以对传递进来的参数<strong>原样拼接</strong>在 SQL 中。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;select id&#x3D;&quot;getSubject3&quot; parameterType&#x3D;&quot;Integer&quot; resultType&#x3D;&quot;Subject&quot;&gt;<br>    SELECT * FROM subject<br>    WHERE id &#x3D; $&#123;id&#125;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>实际场景下，不推荐这么做。因为，可能有 SQL 注入的风险。</li>
</ul>
<hr>
<p><code>#&#123;&#125;</code> 是 SQL 的参数占位符，Mybatis 会将 SQL 中的 <code>#&#123;&#125;</code> 替换为 <code>?</code> 号，在 SQL 执行前会使用 PreparedStatement 的参数设置方法，按序给 SQL 的 <code>?</code> 号占位符设置参数值，比如 <code>ps.setInt(0, parameterValue)</code> 。 所以，<code>#&#123;&#125;</code> 是<strong>预编译处理</strong>，可以有效防止 SQL 注入，提高系统安全性。</p>
<hr>
<p>另外，<code>#&#123;&#125;</code> 和 <code>$&#123;&#125;</code> 的取值方式非常方便。例如：<code>#&#123;item.name&#125;</code> 的取值方式，为使用反射从参数对象中，获取 <code>item</code> 对象的 <code>name</code> 属性值，相当于 <code>param.getItem().getName()</code> 。</p>
<h2 id="当实体类中的属性名和表中的字段名不一样-，怎么办？"><a href="#当实体类中的属性名和表中的字段名不一样-，怎么办？" class="headerlink" title="当实体类中的属性名和表中的字段名不一样 ，怎么办？"></a>当实体类中的属性名和表中的字段名不一样 ，怎么办？</h2><p>第一种， 通过在查询的 SQL 语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;select id&#x3D;&quot;selectOrder&quot; parameterType&#x3D;&quot;Integer&quot; resultType&#x3D;&quot;Order&quot;&gt; <br>    SELECT order_id AS id, order_no AS orderno, order_price AS price <br>    FROM orders <br>    WHERE order_id &#x3D; #&#123;id&#125;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>这里，艿艿还有几点建议：<ul>
<li>1、数据库的关键字，统一使用大写，例如：<code>SELECT</code>、<code>AS</code>、<code>FROM</code>、<code>WHERE</code> 。</li>
<li>2、每 5 个查询字段换一行，保持整齐。</li>
<li>3、<code>,</code> 的后面，和 <code>=</code> 的前后，需要有空格，更加清晰。</li>
<li>4、<code>SELECT</code>、<code>FROM</code>、<code>WHERE</code> 等，单独一行，高端大气。</li>
</ul>
</li>
</ul>
<hr>
<p>第二种，是第一种的特殊情况。大多数场景下，数据库字段名和实体类中的属性名差，主要是前者为<strong>下划线风格</strong>，后者为<strong>驼峰风格</strong>。在这种情况下，可以直接配置如下，实现自动的下划线转驼峰的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;setting name&#x3D;&quot;logImpl&quot; value&#x3D;&quot;LOG4J&quot;&#x2F;&gt;<br>    &lt;setting name&#x3D;&quot;mapUnderscoreToCamelCase&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;<br>&lt;&#x2F;settings&gt;<br></code></pre></td></tr></table></figure>

<p>😈 也就说，约定大于配置。非常推荐！</p>
<hr>
<p>第三种，通过 <code>&lt;resultMap&gt;</code> 来映射字段名和实体类属性名的一一对应的关系。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;resultMap type&#x3D;&quot;me.gacl.domain.Order&quot; id&#x3D;”OrderResultMap”&gt; <br>    &lt;!–- 用 id 属性来映射主键字段 -–&gt; <br>    &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;order_id&quot;&gt; <br>    &lt;!–- 用 result 属性来映射非主键字段，property 为实体类属性名，column 为数据表中的属性 -–&gt; <br>    &lt;result property&#x3D;&quot;orderNo&quot; column &#x3D;&quot;order_no&quot; &#x2F;&gt; <br>    &lt;result property&#x3D;&quot;price&quot; column&#x3D;&quot;order_price&quot; &#x2F;&gt; <br>&lt;&#x2F;resultMap&gt;<br><br>&lt;select id&#x3D;&quot;getOrder&quot; parameterType&#x3D;&quot;Integer&quot; resultMap&#x3D;&quot;OrderResultMap&quot;&gt;<br>    SELECT * <br>    FROM orders <br>    WHERE order_id &#x3D; #&#123;id&#125;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>此处 <code>SELECT *</code> 仅仅作为示例只用，实际场景下，千万千万千万不要这么干。用多少字段，查询多少字段。</li>
<li>相比第一种，第三种的<strong>重用性</strong>会一些。</li>
</ul>
<h2 id="XML-映射文件中，除了常见的-select-insert-update-delete标-签之外，还有哪些标签？"><a href="#XML-映射文件中，除了常见的-select-insert-update-delete标-签之外，还有哪些标签？" class="headerlink" title="XML 映射文件中，除了常见的 select | insert | update | delete标 签之外，还有哪些标签？"></a>XML 映射文件中，除了常见的 select | insert | update | delete标 签之外，还有哪些标签？</h2><p>如下部分，可见 <a href="http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html">《MyBatis 文档 —— Mapper XML 文件》</a> ：</p>
<ul>
<li><p><code>&lt;cache /&gt;</code> 标签，给定命名空间的缓存配置。</p>
<ul>
<li><code>&lt;cache-ref /&gt;</code> 标签，其他命名空间缓存配置的引用。</li>
</ul>
</li>
<li><p><code>&lt;resultMap /&gt;</code> 标签，是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。</p>
</li>
<li><p><del>`` 标签，已废弃！老式风格的参数映射。内联参数是首选,这个元素可能在将来被移除，这里不会记录。</del></p>
</li>
<li><p><code>&lt;sql /&gt;</code>标签，可被其他语句引用的可重用语句块。</p>
<ul>
<li><code>&lt;include /&gt;</code> 标签，引用 <code>&lt;sql /&gt;</code> 标签的语句。</li>
</ul>
</li>
<li><p><code>&lt;selectKey /&gt;</code> 标签，不支持自增的主键生成策略标签。</p>
</li>
</ul>
<p>如下部分，可见 <a href="http://www.mybatis.org/mybatis-3/zh/dynamic-sql.html">《MyBatis 文档 —— 动态 SQL》</a> ：</p>
<ul>
<li><code>&lt;if /&gt;</code></li>
<li><code>&lt;choose /&gt;</code>、<code>&lt;when /&gt;</code>、<code>&lt;otherwise /&gt;</code></li>
<li><code>&lt;trim /&gt;</code>、<code>&lt;where /&gt;</code>、<code>&lt;set /&gt;</code></li>
<li><code>&lt;foreach /&gt;</code></li>
<li><code>&lt;bind /&gt;</code></li>
</ul>
<h2 id="Mybatis-动态-SQL-是做什么的？都有哪些动态-SQL-？能简述一下动态-SQL-的执行原理吗？"><a href="#Mybatis-动态-SQL-是做什么的？都有哪些动态-SQL-？能简述一下动态-SQL-的执行原理吗？" class="headerlink" title="Mybatis 动态 SQL 是做什么的？都有哪些动态 SQL ？能简述一下动态 SQL 的执行原理吗？"></a>Mybatis 动态 SQL 是做什么的？都有哪些动态 SQL ？能简述一下动态 SQL 的执行原理吗？</h2><ul>
<li>Mybatis 动态 SQL ，可以让我们在 XML 映射文件内，以 XML 标签的形式编写动态 SQL ，完成逻辑判断和动态拼接 SQL 的功能。</li>
<li>Mybatis 提供了 9 种动态 SQL 标签：<code>&lt;if /&gt;</code>、<code>&lt;choose /&gt;</code>、<code>&lt;when /&gt;</code>、<code>&lt;otherwise /&gt;</code>、<code>&lt;trim /&gt;</code>、<code>&lt;where /&gt;</code>、<code>&lt;set /&gt;</code>、<code>&lt;foreach /&gt;</code>、<code>&lt;bind /&gt;</code> 。</li>
<li>其执行原理为，使用 <strong>OGNL</strong> 的表达式，从 SQL 参数对象中计算表达式的值，根据表达式的值动态拼接 SQL ，以此来完成动态 SQL 的功能。</li>
</ul>
<p>如上的内容，更加详细的话，请看 <a href="http://www.mybatis.org/mybatis-3/zh/dynamic-sql.html">《MyBatis 文档 —— 动态 SQL》</a> 文档。</p>
<h2 id="最佳实践中，通常一个-XML-映射文件，都会写一个-Mapper-接口与之对应。请问，这个-Mapper-接口的工作原理是什么？Mapper-接口里的方法，参数不同时，方法能重载吗？"><a href="#最佳实践中，通常一个-XML-映射文件，都会写一个-Mapper-接口与之对应。请问，这个-Mapper-接口的工作原理是什么？Mapper-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="最佳实践中，通常一个 XML 映射文件，都会写一个 Mapper 接口与之对应。请问，这个 Mapper 接口的工作原理是什么？Mapper 接口里的方法，参数不同时，方法能重载吗？"></a>最佳实践中，通常一个 XML 映射文件，都会写一个 Mapper 接口与之对应。请问，这个 Mapper 接口的工作原理是什么？Mapper 接口里的方法，参数不同时，方法能重载吗？</h2><p>Mapper 接口，对应的关系如下：</p>
<ul>
<li>接口的全限名，就是映射文件中的 <code>&quot;namespace&quot;</code> 的值。</li>
<li>接口的方法名，就是映射文件中 MappedStatement 的 <code>&quot;id&quot;</code> 值。</li>
<li>接口方法内的参数，就是传递给 SQL 的参数。</li>
</ul>
<p>Mapper 接口是没有实现类的，当调用接口方法时，接口全限名 + 方法名拼接字符串作为 key 值，可唯一定位一个对应的 MappedStatement 。举例：<code>com.mybatis3.mappers.StudentDao.findStudentById</code> ，可以唯一找到 <code>&quot;namespace&quot;</code> 为 <code>com.mybatis3.mappers.StudentDao</code> 下面 <code>&quot;id&quot;</code> 为 <code>findStudentById</code> 的 MappedStatement 。</p>
<p>总结来说，在 Mybatis 中，每一个 <code>&lt;select /&gt;</code>、<code>&lt;insert /&gt;</code>、<code>&lt;update /&gt;</code>、<code>&lt;delete /&gt;</code> 标签，都会被解析为一个 MappedStatement 对象。</p>
<p>另外，Mapper 接口的实现类，通过 MyBatis 使用 <strong>JDK Proxy</strong> 自动生成其代理对象 Proxy ，而代理对象 Proxy 会拦截接口方法，从而“调用”对应的 MappedStatement 方法，最终执行 SQL ，返回执行结果。整体流程如下图：<a href="http://static2.iocoder.cn/images/MyBatis/2020_03_15/02.png"><img src="http://cdn.tuwenbin.vip/02.png" alt="流程"></a>流程</p>
<ul>
<li><p>其中，SqlSession 在调用 Executor 之前，会获得对应的 MappedStatement 方法。例如：<code>DefaultSqlSession#select(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler)</code> 方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; DefaultSqlSession.java<br><br>@Override<br>public void select(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler) &#123;<br>    try &#123;<br>        &#x2F;&#x2F; 获得 MappedStatement 对象<br>        MappedStatement ms &#x3D; configuration.getMappedStatement(statement);<br>        &#x2F;&#x2F; 执行查询<br>        executor.query(ms, wrapCollection(parameter), rowBounds, handler);<br>    &#125; catch (Exception e) &#123;<br>        throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);<br>    &#125; finally &#123;<br>        ErrorContext.instance().reset();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>完整的流程，胖友可以慢慢撸下 MyBatis 的源码。</li>
</ul>
</li>
</ul>
<hr>
<p>Mapper 接口里的方法，是不能重载的，因为是<strong>全限名 + 方法名</strong>的保存和寻找策略。😈 所以有时，想个 Mapper 接口里的方法名，还是蛮闹心的，嘿嘿。</p>
<h2 id="Mapper-接口绑定有几种实现方式-分别是怎么实现的"><a href="#Mapper-接口绑定有几种实现方式-分别是怎么实现的" class="headerlink" title="Mapper 接口绑定有几种实现方式,分别是怎么实现的?"></a>Mapper 接口绑定有几种实现方式,分别是怎么实现的?</h2><p>接口绑定有三种实现方式：</p>
<p>第一种，通过 <strong>XML Mapper</strong> 里面写 SQL 来绑定。在这种情况下，要指定 XML 映射文件里面的 <code>&quot;namespace&quot;</code> 必须为接口的全路径名。</p>
<p>第二种，通过<strong>注解</strong>绑定，就是在接口的方法上面加上 <code>@Select</code>、<code>@Update</code>、<code>@Insert</code>、<code>@Delete</code> 注解，里面包含 SQL 语句来绑定。</p>
<p>第三种，是第二种的特例，也是通过<strong>注解</strong>绑定，在接口的方法上面加上 <code>@SelectProvider</code>、<code>@UpdateProvider</code>、<code>@InsertProvider</code>、<code>@DeleteProvider</code> 注解，通过 Java 代码，生成对应的动态 SQL 。</p>
<hr>
<p>实际场景下，最最最推荐的是<strong>第一种</strong>方式。因为，SQL 通过注解写在 Java 代码中，会非常杂乱。而写在 XML 中，更加有整体性，并且可以更加方便的使用 OGNL 表达式。</p>
<h2 id="Mybatis-的-XML-Mapper文件中，不同的-XML-映射文件，id-是否可以重复？"><a href="#Mybatis-的-XML-Mapper文件中，不同的-XML-映射文件，id-是否可以重复？" class="headerlink" title="Mybatis 的 XML Mapper文件中，不同的 XML 映射文件，id 是否可以重复？"></a>Mybatis 的 XML Mapper文件中，不同的 XML 映射文件，id 是否可以重复？</h2><p>不同的 XML Mapper 文件，如果配置了 <code>&quot;namespace&quot;</code> ，那么 id 可以重复；如果没有配置 <code>&quot;namespace&quot;</code> ，那么 id 不能重复。毕竟<code>&quot;namespace&quot;</code> 不是必须的，只是最佳实践而已。</p>
<p>原因就是，<code>namespace + id</code> 是作为 <code>Map&lt;String, MappedStatement&gt;</code> 的 key 使用的。如果没有 <code>&quot;namespace&quot;</code>，就剩下 id ，那么 id 重复会导致数据互相覆盖。如果有了 <code>&quot;namespace&quot;</code>，自然 id 就可以重复，<code>&quot;namespace&quot;</code>不同，<code>namespace + id</code> 自然也就不同。</p>
<h2 id="如何获取自动生成的-主-键值"><a href="#如何获取自动生成的-主-键值" class="headerlink" title="如何获取自动生成的(主)键值?"></a>如何获取自动生成的(主)键值?</h2><p>不同的数据库，获取自动生成的(主)键值的方式是不同的。</p>
<p>MySQL 有两种方式，但是<strong>自增主键</strong>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 方式一，使用 useGeneratedKeys + keyProperty 属性<br>&lt;insert id&#x3D;&quot;insert&quot; parameterType&#x3D;&quot;Person&quot; useGeneratedKeys&#x3D;&quot;true&quot; keyProperty&#x3D;&quot;id&quot;&gt;<br>    INSERT INTO person(name, pswd)<br>    VALUE (#&#123;name&#125;, #&#123;pswd&#125;)<br>&lt;&#x2F;insert&gt;<br>    <br>&#x2F;&#x2F; 方式二，使用 &#96;&lt;selectKey &#x2F;&gt;&#96; 标签<br>&lt;insert id&#x3D;&quot;insert&quot; parameterType&#x3D;&quot;Person&quot;&gt;<br>    &lt;selectKey keyProperty&#x3D;&quot;id&quot; resultType&#x3D;&quot;long&quot; order&#x3D;&quot;AFTER&quot;&gt;<br>        SELECT LAST_INSERT_ID()<br>    &lt;&#x2F;selectKey&gt;<br>        <br>    INSERT INTO person(name, pswd)<br>    VALUE (#&#123;name&#125;, #&#123;pswd&#125;)<br>&lt;&#x2F;insert&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>其中，<strong>方式一</strong>较为常用。</li>
</ul>
<hr>
<p>Oracle 有两种方式，<strong>序列</strong>和<strong>触发器</strong>。因为艿艿自己不了解 Oracle ，所以问了银行的朋友，他们是使用<strong>序列</strong>。而基于<strong>序列</strong>，根据 <code>&lt;selectKey /&gt;</code> 执行的时机，也有两种方式，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 这个是创建表的自增序列<br>CREATE SEQUENCE student_sequence<br>INCREMENT BY 1<br>NOMAXVALUE<br>NOCYCLE<br>CACHE 10;<br><br>&#x2F;&#x2F; 方式一，使用 &#96;&lt;selectKey &#x2F;&gt;&#96; 标签 + BEFORE<br>&lt;insert id&#x3D;&quot;add&quot; parameterType&#x3D;&quot;Student&quot;&gt;<br>　　&lt;selectKey keyProperty&#x3D;&quot;student_id&quot; resultType&#x3D;&quot;int&quot; order&#x3D;&quot;BEFORE&quot;&gt;<br>      select student_sequence.nextval FROM dual<br>    &lt;&#x2F;selectKey&gt;<br>    <br>     INSERT INTO student(student_id, student_name, student_age)<br>     VALUES (#&#123;student_id&#125;,#&#123;student_name&#125;,#&#123;student_age&#125;)<br>&lt;&#x2F;insert&gt;<br><br>&#x2F;&#x2F; 方式二，使用 &#96;&lt;selectKey &#x2F;&gt;&#96; 标签 + AFTER<br>&lt;insert id&#x3D;&quot;save&quot; parameterType&#x3D;&quot;com.threeti.to.ZoneTO&quot; &gt;<br>    &lt;selectKey resultType&#x3D;&quot;java.lang.Long&quot; keyProperty&#x3D;&quot;id&quot; order&#x3D;&quot;AFTER&quot; &gt;<br>      SELECT SEQ_ZONE.CURRVAL AS id FROM dual<br>    &lt;&#x2F;selectKey&gt;<br>    <br>    INSERT INTO TBL_ZONE (ID, NAME ) <br>    VALUES (SEQ_ZONE.NEXTVAL, #&#123;name,jdbcType&#x3D;VARCHAR&#125;)<br>&lt;&#x2F;insert&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>他们使用第一种方式，没有具体原因，可能就没什么讲究吧。嘿嘿。</li>
</ul>
<p>至于为什么不用<strong>触发器</strong>呢？朋友描述如下：</p>
<blockquote>
<p>朋友：触发器不行啊，我们这边原来也有触发器，一有数据更改就会有问题了呀<br>艿艿：数据更改指的是？<br>朋友：就改线上某几条数据<br>艿艿：噢噢。手动改是吧？<br>朋友：不行~</p>
</blockquote>
<hr>
<p>当然，数据库还有 SQLServer、PostgreSQL、DB2、H2 等等，具体的方式，胖友自己 Google 下噢。</p>
<p>关于如何获取自动生成的(主)键值的<strong>原理</strong>，可以看看 <a href="http://svip.iocoder.cn/MyBatis/executor-3/">《精尽 MyBatis 源码分析 —— SQL 执行（三）之 KeyGenerator》</a> 。</p>
<h2 id="Mybatis-执行批量插入，能返回数据库主键列表吗？"><a href="#Mybatis-执行批量插入，能返回数据库主键列表吗？" class="headerlink" title="Mybatis 执行批量插入，能返回数据库主键列表吗？"></a>Mybatis 执行批量插入，能返回数据库主键列表吗？</h2><p>能，JDBC 都能做，Mybatis 当然也能做。</p>
<h2 id="在-Mapper-中如何传递多个参数"><a href="#在-Mapper-中如何传递多个参数" class="headerlink" title="在 Mapper 中如何传递多个参数?"></a>在 Mapper 中如何传递多个参数?</h2><p>第一种，使用 Map 集合，装载多个参数进行传递。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 调用方法<br>Map&lt;String, Object&gt; map &#x3D; new HashMap();<br>map.put(&quot;start&quot;, start);<br>map.put(&quot;end&quot;, end);<br>return studentMapper.selectStudents(map);<br><br>&#x2F;&#x2F; Mapper 接口<br>List&lt;Student&gt; selectStudents(Map&lt;String, Object&gt; map);<br><br>&#x2F;&#x2F; Mapper XML 代码<br>&lt;select id&#x3D;&quot;selectStudents&quot; parameterType&#x3D;&quot;Map&quot; resultType&#x3D;&quot;Student&quot;&gt;<br>    SELECT * <br>    FROM students <br>    LIMIT #&#123;start&#125;, #&#123;end&#125;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>显然，这不是一种优雅的方式。</li>
</ul>
<hr>
<p>第二种，保持传递多个参数，使用 <code>@Param</code> 注解。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 调用方法<br>return studentMapper.selectStudents(0, 10);<br><br>&#x2F;&#x2F; Mapper 接口<br>List&lt;Student&gt; selectStudents(@Param(&quot;start&quot;) Integer start, @Param(&quot;end&quot;) Integer end);<br><br>&#x2F;&#x2F; Mapper XML 代码<br>&lt;select id&#x3D;&quot;selectStudents&quot; resultType&#x3D;&quot;Student&quot;&gt;<br>    SELECT * <br>    FROM students <br>    LIMIT #&#123;start&#125;, #&#123;end&#125;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>推荐使用这种方式。</li>
</ul>
<hr>
<p>第三种，保持传递多个参数，不使用 <code>@Param</code> 注解。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 调用方法<br>return studentMapper.selectStudents(0, 10);<br><br>&#x2F;&#x2F; Mapper 接口<br>List&lt;Student&gt; selectStudents(Integer start, Integer end);<br><br>&#x2F;&#x2F; Mapper XML 代码<br>&lt;select id&#x3D;&quot;selectStudents&quot; resultType&#x3D;&quot;Student&quot;&gt;<br>    SELECT * <br>    FROM students <br>    LIMIT #&#123;param1&#125;, #&#123;param2&#125;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>其中，按照参数在方法方法中的位置，从 1 开始，逐个为 <code>#&#123;param1&#125;</code>、<code>#&#123;param2&#125;</code>、<code>#&#123;param3&#125;</code> 不断向下。</li>
</ul>
<h2 id="Mybatis-是否可以映射-Enum-枚举类？"><a href="#Mybatis-是否可以映射-Enum-枚举类？" class="headerlink" title="Mybatis 是否可以映射 Enum 枚举类？"></a>Mybatis 是否可以映射 Enum 枚举类？</h2><p>Mybatis 可以映射枚举类，对应的实现类为 EnumTypeHandler 或 EnumOrdinalTypeHandler 。</p>
<ul>
<li>EnumTypeHandler ，基于 <code>Enum.name</code> 属性( String )。<strong>默认</strong>。</li>
<li>EnumOrdinalTypeHandler ，基于 <code>Enum.ordinal</code> 属性( <code>int</code> )。可通过 <code>&lt;setting name=&quot;defaultEnumTypeHandler&quot; value=&quot;EnumOrdinalTypeHandler&quot; /&gt;</code> 来设置。</li>
</ul>
<p>😈 当然，实际开发场景，我们很少使用 Enum 类型，更加的方式是，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class Dog &#123;<br><br>    public static final int STATUS_GOOD &#x3D; 1;<br>    public static final int STATUS_BETTER &#x3D; 2;<br>    public static final int STATUS_BEST &#x3D; 3；<br>    <br>    private int status;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<p>并且，不单可以映射枚举类，Mybatis 可以映射任何对象到表的一列上。映射方式为自定义一个 TypeHandler 类，实现 TypeHandler 的<code>#setParameter(...)</code> 和 <code>#getResult(...)</code> 接口方法。</p>
<p>TypeHandler 有两个作用：</p>
<ul>
<li>一是，完成从 javaType 至 jdbcType 的转换。</li>
<li>二是，完成 jdbcType 至 javaType 的转换。</li>
</ul>
<p>具体体现为 <code>#setParameter(...)</code> 和 <code>#getResult(..)</code> 两个方法，分别代表设置 SQL 问号占位符参数和获取列查询结果。</p>
<p>关于 TypeHandler 的<strong>原理</strong>，可以看看 <a href="http://svip.iocoder.cn/MyBatis/type-package/">《精尽 MyBatis 源码分析 —— 类型模块》</a> 。</p>
<h2 id="Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？"></a>Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h2><p>Mybatis 有四种 Executor 执行器，分别是 SimpleExecutor、ReuseExecutor、BatchExecutor、CachingExecutor 。</p>
<ul>
<li>SimpleExecutor ：每执行一次 update 或 select 操作，就创建一个 Statement 对象，用完立刻关闭 Statement 对象。</li>
<li>ReuseExecutor ：执行 update 或 select 操作，以 SQL 作为key 查找<strong>缓存</strong>的 Statement 对象，存在就使用，不存在就创建；用完后，不关闭 Statement 对象，而是放置于缓存 <code>Map&lt;String, Statement&gt;</code> 内，供下一次使用。简言之，就是重复使用 Statement 对象。</li>
<li>BatchExecutor ：执行 update 操作（没有 select 操作，因为 JDBC 批处理不支持 select  操作），将所有 SQL 都添加到批处理中（通过 addBatch 方法），等待统一执行（使用 executeBatch 方法）。它缓存了多个  Statement 对象，每个 Statement 对象都是调用 addBatch 方法完毕后，等待一次执行 executeBatch 批处理。<strong>实际上，整个过程与 JDBC 批处理是相同</strong>。</li>
<li>CachingExecutor ：在上述的三个执行器之上，增加<strong>二级缓存</strong>的功能。</li>
</ul>
<hr>
<p>通过设置 <code>&lt;setting name=&quot;defaultExecutorType&quot; value=&quot;&quot;&gt;</code> 的 <code>&quot;value&quot;</code> 属性，可传入 SIMPLE、REUSE、BATCH 三个值，分别使用 SimpleExecutor、ReuseExecutor、BatchExecutor 执行器。</p>
<p>通过设置 <code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;&quot;</code> 的 <code>&quot;value&quot;</code> 属性为 <code>true</code> 时，创建 CachingExecutor 执行器。</p>
<hr>
<p>这块的源码解析，可见 <a href="http://svip.iocoder.cn/MyBatis/executor-1">《精尽 MyBatis 源码分析 —— SQL 执行（一）之 Executor》</a> 。</p>
<h2 id="MyBatis-如何执行批量插入"><a href="#MyBatis-如何执行批量插入" class="headerlink" title="MyBatis 如何执行批量插入?"></a>MyBatis 如何执行批量插入?</h2><p>首先，在 Mapper XML 编写一个简单的 Insert 语句。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;insert id&#x3D;&quot;insertUser&quot; parameterType&#x3D;&quot;String&quot;&gt; <br>    INSERT INTO users(name) <br>    VALUES (#&#123;value&#125;) <br>&lt;&#x2F;insert&gt;<br></code></pre></td></tr></table></figure>

<p>然后，然后在对应的 Mapper 接口中，编写映射的方法。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public interface UserMapper &#123;<br>    <br>    void insertUser(@Param(&quot;name&quot;) String name);<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后，调用该 Mapper 接口方法。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">private static SqlSessionFactory sqlSessionFactory;<br><br>@Test<br>public void testBatch() &#123;<br>    &#x2F;&#x2F; 创建要插入的用户的名字的数组<br>    List&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;();<br>    names.add(&quot;占小狼&quot;);<br>    names.add(&quot;朱小厮&quot;);<br>    names.add(&quot;徐妈&quot;);<br>    names.add(&quot;飞哥&quot;);<br><br>    &#x2F;&#x2F; 获得执行器类型为 Batch 的 SqlSession 对象，并且 autoCommit &#x3D; false ，禁止事务自动提交<br>    try (SqlSession session &#x3D; sqlSessionFactory.openSession(ExecutorType.BATCH, false)) &#123;<br>        &#x2F;&#x2F; 获得 Mapper 对象<br>        UserMapper mapper &#x3D; session.getMapper(UserMapper.class);<br>        &#x2F;&#x2F; 循环插入<br>        for (String name : names) &#123;<br>            mapper.insertUser(name);<br>        &#125;<br>        &#x2F;&#x2F; 提交批量操作<br>        session.commit();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>代码比较简单，胖友仔细看看。当然，还有另一种方式，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">INSERT INTO [表名]([列名],[列名]) <br>VALUES<br>([列值],[列值])),<br>([列值],[列值])),<br>([列值],[列值]));<br></code></pre></td></tr></table></figure>

<ul>
<li>对于这种方式，需要保证单条 SQL 不超过语句的最大限制 <code>max_allowed_packet</code> 大小，默认为 1 M 。</li>
</ul>
<p>这两种方式的性能对比，可以看看 [《<a href="https://www.jianshu.com/p/cce617be9f9e">实验]mybatis批量插入方式的比较》</a> 。</p>
<h2 id="介绍-MyBatis-的一级缓存和二级缓存的概念和实现原理？"><a href="#介绍-MyBatis-的一级缓存和二级缓存的概念和实现原理？" class="headerlink" title="介绍 MyBatis 的一级缓存和二级缓存的概念和实现原理？"></a>介绍 MyBatis 的一级缓存和二级缓存的概念和实现原理？</h2><p>内容有些长，直接参见 <a href="https://tech.meituan.com/mybatis_cache.html">《聊聊 MyBatis 缓存机制》</a> 一文。</p>
<hr>
<p>这块的源码解析，可见 <a href="http://svip.iocoder.cn/MyBatis/cache-package">《精尽 MyBatis 源码分析 —— 缓存模块》</a> 。</p>
<h2 id="Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h2><p>Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载。其中，association 指的就是<strong>一对一</strong>，collection 指的就是<strong>一对多查询</strong>。</p>
<p>在 Mybatis 配置文件中，可以配置 <code>&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot; /&gt;</code> 来启用延迟加载的功能。默认情况下，延迟加载的功能是<strong>关闭</strong>的。</p>
<hr>
<p>它的原理是，使用 CGLIB 或 Javassist( 默认 ) 创建目标对象的代理对象。当调用代理对象的延迟加载属性的 getting 方法时，进入拦截器方法。比如调用 <code>a.getB().getName()</code> 方法，进入拦截器的 <code>invoke(...)</code> 方法，发现 <code>a.getB()</code> 需要延迟加载时，那么就会单独发送事先保存好的查询关联 B 对象的 SQL ，把 B 查询上来，然后调用<code>a.setB(b)</code> 方法，于是 <code>a</code> 对象 <code>b</code> 属性就有值了，接着完成<code>a.getB().getName()</code> 方法的调用。这就是延迟加载的基本原理。</p>
<p>当然了，不光是 Mybatis，几乎所有的包括 Hibernate 在内，支持延迟加载的原理都是一样的。</p>
<hr>
<p>这块的源码解析，可见 <a href="http://svip.iocoder.cn/MyBatis/executor-5">《 精尽 MyBatis 源码分析 —— SQL 执行（五）之延迟加载》</a> 文章。</p>
<h2 id="Mybatis-能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"><a href="#Mybatis-能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。" class="headerlink" title="Mybatis 能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"></a>Mybatis 能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。</h2><blockquote>
<p>艿艿：这道题有点难度。理解倒是好理解，主要那块源码的实现，艿艿看的有点懵逼。大体的意思是懂的，但是一些细节没扣完。</p>
</blockquote>
<p>能，Mybatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询。</p>
<blockquote>
<p>艿艿：不过貌似，我自己实际开发中，还是比较喜欢自己去查询和拼接映射的数据。😈</p>
</blockquote>
<ul>
<li>多对一查询，其实就是一对一查询，只需要把 <code>selectOne(...)</code> 修改为 <code>selectList(...)</code> 即可。案例可见 <a href="https://blog.csdn.net/xzm_rainbow/article/details/15336959">《MyBatis：多对一表关系详解》</a> 。</li>
<li>多对多查询，其实就是一对多查询，只需要把 <code>#selectOne(...)</code> 修改为 <code>selectList(...)</code> 即可。案例可见 <a href="https://blog.csdn.net/eson_15/article/details/51655188">《【MyBatis学习10】高级映射之多对多查询》</a> 。</li>
</ul>
<hr>
<p>关联对象查询，有两种实现方式：</p>
<blockquote>
<p>艿艿：所有的技术方案，即会有好处，又会有坏处。很难出现，一个完美的银弹方案。</p>
</blockquote>
<ul>
<li>一种是单独发送一个 SQL 去查询关联对象，赋给主对象，然后返回主对象。好处是多条 SQL 分开，相对简单，坏处是发起的 SQL 可能会比较多。</li>
<li>另一种是使用嵌套查询，嵌套查询的含义为使用 <code>join</code> 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值。好处是只发一个 SQL 查询，就可以把主对象和其关联对象查出来，坏处是 SQL 可能比较复杂。</li>
</ul>
<p>那么问题来了，<code>join</code> 查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个呢？其去重复的原理是 <code>&lt;resultMap&gt;</code> 标签内的<code>&lt;id&gt;</code> 子标签，指定了唯一确定一条记录的 <code>id</code> 列。Mybatis 会根据<code>&lt;id&gt;</code> 列值来完成 100 条记录的去重复功能，<code>&lt;id&gt;</code> 可以有多个，代表了联合主键的语意。</p>
<p>同样主对象的关联对象，也是根据这个原理去重复的。尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。例如：下面 <code>join</code> 查询出来6条记录，一、二列是 Teacher 对象列，第三列为 Student 对象列。Mybatis 去重复处理后，结果为 1 个老师和 6 个学生，而不是 6 个老师和 6 个学生。</p>
<table>
<thead>
<tr>
<th>t_id</th>
<th>t_name</th>
<th>s_id</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>teacher</td>
<td>38</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>39</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>40</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>41</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>42</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>43</td>
</tr>
</tbody></table>
<h2 id="简述-Mybatis-的插件运行原理？以及如何编写一个插件？"><a href="#简述-Mybatis-的插件运行原理？以及如何编写一个插件？" class="headerlink" title="简述 Mybatis 的插件运行原理？以及如何编写一个插件？"></a>简述 Mybatis 的插件运行原理？以及如何编写一个插件？</h2><p>Mybatis 仅可以编写针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor 这 4 种接口的插件。</p>
<p>Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 <code>#invoke(...)</code>方法。当然，只会拦截那些你指定需要拦截的方法。</p>
<hr>
<p>编写一个 MyBatis 插件的步骤如下：</p>
<ol>
<li>首先，实现 Mybatis 的 Interceptor 接口，并实现 <code>#intercept(...)</code> 方法。</li>
<li>然后，在给插件编写注解，指定要拦截哪一个接口的哪些方法即可</li>
<li>最后，在配置文件中配置你编写的插件。</li>
</ol>
<p>具体的，可以参考 <a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#plugins">《MyBatis 官方文档 —— 插件》</a> 。</p>
<hr>
<p>插件的详细解析，可以看看 <a href="http://svip.iocoder.cn/MyBatis/plugin-1">《精尽 MyBatis 源码分析 —— 插件体系（一）之原理》</a> 。</p>
<h2 id="Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>Mybatis 是如何进行分页的？分页插件的原理是什么？</h2><p>Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的<strong>内存分页</strong>，而非<strong>数据库分页</strong>。</p>
<p>所以，实际场景下，不适合直接使用 MyBatis 原有的 RowBounds 对象进行分页。而是使用如下两种方案：</p>
<ul>
<li>在 SQL 内直接书写带有数据库分页的参数来完成数据库分页功能</li>
<li>也可以使用分页插件来完成数据库分页。</li>
</ul>
<p>这两者都是基于数据库分页，差别在于前者是工程师<strong>手动</strong>编写分页条件，后者是插件<strong>自动</strong>添加分页条件。</p>
<hr>
<p>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义分页插件。在插件的拦截方法内，拦截待执行的 SQL ，然后重写 SQL ，根据dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<p>举例：<code>SELECT * FROM student</code> ，拦截 SQL 后重写为：<code>select * FROM student LIMI 0，10</code> 。</p>
<p>目前市面上目前使用比较广泛的 MyBatis 分页插件有：</p>
<ul>
<li><a href="https://github.com/pagehelper/Mybatis-PageHelper">Mybatis-PageHelper</a></li>
<li><a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a></li>
</ul>
<p>从现在看来，<a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a> 逐步使用的更加广泛。</p>
<p>关于 MyBatis 分页插件的原理深入，可以看看 <a href="http://svip.iocoder.cn/MyBatis/plugin-2">《精尽 MyBatis 源码分析 —— 插件体系（二）之 PageHelper》</a> 。</p>
<h2 id="MyBatis-与-Hibernate-有哪些不同？"><a href="#MyBatis-与-Hibernate-有哪些不同？" class="headerlink" title="MyBatis 与 Hibernate 有哪些不同？"></a>MyBatis 与 Hibernate 有哪些不同？</h2><p>Mybatis 和 Hibernate 不同，它<strong>不完全是</strong>一个 ORM 框架，因为MyBatis 需要程序员自己编写 SQL 语句。不过 MyBatis 可以通过 XML 或注解方式灵活配置要运行的 SQL 语句，并将 Java 对象和 SQL 语句映射生成最终执行的 SQL ，最后将 SQL 执行的结果再映射生成 Java 对象。</p>
<p>Mybatis 学习门槛低，简单易学，程序员直接编写原生态 SQL ，可严格控制 SQL 执行性能，灵活度高。但是灵活的前提是 MyBatis 无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套 SQL 映射文件，工作量大。</p>
<p>Hibernate 对象/关系映射能力强，数据库无关性好。如果用 Hibernate 开发可以节省很多代码，提高效率。但是  Hibernate 的缺点是学习门槛高，要精通门槛更高，而且怎么设计 O/R 映射，在性能和对象模型之间如何权衡，以及怎样用好  Hibernate 需要具有很强的经验和能力才行。 </p>
<p>总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。简单总结如下：</p>
<ul>
<li>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取。</li>
<li>Mybatis 属于半自动 ORM 映射工具，在查询关联对象或关联集合对象时，需要手动编写 SQL 来完成。</li>
</ul>
<p>另外，在 <a href="https://www.jianshu.com/p/96171e647885">《浅析 Mybatis 与 Hibernate 的区别与用途》</a> 文章，也是写的非常不错的。</p>
<p>当然，实际上，MyBatis 也可以搭配自动生成代码的工具，提升开发效率，还可以使用 <a href="http://mp.baomidou.com/">MyBatis-Plus</a> 框架，已经内置常用的 SQL 操作，也是非常不错的。</p>
<h2 id="JDBC-编程有哪些不足之处，MyBatis是如何解决这些问题的？"><a href="#JDBC-编程有哪些不足之处，MyBatis是如何解决这些问题的？" class="headerlink" title="JDBC 编程有哪些不足之处，MyBatis是如何解决这些问题的？"></a>JDBC 编程有哪些不足之处，MyBatis是如何解决这些问题的？</h2><p>问题一：SQL 语句写在代码中造成代码不易维护，且代码会比较混乱。</p>
<p>解决方式：将 SQL 语句配置在 Mapper XML 文件中，与 Java 代码分离。</p>
<hr>
<p>问题二：根据参数不同，拼接不同的 SQL 语句非常麻烦。例如 SQL 语句的 WHERE 条件不一定，可能多也可能少，占位符需要和参数一一对应。 </p>
<p>解决方式：MyBatis 提供 <code>&lt;where /&gt;</code>、<code>&lt;if /&gt;</code> 等等动态语句所需要的标签，并支持 OGNL 表达式，简化了动态 SQL 拼接的代码，提升了开发效率。</p>
<hr>
<p>问题三，对结果集解析麻烦，SQL 变化可能导致解析代码变化，且解析前需要遍历。</p>
<p>解决方式：Mybatis 自动将 SQL 执行结果映射成 Java 对象。</p>
<hr>
<p>问题四，数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。</p>
<p>解决方式：在 <code>mybatis-config.xml</code> 中，配置数据链接池，使用连接池管理数据库链接。</p>
<p>😈 当然，即使不使用 MyBatis ，也可以使用数据库连接池。<br>另外，MyBatis 默认提供了数据库连接池的实现，只是说，因为其它开源的数据库连接池性能更好，所以一般很少使用 MyBatis 自带的连接池实现。</p>
<h2 id="Mybatis-比-IBatis-比较大的几个改进是什么？"><a href="#Mybatis-比-IBatis-比较大的几个改进是什么？" class="headerlink" title="Mybatis 比 IBatis 比较大的几个改进是什么？"></a>Mybatis 比 IBatis 比较大的几个改进是什么？</h2><blockquote>
<p>这是一个选择性了解的问题，因为可能现在很多面试官，都没用过 IBatis 框架。</p>
</blockquote>
<ol>
<li>有接口绑定，包括注解绑定 SQL 和 XML 绑定 SQL 。</li>
<li>动态 SQL 由原来的节点配置变成 OGNL 表达式。</li>
<li>在一对一或一对多的时候，引进了 <code>association</code> ，在一对多的时候，引入了 <code>collection</code>节点，不过都是在 <code>&lt;resultMap /&gt;</code> 里面配置。</li>
</ol>
<h2 id="Mybatis-映射文件中，如果-A-标签通过-include-引用了B标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在A标签的前面？"><a href="#Mybatis-映射文件中，如果-A-标签通过-include-引用了B标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在A标签的前面？" class="headerlink" title="Mybatis 映射文件中，如果 A 标签通过 include 引用了B标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在A标签的前面？"></a>Mybatis 映射文件中，如果 A 标签通过 include 引用了B标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在A标签的前面？</h2><blockquote>
<p>老艿艿：这道题目，已经和源码实现，有点关系了。</p>
</blockquote>
<p>虽然 Mybatis 解析 XML 映射文件是<strong>按照顺序</strong>解析的。但是，被引用的 B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。<strong>也就是说，无需按照顺序，进行定义</strong>。</p>
<p>原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为<strong>未解析状态</strong>。然后，继续解析余下的标签，包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析A标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</p>
<p>可能有一些绕，胖友可以看看 <a href="http://svip.iocoder.cn/MyBatis/builder-package-1">《精尽 MyBatis 源码解析 —— MyBatis 初始化（一）之加载 mybatis-config》</a> 。</p>
<p>此处，我们在引申一个问题，Spring IOC 中，存在互相依赖的 Bean 对象，该如何解决呢？答案见 <a href="http://svip.iocoder.cn/Spring/IoC-get-Bean-createBean-5/">《【死磕 Spring】—— IoC 之加载 Bean：创建 Bean（五）之循环依赖处理》</a> 。</p>
<h2 id="简述-Mybatis-的-XML-映射文件和-Mybatis-内部数据结构之间的映射关系？"><a href="#简述-Mybatis-的-XML-映射文件和-Mybatis-内部数据结构之间的映射关系？" class="headerlink" title="简述 Mybatis 的 XML 映射文件和 Mybatis 内部数据结构之间的映射关系？"></a>简述 Mybatis 的 XML 映射文件和 Mybatis 内部数据结构之间的映射关系？</h2><blockquote>
<p>老艿艿：这道题目，已经和源码实现，有点关系了。</p>
</blockquote>
<p>Mybatis 将所有 XML 配置信息都封装到 All-In-One 重量级对象Configuration内部。</p>
<p>在 XML Mapper 文件中：</p>
<ul>
<li><code>&lt;parameterMap&gt;</code> 标签，会被解析为 ParameterMap 对象，其每个子元素会被解析为 ParameterMapping 对象。</li>
<li><code>&lt;resultMap&gt;</code> 标签，会被解析为 ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。</li>
<li>每一个 <code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code> 标签，均会被解析为一个 MappedStatement 对象，标签内的 SQL 会被解析为一个 BoundSql 对象。</li>
</ul>
<h2 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h2><p>参考与推荐如下文章：</p>
<ul>
<li>祖大俊 <a href="https://my.oschina.net/zudajun/blog/747682">《Mybatis3.4.x技术内幕（二十三）：Mybatis面试问题集锦（大结局）》</a></li>
<li>Java3y <a href="https://segmentfault.com/a/1190000013678579">《Mybatis 常见面试题》</a></li>
<li>Homiss <a href="https://github.com/Homiss/Java-interview-questions/blob/master/%E6%A1%86%E6%9E%B6/MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98.md">《MyBatis 面试题》</a></li>
</ul>
]]></content>
      <categories>
        <category>MyBatis</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>精尽 Spring Boot 面试题</title>
    <url>/2016/10/12/%E7%B2%BE%E5%B0%BD%20Spring%20Boot%20%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="精尽-Spring-Boot-面试题"><a href="#精尽-Spring-Boot-面试题" class="headerlink" title="精尽 Spring Boot 面试题"></a>精尽 Spring Boot 面试题</h1><p>以下面试题，基于网络整理，和自己编辑。具体参考的文章，会在文末给出所有的链接。</p>
<p>如果胖友有自己的疑问，欢迎在星球提问，我们一起整理吊吊的 Spring Boot 面试题的大保健。</p>
<p>而题目的难度，艿艿尽量按照从容易到困难的顺序，逐步下去。</p>
<p>在内容上，我们会分成两大块：</p>
<ul>
<li>核心技术篇，分享 Spring Boot 的核心技术相关的内容。</li>
<li>整合篇，分享 Spring Boot 整合一些框架的面试题，例如 JPA 如何集成到 Spring Boot 中。</li>
</ul>
<h1 id="核心技术篇"><a href="#核心技术篇" class="headerlink" title="核心技术篇"></a>核心技术篇</h1><h2 id="Spring-Boot-是什么？"><a href="#Spring-Boot-是什么？" class="headerlink" title="Spring Boot 是什么？"></a>Spring Boot 是什么？</h2><p><a href="https://github.com/spring-projects/spring-boot">Spring Boot</a> 是 Spring 的<strong>子项目</strong>，正如其名字，提供 Spring 的引导( <strong>Boot</strong> )的功能。</p>
<p>通过 Spring Boot ，我们开发者可以快速配置 Spring 项目，引入各种 Spring MVC、Spring  Transaction、Spring AOP、MyBatis 等等框架，而无需不断重复编写繁重的 Spring 配置，降低了 Spring  的使用成本。</p>
<blockquote>
<p>艿艿：犹记当年，Spring XML 为主的时代，大晚上各种搜索 Spring 的配置，苦不堪言。现在有了 Spring Boot 之后，生活真美好。</p>
</blockquote>
<p>Spring Boot 提供了各种 Starter 启动器，提供标准化的默认配置。例如：</p>
<ul>
<li><a href="https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web/2.1.1.RELEASE"><code>spring-boot-starter-web</code></a> 启动器，可以快速配置 Spring MVC 。</li>
<li><a href="https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter/1.3.2"><code>mybatis-spring-boot-starter</code></a> 启动器，可以快速配置 MyBatis 。 </li>
</ul>
<p>并且，Spring Boot 基本已经一统 Java 项目的开发，大量的开源项目都实现了其的 Starter 启动器。例如：</p>
<ul>
<li><a href="https://github.com/apache/incubator-dubbo-spring-boot-project"><code>incubator-dubbo-spring-boot-project</code></a> 启动器，可以快速配置 Dubbo 。</li>
<li><a href="https://github.com/maihaoche/rocketmq-spring-boot-starter"><code>rocketmq-spring-boot-starter</code></a> 启动器，可以快速配置 RocketMQ 。</li>
</ul>
<h2 id="Spring-Boot-提供了哪些核心功能？"><a href="#Spring-Boot-提供了哪些核心功能？" class="headerlink" title="Spring Boot 提供了哪些核心功能？"></a>Spring Boot 提供了哪些核心功能？</h2><ul>
<li><p>1、独立运行 Spring 项目</p>
<p>  Spring Boot 可以以 jar 包形式独立运行，运行一个 Spring Boot 项目只需要通过 <code>java -jar xx.jar</code> 来运行。</p>
</li>
<li><p>2、内嵌 Servlet 容器</p>
<p>  Spring Boot 可以选择内嵌 Tomcat、Jetty 或者 Undertow，这样我们无须以 war 包形式部署项目。</p>
<blockquote>
<p>第 2 点是对第 1 点的补充，在 Spring Boot 未出来的时候，大多数 Web 项目，是打包成 war 包，部署到 Tomcat、Jetty 等容器。</p>
</blockquote>
</li>
<li><p>3、提供 Starter 简化 Maven 配置</p>
<p>  Spring 提供了一系列的 starter pom 来简化 Maven 的依赖加载。例如，当你使用了 <code>spring-boot-starter-web</code> ，会自动加入如下依赖：<img src="http://cdn.tuwenbin.vip/01-1601209309189.jpg" alt="01"><code>spring-boot-starter-web</code> 的 pom 文件</p>
</li>
<li><p>4、<a href="https://www.jianshu.com/p/ddb6e32e3faf">自动配置 Spring Bean</a></p>
<p>  Spring Boot 检测到特定类的存在，就会针对这个应用做一定的配置，进行自动配置 Bean ，这样会极大地减少我们要使用的配置。</p>
<p>  当然，Spring Boot 只考虑大多数的开发场景，并不是所有的场景，若在实际开发中我们需要配置Bean ，而 Spring Boot 没有提供支持，则可以自定义自动配置进行解决。</p>
</li>
<li><p>5、<a href="https://blog.csdn.net/wangshuang1631/article/details/72810412">准生产的应用监控</a></p>
<p>  Spring Boot 提供基于 HTTP、JMX、SSH 对运行时的项目进行监控。</p>
</li>
<li><p>6、无代码生成和 XML 配置</p>
<p>  Spring Boot 没有引入任何形式的代码生成，它是使用的 Spring 4.0 的条件 <code>@Condition</code> 注解以实现根据条件进行配置。同时使用了  Maven /Gradle 的<strong>依赖传递解析机制</strong>来实现 Spring 应用里面的自动配置。</p>
<blockquote>
<p>第 6 点是第 3 点的补充。</p>
</blockquote>
</li>
</ul>
<h2 id="Spring-Boot-有什么优缺点？"><a href="#Spring-Boot-有什么优缺点？" class="headerlink" title="Spring Boot 有什么优缺点？"></a>Spring Boot 有什么优缺点？</h2><blockquote>
<p>艿艿：任何技术栈，有优点必有缺点，没有银弹。</p>
<p>另外，这个问题的回答，我们是基于 <a href="https://blog.csdn.net/fly_zhyu/article/details/76407830">《Spring Boot浅谈(是什么/能干什么/优点和不足)》</a> 整理，所以胖友主要看下这篇文章。</p>
</blockquote>
<p><strong>Spring Boot 的优点</strong></p>
<blockquote>
<p>艿艿：优点和 <a href="http://svip.iocoder.cn/Spring-Boot/Interview/#">「Spring Boot 提供了哪些核心功能？」</a> 问题的答案，是比较重叠的。</p>
</blockquote>
<ul>
<li>1、使【编码】变简单。</li>
<li>2、使【配置】变简单。</li>
<li>3、使【部署】变简单。</li>
<li>4、使【监控】变简单。</li>
</ul>
<p><strong>Spring Boot 的缺点</strong></p>
<blockquote>
<p>艿艿：如下的缺点，基于 <a href="https://blog.csdn.net/fly_zhyu/article/details/76407830">《Spring Boot浅谈(是什么/能干什么/优点和不足)》</a>，考虑的出发点是把 Spring Boot 作为微服务的框架的选型的角度进行考虑。</p>
</blockquote>
<ul>
<li><p>1、没有提供相应的【服务发现和注册】的配套功能。</p>
<blockquote>
<p>艿艿：当然，实际上 Spring Boot 本身是不需要提供这样的功能。服务发现和注册的功能，是在 Spring Cloud 中进行提供。</p>
</blockquote>
</li>
<li><p>2、自身的 acturator 所提供的【监控功能】，也需要与现有的监控对接。</p>
</li>
<li><p>3、没有配套的【安全管控】方案。</p>
<blockquote>
<p>艿艿：关于这一点，艿艿也有点迷糊，Spring Security 是可以比较方便的集成到 Spring Boot 中，所以不晓得这里的【安全管控】的定义是什么。所以这一点，面试的时候回答，可以暂时先省略。</p>
</blockquote>
</li>
<li><p>4、对于 REST 的落地，还需要自行结合实际进行 URI 的规范化工作    </p>
<blockquote>
<p>艿艿：这个严格来说，不算缺点。本身，是规范的范畴。</p>
</blockquote>
</li>
</ul>
<p>所以，上面的缺点，严格来说可能不太适合在面试中回答。艿艿认为，Spring Boot 的缺点主要是，因为自动配置 Spring Bean  的功能，我们可能无法知道，哪些 Bean 被进行创建了。这个时候，如果我们想要自定义一些 Bean ，可能存在冲突，或者不知道实际注入的情况。</p>
<h2 id="Spring-Boot、Spring-MVC-和-Spring-有什么区别？"><a href="#Spring-Boot、Spring-MVC-和-Spring-有什么区别？" class="headerlink" title="Spring Boot、Spring MVC 和 Spring 有什么区别？"></a>Spring Boot、Spring MVC 和 Spring 有什么区别？</h2><p>Spring 的完整名字，应该是 Spring Framework 。它提供了多个模块，Spring IoC、Spring AOP、Spring MVC 等等。所以，Spring MVC 是 Spring Framework 众多模块中的一个。</p>
<p>而 Spring Boot 是构造在 Spring Framework 之上的 Boot 启动器，旨在更容易的配置一个 Spring 项目。</p>
<p>总结说来，如下图所示：<a href="http://static2.iocoder.cn/images/Spring/2018-12-26/02.png"><img src="http://cdn.tuwenbin.vip/02.png" alt="Spring Boot 对比 Spring MVC 对比 Spring ？"></a>Spring Boot 对比 Spring MVC 对比 Spring ？</p>
<h2 id="Spring-Boot-中的-Starter-是什么？"><a href="#Spring-Boot-中的-Starter-是什么？" class="headerlink" title="Spring Boot 中的 Starter 是什么？"></a>Spring Boot 中的 Starter 是什么？</h2><p>比较<strong>通俗</strong>的说法：</p>
<blockquote>
<p>FROM <a href="https://www.cnblogs.com/EasonJim/p/7615801.html">《Spring Boot 中 Starter 是什么》</a></p>
<p>比如我们要在 Spring Boot 中引入 Web MVC 的支持时，我们通常会引入这个模块 <code>spring-boot-starter-web</code> ，而这个模块如果解压包出来会发现里面什么都没有，只定义了一些 <strong>POM</strong> 依赖。如下图所示：<a href="http://static2.iocoder.cn/images/Spring/2018-12-26/03.png">![<code>spring-boot-starter-web</code>](D:\新建文件夹 (3)\03.png)</a><code>spring-boot-starter-web</code></p>
<p>经过研究，Starter 主要用来简化依赖用的。比如我们之前做MVC时要引入日志组件，那么需要去找到log4j的版本，然后引入，现在有了Starter之后，直接用这个之后，log4j就自动引入了，也不用关心版本这些问题。</p>
</blockquote>
<p>比较<strong>书名</strong>的说法：</p>
<blockquote>
<p>FROM <a href="http://www.importnew.com/27101.html">《Spring Boot Starter 介绍》</a></p>
<p>依赖管理是任何复杂项目的关键部分。以手动的方式来实现依赖管理不太现实，你得花更多时间，同时你在项目的其他重要方面能付出的时间就会变得越少。</p>
<p>Spring Boot Starter 就是为了解决这个问题而诞生的。Starter <strong>POM</strong> 是一组方便的依赖描述符，您可以将其包含在应用程序中。您可以获得所需的所有 Spring 和相关技术的一站式服务，无需通过示例代码搜索和复制粘贴依赖。</p>
</blockquote>
<h2 id="Spring-Boot-常用的-Starter-有哪些？"><a href="#Spring-Boot-常用的-Starter-有哪些？" class="headerlink" title="Spring Boot 常用的 Starter 有哪些？"></a>Spring Boot 常用的 Starter 有哪些？</h2><ul>
<li><code>spring-boot-starter-web</code> ：提供 Spring MVC + 内嵌的 Tomcat 。</li>
<li><code>spring-boot-starter-data-jpa</code> ：提供 Spring JPA + Hibernate 。</li>
<li><code>spring-boot-starter-data-redis</code> ：提供 Redis 。</li>
<li><code>mybatis-spring-boot-starter</code> ：提供 MyBatis 。</li>
</ul>
<h2 id="创建一个-Spring-Boot-Project-的最简单的方法是什么？"><a href="#创建一个-Spring-Boot-Project-的最简单的方法是什么？" class="headerlink" title="创建一个 Spring Boot Project 的最简单的方法是什么？"></a>创建一个 Spring Boot Project 的最简单的方法是什么？</h2><p>Spring Initializr 是创建 Spring Boot Projects 的一个很好的工具。打开 <code>&quot;https://start.spring.io/&quot;</code> 网站，我们可以看到 Spring Initializr 工具，如下图所示：</p>
<p><a href="http://static2.iocoder.cn/images/Spring/2018-12-26/04.png">![Spring Initializr](D:\新建文件夹 (3)\04.png)</a>Spring Initializr</p>
<ul>
<li>图中的每一个<strong>红线</strong>，都可以填写相应的配置。相信胖友都很熟悉，就不哔哔了。</li>
<li>点击生 GenerateProject ，生成 Spring Boot Project 。</li>
<li>将项目导入 IDEA ，记得选择现有的 Maven 项目。</li>
</ul>
<hr>
<p>当然，我们以前使用 IDEA 创建 Spring 项目的方式，也一样能创建 Spring Boot Project 。Spring Initializr 更多的是，提供一个便捷的工具。</p>
<h2 id="如何统一引入-Spring-Boot-版本？"><a href="#如何统一引入-Spring-Boot-版本？" class="headerlink" title="如何统一引入 Spring Boot 版本？"></a>如何统一引入 Spring Boot 版本？</h2><p><strong>目前有两种方式</strong>。</p>
<p>① 方式一：继承 <code>spring-boot-starter-parent</code> 项目。配置代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;parent&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;1.5.1.RELEASE&lt;&#x2F;version&gt;<br>&lt;&#x2F;parent&gt;<br></code></pre></td></tr></table></figure>

<p>② 方式二：导入 spring-boot-dependencies 项目依赖。配置代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dependencyManagement&gt;<br>    &lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>            &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;<br>            &lt;version&gt;1.5.1.RELEASE&lt;&#x2F;version&gt;<br>            &lt;type&gt;pom&lt;&#x2F;type&gt;<br>            &lt;scope&gt;import&lt;&#x2F;scope&gt;<br>        &lt;&#x2F;dependency&gt;<br>    &lt;&#x2F;dependencies&gt;<br>&lt;&#x2F;dependencyManagement&gt;<br></code></pre></td></tr></table></figure>

<p><strong>如何选择？</strong></p>
<p>因为一般我们的项目中，都有项目自己的 Maven parent 项目，所以【方式一】显然会存在冲突。所以实际场景下，推荐使用【方式二】。</p>
<p>详细的，推荐阅读 <a href="https://blog.csdn.net/rainbow702/article/details/55046298">《Spring Boot 不使用默认的 parent，改用自己的项目的 parent》</a> 文章。</p>
<p>另外，在使用 Spring Cloud 的时候，也可以使用这样的方式。</p>
<h2 id="运行-Spring-Boot-有哪几种方式？"><a href="#运行-Spring-Boot-有哪几种方式？" class="headerlink" title="运行 Spring Boot 有哪几种方式？"></a>运行 Spring Boot 有哪几种方式？</h2><ul>
<li>1、打包成 Fat Jar ，直接使用 <code>java -jar</code> 运行。目前主流的做法，推荐。</li>
<li>2、在 IDEA 或 Eclipse 中，直接运行应用的 Spring Boot 启动类的 <code>#main(String[] args)</code> 启动。适用于开发调试场景。</li>
<li>3、如果是 Web 项目，可以打包成 War 包，使用外部 Tomcat 或 Jetty 等容器。</li>
</ul>
<h2 id="如何打包-Spring-Boot-项目？"><a href="#如何打包-Spring-Boot-项目？" class="headerlink" title="如何打包 Spring Boot 项目？"></a>如何打包 Spring Boot 项目？</h2><p>通过引入 <code>spring-boot-maven-plugin</code> 插件，执行 <code>mvn clean package</code> 命令，将 Spring Boot 项目打成一个 Fat Jar 。后续，我们就可以直接使用 <code>java -jar</code> 运行。</p>
<p>关于 <code>spring-boot-maven-plugin</code> 插件，更多详细的可以看看 [《创建可执行 jar》](<a href="https://qbgbook.gitbooks.io/spring-boot-reference-guide-zh/II">https://qbgbook.gitbooks.io/spring-boot-reference-guide-zh/II</a>. Getting started/11.5. Creating an executable jar.html) 。</p>
<h2 id="如果更改内嵌-Tomcat-的端口？"><a href="#如果更改内嵌-Tomcat-的端口？" class="headerlink" title="如果更改内嵌 Tomcat 的端口？"></a>如果更改内嵌 Tomcat 的端口？</h2><ul>
<li><p>方式一，修改 <code>application.properties</code> 配置文件的 <code>server.port</code> 属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">server.port&#x3D;9090<br></code></pre></td></tr></table></figure>
</li>
<li><p>方式二，通过启动命令增加 <code>server.port</code> 参数进行修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">java -jar xxx.jar --server.port&#x3D;9090<br></code></pre></td></tr></table></figure>

</li>
</ul>
<p>当然，以上的方式，不仅仅适用于 Tomcat ，也适用于 Jetty、Undertow 等服务器。</p>
<h2 id="如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？"><a href="#如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？" class="headerlink" title="如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？"></a>如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？</h2><p>一共有三种方式，可以实现效果：</p>
<ul>
<li><p>【推荐】<code>spring-boot-devtools</code> 插件。注意，这个工具需要配置 IDEA 的自动编译。</p>
</li>
<li><p>Spring Loaded 插件。</p>
<blockquote>
<p>Spring Boot 2.X 后，官方宣布不再支持 Spring Loaded 插件 的更新，所以基本可以无视它了。</p>
</blockquote>
</li>
<li><p><a href="https://www.jianshu.com/p/bab43eaa4e14">JRebel</a> 插件，需要付费。</p>
</li>
</ul>
<p>关于如何使用 <code>spring-boot-devtools</code> 和 Spring Loaded 插件，胖友可以看看 <a href="https://segmentfault.com/a/1190000014488100">《Spring Boot 学习笔记：Spring Boot Developer Tools 与热部署》</a> 。</p>
<h2 id="Spring-Boot-的配置文件有哪几种格式？"><a href="#Spring-Boot-的配置文件有哪几种格式？" class="headerlink" title="Spring Boot 的配置文件有哪几种格式？"></a>Spring Boot 的配置文件有哪几种格式？</h2><p>Spring Boot 目前支持两种格式的配置文件：</p>
<ul>
<li><p><code>.properties</code> 格式。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">server.port &#x3D; 9090<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>.yaml</code> 格式。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">server:<br>    port: 9090<br></code></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<p>可能有胖友不了解 <strong>YAML 格式</strong>？</p>
<p>YAML 是一种人类可读的数据序列化语言，它通常用于配置文件。</p>
<ul>
<li><p>与 Properties 文件相比，如果我们想要在配置文件中添加复杂的属性 YAML 文件就更加<strong>结构化</strong>。从上面的示例，我们可以看出 YAML 具有<strong>分层</strong>配置数据。</p>
</li>
<li><p>当然 YAML 在 Spring 会存在一个缺陷，</p>
<p><code>@PropertySource</code></p>
<p> 注解不支持读取 YAML 配置文件，仅支持 Properties 配置文件。</p>
<ul>
<li>不过这个问题也不大，可以麻烦一点使用 <a href="https://blog.csdn.net/lafengwnagzi/article/details/74178374"><code>@Value</code></a> 注解，来读取 YAML 配置项。</li>
</ul>
</li>
</ul>
<p>实际场景下，艿艿相对比较喜欢使用 Properties 配置文件。个人喜欢~当然，YAML 已经越来越流行了。</p>
<h2 id="Spring-Boot-默认配置文件是什么？"><a href="#Spring-Boot-默认配置文件是什么？" class="headerlink" title="Spring Boot 默认配置文件是什么？"></a>Spring Boot 默认配置文件是什么？</h2><p>对于 Spring Boot 应用，默认的配置文件根目录下的 <strong>application</strong> 配置文件，当然可以是 Properties 格式，也可以是 YAML 格式。</p>
<p>可能有胖友说，我在网上看到面试题中，说还有一个根目录下的 <strong>bootstrap</strong> 配置文件。这个是 Spring Cloud 新增的启动配置文件，<a href="https://my.oschina.net/freeskyjs/blog/1843048">需要引入 <code>spring-cloud-context</code> 依赖后，才会进行加载</a>。它的特点和用途主要是：</p>
<blockquote>
<p>参考 <a href="https://my.oschina.net/neverforget/blog/1525947">《Spring Cloud 中配置文件名 bootstrap.yml 和 application.yml 区别》</a> 文章。</p>
</blockquote>
<ul>
<li>【特点】因为 bootstrap 由父 ApplicationContext 加载，比 application 优先加载。</li>
<li>【特点】因为 bootstrap 优先于 application 加载，所以不会被它覆盖。 </li>
<li>【用途】使用配置中心 Spring Cloud Config 时，需要在 bootstrap 中配置配置中心的地址，从而实现父 ApplicationContext 加载时，从配置中心拉取相应的配置到应用中。</li>
</ul>
<p>另外，<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html">《Appendix A. Common application properties》</a> 中，有 application 配置文件的通用属性列表。</p>
<h2 id="Spring-Boot-如何定义多套不同环境配置？"><a href="#Spring-Boot-如何定义多套不同环境配置？" class="headerlink" title="Spring Boot 如何定义多套不同环境配置？"></a>Spring Boot 如何定义多套不同环境配置？</h2><p>可以参考 <a href="https://blog.csdn.net/top_code/article/details/78570047">《Spring Boot 教程 - Spring Boot Profiles 实现多环境下配置切换》</a> 一文。</p>
<p>但是，需要考虑一个问题，生产环境的配置文件的安全性，显然我们不能且不应该把生产的配置放到项目的 Git 仓库中进行管理。那么应该怎么办呢？</p>
<ul>
<li>方案一，生产环境的配置文件放在生产环境的服务器中，以 <code>java -jar myproject.jar --spring.config.location=/xxx/yyy/application-prod.properties</code> 命令，设置 参数 <code>spring.config.location</code> 指向配置文件。</li>
<li>方案二，使用 Jenkins 在执行打包，配置上 Maven Profile 功能，使用服务器上的配置文件。😈 整体来说，和【方案一】的差异是，将配置文件打包进了 Jar 包中。</li>
<li>方案三，使用配置中心。</li>
</ul>
<h2 id="Spring-Boot-配置加载顺序？"><a href="#Spring-Boot-配置加载顺序？" class="headerlink" title="Spring Boot 配置加载顺序？"></a>Spring Boot 配置加载顺序？</h2><p>在 Spring Boot 中，除了我们常用的 application 配置文件之外，还有：</p>
<ul>
<li>系统环境变量</li>
<li>命令行参数</li>
<li>等等…</li>
</ul>
<p>参考 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html">《Externalized Configuration》</a> 文档，我们整理顺序如下：</p>
<ol>
<li><p><code>spring-boot-devtools</code>依赖的 <code>spring-boot-devtools.properties</code>配置文件。</p>
<blockquote>
<p>这个灰常小众，具体说明可以看看 <a href="https://blog.csdn.net/u011499747/article/details/71746325">《Spring Boot参考文档（12）开发者工具》</a> ，建议无视。</p>
</blockquote>
</li>
<li><p>单元测试上的 <code>@TestPropertySource</code>和 <code>@SpringBootTest</code>注解指定的参数。</p>
<blockquote>
<p>前者的优先级高于后者。可以看看 <a href="https://segmentfault.com/a/1190000010854607">《Spring、Spring Boot 和TestNG 测试指南 - @TestPropertySource》</a> 一文。</p>
</blockquote>
</li>
<li><p>命令行指定的参数。例如 <code>java -jar springboot.jar --server.port=9090</code> 。</p>
</li>
<li><p>命令行中的 <code>spring.application.json</code> 指定参数。例如 <code>java -Dspring.application.json=&#39;&#123;&quot;name&quot;:&quot;Java&quot;&#125;&#39; -jar springboot.jar</code> 。</p>
</li>
<li><p>ServletConfig 初始化参数。</p>
</li>
<li><p>ServletContext 初始化参数。</p>
</li>
<li><p>JNDI 参数。例如 <code>java:comp/env</code> 。</p>
</li>
<li><p>Java 系统变量，即 <code>System#getProperties()</code> 方法对应的。</p>
</li>
<li><p>操作系统环境变量。</p>
</li>
<li><p>RandomValuePropertySource 配置的 <code>random.*</code> 属性对应的值。</p>
</li>
<li><p>Jar <strong>外部</strong>的带指定 profile 的 application 配置文件。例如 <code>application-&#123;profile&#125;.yaml</code> 。</p>
</li>
<li><p>Jar <strong>内部</strong>的带指定 profile 的 application 配置文件。例如 <code>application-&#123;profile&#125;.yaml</code> 。</p>
</li>
<li><p>Jar <strong>外部</strong> application 配置文件。例如 <code>application.yaml</code> 。</p>
</li>
<li><p>Jar <strong>内部</strong> application 配置文件。例如 <code>application.yaml</code> 。</p>
</li>
<li><p>在自定义的 <code>@Configuration</code> 类中定于的 <code>@PropertySource</code> 。</p>
</li>
<li><p>启动的 main 方法中，定义的默认配置。即通过 <code>SpringApplication#setDefaultProperties(Map&lt;String, Object&gt; defaultProperties)</code> 方法进行设置。</p>
</li>
</ol>
<p>嘿嘿，是不是很多很长，不用真的去记住。</p>
<ul>
<li>一般来说，面试官不会因为这个题目回答的不好，对你扣分。</li>
<li>实际使用时，做下测试即可。</li>
<li>每一种配置方式的详细说明，可以看看 <a href="https://segmentfault.com/a/1190000015069140">《Spring Boot 参考指南（外部化配置）》</a> 。</li>
</ul>
<h2 id="Spring-Boot-有哪些配置方式？"><a href="#Spring-Boot-有哪些配置方式？" class="headerlink" title="Spring Boot 有哪些配置方式？"></a>Spring Boot 有哪些配置方式？</h2><p>和 Spring 一样，一共提供了三种方式。</p>
<ul>
<li><p>1、XML 配置文件。</p>
<p>  Bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;bean id&#x3D;&quot;studentBean&quot; class&#x3D;&quot;org.edureka.firstSpring.StudentBean&quot;&gt;<br>    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;Edureka&quot;&gt;&lt;&#x2F;property&gt;<br>&lt;&#x2F;bean&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>2、注解配置。</p>
<p>  您可以通过在相关的类，方法或字段声明上使用注解，将 Bean 配置为组件类本身，而不是使用 XML 来描述 Bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;beans&gt;<br>&lt;context:annotation-config&#x2F;&gt;<br>&lt;!-- bean definitions go here --&gt;<br>&lt;&#x2F;beans&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>3、Java Config 配置。</p>
<p>  Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p>
<ul>
<li><p><code>@Bean</code> 注解扮演与 <code>&lt;bean /&gt;</code> 元素相同的角色。</p>
</li>
<li><p><code>@Configuration</code> 类允许通过简单地调用同一个类中的其他 <code>@Bean</code> 方法来定义 Bean 间依赖关系。</p>
</li>
<li><p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Configuration<br>public class StudentConfig &#123;<br>    <br>    @Bean<br>    public StudentBean myStudent() &#123;<br>        return new StudentBean();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>是不是很熟悉 😈</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>目前主要使用 <strong>Java Config</strong> 配置为主。当然，三种配置方式是可以混合使用的。例如说：</p>
<ul>
<li>Dubbo 服务的配置，艿艿喜欢使用 XML 。</li>
<li>Spring MVC 请求的配置，艿艿喜欢使用 <code>@RequestMapping</code> 注解。</li>
<li>Spring MVC 拦截器的配置，艿艿喜欢 Java Config 配置。</li>
</ul>
<hr>
<p>另外，现在已经是 Spring Boot 的天下，所以更加是 <strong>Java Config</strong> 配置为主。</p>
<h2 id="Spring-Boot-的核心注解是哪个？"><a href="#Spring-Boot-的核心注解是哪个？" class="headerlink" title="Spring Boot 的核心注解是哪个？"></a>Spring Boot 的核心注解是哪个？</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">package cn.iocoder.skywalking.web01;<br><br>import org.springframework.boot.SpringApplication;<br>import org.springframework.boot.autoconfigure.SpringBootApplication;<br><br>@SpringBootApplication<br>public class Web01Application &#123;<br><br>    public static void main(String[] args) &#123;<br>        SpringApplication.run(Web01Application.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>@SpringBootApplication</code> 注解，就是 Spring Boot 的核心注解。</li>
</ul>
<p><code>org.springframework.boot.autoconfigure.@SpringBootApplication</code> 注解的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; SpringBootApplication.java<br><br>@Target(&#123;ElementType.TYPE&#125;)<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>@Inherited<br>@SpringBootConfiguration<br>@EnableAutoConfiguration<br>@ComponentScan(<br>    excludeFilters &#x3D; &#123;@Filter(<br>    type &#x3D; FilterType.CUSTOM,<br>    classes &#x3D; &#123;TypeExcludeFilter.class&#125;<br>), @Filter(<br>    type &#x3D; FilterType.CUSTOM,<br>    classes &#x3D; &#123;AutoConfigurationExcludeFilter.class&#125;<br>)&#125;<br>)<br>public @interface SpringBootApplication &#123;<br>    @AliasFor(<br>        annotation &#x3D; EnableAutoConfiguration.class<br>    )<br>    Class&lt;?&gt;[] exclude() default &#123;&#125;;<br><br>    @AliasFor(<br>        annotation &#x3D; EnableAutoConfiguration.class<br>    )<br>    String[] excludeName() default &#123;&#125;;<br><br>    @AliasFor(<br>        annotation &#x3D; ComponentScan.class,<br>        attribute &#x3D; &quot;basePackages&quot;<br>    )<br>    String[] scanBasePackages() default &#123;&#125;;<br><br>    @AliasFor(<br>        annotation &#x3D; ComponentScan.class,<br>        attribute &#x3D; &quot;basePackageClasses&quot;<br>    )<br>    Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>它组合了 3 个注解，详细说明，胖友看看 <a href="https://blog.csdn.net/claram/article/details/75125749">《Spring Boot 系列：@SpringBootApplication 注解》</a> 。</p>
</li>
<li><p><code>@Configuration</code> 注解，指定类是 <strong>Bean 定义</strong>的配置类。</p>
<blockquote>
<p><code>@Configuration</code> 注解，来自 <code>spring-context</code> 项目，用于 Java Config ，不是 Spring Boot 新带来的。</p>
</blockquote>
</li>
<li><p><code>#ComponentScan</code> 注解，扫描指定包下的 Bean 们。</p>
<blockquote>
<p><code>@ComponentScan</code> 注解，来自 <code>spring-context</code> 项目，用于 Java Config ，不是 Spring Boot 新带来的。</p>
</blockquote>
</li>
<li><p><code>@EnableAutoConfiguration</code> 注解，打开自动配置的功能。如果我们想要关闭某个类的自动配置，可以设置注解的 <code>exclude</code> 或 <code>excludeName</code> 属性。</p>
<blockquote>
<p><code>@EnableAutoConfiguration</code> 注解，来自 <code>spring-boot-autoconfigure</code> 项目，<strong>它才是 Spring Boot 新带来的</strong>。</p>
</blockquote>
</li>
</ul>
<h2 id="什么是-Spring-Boot-自动配置？"><a href="#什么是-Spring-Boot-自动配置？" class="headerlink" title="什么是 Spring Boot 自动配置？"></a>什么是 Spring Boot 自动配置？</h2><p>在 <a href="http://svip.iocoder.cn/Spring-Boot/Interview/#">「Spring Boot 的核心注解是哪个？」</a> 中，我们已经看到，使用 <code>@@EnableAutoConfiguration</code> 注解，打开 Spring Boot 自动配置的功能。具体如何实现的，可以看看如下两篇文章：</p>
<ul>
<li><a href="https://www.jianshu.com/p/464d04c36fb1">《@EnableAutoConfiguration 注解的工作原理》</a> 。</li>
<li><a href="https://juejin.im/post/5b679fbc5188251aad213110">《一个面试题引起的 Spring Boot 启动解析》</a></li>
<li>建议，能一边调试，一边看这篇文章。调试很简单，任一搭建一个 Spring Boot 项目即可。</li>
</ul>
<p>如下是一个比较简单的总结：</p>
<ol>
<li>Spring Boot 在启动时扫描项目所依赖的 jar 包，寻找包含<code>spring.factories</code> 文件的 jar 包。</li>
<li>根据 <code>spring.factories</code> 配置加载 AutoConfigure 类。</li>
<li>根据 [<code>@Conditional</code> 等条件注解](<a href="http://svip.iocoder.cn/Spring-Boot/Interview/Spring">http://svip.iocoder.cn/Spring-Boot/Interview/Spring</a> Boot 条件注解) 的条件，进行自动配置并将 Bean 注入 Spring IoC 中。</li>
</ol>
<h2 id="Spring-Boot-有哪几种读取配置的方式？"><a href="#Spring-Boot-有哪几种读取配置的方式？" class="headerlink" title="Spring Boot 有哪几种读取配置的方式？"></a>Spring Boot 有哪几种读取配置的方式？</h2><p>Spring Boot 目前支持 <strong>2</strong> 种读取配置：</p>
<ol>
<li><p><code>@Value</code> 注解，读取配置到属性。最最最常用。</p>
<blockquote>
<p>另外，支持和 <code>@PropertySource</code> 注解一起使用，指定使用的配置文件。</p>
</blockquote>
</li>
<li><p><code>@ConfigurationProperties</code> 注解，读取配置到类上。</p>
<blockquote>
<p>另外，支持和 <code>@PropertySource</code> 注解一起使用，指定使用的配置文件。</p>
</blockquote>
</li>
</ol>
<p>详细的使用方式，可以参考 <a href="https://aoyouzi.iteye.com/blog/2422837">《Spring Boot 读取配置的几种方式》</a> 。</p>
<h2 id="使用-Spring-Boot-后，项目结构是怎么样的呢？"><a href="#使用-Spring-Boot-后，项目结构是怎么样的呢？" class="headerlink" title="使用 Spring Boot 后，项目结构是怎么样的呢？"></a>使用 Spring Boot 后，项目结构是怎么样的呢？</h2><p>我们先来说说项目的分层。一般来说，主流的有两种方式：</p>
<ul>
<li>方式一，<code>controller</code>、<code>service</code>、<code>dao</code> 三个包，每个包下面添加相应的 XXXController、YYYService、ZZZDAO 。</li>
<li>方式二，按照业务模块分包，每个包里面放 Controller、Service、DAO 类。例如，业务模块分成 <code>user</code>、<code>order</code>、<code>item</code> 等等包，在 <code>user</code> 包里放 UserController、UserService、UserDAO 类。</li>
</ul>
<p>那么，使用 Spring Boot 的项目怎么分层呢？艿艿自己的想法</p>
<ul>
<li>现在项目都会进行服务化分拆，每个项目不会特别复杂，所以建议使用【方式一】。</li>
<li>以前的项目，大多是单体的项目，动则项目几万到几十万的代码，当时多采用【方式二】。</li>
</ul>
<p>下面是一个简单的 Spring Boot 项目的 Demo ，如下所示：<a href="http://static2.iocoder.cn/images/Spring/2018-12-26/05.png">![Spring Boot 项目的 Demo](D:\新建文件夹 (3)\05.png)</a>Spring Boot 项目的 Demo</p>
<h2 id="如何在-Spring-Boot-启动的时候运行一些特殊的代码？"><a href="#如何在-Spring-Boot-启动的时候运行一些特殊的代码？" class="headerlink" title="如何在 Spring Boot 启动的时候运行一些特殊的代码？"></a>如何在 Spring Boot 启动的时候运行一些特殊的代码？</h2><p>如果需要在 SpringApplication 启动后执行一些特殊的代码，你可以实现 ApplicationRunner 或 CommandLineRunner 接口，这两个接口工作方式相同，都只提供单一的 run 方法，该方法仅在 <code>SpringApplication#run(...)</code> 方法<strong>完成之前调用</strong>。</p>
<p>一般情况下，我们不太会使用该功能。如果真需要，胖友可以详细看看 [《使用 ApplicationRunner 或 CommandLineRunner 》](<a href="https://qbgbook.gitbooks.io/spring-boot-reference-guide-zh/IV">https://qbgbook.gitbooks.io/spring-boot-reference-guide-zh/IV</a>. Spring Boot features/23.8 Using the ApplicationRunner or CommandLineRunner.html) 。</p>
<h2 id="Spring-Boot-2-X-有什么新特性？"><a href="#Spring-Boot-2-X-有什么新特性？" class="headerlink" title="Spring Boot 2.X 有什么新特性？"></a>Spring Boot 2.X 有什么新特性？</h2><ol>
<li>起步 JDK 8 和支持 JDK 9</li>
<li>第三方库的升级</li>
<li>Reactive Spring</li>
<li>HTTP/2 支持</li>
<li>配置属性的绑定</li>
<li>Gradle 插件</li>
<li>Actuator 改进</li>
<li>数据支持的改进</li>
<li>Web 的改进</li>
<li>支持 Quartz 自动配置</li>
<li>测试的改进</li>
<li>其它…</li>
</ol>
<p>详细的说明，可以看看 <a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-new-features">《Spring Boot 2.0系列文章(二)：Spring Boot 2.0 新特性详解》</a> 。</p>
<h1 id="整合篇"><a href="#整合篇" class="headerlink" title="整合篇"></a>整合篇</h1><h2 id="如何将内嵌服务器换成-Jetty-？"><a href="#如何将内嵌服务器换成-Jetty-？" class="headerlink" title="如何将内嵌服务器换成 Jetty ？"></a>如何将内嵌服务器换成 Jetty ？</h2><p>默认情况下，<code>spring-boot-starter-web</code> 模块使用 Tomcat 作为内嵌的服务器。所以需要去除对 <code>spring-boot-starter-tomcat</code> 模块的引用，添加 <code>spring-boot-starter-jetty</code> 模块的引用。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;<br>    &lt;exclusions&gt;<br>        &lt;exclusion&gt; &lt;!-- 去除 Tomcat --&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;<br>        &lt;&#x2F;exclusion&gt;<br>    &lt;&#x2F;exclusions&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;dependency&gt; &lt;!-- 引入 Jetty --&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-jetty&lt;&#x2F;artifactId&gt;<br>&lt;&#x2F;dependency&gt;<br></code></pre></td></tr></table></figure>

<h2 id="Spring-Boot-中的监视器-Actuator-是什么？"><a href="#Spring-Boot-中的监视器-Actuator-是什么？" class="headerlink" title="Spring Boot 中的监视器 Actuator 是什么？"></a>Spring Boot 中的监视器 Actuator 是什么？</h2><p><code>spring-boot-actuator</code> 提供 Spring Boot 的监视器功能，可帮助我们访问生产环境中正在运行的应用程序的<strong>当前状态</strong>。</p>
<ul>
<li>关于 Spring Boot Actuator 的教程，可以看看 <a href="https://www.jianshu.com/p/af9738634a21">《Spring Boot Actuator 使用》</a> 。</li>
<li>上述教程是基于 Spring Boot 1.X 的版本，如果胖友使用 Spring Boot 2.X 的版本，你将会发现 <code>/beans</code> 等 Endpoint 是不存在的，参考 <a href="https://stackoverflow.com/questions/49174700/spring-boot-2-actuator-endpoint-where-is-beans-endpoint">《Spring boot 2 - Actuator endpoint, where is /beans endpoint》</a> 问题来解决。</li>
</ul>
<p><strong>安全性</strong></p>
<p>Spring Boot 2.X 默认情况下，<code>spring-boot-actuator</code> 产生的 Endpoint 是没有安全保护的，但是 Actuator 可能暴露敏感信息。</p>
<p>所以一般的做法是，引入 <code>spring-boot-start-security</code> 依赖，使用 Spring Security 对它们进行安全保护。</p>
<h2 id="如何集成-Spring-Boot-和-Spring-MVC-？"><a href="#如何集成-Spring-Boot-和-Spring-MVC-？" class="headerlink" title="如何集成 Spring Boot 和 Spring MVC ？"></a>如何集成 Spring Boot 和 Spring MVC ？</h2><ol>
<li><p>引入 <code>spring-boot-starter-web</code> 的依赖。</p>
</li>
<li><p>实现 WebMvcConfigurer 接口，可添加自定义的 Spring MVC 配置。</p>
<blockquote>
<p>因为 Spring Boot 2 基于 JDK 8 的版本，而 JDK 8 提供 <code>default</code> 方法，所以 Spring Boot 2 废弃了 WebMvcConfigurerAdapter 适配类，直接使用 WebMvcConfigurer 即可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; WebMvcConfigurer.java<br>public interface WebMvcConfigurer &#123;<br><br>    &#x2F;** 配置路径匹配器 **&#x2F;<br>    default void configurePathMatch(PathMatchConfigurer configurer) &#123;&#125;<br>    <br>    &#x2F;** 配置内容裁决的一些选项 **&#x2F;<br>    default void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123; &#125;<br><br>    &#x2F;** 异步相关的配置 **&#x2F;<br>    default void configureAsyncSupport(AsyncSupportConfigurer configurer) &#123; &#125;<br><br>    default void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; &#125;<br><br>    default void addFormatters(FormatterRegistry registry) &#123;<br>    &#125;<br><br>    &#x2F;** 添加拦截器 **&#x2F;<br>    default void addInterceptors(InterceptorRegistry registry) &#123; &#125;<br><br>    &#x2F;** 静态资源处理 **&#x2F;<br>    default void addResourceHandlers(ResourceHandlerRegistry registry) &#123; &#125;<br><br>    &#x2F;** 解决跨域问题 **&#x2F;<br>    default void addCorsMappings(CorsRegistry registry) &#123; &#125;<br><br>    default void addViewControllers(ViewControllerRegistry registry) &#123; &#125;<br><br>    &#x2F;** 配置视图解析器 **&#x2F;<br>    default void configureViewResolvers(ViewResolverRegistry registry) &#123; &#125;<br><br>    &#x2F;** 添加参数解析器 **&#x2F;<br>    default void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) &#123;<br>    &#125;<br><br>    &#x2F;** 添加返回值处理器 **&#x2F;<br>    default void addReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler&gt; handlers) &#123; &#125;<br><br>    &#x2F;** 这里配置视图解析器 **&#x2F;<br>    default void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; &#125;<br><br>    &#x2F;** 配置消息转换器 **&#x2F;<br>    default void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; &#125;<br><br>   &#x2F;** 配置异常处理器 **&#x2F;<br>    default void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123; &#125;<br><br>    default void extendHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123; &#125;<br><br>    @Nullable<br>    default Validator getValidator() &#123; return null; &#125;<br><br>    @Nullable<br>    default MessageCodesResolver getMessageCodesResolver() &#123;  return null; &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<p>在使用 Spring MVC 时，我们一般会做如下几件事情：</p>
<ol>
<li>实现自己项目需要的拦截器，并在 WebMvcConfigurer 实现类中配置。可参见 <a href="https://github.com/YunaiV/oceans/blob/2a2d3746905f1349e260e88049e7e28346c7648f/bff/webapp-bff/src/main/java/cn/iocoder/oceans/webapp/bff/config/MVCConfiguration.java">MVCConfiguration</a> 类。</li>
<li>配置 <code>@ControllerAdvice</code> + <code>@ExceptionHandler</code> 注解，实现全局异常处理。可参见 <a href="https://github.com/YunaiV/oceans/blob/2a2d3746905f1349e260e88049e7e28346c7648f/bff/webapp-bff/src/main/java/cn/iocoder/oceans/webapp/bff/config/GlobalExceptionHandler.java">GlobalExceptionHandler</a> 类。</li>
<li>配置 <code>@ControllerAdvice</code> ，实现 ResponseBodyAdvice 接口，实现全局统一返回。可参见 <a href="https://github.com/YunaiV/oceans/blob/2a2d3746905f1349e260e88049e7e28346c7648f/bff/webapp-bff/src/main/java/cn/iocoder/oceans/webapp/bff/config/GlobalResponseBodyAdvice.java">GlobalResponseBodyAdvice</a> 。</li>
</ol>
<p>当然，有一点需要注意，WebMvcConfigurer、ResponseBodyAdvice、<code>@ControllerAdvice</code>、<code>@ExceptionHandler</code> 接口，都是 Spring MVC 框架自身已经有的东西。</p>
<ul>
<li><code>spring-boot-starter-web</code> 的依赖，帮我们解决的是 Spring MVC 的依赖以及相关的 Tomcat 等组件。</li>
</ul>
<h2 id="如何集成-Spring-Boot-和-Spring-Security-？"><a href="#如何集成-Spring-Boot-和-Spring-Security-？" class="headerlink" title="如何集成 Spring Boot 和 Spring Security ？"></a>如何集成 Spring Boot 和 Spring Security ？</h2><p>目前比较主流的安全框架有两个：</p>
<ol>
<li>Spring Security</li>
<li>Apache Shiro</li>
</ol>
<p>对于任何项目来说，安全认证总是少不了，同样适用于使用 Spring Boot 的项目。相对来说，Spring Security 现在会比 Apache Shiro 更流行。</p>
<p>Spring Boot 和 Spring Security 的配置方式比较简单：</p>
<ol>
<li>引入 <code>spring-boot-starter-security</code> 的依赖。</li>
<li>继承 WebSecurityConfigurerAdapter ，添加<strong>自定义</strong>的安全配置。</li>
</ol>
<p>当然，每个项目的安全配置是不同的，需要胖友自己选择。更多详细的使用，建议认真阅读如下文章：</p>
<ul>
<li><a href="http://blog.didispace.com/springbootsecurity/">《Spring Boot中 使用 Spring Security 进行安全控制》</a> ，快速上手。</li>
<li><a href="http://www.iocoder.cn/Spring-Security/good-collection/">《Spring Security 实现原理与源码解析系统 —— 精品合集》</a> ，深入源码。</li>
</ul>
<p>另外，安全是一个很大的话题，感兴趣的胖友，可以看看 <a href="https://www.jdon.com/49653">《Spring Boot 十种安全措施》</a> 一文。</p>
<h2 id="如何集成-Spring-Boot-和-Spring-Security-OAuth2-？"><a href="#如何集成-Spring-Boot-和-Spring-Security-OAuth2-？" class="headerlink" title="如何集成 Spring Boot 和 Spring Security OAuth2 ？"></a>如何集成 Spring Boot 和 Spring Security OAuth2 ？</h2><p>参见 <a href="http://www.iocoder.cn/Spring-Security/OAuth2-learning/">《Spring Security OAuth2 入门》</a> 文章，内容有点多。</p>
<h2 id="如何集成-Spring-Boot-和-JPA-？"><a href="#如何集成-Spring-Boot-和-JPA-？" class="headerlink" title="如何集成 Spring Boot 和 JPA ？"></a>如何集成 Spring Boot 和 JPA ？</h2><ol>
<li>引入 <code>spring-boot-starter-data-jpa</code> 的依赖。</li>
<li>在 application 配置文件中，加入 JPA 相关的少量配置。当然，数据库的配置也要添加进去。</li>
<li>具体编码。</li>
</ol>
<p>详细的使用，胖友可以参考：</p>
<ul>
<li><a href="http://www.iocoder.cn/Spring-Boot/battcn/v2-orm-jpa/">《一起来学 SpringBoot 2.x | 第六篇：整合 Spring Data JPA》</a></li>
</ul>
<p>有两点需要注意：</p>
<ul>
<li>Spring Boot 2 默认使用的数据库连接池是 <a href="https://github.com/brettwooldridge/HikariCP">HikariCP</a> ，目前最好的性能的数据库连接池的实现。</li>
<li><code>spring-boot-starter-data-jpa</code> 的依赖，使用的默认 JPA 实现是 Hibernate 5.X 。</li>
</ul>
<h2 id="如何集成-Spring-Boot-和-MyBatis-？"><a href="#如何集成-Spring-Boot-和-MyBatis-？" class="headerlink" title="如何集成 Spring Boot 和 MyBatis ？"></a>如何集成 Spring Boot 和 MyBatis ？</h2><ol>
<li>引入 <code>mybatis-spring-boot-starter</code> 的依赖。</li>
<li>在 application 配置文件中，加入 MyBatis 相关的少量配置。当然，数据库的配置也要添加进去。</li>
<li>具体编码。</li>
</ol>
<p>详细的使用，胖友可以参考：</p>
<ul>
<li><a href="http://www.iocoder.cn/Spring-Boot/battcn/v2-orm-mybatis/">《一起来学 SpringBoot 2.x | 第七篇：整合 Mybatis》</a></li>
</ul>
<h2 id="如何集成-Spring-Boot-和-RabbitMQ-？"><a href="#如何集成-Spring-Boot-和-RabbitMQ-？" class="headerlink" title="如何集成 Spring Boot 和 RabbitMQ ？"></a>如何集成 Spring Boot 和 RabbitMQ ？</h2><ol>
<li>引入 <code>spring-boot-starter-amqp</code> 的依赖</li>
<li>在 application 配置文件中，加入 RabbitMQ 相关的少量配置。</li>
<li>具体编码。</li>
</ol>
<p>详细的使用，胖友可以参考：</p>
<ul>
<li><a href="http://www.iocoder.cn/Spring-Boot/battcn/v2-queue-rabbitmq/">《一起来学 SpringBoot 2.x | 第十二篇：初探 RabbitMQ 消息队列》</a></li>
<li><a href="http://www.iocoder.cn/Spring-Boot/battcn/v2-queue-rabbitmq-delay/">《一起来学 SpringBoot 2.x | 第十三篇：RabbitMQ 延迟队列》</a></li>
</ul>
<h2 id="如何集成-Spring-Boot-和-Kafka-？"><a href="#如何集成-Spring-Boot-和-Kafka-？" class="headerlink" title="如何集成 Spring Boot 和 Kafka ？"></a>如何集成 Spring Boot 和 Kafka ？</h2><ol>
<li>引入 <code>spring-kafka</code> 的依赖。</li>
<li>在 application 配置文件中，加入 Kafka 相关的少量配置。</li>
<li>具体编码。</li>
</ol>
<p>详细的使用，胖友可以参考：</p>
<ul>
<li><a href="http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/">《Spring Boot系列文章（一）：SpringBoot Kafka 整合使用》</a></li>
</ul>
<h2 id="如何集成-Spring-Boot-和-RocketMQ-？"><a href="#如何集成-Spring-Boot-和-RocketMQ-？" class="headerlink" title="如何集成 Spring Boot 和 RocketMQ ？"></a>如何集成 Spring Boot 和 RocketMQ ？</h2><ol>
<li>引入 <code>rocketmq-spring-boot</code> 的依赖。</li>
<li>在 application 配置文件中，加入 RocketMQ 相关的少量配置。</li>
<li>具体编码。</li>
</ol>
<p>详细的使用，胖友可以参考：</p>
<ul>
<li><a href="http://www.iocoder.cn/RocketMQ/start/spring-boot-example">《我用这种方法在 Spring 中实现消息的发送和消费》</a></li>
</ul>
<h2 id="Spring-Boot-支持哪些日志框架？"><a href="#Spring-Boot-支持哪些日志框架？" class="headerlink" title="Spring Boot 支持哪些日志框架？"></a>Spring Boot 支持哪些日志框架？</h2><p>Spring Boot 支持的日志框架有：</p>
<ul>
<li>Logback</li>
<li>Log4j2</li>
<li>Log4j</li>
<li>Java Util  Logging</li>
</ul>
<p>默认使用的是 Logback 日志框架，也是目前较为推荐的，具体配置，可以参见 <a href="http://www.iocoder.cn/Spring-Boot/battcn/v2-config-logs/">《一起来学 SpringBoot 2.x | 第三篇：SpringBoot 日志配置》</a> 。</p>
<p>因为 Log4j2 的性能更加优秀，也有人在生产上使用，可以参考 <a href="https://www.jianshu.com/p/f18a9cff351d">《Spring Boot Log4j2 日志性能之巅》</a> 配置。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>😈 看完之后，复习复习 Spring Boot 美滋滋。有一种奇怪的感觉，把面试题写成了 Spring 的学习指南。</p>
<p>当然，如果胖友有新的面试题，欢迎在星球一起探讨补充。</p>
<p>参考和推荐如下文章：</p>
<ul>
<li>我有面试宝典 [《<a href="http://www.wityx.com/post/242_1_1.html">经验分享] Spring Boot面试题总结》</a></li>
<li>Java 知音 <a href="https://cloud.tencent.com/developer/article/1348086">《Spring Boot 面试题精华》</a></li>
<li>祖大帅 <a href="https://juejin.im/post/5b679fbc5188251aad213110">《一个面试题引起的 Spring Boot 启动解析》</a></li>
<li>大胡子叔叔_ <a href="https://blog.csdn.net/panhaigang123/article/details/79587612">《Spring Boot + Spring Cloud 相关面试题》</a></li>
<li>墨斗鱼博客 <a href="https://www.mudouyu.com/article/26">《20 道 Spring Boot 面试题》</a></li>
<li>夕阳雨晴 <a href="https://blog.csdn.net/sun1021873926/article/details/78176354">《Spring Boot Starter 的面试题》</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring Boot</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习笔记</title>
    <url>/2019/10/12/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="MySQL学习笔记"><a href="#MySQL学习笔记" class="headerlink" title="MySQL学习笔记"></a>MySQL学习笔记</h1><h2 id="登录和退出MySQL服务器"><a href="#登录和退出MySQL服务器" class="headerlink" title="登录和退出MySQL服务器"></a>登录和退出MySQL服务器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 登录MySQL</span><br><span class="hljs-meta">$</span><span class="bash"> mysql -u root -p12345612</span><br><br><span class="hljs-meta">#</span><span class="bash"> 退出MySQL数据库服务器</span><br>exit;<br></code></pre></td></tr></table></figure>

<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 显示所有数据库<br>show databases;<br><br>-- 创建数据库<br>CREATE DATABASE test;<br><br>-- 切换数据库<br>use test;<br><br>-- 显示数据库中的所有表<br>show tables;<br><br>-- 创建数据表<br>CREATE TABLE pet (<br>    name VARCHAR(20),<br>    owner VARCHAR(20),<br>    species VARCHAR(20),<br>    sex CHAR(1),<br>    birth DATE,<br>    death DATE<br>);<br><br>-- 查看数据表结构<br>-- describe pet;<br>desc pet;<br><br>-- 查询表<br>SELECT * from pet;<br><br>-- 插入数据<br>INSERT INTO pet VALUES (&#39;puffball&#39;, &#39;Diane&#39;, &#39;hamster&#39;, &#39;f&#39;, &#39;1990-03-30&#39;, NULL);<br><br>-- 修改数据<br>UPDATE pet SET name &#x3D; &#39;squirrel&#39; where owner &#x3D; &#39;Diane&#39;;<br><br>-- 删除数据<br>DELETE FROM pet where name &#x3D; &#39;squirrel&#39;;<br><br>-- 删除表<br>DROP TABLE myorder;<br></code></pre></td></tr></table></figure>

<h2 id="建表约束"><a href="#建表约束" class="headerlink" title="建表约束"></a>建表约束</h2><h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 主键约束<br>-- 使某个字段不重复且不得为空，确保表内所有数据的唯一性。<br>CREATE TABLE user (<br>    id INT PRIMARY KEY,<br>    name VARCHAR(20)<br>);<br><br>-- 联合主键<br>-- 联合主键中的每个字段都不能为空，并且加起来不能和已设置的联合主键重复。<br>CREATE TABLE user (<br>    id INT,<br>    name VARCHAR(20),<br>    password VARCHAR(20),<br>    PRIMARY KEY(id, name)<br>);<br><br>-- 自增约束<br>-- 自增约束的主键由系统自动递增分配。<br>CREATE TABLE user (<br>    id INT PRIMARY KEY AUTO_INCREMENT,<br>    name VARCHAR(20)<br>);<br><br>-- 添加主键约束<br>-- 如果忘记设置主键，还可以通过SQL语句设置（两种方式）：<br>ALTER TABLE user ADD PRIMARY KEY(id);<br>ALTER TABLE user MODIFY id INT PRIMARY KEY;<br><br>-- 删除主键<br>ALTER TABLE user drop PRIMARY KEY;<br></code></pre></td></tr></table></figure>

<h3 id="唯一主键"><a href="#唯一主键" class="headerlink" title="唯一主键"></a>唯一主键</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 唯一约束可以为空，而主键约束不能为空<br><br>-- 建表时创建唯一主键<br>CREATE TABLE user (<br>    id INT,<br>    name VARCHAR(20),<br>    UNIQUE(name)<br>);<br><br>-- unique(id,name)表示两个键在一起不重复就行<br>CREATE TABLE user (<br>    id INT,<br>    name VARCHAR(20),<br>    UNIQUE(id,name)<br>);<br><br>-- 添加唯一主键<br>-- 如果建表时没有设置唯一建，还可以通过SQL语句设置（两种方式）：<br>ALTER TABLE user ADD UNIQUE(name);<br>ALTER TABLE user MODIFY name VARCHAR(20) UNIQUE;<br><br>-- 删除唯一主键<br>ALTER TABLE user DROP INDEX name;<br></code></pre></td></tr></table></figure>

<h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 建表时添加非空约束<br>-- 约束某个字段不能为空<br>CREATE TABLE user (<br>    id INT,<br>    name VARCHAR(20) NOT NULL<br>);<br><br>-- 移除非空约束<br>ALTER TABLE user MODIFY name VARCHAR(20);<br></code></pre></td></tr></table></figure>

<h3 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 建表时添加默认约束<br>-- 约束某个字段的默认值<br>CREATE TABLE user2 (<br>    id INT,<br>    name VARCHAR(20),<br>    age INT DEFAULT 10<br>);<br><br>-- 移除非空约束<br>ALTER TABLE user MODIFY age INT;<br></code></pre></td></tr></table></figure>

<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 班级<br>CREATE TABLE classes (<br>    id INT PRIMARY KEY,<br>    name VARCHAR(20)<br>);<br><br>-- 学生表<br>CREATE TABLE students (<br>    id INT PRIMARY KEY,<br>    name VARCHAR(20),<br>    -- 这里的 class_id 要和 classes 中的 id 字段相关联<br>    class_id INT,<br>    -- 表示 class_id 的值必须来自于 classes 中的 id 字段值<br>    FOREIGN KEY(class_id) REFERENCES classes(id)<br>);<br><br>-- 1. 主表（父表）classes 中没有的数据值，在副表（子表）students 中，是不可以使用的；<br>-- 2. 主表中的记录被副表引用时，主表不可以被删除。<br></code></pre></td></tr></table></figure>

<h2 id="数据库的三大设计范式"><a href="#数据库的三大设计范式" class="headerlink" title="数据库的三大设计范式"></a>数据库的三大设计范式</h2><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>只要字段值还可以继续拆分，就不满足第一范式。</p>
<p>范式设计得越详细，对某些实际操作可能会更好，但并非都有好处，需要对项目的实际情况进行设定。</p>
<h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p>在满足第一范式的前提下，其他列都必须完全依赖于主键列。如果出现不完全依赖，只可能发生在联合主键的情况下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 订单表<br>CREATE TABLE myorder (<br>    product_id INT,<br>    customer_id INT,<br>    product_name VARCHAR(20),<br>    customer_name VARCHAR(20),<br>    PRIMARY KEY (product_id, customer_id)<br>);<br></code></pre></td></tr></table></figure>

<p>实际上，在这张订单表中，<code>product_name</code> 只依赖于 <code>product_id</code> ，<code>customer_name</code> 只依赖于 <code>customer_id</code> 。也就是说，<code>product_name</code> 和 <code>customer_id</code> 是没用关系的，<code>customer_name</code> 和 <code>product_id</code> 也是没有关系的。</p>
<p>这就不满足第二范式：其他列都必须完全依赖于主键列！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE myorder (<br>    order_id INT PRIMARY KEY,<br>    product_id INT,<br>    customer_id INT<br>);<br><br>CREATE TABLE product (<br>    id INT PRIMARY KEY,<br>    name VARCHAR(20)<br>);<br><br>CREATE TABLE customer (<br>    id INT PRIMARY KEY,<br>    name VARCHAR(20)<br>);<br></code></pre></td></tr></table></figure>

<p>拆分之后，<code>myorder</code> 表中的 <code>product_id</code> 和 <code>customer_id</code> 完全依赖于 <code>order_id</code> 主键，而 <code>product</code> 和 <code>customer</code> 表中的其他字段又完全依赖于主键。满足了第二范式的设计！</p>
<h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p>在满足第二范式的前提下，除了主键列之外，其他列之间不能有传递依赖关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE myorder (<br>    order_id INT PRIMARY KEY,<br>    product_id INT,<br>    customer_id INT,<br>    customer_phone VARCHAR(15)<br>);<br></code></pre></td></tr></table></figure>

<p>表中的 <code>customer_phone</code> 有可能依赖于 <code>order_id</code> 、 <code>customer_id</code> 两列，也就不满足了第三范式的设计：其他列之间不能有传递依赖关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE myorder (<br>    order_id INT PRIMARY KEY,<br>    product_id INT,<br>    customer_id INT<br>);<br><br>CREATE TABLE customer (<br>    id INT PRIMARY KEY,<br>    name VARCHAR(20),<br>    phone VARCHAR(15)<br>);<br></code></pre></td></tr></table></figure>

<p>修改后就不存在其他列之间的传递依赖关系，其他列都只依赖于主键列，满足了第三范式的设计！</p>
<h2 id="查询练习"><a href="#查询练习" class="headerlink" title="查询练习"></a>查询练习</h2><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 创建数据库<br>CREATE DATABASE select_test;<br>-- 切换数据库<br>USE select_test;<br><br>-- 创建学生表<br>CREATE TABLE student (<br>    no VARCHAR(20) PRIMARY KEY,<br>    name VARCHAR(20) NOT NULL,<br>    sex VARCHAR(10) NOT NULL,<br>    birthday DATE, -- 生日<br>    class VARCHAR(20) -- 所在班级<br>);<br><br>-- 创建教师表<br>CREATE TABLE teacher (<br>    no VARCHAR(20) PRIMARY KEY,<br>    name VARCHAR(20) NOT NULL,<br>    sex VARCHAR(10) NOT NULL,<br>    birthday DATE,<br>    profession VARCHAR(20) NOT NULL, -- 职称<br>    department VARCHAR(20) NOT NULL -- 部门<br>);<br><br>-- 创建课程表<br>CREATE TABLE course (<br>    no VARCHAR(20) PRIMARY KEY,<br>    name VARCHAR(20) NOT NULL,<br>    t_no VARCHAR(20) NOT NULL, -- 教师编号<br>    -- 表示该 tno 来自于 teacher 表中的 no 字段值<br>    FOREIGN KEY(t_no) REFERENCES teacher(no) <br>);<br><br>-- 成绩表<br>CREATE TABLE score (<br>    s_no VARCHAR(20) NOT NULL, -- 学生编号<br>    c_no VARCHAR(20) NOT NULL, -- 课程号<br>    degree DECIMAL,	-- 成绩<br>    -- 表示该 s_no, c_no 分别来自于 student, course 表中的 no 字段值<br>    FOREIGN KEY(s_no) REFERENCES student(no),	<br>    FOREIGN KEY(c_no) REFERENCES course(no),<br>    -- 设置 s_no, c_no 为联合主键<br>    PRIMARY KEY(s_no, c_no)<br>);<br><br>-- 查看所有表<br>SHOW TABLES;<br><br>-- 添加学生表数据<br>INSERT INTO student VALUES(&#39;101&#39;, &#39;曾华&#39;, &#39;男&#39;, &#39;1977-09-01&#39;, &#39;95033&#39;);<br>INSERT INTO student VALUES(&#39;102&#39;, &#39;匡明&#39;, &#39;男&#39;, &#39;1975-10-02&#39;, &#39;95031&#39;);<br>INSERT INTO student VALUES(&#39;103&#39;, &#39;王丽&#39;, &#39;女&#39;, &#39;1976-01-23&#39;, &#39;95033&#39;);<br>INSERT INTO student VALUES(&#39;104&#39;, &#39;李军&#39;, &#39;男&#39;, &#39;1976-02-20&#39;, &#39;95033&#39;);<br>INSERT INTO student VALUES(&#39;105&#39;, &#39;王芳&#39;, &#39;女&#39;, &#39;1975-02-10&#39;, &#39;95031&#39;);<br>INSERT INTO student VALUES(&#39;106&#39;, &#39;陆军&#39;, &#39;男&#39;, &#39;1974-06-03&#39;, &#39;95031&#39;);<br>INSERT INTO student VALUES(&#39;107&#39;, &#39;王尼玛&#39;, &#39;男&#39;, &#39;1976-02-20&#39;, &#39;95033&#39;);<br>INSERT INTO student VALUES(&#39;108&#39;, &#39;张全蛋&#39;, &#39;男&#39;, &#39;1975-02-10&#39;, &#39;95031&#39;);<br>INSERT INTO student VALUES(&#39;109&#39;, &#39;赵铁柱&#39;, &#39;男&#39;, &#39;1974-06-03&#39;, &#39;95031&#39;);<br><br>-- 添加教师表数据<br>INSERT INTO teacher VALUES(&#39;804&#39;, &#39;李诚&#39;, &#39;男&#39;, &#39;1958-12-02&#39;, &#39;副教授&#39;, &#39;计算机系&#39;);<br>INSERT INTO teacher VALUES(&#39;856&#39;, &#39;张旭&#39;, &#39;男&#39;, &#39;1969-03-12&#39;, &#39;讲师&#39;, &#39;电子工程系&#39;);<br>INSERT INTO teacher VALUES(&#39;825&#39;, &#39;王萍&#39;, &#39;女&#39;, &#39;1972-05-05&#39;, &#39;助教&#39;, &#39;计算机系&#39;);<br>INSERT INTO teacher VALUES(&#39;831&#39;, &#39;刘冰&#39;, &#39;女&#39;, &#39;1977-08-14&#39;, &#39;助教&#39;, &#39;电子工程系&#39;);<br><br>-- 添加课程表数据<br>INSERT INTO course VALUES(&#39;3-105&#39;, &#39;计算机导论&#39;, &#39;825&#39;);<br>INSERT INTO course VALUES(&#39;3-245&#39;, &#39;操作系统&#39;, &#39;804&#39;);<br>INSERT INTO course VALUES(&#39;6-166&#39;, &#39;数字电路&#39;, &#39;856&#39;);<br>INSERT INTO course VALUES(&#39;9-888&#39;, &#39;高等数学&#39;, &#39;831&#39;);<br><br>-- 添加添加成绩表数据<br>INSERT INTO score VALUES(&#39;103&#39;, &#39;3-105&#39;, &#39;92&#39;);<br>INSERT INTO score VALUES(&#39;103&#39;, &#39;3-245&#39;, &#39;86&#39;);<br>INSERT INTO score VALUES(&#39;103&#39;, &#39;6-166&#39;, &#39;85&#39;);<br>INSERT INTO score VALUES(&#39;105&#39;, &#39;3-105&#39;, &#39;88&#39;);<br>INSERT INTO score VALUES(&#39;105&#39;, &#39;3-245&#39;, &#39;75&#39;);<br>INSERT INTO score VALUES(&#39;105&#39;, &#39;6-166&#39;, &#39;79&#39;);<br>INSERT INTO score VALUES(&#39;109&#39;, &#39;3-105&#39;, &#39;76&#39;);<br>INSERT INTO score VALUES(&#39;109&#39;, &#39;3-245&#39;, &#39;68&#39;);<br>INSERT INTO score VALUES(&#39;109&#39;, &#39;6-166&#39;, &#39;81&#39;);<br><br>-- 查看表结构<br>SELECT * FROM course;<br>SELECT * FROM score;<br>SELECT * FROM student;<br>SELECT * FROM teacher;<br></code></pre></td></tr></table></figure>

<h3 id="1-到-10"><a href="#1-到-10" class="headerlink" title="1 到 10"></a>1 到 10</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 查询 student 表的所有行<br>SELECT * FROM student;<br><br>-- 查询 student 表中的 name、sex 和 class 字段的所有行<br>SELECT name, sex, class FROM student;<br><br>-- 查询 teacher 表中不重复的 department 列<br>-- DISTINCT: 去重查询<br>SELECT DISTINCT department FROM teacher;<br><br>-- 查询 score 表中成绩在60-80之间的所有行（区间查询和运算符查询）<br>-- BETWEEN xx AND xx: 查询区间, AND 表示 &quot;并且&quot;<br>SELECT * FROM score WHERE degree BETWEEN 60 AND 80;<br>SELECT * FROM score WHERE degree &gt; 60 AND degree &lt; 80;<br><br>-- 查询 score 表中成绩为 85, 86 或 88 的行<br>-- IN: 查询规定中的多个值<br>SELECT * FROM score WHERE degree IN (85, 86, 88);<br><br>-- 查询 student 表中 &#39;95031&#39; 班或性别为 &#39;女&#39; 的所有行<br>-- or: 表示或者关系<br>SELECT * FROM student WHERE class &#x3D; &#39;95031&#39; or sex &#x3D; &#39;女&#39;;<br><br>-- 以 class 降序的方式查询 student 表的所有行<br>-- DESC: 降序，从高到低<br>-- ASC（默认）: 升序，从低到高<br>SELECT * FROM student ORDER BY class DESC;<br>SELECT * FROM student ORDER BY class ASC;<br><br>-- 以 c_no 升序、degree 降序查询 score 表的所有行<br>SELECT * FROM score ORDER BY c_no ASC, degree DESC;<br><br>-- 查询 &quot;95031&quot; 班的学生人数<br>-- COUNT: 统计<br>SELECT COUNT(*) FROM student WHERE class &#x3D; &#39;95031&#39;;<br><br>-- 查询 score 表中的最高分的学生学号和课程编号（子查询或排序查询）。<br>-- (SELECT MAX(degree) FROM score): 子查询，算出最高分<br>SELECT s_no, c_no FROM score WHERE degree &#x3D; (SELECT MAX(degree) FROM score);<br><br>--  排序查询<br>-- LIMIT r, n: 表示从第r行开始，查询n条数据<br>SELECT s_no, c_no, degree FROM score ORDER BY degree DESC LIMIT 0, 1;<br></code></pre></td></tr></table></figure>

<h3 id="分组计算平均成绩"><a href="#分组计算平均成绩" class="headerlink" title="分组计算平均成绩"></a>分组计算平均成绩</h3><p><strong>查询每门课的平均成绩。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- AVG: 平均值<br>SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;3-105&#39;;<br>SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;3-245&#39;;<br>SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;6-166&#39;;<br><br>-- GROUP BY: 分组查询<br>SELECT c_no, AVG(degree) FROM score GROUP BY c_no;<br></code></pre></td></tr></table></figure>

<h3 id="分组条件与模糊查询"><a href="#分组条件与模糊查询" class="headerlink" title="分组条件与模糊查询"></a>分组条件与模糊查询</h3><p><strong>查询 <code>score</code> 表中至少有 2 名学生选修，并以 3 开头的课程的平均分数。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM score;<br>-- c_no 课程编号<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 103  | 3-105 |     92 |<br>| 103  | 3-245 |     86 |<br>| 103  | 6-166 |     85 |<br>| 105  | 3-105 |     88 |<br>| 105  | 3-245 |     75 |<br>| 105  | 6-166 |     79 |<br>| 109  | 3-105 |     76 |<br>| 109  | 3-245 |     68 |<br>| 109  | 6-166 |     81 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<p>分析表发现，至少有 2 名学生选修的课程是 <code>3-105</code> 、<code>3-245</code> 、<code>6-166</code> ，以 3 开头的课程是 <code>3-105</code> 、<code>3-245</code> 。也就是说，我们要查询所有 <code>3-105</code> 和 <code>3-245</code> 的 <code>degree</code> 平均分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 首先把 c_no, AVG(degree) 通过分组查询出来<br>SELECT c_no, AVG(degree) FROM score GROUP BY c_no<br>+-------+-------------+<br>| c_no  | AVG(degree) |<br>+-------+-------------+<br>| 3-105 |     85.3333 |<br>| 3-245 |     76.3333 |<br>| 6-166 |     81.6667 |<br>+-------+-------------+<br><br>-- 再查询出至少有 2 名学生选修的课程<br>-- HAVING: 表示持有<br>HAVING COUNT(c_no) &gt;&#x3D; 2<br><br>-- 并且是以 3 开头的课程<br>-- LIKE 表示模糊查询，&quot;%&quot; 是一个通配符，匹配 &quot;3&quot; 后面的任意字符。<br>AND c_no LIKE &#39;3%&#39;;<br><br>-- 把前面的SQL语句拼接起来，<br>-- 后面加上一个 COUNT(*)，表示将每个分组的个数也查询出来。<br>SELECT c_no, AVG(degree), COUNT(*) FROM score GROUP BY c_no<br>HAVING COUNT(c_no) &gt;&#x3D; 2 AND c_no LIKE &#39;3%&#39;;<br>+-------+-------------+----------+<br>| c_no  | AVG(degree) | COUNT(*) |<br>+-------+-------------+----------+<br>| 3-105 |     85.3333 |        3 |<br>| 3-245 |     76.3333 |        3 |<br>+-------+-------------+----------+<br></code></pre></td></tr></table></figure>

<h3 id="多表查询-1"><a href="#多表查询-1" class="headerlink" title="多表查询 - 1"></a>多表查询 - 1</h3><p><strong>查询所有学生的 <code>name</code>，以及该学生在 <code>score</code> 表中对应的 <code>c_no</code> 和 <code>degree</code> 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT no, name FROM student;<br>+-----+-----------+<br>| no  | name      |<br>+-----+-----------+<br>| 101 | 曾华      |<br>| 102 | 匡明      |<br>| 103 | 王丽      |<br>| 104 | 李军      |<br>| 105 | 王芳      |<br>| 106 | 陆军      |<br>| 107 | 王尼玛    |<br>| 108 | 张全蛋    |<br>| 109 | 赵铁柱    |<br>+-----+-----------+<br><br>SELECT s_no, c_no, degree FROM score;<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 103  | 3-105 |     92 |<br>| 103  | 3-245 |     86 |<br>| 103  | 6-166 |     85 |<br>| 105  | 3-105 |     88 |<br>| 105  | 3-245 |     75 |<br>| 105  | 6-166 |     79 |<br>| 109  | 3-105 |     76 |<br>| 109  | 3-245 |     68 |<br>| 109  | 6-166 |     81 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<p>通过分析可以发现，只要把 <code>score</code> 表中的 <code>s_no</code> 字段值替换成 <code>student</code> 表中对应的 <code>name</code> 字段值就可以了，如何做呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- FROM...: 表示从 student, score 表中查询<br>-- WHERE 的条件表示为，只有在 student.no 和 score.s_no 相等时才显示出来。<br>SELECT name, c_no, degree FROM student, score <br>WHERE student.no &#x3D; score.s_no;<br>+-----------+-------+--------+<br>| name      | c_no  | degree |<br>+-----------+-------+--------+<br>| 王丽      | 3-105 |     92 |<br>| 王丽      | 3-245 |     86 |<br>| 王丽      | 6-166 |     85 |<br>| 王芳      | 3-105 |     88 |<br>| 王芳      | 3-245 |     75 |<br>| 王芳      | 6-166 |     79 |<br>| 赵铁柱    | 3-105 |     76 |<br>| 赵铁柱    | 3-245 |     68 |<br>| 赵铁柱    | 6-166 |     81 |<br>+-----------+-------+--------+<br></code></pre></td></tr></table></figure>

<h3 id="多表查询-2"><a href="#多表查询-2" class="headerlink" title="多表查询 - 2"></a>多表查询 - 2</h3><p><strong>查询所有学生的 <code>no</code> 、课程名称 ( <code>course</code> 表中的 <code>name</code> ) 和成绩 ( <code>score</code> 表中的 <code>degree</code> ) 列。</strong></p>
<p>只有 <code>score</code> 关联学生的 <code>no</code> ，因此只要查询 <code>score</code> 表，就能找出所有和学生相关的 <code>no</code> 和 <code>degree</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT s_no, c_no, degree FROM score;<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 103  | 3-105 |     92 |<br>| 103  | 3-245 |     86 |<br>| 103  | 6-166 |     85 |<br>| 105  | 3-105 |     88 |<br>| 105  | 3-245 |     75 |<br>| 105  | 6-166 |     79 |<br>| 109  | 3-105 |     76 |<br>| 109  | 3-245 |     68 |<br>| 109  | 6-166 |     81 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<p>然后查询 <code>course</code> 表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">+-------+-----------------+<br>| no    | name            |<br>+-------+-----------------+<br>| 3-105 | 计算机导论      |<br>| 3-245 | 操作系统        |<br>| 6-166 | 数字电路        |<br>| 9-888 | 高等数学        |<br>+-------+-----------------+<br></code></pre></td></tr></table></figure>

<p>只要把 <code>score</code> 表中的 <code>c_no</code> 替换成 <code>course</code> 表中对应的 <code>name</code> 字段值就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 增加一个查询字段 name，分别从 score、course 这两个表中查询。<br>-- as 表示取一个该字段的别名。<br>SELECT s_no, name as c_name, degree FROM score, course<br>WHERE score.c_no &#x3D; course.no;<br>+------+-----------------+--------+<br>| s_no | c_name          | degree |<br>+------+-----------------+--------+<br>| 103  | 计算机导论      |     92 |<br>| 105  | 计算机导论      |     88 |<br>| 109  | 计算机导论      |     76 |<br>| 103  | 操作系统        |     86 |<br>| 105  | 操作系统        |     75 |<br>| 109  | 操作系统        |     68 |<br>| 103  | 数字电路        |     85 |<br>| 105  | 数字电路        |     79 |<br>| 109  | 数字电路        |     81 |<br>+------+-----------------+--------+<br></code></pre></td></tr></table></figure>

<h3 id="三表关联查询"><a href="#三表关联查询" class="headerlink" title="三表关联查询"></a>三表关联查询</h3><p><strong>查询所有学生的 <code>name</code> 、课程名 ( <code>course</code> 表中的 <code>name</code> ) 和 <code>degree</code> 。</strong></p>
<p>只有 <code>score</code> 表中关联学生的学号和课堂号，我们只要围绕着 <code>score</code> 这张表查询就好了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM score;<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 103  | 3-105 |     92 |<br>| 103  | 3-245 |     86 |<br>| 103  | 6-166 |     85 |<br>| 105  | 3-105 |     88 |<br>| 105  | 3-245 |     75 |<br>| 105  | 6-166 |     79 |<br>| 109  | 3-105 |     76 |<br>| 109  | 3-245 |     68 |<br>| 109  | 6-166 |     81 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<p>只要把 <code>s_no</code> 和 <code>c_no</code> 替换成 <code>student</code> 和 <code>srouse</code> 表中对应的 <code>name</code> 字段值就好了。</p>
<p>首先把 <code>s_no</code> 替换成 <code>student</code> 表中的 <code>name</code> 字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT name, c_no, degree FROM student, score WHERE student.no &#x3D; score.s_no;<br>+-----------+-------+--------+<br>| name      | c_no  | degree |<br>+-----------+-------+--------+<br>| 王丽      | 3-105 |     92 |<br>| 王丽      | 3-245 |     86 |<br>| 王丽      | 6-166 |     85 |<br>| 王芳      | 3-105 |     88 |<br>| 王芳      | 3-245 |     75 |<br>| 王芳      | 6-166 |     79 |<br>| 赵铁柱    | 3-105 |     76 |<br>| 赵铁柱    | 3-245 |     68 |<br>| 赵铁柱    | 6-166 |     81 |<br>+-----------+-------+--------+<br></code></pre></td></tr></table></figure>

<p>再把 <code>c_no</code> 替换成 <code>course</code> 表中的 <code>name</code> 字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 课程表<br>SELECT no, name FROM course;<br>+-------+-----------------+<br>| no    | name            |<br>+-------+-----------------+<br>| 3-105 | 计算机导论      |<br>| 3-245 | 操作系统        |<br>| 6-166 | 数字电路        |<br>| 9-888 | 高等数学        |<br>+-------+-----------------+<br><br>-- 由于字段名存在重复，使用 &quot;表名.字段名 as 别名&quot; 代替。<br>SELECT student.name as s_name, course.name as c_name, degree <br>FROM student, score, course<br>WHERE student.NO &#x3D; score.s_no<br>AND score.c_no &#x3D; course.no;<br></code></pre></td></tr></table></figure>

<h3 id="子查询加分组求平均分"><a href="#子查询加分组求平均分" class="headerlink" title="子查询加分组求平均分"></a>子查询加分组求平均分</h3><p><strong>查询 <code>95031</code> 班学生每门课程的平均成绩。</strong></p>
<p>在 <code>score</code> 表中根据 <code>student</code>  表的学生编号筛选出学生的课堂号和成绩：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- IN (..): 将筛选出的学生号当做 s_no 的条件查询<br>SELECT s_no, c_no, degree FROM score<br>WHERE s_no IN (SELECT no FROM student WHERE class &#x3D; &#39;95031&#39;);<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 105  | 3-105 |     88 |<br>| 105  | 3-245 |     75 |<br>| 105  | 6-166 |     79 |<br>| 109  | 3-105 |     76 |<br>| 109  | 3-245 |     68 |<br>| 109  | 6-166 |     81 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<p>这时只要将 <code>c_no</code> 分组一下就能得出 <code>95031</code> 班学生每门课的平均成绩：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT c_no, AVG(degree) FROM score<br>WHERE s_no IN (SELECT no FROM student WHERE class &#x3D; &#39;95031&#39;)<br>GROUP BY c_no;<br>+-------+-------------+<br>| c_no  | AVG(degree) |<br>+-------+-------------+<br>| 3-105 |     82.0000 |<br>| 3-245 |     71.5000 |<br>| 6-166 |     80.0000 |<br>+-------+-------------+<br></code></pre></td></tr></table></figure>

<h3 id="子查询-1"><a href="#子查询-1" class="headerlink" title="子查询 - 1"></a>子查询 - 1</h3><p><strong>查询在 <code>3-105</code> 课程中，所有成绩高于 <code>109</code> 号同学的记录。</strong></p>
<p>首先筛选出课堂号为 <code>3-105</code> ，在找出所有成绩高于 <code>109</code> 号同学的的行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM score <br>WHERE c_no &#x3D; &#39;3-105&#39;<br>AND degree &gt; (SELECT degree FROM score WHERE s_no &#x3D; &#39;109&#39; AND c_no &#x3D; &#39;3-105&#39;);<br></code></pre></td></tr></table></figure>

<h3 id="子查询-2"><a href="#子查询-2" class="headerlink" title="子查询 - 2"></a>子查询 - 2</h3><p><strong>查询所有成绩高于 <code>109</code> 号同学的 <code>3-105</code> 课程成绩记录。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 不限制课程号，只要成绩大于109号同学的3-105课程成绩就可以。<br>SELECT * FROM score<br>WHERE degree &gt; (SELECT degree FROM score WHERE s_no &#x3D; &#39;109&#39; AND c_no &#x3D; &#39;3-105&#39;);<br></code></pre></td></tr></table></figure>

<h3 id="YEAR-函数与带-IN-关键字查询"><a href="#YEAR-函数与带-IN-关键字查询" class="headerlink" title="YEAR 函数与带 IN 关键字查询"></a>YEAR 函数与带 IN 关键字查询</h3><p><strong>查询所有和 <code>101</code> 、<code>108</code> 号学生同年出生的 <code>no</code> 、<code>name</code> 、<code>birthday</code> 列。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- YEAR(..): 取出日期中的年份<br>SELECT no, name, birthday FROM student<br>WHERE YEAR(birthday) IN (SELECT YEAR(birthday) FROM student WHERE no IN (101, 108));<br></code></pre></td></tr></table></figure>

<h3 id="多层嵌套子查询"><a href="#多层嵌套子查询" class="headerlink" title="多层嵌套子查询"></a>多层嵌套子查询</h3><p><strong>查询 <code>&#39;张旭&#39;</code> 教师任课的学生成绩表。</strong></p>
<p>首先找到教师编号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT NO FROM teacher WHERE NAME &#x3D; &#39;张旭&#39;<br></code></pre></td></tr></table></figure>

<p>通过 <code>sourse</code> 表找到该教师课程号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT NO FROM course WHERE t_no &#x3D; ( SELECT NO FROM teacher WHERE NAME &#x3D; &#39;张旭&#39; );<br></code></pre></td></tr></table></figure>

<p>通过筛选出的课程号查询成绩表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM score WHERE c_no &#x3D; (<br>    SELECT no FROM course WHERE t_no &#x3D; ( <br>        SELECT no FROM teacher WHERE NAME &#x3D; &#39;张旭&#39; <br>    )<br>);<br></code></pre></td></tr></table></figure>

<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p><strong>查询某选修课程多于5个同学的教师姓名。</strong></p>
<p>首先在 <code>teacher</code> 表中，根据 <code>no</code> 字段来判断该教师的同一门课程是否有至少5名学员选修：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 查询 teacher 表<br>SELECT no, name FROM teacher;<br>+-----+--------+<br>| no  | name   |<br>+-----+--------+<br>| 804 | 李诚   |<br>| 825 | 王萍   |<br>| 831 | 刘冰   |<br>| 856 | 张旭   |<br>+-----+--------+<br><br>SELECT name FROM teacher WHERE no IN (<br>    -- 在这里找到对应的条件<br>);<br></code></pre></td></tr></table></figure>

<p>查看和教师编号有有关的表的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM course;<br>-- t_no: 教师编号<br>+-------+-----------------+------+<br>| no    | name            | t_no |<br>+-------+-----------------+------+<br>| 3-105 | 计算机导论      | 825  |<br>| 3-245 | 操作系统        | 804  |<br>| 6-166 | 数字电路        | 856  |<br>| 9-888 | 高等数学        | 831  |<br>+-------+-----------------+------+<br></code></pre></td></tr></table></figure>

<p>我们已经找到和教师编号有关的字段就在 <code>course</code> 表中，但是还无法知道哪门课程至少有5名学生选修，所以还需要根据 <code>score</code> 表来查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 在此之前向 score 插入一些数据，以便丰富查询条件。<br>INSERT INTO score VALUES (&#39;101&#39;, &#39;3-105&#39;, &#39;90&#39;);<br>INSERT INTO score VALUES (&#39;102&#39;, &#39;3-105&#39;, &#39;91&#39;);<br>INSERT INTO score VALUES (&#39;104&#39;, &#39;3-105&#39;, &#39;89&#39;);<br><br>-- 查询 score 表<br>SELECT * FROM score;<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 101  | 3-105 |     90 |<br>| 102  | 3-105 |     91 |<br>| 103  | 3-105 |     92 |<br>| 103  | 3-245 |     86 |<br>| 103  | 6-166 |     85 |<br>| 104  | 3-105 |     89 |<br>| 105  | 3-105 |     88 |<br>| 105  | 3-245 |     75 |<br>| 105  | 6-166 |     79 |<br>| 109  | 3-105 |     76 |<br>| 109  | 3-245 |     68 |<br>| 109  | 6-166 |     81 |<br>+------+-------+--------+<br><br>-- 在 score 表中将 c_no 作为分组，并且限制 c_no 持有至少 5 条数据。<br>SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5;<br>+-------+<br>| c_no  |<br>+-------+<br>| 3-105 |<br>+-------+<br></code></pre></td></tr></table></figure>

<p>根据筛选出来的课程号，找出在某课程中，拥有至少5名学员的教师编号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT t_no FROM course WHERE no IN (<br>    SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5<br>);<br>+------+<br>| t_no |<br>+------+<br>| 825  |<br>+------+<br></code></pre></td></tr></table></figure>

<p>在 <code>teacher</code> 表中，根据筛选出来的教师编号找到教师姓名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT name FROM teacher WHERE no IN (<br>    -- 最终条件<br>    SELECT t_no FROM course WHERE no IN (<br>        SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5<br>    )<br>);<br></code></pre></td></tr></table></figure>

<h3 id="子查询-3"><a href="#子查询-3" class="headerlink" title="子查询 - 3"></a>子查询 - 3</h3><p><strong>查询 “计算机系” 课程的成绩表。</strong></p>
<p>思路是，先找出 <code>course</code> 表中所有 <code>计算机系</code> 课程的编号，然后根据这个编号查询 <code>score</code> 表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 通过 teacher 表查询所有 &#96;计算机系&#96; 的教师编号<br>SELECT no, name, department FROM teacher WHERE department &#x3D; &#39;计算机系&#39;<br>+-----+--------+--------------+<br>| no  | name   | department   |<br>+-----+--------+--------------+<br>| 804 | 李诚   | 计算机系     |<br>| 825 | 王萍   | 计算机系     |<br>+-----+--------+--------------+<br><br>-- 通过 course 表查询该教师的课程编号<br>SELECT no FROM course WHERE t_no IN (<br>    SELECT no FROM teacher WHERE department &#x3D; &#39;计算机系&#39;<br>);<br>+-------+<br>| no    |<br>+-------+<br>| 3-245 |<br>| 3-105 |<br>+-------+<br><br>-- 根据筛选出来的课程号查询成绩表<br>SELECT * FROM score WHERE c_no IN (<br>    SELECT no FROM course WHERE t_no IN (<br>        SELECT no FROM teacher WHERE department &#x3D; &#39;计算机系&#39;<br>    )<br>);<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 103  | 3-245 |     86 |<br>| 105  | 3-245 |     75 |<br>| 109  | 3-245 |     68 |<br>| 101  | 3-105 |     90 |<br>| 102  | 3-105 |     91 |<br>| 103  | 3-105 |     92 |<br>| 104  | 3-105 |     89 |<br>| 105  | 3-105 |     88 |<br>| 109  | 3-105 |     76 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<h3 id="UNION-和-NOTIN-的使用"><a href="#UNION-和-NOTIN-的使用" class="headerlink" title="UNION 和 NOTIN 的使用"></a>UNION 和 NOTIN 的使用</h3><p><strong>查询 <code>计算机系</code> 与 <code>电子工程系</code> 中的不同职称的教师。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- NOT: 代表逻辑非<br>SELECT * FROM teacher WHERE department &#x3D; &#39;计算机系&#39; AND profession NOT IN (<br>    SELECT profession FROM teacher WHERE department &#x3D; &#39;电子工程系&#39;<br>)<br>-- 合并两个集<br>UNION<br>SELECT * FROM teacher WHERE department &#x3D; &#39;电子工程系&#39; AND profession NOT IN (<br>    SELECT profession FROM teacher WHERE department &#x3D; &#39;计算机系&#39;<br>);<br></code></pre></td></tr></table></figure>

<h3 id="ANY-表示至少一个-DESC-降序"><a href="#ANY-表示至少一个-DESC-降序" class="headerlink" title="ANY 表示至少一个 - DESC ( 降序 )"></a>ANY 表示至少一个 - DESC ( 降序 )</h3><p><strong>查询课程 <code>3-105</code> 且成绩 <u>至少</u> 高于 <code>3-245</code> 的 <code>score</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39;;<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 101  | 3-105 |     90 |<br>| 102  | 3-105 |     91 |<br>| 103  | 3-105 |     92 |<br>| 104  | 3-105 |     89 |<br>| 105  | 3-105 |     88 |<br>| 109  | 3-105 |     76 |<br>+------+-------+--------+<br><br>SELECT * FROM score WHERE c_no &#x3D; &#39;3-245&#39;;<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 103  | 3-245 |     86 |<br>| 105  | 3-245 |     75 |<br>| 109  | 3-245 |     68 |<br>+------+-------+--------+<br><br>-- ANY: 符合SQL语句中的任意条件。<br>-- 也就是说，在 3-105 成绩中，只要有一个大于从 3-245 筛选出来的任意行就符合条件，<br>-- 最后根据降序查询结果。<br>SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39; AND degree &gt; ANY(<br>    SELECT degree FROM score WHERE c_no &#x3D; &#39;3-245&#39;<br>) ORDER BY degree DESC;<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 103  | 3-105 |     92 |<br>| 102  | 3-105 |     91 |<br>| 101  | 3-105 |     90 |<br>| 104  | 3-105 |     89 |<br>| 105  | 3-105 |     88 |<br>| 109  | 3-105 |     76 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<h3 id="表示所有的-ALL"><a href="#表示所有的-ALL" class="headerlink" title="表示所有的 ALL"></a>表示所有的 ALL</h3><p><strong>查询课程 <code>3-105</code> 且成绩高于 <code>3-245</code> 的 <code>score</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 只需对上一道题稍作修改。<br>-- ALL: 符合SQL语句中的所有条件。<br>-- 也就是说，在 3-105 每一行成绩中，都要大于从 3-245 筛选出来全部行才算符合条件。<br>SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39; AND degree &gt; ALL(<br>    SELECT degree FROM score WHERE c_no &#x3D; &#39;3-245&#39;<br>);<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 101  | 3-105 |     90 |<br>| 102  | 3-105 |     91 |<br>| 103  | 3-105 |     92 |<br>| 104  | 3-105 |     89 |<br>| 105  | 3-105 |     88 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<h3 id="复制表的数据作为条件查询"><a href="#复制表的数据作为条件查询" class="headerlink" title="复制表的数据作为条件查询"></a>复制表的数据作为条件查询</h3><p><strong>查询某课程成绩比该课程平均成绩低的 <code>score</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 查询平均分<br>SELECT c_no, AVG(degree) FROM score GROUP BY c_no;<br>+-------+-------------+<br>| c_no  | AVG(degree) |<br>+-------+-------------+<br>| 3-105 |     87.6667 |<br>| 3-245 |     76.3333 |<br>| 6-166 |     81.6667 |<br>+-------+-------------+<br><br>-- 查询 score 表<br>SELECT degree FROM score;<br>+--------+<br>| degree |<br>+--------+<br>|     90 |<br>|     91 |<br>|     92 |<br>|     86 |<br>|     85 |<br>|     89 |<br>|     88 |<br>|     75 |<br>|     79 |<br>|     76 |<br>|     68 |<br>|     81 |<br>+--------+<br><br>-- 将表 b 作用于表 a 中查询数据<br>-- score a (b): 将表声明为 a (b)，<br>-- 如此就能用 a.c_no &#x3D; b.c_no 作为条件执行查询了。<br>SELECT * FROM score a WHERE degree &lt; (<br>    (SELECT AVG(degree) FROM score b WHERE a.c_no &#x3D; b.c_no)<br>);<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 105  | 3-245 |     75 |<br>| 105  | 6-166 |     79 |<br>| 109  | 3-105 |     76 |<br>| 109  | 3-245 |     68 |<br>| 109  | 6-166 |     81 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<h3 id="子查询-4"><a href="#子查询-4" class="headerlink" title="子查询 - 4"></a>子查询 - 4</h3><p><strong>查询所有任课 ( 在 <code>course</code> 表里有课程 ) 教师的 <code>name</code> 和 <code>department</code></strong> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT name, department FROM teacher WHERE no IN (SELECT t_no FROM course);<br>+--------+-----------------+<br>| name   | department      |<br>+--------+-----------------+<br>| 李诚   | 计算机系        |<br>| 王萍   | 计算机系        |<br>| 刘冰   | 电子工程系      |<br>| 张旭   | 电子工程系      |<br>+--------+-----------------+<br></code></pre></td></tr></table></figure>

<h3 id="条件加组筛选"><a href="#条件加组筛选" class="headerlink" title="条件加组筛选"></a>条件加组筛选</h3><p><strong>查询 <code>student</code> 表中至少有 2 名男生的 <code>class</code> 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 查看学生表信息<br>SELECT * FROM student;<br>+-----+-----------+-----+------------+-------+<br>| no  | name      | sex | birthday   | class |<br>+-----+-----------+-----+------------+-------+<br>| 101 | 曾华      | 男  | 1977-09-01 | 95033 |<br>| 102 | 匡明      | 男  | 1975-10-02 | 95031 |<br>| 103 | 王丽      | 女  | 1976-01-23 | 95033 |<br>| 104 | 李军      | 男  | 1976-02-20 | 95033 |<br>| 105 | 王芳      | 女  | 1975-02-10 | 95031 |<br>| 106 | 陆军      | 男  | 1974-06-03 | 95031 |<br>| 107 | 王尼玛    | 男  | 1976-02-20 | 95033 |<br>| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |<br>| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |<br>| 110 | 张飞      | 男  | 1974-06-03 | 95038 |<br>+-----+-----------+-----+------------+-------+<br><br>-- 只查询性别为男，然后按 class 分组，并限制 class 行大于 1。<br>SELECT class FROM student WHERE sex &#x3D; &#39;男&#39; GROUP BY class HAVING COUNT(*) &gt; 1;<br>+-------+<br>| class |<br>+-------+<br>| 95033 |<br>| 95031 |<br>+-------+<br></code></pre></td></tr></table></figure>

<h3 id="NOTLIKE-模糊查询取反"><a href="#NOTLIKE-模糊查询取反" class="headerlink" title="NOTLIKE 模糊查询取反"></a>NOTLIKE 模糊查询取反</h3><p><strong>查询 <code>student</code> 表中不姓 “王” 的同学记录。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- NOT: 取反<br>-- LIKE: 模糊查询<br>mysql&gt; SELECT * FROM student WHERE name NOT LIKE &#39;王%&#39;;<br>+-----+-----------+-----+------------+-------+<br>| no  | name      | sex | birthday   | class |<br>+-----+-----------+-----+------------+-------+<br>| 101 | 曾华      | 男  | 1977-09-01 | 95033 |<br>| 102 | 匡明      | 男  | 1975-10-02 | 95031 |<br>| 104 | 李军      | 男  | 1976-02-20 | 95033 |<br>| 106 | 陆军      | 男  | 1974-06-03 | 95031 |<br>| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |<br>| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |<br>| 110 | 张飞      | 男  | 1974-06-03 | 95038 |<br>+-----+-----------+-----+------------+-------+<br></code></pre></td></tr></table></figure>

<h3 id="YEAR-与-NOW-函数"><a href="#YEAR-与-NOW-函数" class="headerlink" title="YEAR 与 NOW 函数"></a>YEAR 与 NOW 函数</h3><p><strong>查询 <code>student</code> 表中每个学生的姓名和年龄。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 使用函数 YEAR(NOW()) 计算出当前年份，减去出生年份后得出年龄。<br>SELECT name, YEAR(NOW()) - YEAR(birthday) as age FROM student;<br>+-----------+------+<br>| name      | age  |<br>+-----------+------+<br>| 曾华      |   42 |<br>| 匡明      |   44 |<br>| 王丽      |   43 |<br>| 李军      |   43 |<br>| 王芳      |   44 |<br>| 陆军      |   45 |<br>| 王尼玛    |   43 |<br>| 张全蛋    |   44 |<br>| 赵铁柱    |   45 |<br>| 张飞      |   45 |<br>+-----------+------+<br></code></pre></td></tr></table></figure>

<h3 id="MAX-与-MIN-函数"><a href="#MAX-与-MIN-函数" class="headerlink" title="MAX 与 MIN 函数"></a>MAX 与 MIN 函数</h3><p><strong>查询 <code>student</code> 表中最大和最小的 <code>birthday</code> 值。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT MAX(birthday), MIN(birthday) FROM student;<br>+---------------+---------------+<br>| MAX(birthday) | MIN(birthday) |<br>+---------------+---------------+<br>| 1977-09-01    | 1974-06-03    |<br>+---------------+---------------+<br></code></pre></td></tr></table></figure>

<h3 id="多段排序"><a href="#多段排序" class="headerlink" title="多段排序"></a>多段排序</h3><p><strong>以 <code>class</code> 和 <code>birthday</code> 从大到小的顺序查询 <code>student</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM student ORDER BY class DESC, birthday;<br>+-----+-----------+-----+------------+-------+<br>| no  | name      | sex | birthday   | class |<br>+-----+-----------+-----+------------+-------+<br>| 110 | 张飞      | 男  | 1974-06-03 | 95038 |<br>| 103 | 王丽      | 女  | 1976-01-23 | 95033 |<br>| 104 | 李军      | 男  | 1976-02-20 | 95033 |<br>| 107 | 王尼玛    | 男  | 1976-02-20 | 95033 |<br>| 101 | 曾华      | 男  | 1977-09-01 | 95033 |<br>| 106 | 陆军      | 男  | 1974-06-03 | 95031 |<br>| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |<br>| 105 | 王芳      | 女  | 1975-02-10 | 95031 |<br>| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |<br>| 102 | 匡明      | 男  | 1975-10-02 | 95031 |<br>+-----+-----------+-----+------------+-------+<br></code></pre></td></tr></table></figure>

<h3 id="子查询-5"><a href="#子查询-5" class="headerlink" title="子查询 - 5"></a>子查询 - 5</h3><p><strong>查询 “男” 教师及其所上的课程。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM course WHERE t_no in (SELECT no FROM teacher WHERE sex &#x3D; &#39;男&#39;);<br>+-------+--------------+------+<br>| no    | name         | t_no |<br>+-------+--------------+------+<br>| 3-245 | 操作系统     | 804  |<br>| 6-166 | 数字电路     | 856  |<br>+-------+--------------+------+<br></code></pre></td></tr></table></figure>

<h3 id="MAX-函数与子查询"><a href="#MAX-函数与子查询" class="headerlink" title="MAX 函数与子查询"></a>MAX 函数与子查询</h3><p><strong>查询最高分同学的 <code>score</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 找出最高成绩（该查询只能有一个结果）<br>SELECT MAX(degree) FROM score;<br><br>-- 根据上面的条件筛选出所有最高成绩表，<br>-- 该查询可能有多个结果，假设 degree 值多次符合条件。<br>SELECT * FROM score WHERE degree &#x3D; (SELECT MAX(degree) FROM score);<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 103  | 3-105 |     92 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<h3 id="子查询-6"><a href="#子查询-6" class="headerlink" title="子查询 - 6"></a>子查询 - 6</h3><p><strong>查询和 “李军” 同性别的所有同学 <code>name</code> 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 首先将李军的性别作为条件取出来<br>SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;;<br>+-----+<br>| sex |<br>+-----+<br>| 男  |<br>+-----+<br><br>-- 根据性别查询 name 和 sex<br>SELECT name, sex FROM student WHERE sex &#x3D; (<br>    SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;<br>);<br>+-----------+-----+<br>| name      | sex |<br>+-----------+-----+<br>| 曾华      | 男  |<br>| 匡明      | 男  |<br>| 李军      | 男  |<br>| 陆军      | 男  |<br>| 王尼玛    | 男  |<br>| 张全蛋    | 男  |<br>| 赵铁柱    | 男  |<br>| 张飞      | 男  |<br>+-----------+-----+<br></code></pre></td></tr></table></figure>

<h3 id="子查询-7"><a href="#子查询-7" class="headerlink" title="子查询 - 7"></a>子查询 - 7</h3><p><strong>查询和 “李军” 同性别且同班的同学 <code>name</code> 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT name, sex, class FROM student WHERE sex &#x3D; (<br>    SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;<br>) AND class &#x3D; (<br>    SELECT class FROM student WHERE name &#x3D; &#39;李军&#39;<br>);<br>+-----------+-----+-------+<br>| name      | sex | class |<br>+-----------+-----+-------+<br>| 曾华      | 男  | 95033 |<br>| 李军      | 男  | 95033 |<br>| 王尼玛    | 男  | 95033 |<br>+-----------+-----+-------+<br></code></pre></td></tr></table></figure>

<h3 id="子查询-8"><a href="#子查询-8" class="headerlink" title="子查询 - 8"></a>子查询 - 8</h3><p><strong>查询所有选修 “计算机导论” 课程的 “男” 同学成绩表。</strong></p>
<p>需要的 “计算机导论” 和性别为 “男” 的编号可以在 <code>course</code> 和 <code>student</code> 表中找到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM score WHERE c_no &#x3D; (<br>    SELECT no FROM course WHERE name &#x3D; &#39;计算机导论&#39;<br>) AND s_no IN (<br>    SELECT no FROM student WHERE sex &#x3D; &#39;男&#39;<br>);<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 101  | 3-105 |     90 |<br>| 102  | 3-105 |     91 |<br>| 104  | 3-105 |     89 |<br>| 109  | 3-105 |     76 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<h3 id="按等级查询"><a href="#按等级查询" class="headerlink" title="按等级查询"></a>按等级查询</h3><p>建立一个 <code>grade</code> 表代表学生的成绩等级，并插入数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE grade (<br>    low INT(3),<br>    upp INT(3),<br>    grade char(1)<br>);<br><br>INSERT INTO grade VALUES (90, 100, &#39;A&#39;);<br>INSERT INTO grade VALUES (80, 89, &#39;B&#39;);<br>INSERT INTO grade VALUES (70, 79, &#39;C&#39;);<br>INSERT INTO grade VALUES (60, 69, &#39;D&#39;);<br>INSERT INTO grade VALUES (0, 59, &#39;E&#39;);<br><br>SELECT * FROM grade;<br>+------+------+-------+<br>| low  | upp  | grade |<br>+------+------+-------+<br>|   90 |  100 | A     |<br>|   80 |   89 | B     |<br>|   70 |   79 | C     |<br>|   60 |   69 | D     |<br>|    0 |   59 | E     |<br>+------+------+-------+<br></code></pre></td></tr></table></figure>

<p><strong>查询所有学生的 <code>s_no</code> 、<code>c_no</code> 和 <code>grade</code> 列。</strong></p>
<p>思路是，使用区间 ( <code>BETWEEN</code> ) 查询，判断学生的成绩 ( <code>degree</code> )  在 <code>grade</code> 表的 <code>low</code> 和 <code>upp</code> 之间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT s_no, c_no, grade FROM score, grade <br>WHERE degree BETWEEN low AND upp;<br>+------+-------+-------+<br>| s_no | c_no  | grade |<br>+------+-------+-------+<br>| 101  | 3-105 | A     |<br>| 102  | 3-105 | A     |<br>| 103  | 3-105 | A     |<br>| 103  | 3-245 | B     |<br>| 103  | 6-166 | B     |<br>| 104  | 3-105 | B     |<br>| 105  | 3-105 | B     |<br>| 105  | 3-245 | C     |<br>| 105  | 6-166 | C     |<br>| 109  | 3-105 | C     |<br>| 109  | 3-245 | D     |<br>| 109  | 6-166 | B     |<br>+------+-------+-------+<br></code></pre></td></tr></table></figure>

<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>准备用于测试连接查询的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE DATABASE testJoin;<br><br>CREATE TABLE person (<br>    id INT,<br>    name VARCHAR(20),<br>    cardId INT<br>);<br><br>CREATE TABLE card (<br>    id INT,<br>    name VARCHAR(20)<br>);<br><br>INSERT INTO card VALUES (1, &#39;饭卡&#39;), (2, &#39;建行卡&#39;), (3, &#39;农行卡&#39;), (4, &#39;工商卡&#39;), (5, &#39;邮政卡&#39;);<br>SELECT * FROM card;<br>+------+-----------+<br>| id   | name      |<br>+------+-----------+<br>|    1 | 饭卡      |<br>|    2 | 建行卡    |<br>|    3 | 农行卡    |<br>|    4 | 工商卡    |<br>|    5 | 邮政卡    |<br>+------+-----------+<br><br>INSERT INTO person VALUES (1, &#39;张三&#39;, 1), (2, &#39;李四&#39;, 3), (3, &#39;王五&#39;, 6);<br>SELECT * FROM person;<br>+------+--------+--------+<br>| id   | name   | cardId |<br>+------+--------+--------+<br>|    1 | 张三   |      1 |<br>|    2 | 李四   |      3 |<br>|    3 | 王五   |      6 |<br>+------+--------+--------+<br></code></pre></td></tr></table></figure>

<p>分析两张表发现，<code>person</code> 表并没有为 <code>cardId</code> 字段设置一个在 <code>card</code> 表中对应的 <code>id</code> 外键。如果设置了的话，<code>person</code> 中 <code>cardId</code> 字段值为 <code>6</code> 的行就插不进去，因为该 <code>cardId</code> 值在 <code>card</code> 表中并没有。</p>
<h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>要查询这两张表中有关系的数据，可以使用 <code>INNER JOIN</code> ( 内连接 ) 将它们连接在一起。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- INNER JOIN: 表示为内连接，将两张表拼接在一起。<br>-- on: 表示要执行某个条件。<br>SELECT * FROM person INNER JOIN card on person.cardId &#x3D; card.id;<br>+------+--------+--------+------+-----------+<br>| id   | name   | cardId | id   | name      |<br>+------+--------+--------+------+-----------+<br>|    1 | 张三   |      1 |    1 | 饭卡      |<br>|    2 | 李四   |      3 |    3 | 农行卡    |<br>+------+--------+--------+------+-----------+<br><br>-- 将 INNER 关键字省略掉，结果也是一样的。<br>-- SELECT * FROM person JOIN card on person.cardId &#x3D; card.id;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code>card</code> 的整张表被连接到了右边。</p>
</blockquote>
<h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p>完整显示左边的表 ( <code>person</code> ) ，右边的表如果符合条件就显示，不符合则补 <code>NULL</code> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- LEFT JOIN 也叫做 LEFT OUTER JOIN，用这两种方式的查询结果是一样的。<br>SELECT * FROM person LEFT JOIN card on person.cardId &#x3D; card.id;<br>+------+--------+--------+------+-----------+<br>| id   | name   | cardId | id   | name      |<br>+------+--------+--------+------+-----------+<br>|    1 | 张三   |      1 |    1 | 饭卡      |<br>|    2 | 李四   |      3 |    3 | 农行卡    |<br>|    3 | 王五   |      6 | NULL | NULL      |<br>+------+--------+--------+------+-----------+<br></code></pre></td></tr></table></figure>

<h4 id="右外链接"><a href="#右外链接" class="headerlink" title="右外链接"></a>右外链接</h4><p>完整显示右边的表 ( <code>card</code> ) ，左边的表如果符合条件就显示，不符合则补 <code>NULL</code> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM person RIGHT JOIN card on person.cardId &#x3D; card.id;<br>+------+--------+--------+------+-----------+<br>| id   | name   | cardId | id   | name      |<br>+------+--------+--------+------+-----------+<br>|    1 | 张三   |      1 |    1 | 饭卡      |<br>|    2 | 李四   |      3 |    3 | 农行卡    |<br>| NULL | NULL   |   NULL |    2 | 建行卡    |<br>| NULL | NULL   |   NULL |    4 | 工商卡    |<br>| NULL | NULL   |   NULL |    5 | 邮政卡    |<br>+------+--------+--------+------+-----------+<br></code></pre></td></tr></table></figure>

<h4 id="全外链接"><a href="#全外链接" class="headerlink" title="全外链接"></a>全外链接</h4><p>完整显示两张表的全部数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- MySQL 不支持这种语法的全外连接<br>-- SELECT * FROM person FULL JOIN card on person.cardId &#x3D; card.id;<br>-- 出现错误：<br>-- ERROR 1054 (42S22): Unknown column &#39;person.cardId&#39; in &#39;on clause&#39;<br><br>-- MySQL全连接语法，使用 UNION 将两张表合并在一起。<br>SELECT * FROM person LEFT JOIN card on person.cardId &#x3D; card.id<br>UNION<br>SELECT * FROM person RIGHT JOIN card on person.cardId &#x3D; card.id;<br>+------+--------+--------+------+-----------+<br>| id   | name   | cardId | id   | name      |<br>+------+--------+--------+------+-----------+<br>|    1 | 张三   |      1 |    1 | 饭卡      |<br>|    2 | 李四   |      3 |    3 | 农行卡    |<br>|    3 | 王五   |      6 | NULL | NULL      |<br>| NULL | NULL   |   NULL |    2 | 建行卡    |<br>| NULL | NULL   |   NULL |    4 | 工商卡    |<br>| NULL | NULL   |   NULL |    5 | 邮政卡    |<br>+------+--------+--------+------+-----------+<br></code></pre></td></tr></table></figure>

<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>在 MySQL 中，事务其实是一个最小的不可分割的工作单元。事务能够<strong>保证一个业务的完整性</strong>。</p>
<p>比如我们的银行转账：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- a -&gt; -100<br>UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;<br><br>-- b -&gt; +100<br>UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;<br></code></pre></td></tr></table></figure>

<p>在实际项目中，假设只有一条 SQL 语句执行成功，而另外一条执行失败了，就会出现数据前后不一致。</p>
<p>因此，在执行多条有关联 SQL 语句时，<strong>事务</strong>可能会要求这些 SQL 语句要么同时执行成功，要么就都执行失败。</p>
<h3 id="如何控制事务-COMMIT-ROLLBACK"><a href="#如何控制事务-COMMIT-ROLLBACK" class="headerlink" title="如何控制事务 - COMMIT / ROLLBACK"></a>如何控制事务 - COMMIT / ROLLBACK</h3><p>在 MySQL 中，事务的<strong>自动提交</strong>状态默认是开启的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 查询事务的自动提交状态<br>SELECT @@AUTOCOMMIT;<br>+--------------+<br>| @@AUTOCOMMIT |<br>+--------------+<br>|            1 |<br>+--------------+<br></code></pre></td></tr></table></figure>

<p><strong>自动提交的作用</strong>：当我们执行一条 SQL 语句的时候，其产生的效果就会立即体现出来，且不能<strong>回滚</strong>。</p>
<p>什么是回滚？举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE DATABASE bank;<br><br>USE bank;<br><br>CREATE TABLE user (<br>    id INT PRIMARY KEY,<br>    name VARCHAR(20),<br>    money INT<br>);<br><br>INSERT INTO user VALUES (1, &#39;a&#39;, 1000);<br><br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |  1000 |<br>+----+------+-------+<br></code></pre></td></tr></table></figure>

<p>可以看到，在执行插入语句后数据立刻生效，原因是 MySQL 中的事务自动将它<strong>提交</strong>到了数据库中。那么所谓<strong>回滚</strong>的意思就是，撤销执行过的所有 SQL 语句，使其回滚到<strong>最后一次提交</strong>数据时的状态。</p>
<p>在 MySQL 中使用 <code>ROLLBACK</code> 执行回滚：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 回滚到最后一次提交<br>ROLLBACK;<br><br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |  1000 |<br>+----+------+-------+<br></code></pre></td></tr></table></figure>

<p>由于所有执行过的 SQL 语句都已经被提交过了，所以数据并没有发生回滚。那如何让数据可以发生回滚？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 关闭自动提交<br>SET AUTOCOMMIT &#x3D; 0;<br><br>-- 查询自动提交状态<br>SELECT @@AUTOCOMMIT;<br>+--------------+<br>| @@AUTOCOMMIT |<br>+--------------+<br>|            0 |<br>+--------------+<br></code></pre></td></tr></table></figure>

<p>将自动提交关闭后，测试数据回滚：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">INSERT INTO user VALUES (2, &#39;b&#39;, 1000);<br><br>-- 关闭 AUTOCOMMIT 后，数据的变化是在一张虚拟的临时数据表中展示，<br>-- 发生变化的数据并没有真正插入到数据表中。<br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |  1000 |<br>|  2 | b    |  1000 |<br>+----+------+-------+<br><br>-- 数据表中的真实数据其实还是：<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |  1000 |<br>+----+------+-------+<br><br>-- 由于数据还没有真正提交，可以使用回滚<br>ROLLBACK;<br><br>-- 再次查询<br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |  1000 |<br>+----+------+-------+<br></code></pre></td></tr></table></figure>

<p>那如何将虚拟的数据真正提交到数据库中？使用 <code>COMMIT</code> : </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">INSERT INTO user VALUES (2, &#39;b&#39;, 1000);<br>-- 手动提交数据（持久性），<br>-- 将数据真正提交到数据库中，执行后不能再回滚提交过的数据。<br>COMMIT;<br><br>-- 提交后测试回滚<br>ROLLBACK;<br><br>-- 再次查询（回滚无效了）<br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |  1000 |<br>|  2 | b    |  1000 |<br>+----+------+-------+<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>总结</strong></p>
<ol>
<li><p><strong>自动提交</strong></p>
<ul>
<li><p>查看自动提交状态：<code>SELECT @@AUTOCOMMIT</code> ；</p>
</li>
<li><p>设置自动提交状态：<code>SET AUTOCOMMIT = 0</code> 。</p>
</li>
</ul>
</li>
<li><p><strong>手动提交</strong></p>
<p><code>@@AUTOCOMMIT = 0</code> 时，使用 <code>COMMIT</code> 命令提交事务。</p>
</li>
<li><p><strong>事务回滚</strong></p>
<p><code>@@AUTOCOMMIT = 0</code> 时，使用 <code>ROLLBACK</code> 命令回滚事务。</p>
</li>
</ol>
</blockquote>
<p><strong>事务的实际应用</strong>，让我们再回到银行转账项目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 转账<br>UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;<br><br>-- 到账<br>UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;<br><br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |   900 |<br>|  2 | b    |  1100 |<br>+----+------+-------+<br></code></pre></td></tr></table></figure>

<p>这时假设在转账时发生了意外，就可以使用 <code>ROLLBACK</code> 回滚到最后一次提交的状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 假设转账发生了意外，需要回滚。<br>ROLLBACK;<br><br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |  1000 |<br>|  2 | b    |  1000 |<br>+----+------+-------+<br></code></pre></td></tr></table></figure>

<p>这时我们又回到了发生意外之前的状态，也就是说，事务给我们提供了一个可以反悔的机会。假设数据没有发生意外，这时可以手动将数据真正提交到数据表中：<code>COMMIT</code> 。</p>
<h3 id="手动开启事务-BEGIN-START-TRANSACTION"><a href="#手动开启事务-BEGIN-START-TRANSACTION" class="headerlink" title="手动开启事务 - BEGIN / START TRANSACTION"></a>手动开启事务 - BEGIN / START TRANSACTION</h3><p>事务的默认提交被开启 ( <code>@@AUTOCOMMIT = 1</code> ) 后，此时就不能使用事务回滚了。但是我们还可以手动开启一个事务处理事件，使其可以发生回滚：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 使用 BEGIN 或者 START TRANSACTION 手动开启一个事务<br>-- START TRANSACTION;<br>BEGIN;<br>UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;<br>UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;<br><br>-- 由于手动开启的事务没有开启自动提交，<br>-- 此时发生变化的数据仍然是被保存在一张临时表中。<br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |   900 |<br>|  2 | b    |  1100 |<br>+----+------+-------+<br><br>-- 测试回滚<br>ROLLBACK;<br><br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |  1000 |<br>|  2 | b    |  1000 |<br>+----+------+-------+<br></code></pre></td></tr></table></figure>

<p>仍然使用 <code>COMMIT</code> 提交数据，提交后无法再发生本次事务的回滚。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">BEGIN;<br>UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;<br>UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;<br><br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |   900 |<br>|  2 | b    |  1100 |<br>+----+------+-------+<br><br>-- 提交数据<br>COMMIT;<br><br>-- 测试回滚（无效，因为表的数据已经被提交）<br>ROLLBACK;<br></code></pre></td></tr></table></figure>

<h3 id="事务的-ACID-特征与使用"><a href="#事务的-ACID-特征与使用" class="headerlink" title="事务的 ACID 特征与使用"></a>事务的 ACID 特征与使用</h3><p><strong>事务的四大特征：</strong></p>
<ul>
<li><strong>A 原子性</strong>：事务是最小的单位，不可以再分割；</li>
<li><strong>C 一致性</strong>：要求同一事务中的 SQL 语句，必须保证同时成功或者失败；</li>
<li><strong>I 隔离性</strong>：事务1 和 事务2 之间是具有隔离性的；</li>
<li><strong>D 持久性</strong>：事务一旦结束 ( <code>COMMIT</code> ) ，就不可以再返回了 ( <code>ROLLBACK</code> ) 。</li>
</ul>
<h3 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h3><p><strong>事务的隔离性可分为四种 ( 性能从低到高 )</strong> ：</p>
<ol>
<li><p><strong>READ UNCOMMITTED ( 读取未提交 )</strong></p>
<p>如果有多个事务，那么任意事务都可以看见其他事务的<strong>未提交数据</strong>。</p>
</li>
<li><p><strong>READ COMMITTED ( 读取已提交 )</strong></p>
<p>只能读取到其他事务<strong>已经提交的数据</strong>。</p>
</li>
<li><p><strong>REPEATABLE READ ( 可被重复读 )</strong></p>
<p>如果有多个连接都开启了事务，那么事务之间不能共享数据记录，否则只能共享已提交的记录。</p>
</li>
<li><p><strong>SERIALIZABLE ( 串行化 )</strong></p>
<p>所有的事务都会按照<strong>固定顺序执行</strong>，执行完一个事务后再继续执行下一个事务的<strong>写入操作</strong>。</p>
</li>
</ol>
<p>查看当前数据库的默认隔离级别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- MySQL 8.x, GLOBAL 表示系统级别，不加表示会话级别。<br>SELECT @@GLOBAL.TRANSACTION_ISOLATION;<br>SELECT @@TRANSACTION_ISOLATION;<br>+--------------------------------+<br>| @@GLOBAL.TRANSACTION_ISOLATION |<br>+--------------------------------+<br>| REPEATABLE-READ                | -- MySQL的默认隔离级别，可以重复读。<br>+--------------------------------+<br><br>-- MySQL 5.x<br>SELECT @@GLOBAL.TX_ISOLATION;<br>SELECT @@TX_ISOLATION;<br></code></pre></td></tr></table></figure>

<p>修改隔离级别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 设置系统隔离级别，LEVEL 后面表示要设置的隔离级别 (READ UNCOMMITTED)。<br>SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;<br><br>-- 查询系统隔离级别，发现已经被修改。<br>SELECT @@GLOBAL.TRANSACTION_ISOLATION;<br>+--------------------------------+<br>| @@GLOBAL.TRANSACTION_ISOLATION |<br>+--------------------------------+<br>| READ-UNCOMMITTED               |<br>+--------------------------------+<br></code></pre></td></tr></table></figure>

<h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>测试 <strong>READ UNCOMMITTED ( 读取未提交 )</strong> 的隔离性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">INSERT INTO user VALUES (3, &#39;小明&#39;, 1000);<br>INSERT INTO user VALUES (4, &#39;淘宝店&#39;, 1000);<br><br>SELECT * FROM user;<br>+----+-----------+-------+<br>| id | name      | money |<br>+----+-----------+-------+<br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>+----+-----------+-------+<br><br>-- 开启一个事务操作数据<br>-- 假设小明在淘宝店买了一双800块钱的鞋子：<br>START TRANSACTION;<br>UPDATE user SET money &#x3D; money - 800 WHERE name &#x3D; &#39;小明&#39;;<br>UPDATE user SET money &#x3D; money + 800 WHERE name &#x3D; &#39;淘宝店&#39;;<br><br>-- 然后淘宝店在另一方查询结果，发现钱已到账。<br>SELECT * FROM user;<br>+----+-----------+-------+<br>| id | name      | money |<br>+----+-----------+-------+<br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |   200 |<br>|  4 | 淘宝店    |  1800 |<br>+----+-----------+-------+<br></code></pre></td></tr></table></figure>

<p>由于小明的转账是在新开启的事务上进行操作的，而该操作的结果是可以被其他事务（另一方的淘宝店）看见的，因此淘宝店的查询结果是正确的，淘宝店确认到账。但就在这时，如果小明在它所处的事务上又执行了 <code>ROLLBACK</code> 命令，会发生什么？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 小明所处的事务<br>ROLLBACK;<br><br>-- 此时无论对方是谁，如果再去查询结果就会发现：<br>SELECT * FROM user;<br>+----+-----------+-------+<br>| id | name      | money |<br>+----+-----------+-------+<br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>+----+-----------+-------+<br></code></pre></td></tr></table></figure>

<p>这就是所谓的<strong>脏读</strong>，一个事务读取到另外一个事务还未提交的数据。这在实际开发中是不允许出现的。</p>
<h4 id="读取已提交"><a href="#读取已提交" class="headerlink" title="读取已提交"></a>读取已提交</h4><p>把隔离级别设置为 <strong>READ COMMITTED</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;<br>SELECT @@GLOBAL.TRANSACTION_ISOLATION;<br>+--------------------------------+<br>| @@GLOBAL.TRANSACTION_ISOLATION |<br>+--------------------------------+<br>| READ-COMMITTED                 |<br>+--------------------------------+<br></code></pre></td></tr></table></figure>

<p>这样，再有新的事务连接进来时，它们就只能查询到已经提交过的事务数据了。但是对于当前事务来说，它们看到的还是未提交的数据，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 正在操作数据事务（当前事务）<br>START TRANSACTION;<br>UPDATE user SET money &#x3D; money - 800 WHERE name &#x3D; &#39;小明&#39;;<br>UPDATE user SET money &#x3D; money + 800 WHERE name &#x3D; &#39;淘宝店&#39;;<br><br>-- 虽然隔离级别被设置为了 READ COMMITTED，但在当前事务中，<br>-- 它看到的仍然是数据表中临时改变数据，而不是真正提交过的数据。<br>SELECT * FROM user;<br>+----+-----------+-------+<br>| id | name      | money |<br>+----+-----------+-------+<br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |   200 |<br>|  4 | 淘宝店    |  1800 |<br>+----+-----------+-------+<br><br><br>-- 假设此时在远程开启了一个新事务，连接到数据库。<br>$ mysql -u root -p12345612<br><br>-- 此时远程连接查询到的数据只能是已经提交过的<br>SELECT * FROM user;<br>+----+-----------+-------+<br>| id | name      | money |<br>+----+-----------+-------+<br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>+----+-----------+-------+<br></code></pre></td></tr></table></figure>

<p>但是这样还有问题，那就是假设一个事务在操作数据时，其他事务干扰了这个事务的数据。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 小张在查询数据的时候发现：<br>SELECT * FROM user;<br>+----+-----------+-------+<br>| id | name      | money |<br>+----+-----------+-------+<br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |   200 |<br>|  4 | 淘宝店    |  1800 |<br>+----+-----------+-------+<br><br>-- 在小张求表的 money 平均值之前，小王做了一个操作：<br>START TRANSACTION;<br>INSERT INTO user VALUES (5, &#39;c&#39;, 100);<br>COMMIT;<br><br>-- 此时表的真实数据是：<br>SELECT * FROM user;<br>+----+-----------+-------+<br>| id | name      | money |<br>+----+-----------+-------+<br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>|  5 | c         |   100 |<br>+----+-----------+-------+<br><br>-- 这时小张再求平均值的时候，就会出现计算不相符合的情况：<br>SELECT AVG(money) FROM user;<br>+------------+<br>| AVG(money) |<br>+------------+<br>|  820.0000  |<br>+------------+<br></code></pre></td></tr></table></figure>

<p>虽然 <strong>READ COMMITTED</strong> 让我们只能读取到其他事务已经提交的数据，但还是会出现问题，就是<strong>在读取同一个表的数据时，可能会发生前后不一致的情况。</strong>这被称为<strong>不可重复读现象 ( READ COMMITTED )</strong> 。</p>
<h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>将隔离级别设置为 <strong>REPEATABLE READ ( 可被重复读取 )</strong> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br>SELECT @@GLOBAL.TRANSACTION_ISOLATION;<br>+--------------------------------+<br>| @@GLOBAL.TRANSACTION_ISOLATION |<br>+--------------------------------+<br>| REPEATABLE-READ                |<br>+--------------------------------+<br></code></pre></td></tr></table></figure>

<p>测试 <strong>REPEATABLE READ</strong> ，假设在两个不同的连接上分别执行 <code>START TRANSACTION</code> :</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 小张 - 成都</span><br><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">1000</span>);<br><br><span class="hljs-comment">-- 小王 - 北京</span><br><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<br><br><span class="hljs-comment">-- 小张 - 成都</span><br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure>

<p>当前事务开启后，没提交之前，查询不到，提交后可以被查询到。但是，在提交之前其他事务被开启了，那么在这条事务线上，就不会查询到当前有操作事务的连接。相当于开辟出一条单独的线程。</p>
<p>无论小张是否执行过 <code>COMMIT</code> ，在小王这边，都不会查询到小张的事务记录，而是只会查询到自己所处事务的记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;<br>+<span class="hljs-comment">----+-----------+-------+</span><br>| id | name      | money |<br>+<span class="hljs-comment">----+-----------+-------+</span><br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>|  5 | c         |   100 |<br>+<span class="hljs-comment">----+-----------+-------+</span><br></code></pre></td></tr></table></figure>

<p>这是<strong>因为小王在此之前开启了一个新的事务 ( <code>START TRANSACTION</code> ) **，那么</strong>在他的这条新事务的线上，跟其他事务是没有联系的**，也就是说，此时如果其他事务正在操作数据，它是不知道的。</p>
<p>然而事实是，在真实的数据表中，小张已经插入了一条数据。但是小王此时并不知道，也插入了同一条数据，会发生什么呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">1000</span>);<br><span class="hljs-comment">-- ERROR 1062 (23000): Duplicate entry &#x27;6&#x27; for key &#x27;PRIMARY&#x27;</span><br></code></pre></td></tr></table></figure>

<p>报错了，操作被告知已存在主键为 <code>6</code> 的字段。这种现象也被称为<strong>幻读，一个事务提交的数据，不能被其他事务读取到</strong>。</p>
<h4 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h4><p>顾名思义，就是所有事务的<strong>写入操作</strong>全都是串行化的。什么意思？把隔离级别修改成 <strong>SERIALIZABLE</strong> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;<br>SELECT @@GLOBAL.TRANSACTION_ISOLATION;<br>+--------------------------------+<br>| @@GLOBAL.TRANSACTION_ISOLATION |<br>+--------------------------------+<br>| SERIALIZABLE                   |<br>+--------------------------------+<br></code></pre></td></tr></table></figure>

<p>还是拿小张和小王来举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 小张 - 成都<br>START TRANSACTION;<br><br>-- 小王 - 北京<br>START TRANSACTION;<br><br>-- 开启事务之前先查询表，准备操作数据。<br>SELECT * FROM user;<br>+----+-----------+-------+<br>| id | name      | money |<br>+----+-----------+-------+<br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>|  5 | c         |   100 |<br>|  6 | d         |  1000 |<br>+----+-----------+-------+<br><br>-- 发现没有 7 号王小花，于是插入一条数据：<br>INSERT INTO user VALUES (7, &#39;王小花&#39;, 1000);<br></code></pre></td></tr></table></figure>

<p>此时会发生什么呢？由于现在的隔离级别是 <strong>SERIALIZABLE ( 串行化 )</strong> ，串行化的意思就是：假设把所有的事务都放在一个串行的队列中，那么所有的事务都会按照<strong>固定顺序执行</strong>，执行完一个事务后再继续执行下一个事务的<strong>写入操作</strong> ( <strong>这意味着队列中同时只能执行一个事务的写入操作</strong> ) 。</p>
<p>根据这个解释，小王在插入数据时，会出现等待状态，直到小张执行 <code>COMMIT</code> 结束它所处的事务，或者出现等待超时。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>精尽 Redis 面试题</title>
    <url>/2016/10/12/%E7%B2%BE%E5%B0%BD%20Redis%20%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="精尽-Redis-面试题"><a href="#精尽-Redis-面试题" class="headerlink" title="精尽 Redis 面试题"></a>精尽 Redis 面试题</h1><blockquote>
<p>这个面试题是建立在胖友看过 <a href="http://svip.iocoder.cn/Cache/Interview">《精尽【缓存 】面试题》</a> 。</p>
</blockquote>
<p>以下面试题，基于网络整理，和自己编辑。具体参考的文章，会在文末给出所有的链接。</p>
<p>如果胖友有自己的疑问，欢迎在星球提问，我们一起整理吊吊的 Redis 面试题的大保健。</p>
<p>而题目的难度，艿艿尽量按照从容易到困难的顺序，逐步下去。</p>
<h2 id="什么是-Redis-？"><a href="#什么是-Redis-？" class="headerlink" title="什么是 Redis ？"></a>什么是 Redis ？</h2><p><a href="http://lib.csdn.net/base/redis">Redis</a> ，全称 Remote Dictionary Server ，是一个基于内存的高性能 Key-Value <a href="http://lib.csdn.net/base/mysql">数据库</a>。</p>
<p>Redis 已经成为互联网公司在缓存组件选择的唯一。例如说，在各种公有云上，缓存服务都是提供的 Redis。再例如说，招聘简历要求上，都会要求掌握 Redis 。</p>
<h2 id="Redis-有什么优点？"><a href="#Redis-有什么优点？" class="headerlink" title="Redis 有什么优点？"></a>Redis 有什么优点？</h2><p>🦅 <strong>1. 速度快</strong></p>
<p>因为数据存在内存中，类似于 HashMap ，HashMap 的优势就是查找和操作的时间复杂度都是O (1) 。</p>
<blockquote>
<p>Redis 本质上是一个 Key-Value 类型的内存数据库，很像 Memcached ，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。</p>
<p>因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value 数据库。</p>
</blockquote>
<ul>
<li>如果我们查看在<a href="https://help.aliyun.com/document_detail/26350.html">阿里云销售的 Redis 规格</a>，最低的也是 8W QPS 。</li>
</ul>
<p>🦅 <strong>2. 支持丰富数据类型</strong></p>
<p>支持 String ，List，Set，Sorted Set，Hash 五种基础的数据结构。</p>
<blockquote>
<p>Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结构，此外单个 Value 的最大限制是 1GB，不像 Memcached只能保存 1MB 的数据，因此 Redis 可以用来实现很多有用的功能。比方说：</p>
<ul>
<li>用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性能消息队列服务。</li>
<li>用他的 Set 可以做高性能的 tag 系统等等。</li>
</ul>
</blockquote>
<p>同时，在基础的数据结构之上，还提供 <a href="http://redisdoc.com/bitmap/index.html">Bitmap</a>、<a href="http://redisdoc.com/hyperloglog/index.html">HyperLogLog</a>、<a href="http://redisdoc.com/geo/index.html">GEO</a> 等高级的数据结构。</p>
<p>如果面试想要加分，胖友一定要去看看这些高级的数据结构，面试与日常开发，必备神器。</p>
<p>🦅 <strong>3. 丰富的特性</strong></p>
<ul>
<li>订阅发布 Pub / Sub 功能</li>
<li>Key 过期策略</li>
<li>事务</li>
<li>支持多个 DB</li>
<li>计数</li>
<li>…</li>
</ul>
<p>并且在 Redis 5.0 增加了 Stream 功能，一个新的强大的支持多播的可持久化的消息队列，提供类似 Kafka 的功能。</p>
<p>🦅 <strong>4. 持久化存储</strong></p>
<p>Redis 提供 RDB 和 AOF 两种数据的持久化存储方案，解决内存数据库最担心的万一 Redis 挂掉，数据会消失掉。</p>
<p>🦅 <strong>5、高可用</strong></p>
<p>内置 Redis Sentinel ，提供高可用方案，实现主从故障自动转移。</p>
<p>内置 Redis Cluster ，提供集群方案，实现基于槽的分片方案，从而支持更大的 Redis 规模。</p>
<h2 id="Redis-有什么缺点？"><a href="#Redis-有什么缺点？" class="headerlink" title="Redis 有什么缺点？"></a>Redis 有什么缺点？</h2><ul>
<li><p>1、由于 Redis 是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然 Redis 本身有 Key 过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。</p>
<blockquote>
<p>另外，可使用 Redis Cluster、Codis 等方案，对 Redis 进行分区，从单机 Redis 变成集群 Redis 。</p>
</blockquote>
</li>
<li><p>2、如果进行完整重同步，由于需要生成 RDB 文件，并进行传输，会占用主机的 CPU ，并会消耗现网的带宽。不过 Redis2.8 版本，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如，新上线的备机。</p>
</li>
<li><p>3、修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，Redis 不能提供服务。</p>
</li>
</ul>
<h2 id="Redis-和-Memcached-的区别有哪些？"><a href="#Redis-和-Memcached-的区别有哪些？" class="headerlink" title="Redis 和 Memcached 的区别有哪些？"></a>Redis 和 Memcached 的区别有哪些？</h2><blockquote>
<p>艿艿：随着 Memcached 日渐没落，这个问题问的越来越少了。</p>
</blockquote>
<p>🦅 <strong>1. Redis 支持复杂的数据结构</strong></p>
<ul>
<li>Memcached 仅提供简单的字符串。</li>
<li>Redis 提供复杂的数据结构，丰富的数据操作。</li>
</ul>
<p>也因为 Redis 支持复杂的数据结构，Redis 即使晚于 Memcached 推出，却获得更多开发者的青睐。</p>
<p>Redis 相比 Memcached 来说，拥有更多的数据结构，能支持更丰富的数据操作。如果需要缓存能够支持更复杂的结构和操作，Redis 会是不错的选择。</p>
<p>🦅 <strong>2. Redis 原生支持集群模式</strong></p>
<ul>
<li>在 Redis3.x 版本中，官方便能支持 Cluster 模式。</li>
<li>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。</li>
</ul>
<p>🦅 <strong>3. 性能对比</strong></p>
<ul>
<li>Redis 只使用单核，而 Memcached 可以使用多核，所以平均每一个核上 Redis在存储小数据时比 Memcached 性能更高。</li>
<li>在 100k 以上的数据中，Memcached 性能要高于 Redis 。虽然 Redis 最近也在存储大数据的性能上进行优化，但是比起 Memcached，还是稍有逊色。</li>
</ul>
<p>更多关于性能的对比，可以看看 <a href="https://www.jianshu.com/p/34f90813d7c9">《Memcached 与 Redis 的关键性能指标比较》</a> 。</p>
<p>🦅 <strong>4. 内存管理机制不同</strong></p>
<p>相比来说，Redis 的内存管理机制，会更加简单。</p>
<ul>
<li>Redis 采用的是<strong>包装</strong>的 malloc/free ，使用时现场申请的方式。</li>
<li>Memcached 采用的是 Slab Allocation 机制管理内存，预分配的内存池的方式。</li>
</ul>
<p>如果对比两者的内存使用效率：</p>
<ul>
<li>简单的 Key-Value 存储的话，Memcached 的内存利用率更高，可以使用类似内存池。</li>
<li>如果 Redis 采用 hash 结构来做 key-value 存储，由于其组合式的压缩， 其内存利用率会高于 Memcached 。</li>
</ul>
<p>🦅 <strong>5. 网络 IO 模型</strong></p>
<ul>
<li>Memcached 是多线程，非阻塞 IO 复用的网络模型，原型上接近 Nignx 。</li>
<li>Redis 使用单线程的 IO 复用模型，自己封装了一个简单的 AeEvent 事件处理框架，主要实现了 epoll ， kqueue 和 select ，更接近 Apache 早期的模式。</li>
</ul>
<p>🦅 <strong>6. 持久化存储</strong></p>
<ul>
<li>Memcached 不支持持久化存储，重启时，数据被清空。</li>
<li>Redis 支持持久化存储，重启时，可以恢复已持久化的数据。</li>
</ul>
<hr>
<p>也推荐阅读下 <a href="https://www.imooc.com/article/23549">《脚踏两只船的困惑 - Memcached 与 Redis》</a> 。</p>
<h2 id="请说说-Redis-的线程模型？"><a href="#请说说-Redis-的线程模型？" class="headerlink" title="请说说 Redis 的线程模型？"></a>请说说 Redis 的线程模型？</h2><blockquote>
<p>艿艿：这个是我从网络上找的资料，讲的灰常不错。<strong>一般来说，回答道 Redis 是非阻塞 IO ，多路复用</strong>。</p>
</blockquote>
<p>Redis 内部使用文件事件处理器 <code>file event handler</code>，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 Socket，根据 Socket 上的事件来选择对应的事件处理器进行处理。</p>
<p>文件事件处理器的结构包含 4 个部分：</p>
<ul>
<li>多个 Socket 。</li>
<li>IO 多路复用程序。</li>
<li>文件事件分派器。</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）。</li>
</ul>
<p>多个 Socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p>
<p>来看客户端与 redis 的一次通信过程：</p>
<p><img src="http://cdn.tuwenbin.vip/6gtq4m9r.bmp" alt="6gtq4m9r">redis-single-thread-model</p>
<ul>
<li>客户端 Socket01 向 Redis 的 Server Socket 请求建立连接，此时 Server Socket 会产生一个 <code>AE_READABLE</code> 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该事件压入队列中。文件事件分派器从队列中获取该事件，交给<code>连接应答处理器</code>。连接应答处理器会创建一个能与客户端通信的 Socket01，并将该 Socket01 的 <code>AE_READABLE</code> 事件与命令请求处理器关联。</li>
<li>假设此时客户端发送了一个 <code>set key value</code> 请求，此时 Redis 中的 Socket01 会产生 <code>AE_READABLE</code> 事件，IO 多路复用程序将事件压入队列，此时事件分派器从队列中获取到该事件，由于前面 Socket01 的 <code>AE_READABLE</code> 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 Scket01 的 <code>set key value</code> 并在自己内存中完成 <code>set key value</code> 的设置。操作完成后，它会将 Scket01 的 <code>AE_WRITABLE</code> 事件与令回复处理器关联。</li>
<li>如果此时客户端准备好接收返回结果了，那么 Redis 中的 Socket01 会产生一个 <code>AE_WRITABLE</code> 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 <code>ok</code>，之后解除 Socket01 的 <code>AE_WRITABLE</code> 事件与命令回复处理器的关联。</li>
</ul>
<p>这样便完成了一次通信。😈 耐心理解一下，灰常重要。如果还是不能理解，可以在网络上搜一些资料，在理解理解。</p>
<h2 id="为什么-Redis-单线程模型也能效率这么高？"><a href="#为什么-Redis-单线程模型也能效率这么高？" class="headerlink" title="为什么 Redis 单线程模型也能效率这么高？"></a>为什么 Redis 单线程模型也能效率这么高？</h2><ul>
<li><p>1、C 语言实现。</p>
<blockquote>
<p>我们都知道，C 语言的执行速度非常快。</p>
</blockquote>
</li>
<li><p>2、纯内存操作。</p>
<blockquote>
<p>Redis 为了达到最快的读写速度，将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以 Redis 具有快速和数据持久化的特征。</p>
<p>如果不将数据放在内存中，磁盘 I/O 速度为严重影响 Redis 的性能。</p>
</blockquote>
</li>
<li><p>3、基于非阻塞的 IO 多路复用机制。</p>
</li>
<li><p>4、单线程，避免了多线程的频繁上下文切换问题。</p>
<blockquote>
<p>Redis 利用队列技术，将并发访问变为串行访问，消除了传统数据库串行控制的开销。</p>
<p>实际上，Redis 4.0 开始，也开始有了一些异步线程，用于处理一些耗时操作。例如说，异步线程，实现<a href="https://blog.csdn.net/zhanglong_4444/article/details/88350443">惰性删除</a>（解决大 KEY 删除，阻塞主线程）和异步 AOF （解决磁盘 IO 紧张时，fsync 执行一次很慢）等等。</p>
</blockquote>
</li>
<li><p>5、丰富的数据结构。</p>
<blockquote>
<p>Redis 全程使用 hash 结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化。例如，压缩表，对短数据进行压缩存储；再再如，跳表，使用有序的数据结构加快读取的速度。</p>
<p>也因为 Redis 是单线程的，所以可以实现丰富的数据结构，无需考虑并发的问题。</p>
</blockquote>
</li>
</ul>
<h2 id="Redis-是单线程的，如何提高多核-CPU-的利用率？"><a href="#Redis-是单线程的，如何提高多核-CPU-的利用率？" class="headerlink" title="Redis 是单线程的，如何提高多核 CPU 的利用率？"></a>Redis 是单线程的，如何提高多核 CPU 的利用率？</h2><p>可以在同一个服务器部署多个 Redis 的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个 CPU ，你可以考虑一下分区。</p>
<h2 id="Redis-有几种持久化方式？"><a href="#Redis-有几种持久化方式？" class="headerlink" title="Redis 有几种持久化方式？"></a>Redis 有几种持久化方式？</h2><blockquote>
<p>艿艿：这个问题有一丢丢长，耐心看完。</p>
<p>面试的时候，如果不能完整回答出来，也不会有大问题。重点，在于有条理，对 RDB 和 AOF 有理解。</p>
</blockquote>
<p>🦅 <strong>持久化方式</strong></p>
<p>Redis 提供了两种方式，实现数据的持久化到硬盘。</p>
<ul>
<li>1、【全量】RDB 持久化，是指在指定的时间间隔内将内存中的<strong>数据集快照</strong>写入磁盘。实际操作过程是，fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</li>
<li>2、【增量】AOF持久化，以日志的形式记录服务器所处理的每一个<strong>写、删除操作</strong>，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</li>
</ul>
<p>🦅 <strong>RDB 优缺点</strong></p>
<p>① 优点</p>
<ul>
<li>灵活设置备份频率和周期。你可能打算每个小时归档一次最近 24 小时的数据，同时还要每天归档一次最近 30 天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</li>
<li>非常适合冷备份，对于灾难恢复而言，RDB  是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。推荐，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 OSS 分布式存储上。</li>
<li>性能最大化。对于 Redis 的服务进程而言，在开始持久化时，它唯一需要做的只是 fork  出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行 IO 操作了。也就是说，RDB 对 Redis  对外提供的读写服务，影响非常小，可以让 Redis 保持高性能。</li>
<li>恢复更快。相比于 AOF 机制，RDB 的恢复速度更更快，更适合恢复数据，特别是在数据集非常大的情况。</li>
</ul>
<p>② 缺点</p>
<ul>
<li><p>如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么 RDB 将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</p>
<blockquote>
<p>所以，RDB 实际场景下，需要和 AOF 一起使用。</p>
</blockquote>
</li>
<li><p>由于 RDB 是通过 fork 子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是 1 秒钟。</p>
<blockquote>
<p>所以，RDB 建议在业务低估，例如在半夜执行。</p>
</blockquote>
</li>
</ul>
<p>🦅 <strong>AOF 优缺点</strong></p>
<p>① 优点</p>
<ul>
<li><p>该机制可以带来更高的<strong>数据安全性</strong>，即数据持久性。Redis 中提供了 3 种同步策略，即每秒同步、每修改(执行一个命令)同步和不同步。</p>
<ul>
<li>事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。</li>
<li>而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。</li>
<li>至于不同步，无需多言，我想大家都能正确的理解它。</li>
</ul>
</li>
<li><p>由于该机制对日志文件的写入操作采用的是 <strong>append</strong> 模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。</p>
<ul>
<li>因为以 append-only 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高。</li>
<li>另外，如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在 Redis 下一次启动之前，我们可以通过 redis-check-aof 工具来帮助我们解决数据一致性的问题。</li>
</ul>
</li>
<li><p>如果 AOF 日志过大，Redis 可以自动启用 <strong>rewrite</strong>  机制。即使出现后台重写操作，也不会影响客户端的读写。因为在 rewrite log  的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。再创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge  后的日志文件 ready 的时候，再交换新老日志文件即可。</p>
<blockquote>
<p>注意，AOF <strong>rewrite</strong> 机制，和 RDB 一样，也需要 fork 出一次子进程，如果 Redis 内存比较大，可能会因为 fork 阻塞下主进程。</p>
</blockquote>
</li>
<li><p>AOF 包含一个格式清晰、易于理解的日志文件用于记录所有的<strong>修改操作</strong>。事实上，我们也可以通过该文件完成数据的重建。</p>
</li>
</ul>
<p>② 缺点</p>
<ul>
<li>对于相同数量的数据集而言，AOF 文件通常要大于 RDB 文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li>
<li>根据同步策略的不同，AOF 在运行效率上往往会慢于 RDB 。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和 RDB 一样高效。</li>
<li>以前 AOF 发生过 bug ，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF  这种较为复杂的基于命令日志/merge/回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug 。不过 AOF 就是为了避免 rewrite 过程导致的 bug ，因此每次 rewrite 并不是基于旧的指令日志进行 merge  的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。</li>
</ul>
<p>🦅 <strong>如何选择</strong></p>
<ul>
<li><p>不要仅仅使用 RDB，因为那样会导致你丢失很多数据。</p>
</li>
<li><p>也不要仅仅使用 AOF，因为那样有两个问题，第一，你通过 AOF 做冷备，没有 RDB 做冷备，来的恢复速度更快; 第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug 。</p>
</li>
<li><p>Redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF  来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB  来进行快速的数据恢复。</p>
<ul>
<li>如果同时使用 RDB 和 AOF 两种持久化机制，那么在 Redis 重启的时候，会使用 <strong>AOF</strong> 来重新构建数据，因为 AOF 中的<strong>数据更加完整</strong>。</li>
</ul>
<blockquote>
<p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用 RDB 持久化。</p>
<p>有很多用户都只使用 AOF 持久化，但并不推荐这种方式：因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用 RDB 还可以避免之前提到的 AOF 程序的 bug。</p>
</blockquote>
</li>
</ul>
<p>在 Redis4.0 版本开始，允许你使用 RDB-AOF 混合持久化方式，详细可见 <a href="https://yq.aliyun.com/articles/193034">《Redis4.0 之 RDB-AOF 混合持久化》</a> 。也因此，RDB 和 AOF 同时使用，是希望达到安全的持久化的推荐方式。</p>
<hr>
<p>另外，RDB 和 AOF 涉及的知识点蛮多的，可以看看：</p>
<ul>
<li><a href="https://redisbook.readthedocs.io/en/latest/internal/rdb.html">《Redis 设计与实现 —— RDB》</a></li>
<li><a href="https://redisbook.readthedocs.io/en/latest/internal/aof.html">《Redis 设计与实现 —— AOF》</a></li>
</ul>
<p>如下是老钱对这块的总结，可能更加适合面试的场景：</p>
<ul>
<li><p>bgsave 做镜像全量持久化，AOF 做增量持久化。因为 bgsave  会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要 AOF 来配合使用。在 Redis 实例重启时，会使用 bgsave  持久化文件重新构建内存，再使用 AOF 重放近期的操作指令来实现完整恢复重启之前的状态。</p>
<blockquote>
<p>和老钱沟通了下，最后一句重启恢复，使用的是 RDB-AOF 的混合方案。</p>
</blockquote>
</li>
<li><p>对方追问那如果突然机器掉电会怎样？取决于 AOF 日志 sync 属性的配置，如果不要求性能，在每条写指令时都 sync  一下磁盘，就不会丢失数据。但是在高性能的要求下每次都 sync 是不现实的，一般都使用定时 sync ，比如 1 秒 1  次，这个时候最多就会丢失 1 秒的数据。</p>
<blockquote>
<p>实际上，极端情况下，是最多丢失 2 秒的数据。因为 AOF 线程，负责每秒执行一次 fsync 操作，操作完成后，记录最后同步时间。主线程，负责对比上次同步时间，如果超过 2 秒，阻塞等待成功。</p>
</blockquote>
</li>
<li><p>对方追问 bgsave 的原理是什么？你给出两个词汇就可以了，fork 和 cow 。fork 是指 Redis 通过创建子进程来进行  bgsave 操作。cow 指的是 copy on write  ，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p>
<blockquote>
<p>艿艿：这里 bgsave 操作后，会产生 RDB 快照文件。</p>
</blockquote>
</li>
</ul>
<p>为什么不建议在主 Redis 节点开启 RDB 功能呢？因为会带来一定时间的阻塞，特别是数据量大的时候。</p>
<blockquote>
<p>如下来自球友【jian】的回答，感恩~</p>
<ul>
<li>【重点】<strong>子进程 fork 相关的阻塞：在 bgsave 的时候，Redis 主进程会 fork  一个子进程，利用操作系统的写时复制技术，这个子进程在拷贝父进程的时候理论上是很快的，因为并不需要全拷贝，比如主进程虽然占了 10G  内存，但子进程拷贝他可能只要 200 毫秒，我认为也就阻塞了 200  毫秒(此耗时基本跟主进程占用的内存是成正比的)，这个具体的时间可以通过统计项 info stats 里的 last_fork_usec 查看。</strong></li>
<li>CPU 单线程相关的阻塞：Redis 主进程是单线程跑在单核 CPU 上的，如果显示绑定了CPU ，则子进程会与主进程共享一个 CPU  ，而子进程进行持久化的时候是非常占CPU（强势  90%），因此这种情况也可能导致提供服务的主进程发生阻塞（因此如果需要持久化功能，不建议绑定CPU）。</li>
<li>内存相关的阻塞：虽然利用写时复制技术可以大大降低进程拷贝的内存消耗，但这也导致了父进程在处理写请求时需要维护修改的内存页，因此这部分内存过大的话（修改页数多或每页占空间大）也会导致父进程的写操作阻塞。（而不巧的是，Linux中TransparentHugePage 会将复制内存页面单位有 4K 变成 2M ，这对于 Redis 来说是比较不友好的，也是建议优化的，具体可百度之）</li>
<li>磁盘相关的阻塞：极端情况下，假设整个机器的内存已经所剩无几，触发了内存交换（SWAP），则整个 Redis的效率将会非常低下（显然这不仅仅针对 save/bgsave ），因此，关注系统的 io 情况，也是定位阻塞问题的一种方法。</li>
</ul>
<p>艿艿后来又看了下这个答案，是 <a href="https://u.jd.com/lDNJa9">《Redis 开发与运维》</a> 的「5.3 持久化 —— 问题定位于优化」小节。</p>
</blockquote>
<h2 id="Redis-有几种数据“过期”策略？"><a href="#Redis-有几种数据“过期”策略？" class="headerlink" title="Redis 有几种数据“过期”策略？"></a>Redis 有几种数据“过期”策略？</h2><p>Redis 的过期策略，就是指当 Redis 中缓存的 key 过期了，Redis 如何处理。</p>
<p>Redis 提供了 3 种数据过期策略：</p>
<ul>
<li>被动删除：当读/写一个已经过期的 key 时，会触发惰性删除策略，直接删除掉这个过期 key 。</li>
<li>主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以 Redis 会定期主动淘汰一批已过期的 key 。</li>
<li>主动删除：当前已用内存超过 maxmemory 限定时，触发主动清理策略，即 <a href="http://svip.iocoder.cn/Redis/Interview/#">「数据“淘汰”策略」</a> 。</li>
</ul>
<p>在 Redis 中，同时使用了上述 3 种策略，即它们<strong>非互斥</strong>的。</p>
<p>想要进一步了解，可以看看 <a href="https://www.cnblogs.com/chenpingzhao/p/5022467.html">《关于 Redis 数据过期策略》</a> 文章。</p>
<h2 id="Redis-有哪几种数据“淘汰”策略？"><a href="#Redis-有哪几种数据“淘汰”策略？" class="headerlink" title="Redis 有哪几种数据“淘汰”策略？"></a>Redis 有哪几种数据“淘汰”策略？</h2><p>Redis 内存数据集大小上升到一定大小的时候，就会进行数据淘汰策略。</p>
<p>Redis 提供了 6 种数据淘汰策略：</p>
<ol>
<li>volatile-lru</li>
<li>volatile-ttl</li>
<li>volatile-random</li>
<li>allkeys-lru</li>
<li>allkeys-random</li>
<li>【默认策略】no-enviction</li>
</ol>
<p>具体的<strong>每种数据淘汰策略的定义</strong>，和<strong>如何选择讨论策略</strong>，可见 <a href="http://blog.720ui.com/2016/redis_action_02_maxmemory_policy/">《Redis实战（二） 内存淘汰机制》</a> 。</p>
<p>在 Redis 4.0 后，基于 LFU（Least Frequently Used）最近最少使用算法，增加了 2 种淘汰策略：</p>
<ol>
<li>volatile-lfu</li>
<li>allkeys-lfu</li>
</ol>
<p>🦅 <strong>Redis LRU 算法</strong></p>
<p>另外，Redis 的 LRU 算法，<strong>并不是一个严格的 LRU 实现</strong>。这意味着 Redis 不能选择最佳候选键来回收，也就是最久未被访问的那些键。相反，Redis 会尝试执行一个近似的 LRU 算法，通过采样一小部分键，然后在采样键中回收最适合(拥有最久未被访问时间)的那个。</p>
<p><strong>Redis 没有使用真正实现严格的 LRU 算是的原因是，因为消耗更多的内存。然而对于使用 Redis 的应用来说，使用近似的 LRU 算法，事实上是等价的。</strong></p>
<p>具体的可以看看如下文章：</p>
<ul>
<li><a href="http://www.iocoder.cn/Fight/Cannot-think-of-The-interviewer-asked-me-what-if-Redis-runs-out-of-memory/?self">《想不到！面试官问我：Redis 内存满了怎么办？》</a></li>
<li><a href="http://ifeve.com/lru-cache/">《使用 Redis 作为一个 LRU 缓存》</a></li>
</ul>
<p>🦅 <strong>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据？</strong></p>
<blockquote>
<p>艿艿：这个是从网络上找到的一个神奇的问题，并且看了答案之后，觉得有点莫名的对不上。</p>
<p>所以，感觉这个问题的目的是，如何保证热点数据不要被淘汰。</p>
</blockquote>
<p>在 <a href="http://svip.iocoder.cn/Redis/Interview/#">「Redis 有哪几种数据“淘汰”策略？」</a> 问题中，我们已经看到，“Redis 内存数据集大小上升到一定 maxmemory 的时候，就会进行数据淘汰策略。” 。</p>
<p>那么，如果我们此时要保证热点数据不被淘汰，那么需要选择 volatile-lru 或  allkeys-lru 这两个基于 LRU 算法的淘汰策略。</p>
<p>相比较来说，最终会选择 allkeys-lru  淘汰策略。原因是，如果我们的应用对缓存的访问符合幂律分布，也就是存在相对热点数据，或者我们不太清楚我们应用的缓存访问分布状况，我们可以选择  allkeys-lru 策略。如果在 Redis 4.0 版本，可以考虑使用 volatile-lfu  ，更加符合“热”的概念，频率越高，代表越热。</p>
<p>🦅 <strong>Redis 回收进程如何工作的？</strong></p>
<p>理解回收进程如何工作是非常重要的：</p>
<ul>
<li>一个客户端运行了新的写命令，添加了新的数据。</li>
<li>Redis 检查内存使用情况，如果大于 maxmemory 的限制, 则根据设定好的策略进行回收。</li>
<li>Redis 执行新命令。</li>
</ul>
<p>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下（跌宕起伏）。</p>
<h2 id="如果有大量的-key-需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的-key-需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的 key 需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</h2><p>如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，Redis可能会出现短暂的卡顿现象。</p>
<p>一般需要在时间上加一个随机值，使得过期时间分散一些。</p>
<hr>
<p>上次基友也碰到这个问题，请教了下，他的方案是调大 hz 参数，每次过期的 key 更多，从而最终达到避免一次过期过多。</p>
<blockquote>
<p>这个定期的频率，由配置文件中的 hz 参数决定，代表了一秒钟内，后台任务期望被调用的次数。Redis 3.0.0 中的默认值是 10 ，代表每秒钟调用 10 次后台任务。</p>
<p>hz 调大将会提高 Redis 主动淘汰的频率，如果你的 Redis 存储中包含很多冷数据占用内存过大的话，可以考虑将这个值调大，但  Redis 作者建议这个值不要超过 100 。我们实际线上将这个值调大到 100 ，观察到 CPU 会增加 2%  左右，但对冷数据的内存释放速度确实有明显的提高（通过观察 keyspace 个数和 used_memory 大小）。</p>
</blockquote>
<h2 id="Redis-有哪些数据结构？"><a href="#Redis-有哪些数据结构？" class="headerlink" title="Redis 有哪些数据结构？"></a>Redis 有哪些数据结构？</h2><p>如果你是 Redis 普通玩家，可能你的回答是如下五种数据结构：</p>
<ul>
<li>字符串 String</li>
<li>字典Hash</li>
<li>列表List</li>
<li>集合Set</li>
<li>有序集合 SortedSet</li>
</ul>
<p>如果你是 Redis 中级玩家，还需要加上下面几种数据结构：</p>
<ul>
<li>HyperLogLog</li>
<li>Geo</li>
<li>Bitmap</li>
</ul>
<p>如果你是 Redis 高端玩家，你可能玩过 Redis Module ，可以再加上下面几种数据结构：</p>
<ul>
<li>BloomFilter</li>
<li>RedisSearch</li>
<li>Redis-ML</li>
<li>JSON</li>
</ul>
<p>另外，在 Redis 5.0 增加了 Stream 功能，一个新的强大的支持多播的可持久化的消息队列，提供类似 Kafka 的功能。😈 默默跟面试官在装一波。</p>
<h2 id="聊聊-Redis-使用场景"><a href="#聊聊-Redis-使用场景" class="headerlink" title="聊聊 Redis 使用场景"></a>聊聊 Redis 使用场景</h2><p>Redis 可用的场景非常之多：</p>
<ul>
<li>数据缓存</li>
<li>会话缓存</li>
<li>时效性数据</li>
<li>访问频率</li>
<li>计数器</li>
<li>社交列表</li>
<li>记录用户判定信息</li>
<li>交集、并集和差集</li>
<li>热门列表与排行榜</li>
<li>最新动态</li>
<li>消息队列</li>
<li>分布式锁</li>
</ul>
<p>详细的介绍，可以看看如下文章：</p>
<ul>
<li><a href="http://blog.720ui.com/2017/redis_core_use/">《聊聊 Redis 使用场景》</a></li>
<li><a href="https://www.jianshu.com/p/af277c77b1c9">《Redis 应用场景及实例》</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/29665317">《Redis 常见的应用场景解析》</a></li>
<li><a href="https://www.zhihu.com/question/19829601">《Redis 和 Memcached 各有什么优缺点，主要的应用场景是什么样的？》</a></li>
</ul>
<h2 id="Redis-支持的-Java-客户端都有哪些？"><a href="#Redis-支持的-Java-客户端都有哪些？" class="headerlink" title="Redis 支持的 Java 客户端都有哪些？"></a>Redis 支持的 Java 客户端都有哪些？</h2><p>使用比较广泛的有三个 Java 客户端：</p>
<ul>
<li><p>Redisson</p>
<blockquote>
<p>Redisson ，是一个高级的分布式协调 Redis 客服端，能帮助用户在分布式环境中轻松实现一些 Java 的对象 (Bloom  filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map,  ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque,  BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong,  CountDownLatch, Publish / Subscribe, HyperLogLog)。</p>
</blockquote>
</li>
<li><p>Jedis</p>
<blockquote>
<p>Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持。</p>
<p>Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，Jedis 功能较为简单。</p>
<p>Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>
</blockquote>
</li>
<li><p>Lettuce</p>
<blockquote>
<p>Lettuce 是一个可伸缩线程安全的 Redis 客户端。多个线程可以共享同一个 RedisConnection 。它利用优秀 Netty NIO 框架来高效地管理多个连接。</p>
</blockquote>
</li>
</ul>
<p>Redis 官方推荐使用 Redisson 或 Jedis 。</p>
<p>Spring Boot 2.x 内置支持 Jedis 和 Lettuce 。一般情况下，建议：</p>
<ul>
<li>使用 Spring Data Redis ，提供了透明使用 Jedis 和 Lettuce  的封装。也就是说，大多数时候，我们可以通过配置使用 Jedis 或 Lettuce 进行 Redis 的操作，而上层使用 Spring Data Redis 提供的统一 API 。</li>
<li>从目前来说，Jedis 会比 Lettuce 更加流行，并且更加稳定。虽然说 Jedis 有一段时间，不再进行更新，但是突然又开始更新，可能是诈尸了。</li>
<li>如果想要更加丰富的特性，例如说分布式锁，布隆过滤器，可以考虑研究下 Redisson 。</li>
</ul>
<h2 id="如何使用-Redis-实现分布式锁？"><a href="#如何使用-Redis-实现分布式锁？" class="headerlink" title="如何使用 Redis 实现分布式锁？"></a>如何使用 Redis 实现分布式锁？</h2><p>Redis 实现分布式锁，需要考虑如下几个方面：</p>
<ul>
<li><p>1、正确的获得锁</p>
<blockquote>
<p>set 指令附带 nx 参数，保证有且只有一个进程获得到。</p>
</blockquote>
</li>
<li><p>2、正确的释放锁</p>
<blockquote>
<p>使用 Lua 脚本，比对锁持有的是不是自己。如果是，则进行删除来释放。</p>
</blockquote>
</li>
<li><p>3、超时的自动释放锁</p>
<blockquote>
<p>set 指令附带 expire 参数，通过过期机制来实现超时释放。</p>
</blockquote>
</li>
<li><p>4、未获得到锁的等待机制</p>
<blockquote>
<p>sleep 或者基于 Redis 的订阅 Pub/Sub 机制。</p>
<p>一些业务场景，可能需要支持获得不到锁，直接返回 false ，不等待。</p>
</blockquote>
</li>
<li><p>5、【可选】锁的重入性</p>
<blockquote>
<p>通过 ThreadLocal<Integer> 记录是第几次获得相同的锁。</p>
<p>1）有且第一次计数为 1 &amp;&amp; 获得锁时，才向 Redis 发起获得锁的操作。 2）有且计数为 0 &amp;&amp; 释放锁时，才向 Redis 发起释放锁的操作。</p>
</blockquote>
</li>
<li><p>6、锁超时的处理</p>
<blockquote>
<p>一般情况下，可以考虑告警 + 后台线程自动续锁的超时时间。通过这样的机制，保证有且仅有一个线程，正在持有锁。</p>
</blockquote>
</li>
<li><p>7、Redis 分布式锁丢失问题</p>
<blockquote>
<p>具体看「方案二：Redlock」。</p>
</blockquote>
</li>
</ul>
<p>下面，我们来详细说下每个方案。</p>
<p>🦅 <strong>方案一：set 指令</strong></p>
<p>先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。</p>
<ul>
<li>这时候对方会告诉你说你回答得不错，然后接着问如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，那会怎么样？</li>
<li>这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得 set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和 expire  合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。</li>
</ul>
<p>所以，我们可以使用 <strong>set</strong> 指令，实现分布式锁。指令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">SET key value [EX seconds] [PX milliseconds] [NX|XX]<br></code></pre></td></tr></table></figure>



<ul>
<li>可以使用 <code>SET key value EX seconds NX</code> 命令，尝试获得锁。</li>
<li>具体的实现，可以参考如下文章：<ul>
<li><a href="http://svip.iocoder.cn/Redisson/ReentrantLock/?self">《精尽 Redisson 源码分析 —— 可重入分布式锁 ReentrantLock》</a></li>
<li><a href="http://www.iocoder.cn/Fight/redisfen-bu-shi-suo-jin-hua-shi/?self">《Redis 分布式锁进化史解读 + 缺陷分析》</a></li>
<li><a href="http://www.iocoder.cn/Fight/Correct-implementation-of-Redis-distributed-locks-by-Java/?self">《Redis 分布式锁的正确实现方式（Java 版）》</a></li>
</ul>
</li>
</ul>
<p>🦅 <strong>方案二：Redlock</strong></p>
<p>set 指令的方案，适合用于在单机 Redis 节点的场景下，在多 Redis 节点的场景下，会存在分布式锁丢失的问题。所以，Redis 作者 Antirez 基于分布式环境下提出了一种更高级的分布式锁的实现方式：Redlock 。</p>
<p>具体的源码解析，可以看看 <a href="http://svip.iocoder.cn/Redisson/RedLock/?self">《精尽 Redisson 源码分析 —— 可靠分布式锁 RedLock》</a> 文章。</p>
<p>具体的方案，胖友可以看看老友飞哥的两篇博客：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/JLEzNqQsx-Lec03eAsXFOQ">《Redlock：Redis分布式锁最牛逼的实现》</a></li>
<li><a href="https://www.jianshu.com/p/f302aa345ca8">《Redisson 实现 Redis 分布式锁的 N 种姿势》</a></li>
</ul>
<p>最近艿艿画了一个 Redisson 实现分布式锁的流程图，胖友可以点击<a href="https://www.processon.com/view/link/5f4c871d079129356ec6f4d7">传送门</a>阅读。</p>
<p>🦅 <strong>对比 Zookeeper 分布式锁</strong></p>
<ul>
<li>从可靠性上来说，Zookeeper 分布式锁好于 Redis 分布式锁。</li>
<li>从性能上来说，Redis 分布式锁好于 Zookeeper 分布式锁。</li>
</ul>
<p>所以，没有绝对的好坏，可以根据自己的业务来具体选择。如果想要更简单，甚至可以考虑基于 MySQL 行锁来实现分布式锁。</p>
<h2 id="如何使用-Redis-实现分布式限流？"><a href="#如何使用-Redis-实现分布式限流？" class="headerlink" title="如何使用 Redis 实现分布式限流？"></a>如何使用 Redis 实现分布式限流？</h2><p>在 Spring Cloud Gateway 中，提供了 Redis 分布式限流器的实现，具体直接看艿艿写的 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-request-rate-limiter/">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.10) 之 RequestRateLimiterGatewayFilterFactory 请求限流》</a> 的 <a href="http://svip.iocoder.cn/Redis/Interview/#">「5.3 Redis Lua 脚本」</a> 部分。</p>
<p>另外，Redisson 库中，也提供了 Redis 分布式限流的实现，不过需要使用 Pro 版本。</p>
<p>🦅 <strong>请用 Redis 和任意语言实现一段恶意登录保护的代码，限制 1 小时内每用户 Id 最多只能登录 5 次。</strong></p>
<p>这个问题，关键点，就是每个用户，每 3600 秒，只能登陆 5 次。这么一想，其实就是一个如何使用 Redis 实现限流的问题。Redis 实现限流，一共有两种方案：</p>
<ul>
<li><p>使用 zset 实现滑动窗口限流。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public boolean isActionAllowed(String userId, String actionKey, int period,<br>    int maxCount) &#123;<br>    String key &#x3D; String.format(&quot;hist:%s:%s&quot;, userId, actionKey); &#x2F;&#x2F; 使用用户编号 + 行为作为 KEY 。这样，我们就可以统计某个用户的操作行为。<br>    long nowTs &#x3D; System.currentTimeMillis(); &#x2F;&#x2F; 获取当前时间。<br>    Pipeline pipe &#x3D; jedis.pipelined(); &#x2F;&#x2F; pipeline 批量操作，提升效率。<br>    pipe.multi(); &#x2F;&#x2F; 此处启动了事务，可以保证指令的原子性。<br>    pipe.zadd(key, nowTs, &quot;&quot; + nowTs); &#x2F;&#x2F; zset 添加，key value score 要看下。<br>    pipe.zremrangeByScore(key, 0, nowTs - (period * 1000)); &#x2F;&#x2F; zremrangeByScore ，移除超过周期的 value 。<br><br>    Response&lt;Long&gt; count &#x3D; pipe.zcard(key); &#x2F;&#x2F; zcard ，计算 zset 的数量<br>    pipe.expire(key, period + 1); &#x2F;&#x2F; 设置过期。这里多 + 1 秒，为了防止网络延迟。<br>    pipe.exec(); &#x2F;&#x2F; pipeline 执行<br>    pipe.close();<br><br>    return count.get() &lt;&#x3D; maxCount; &#x2F;&#x2F; 是否超过最大次数。<br>&#125;<br></code></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>该实现会存在一个问题，可能一个无效的操作，也被记录到次数中。完美的话，可能需要基于 Lua 脚本实现。</li>
<li>另外，上述代码是每秒操作的时间，实际需要改成每 N 秒。比较简单，直接上手怼即可。</li>
</ul>
<ul>
<li><p>使用 Lua 脚本，实现令牌桶限流算法。具体可以看看艿艿对 <a href="http://www.iocoder.cn/Spring-Cloud-Gateway/filter-request-rate-limiter/?self">《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.10) 之 RequestRateLimiterGatewayFilterFactory 请求限流》</a> 的源码解析。</p>
</li>
<li><p>使用 Lua 脚本，实现简单的滑动窗口。具体可以看看艿艿对 <a href="http://svip.iocoder.cn/Redisson/RateLimiter/?self">《精尽 Redisson 源码分析 —— 限流器 RateLimiter》</a> 的源码解析。</p>
</li>
</ul>
<h2 id="如何使用-Redis-实现消息队列？"><a href="#如何使用-Redis-实现消息队列？" class="headerlink" title="如何使用 Redis 实现消息队列？"></a>如何使用 Redis 实现消息队列？</h2><p>一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。</p>
<ul>
<li><p>如果对方追问可不可以不用 sleep 呢？list 还有个指令叫 blpop ，在没有消息的时候，它会阻塞住直到消息到来。</p>
</li>
<li><p>如果对方追问能不能生产一次消费多次呢？使用 pub / sub 主题订阅者模式，可以实现 1:N 的消息队列。</p>
</li>
<li><p>如果对方追问 pub / sub 有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 rabbitmq 等。</p>
<blockquote>
<p>之前生产中，艿艿就碰到因为网络闪断，导致订阅的 pub/sub 消息丢失，导致 JVM 应用的数据字典和系统参数等缓存未刷新，业务受到影响。所以，最好还是使用专业的消息队列的订阅功能（广播消费）。</p>
</blockquote>
</li>
<li><p>如果对方追问 redis  如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用  sortedset ，拿时间戳作为 score ，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore  指令获取 N 秒之前的数据轮询进行处理。</p>
<blockquote>
<p>可能很多胖友会觉得抽象，可以看看 <a href="https://cloud.tencent.com/developer/article/1401122">《Redis 学习笔记之延时队列》</a> 。面试中，能回答到 Redis zset 实现延迟队列，还是蛮加分的。</p>
</blockquote>
</li>
</ul>
<p>到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。</p>
<p>当然，实际上 Redis 真的真的真的不推荐作为消息队列使用，它最多只是消息队列的存储层，上层的逻辑，还需要做大量的封装和支持。</p>
<p>另外，在 Redis 5.0 增加了 Stream 功能，一个新的强大的支持多播的可持久化的消息队列，提供类似 Kafka 的功能。</p>
<h2 id="什么是-Redis-Pipelining-？"><a href="#什么是-Redis-Pipelining-？" class="headerlink" title="什么是 Redis Pipelining ？"></a>什么是 Redis Pipelining ？</h2><p>一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。</p>
<blockquote>
<p>注意，Redis Pipelining 是 Redis Client 实现的功能，而不是 Redis Server 提供的特性。假设我们有 3 个请求进行下举例子。</p>
<ul>
<li>未使用 Pipeline 时，那么整个执行的顺序是，req1-&gt;resp1-&gt;req2-&gt;resp2-&gt;req3-&gt;resp3 。</li>
<li>在使用 Pipeline 时，那么整个执行的顺序是，[req1,req2,req3] 一起发给 Redis Server ，而  Redis Server 收到请求后，一个一个请求进行执行，然后响应，不会进行什么特殊处理。而 Client 在收到  resp1,resp2,resp3 后，进行响应给业务上层。</li>
</ul>
<p>所以，Pipeline 的作用，是避免每发一个请求，就阻塞等待这个请求的结果。</p>
</blockquote>
<p>这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。</p>
<p>Redis 很早就支持管道（<a href="http://redis.cn/topics/pipelining.html">pipelining</a>）技术，因此无论你运行的是什么版本，你都可以使用管道（pipelining）操作 Redis。</p>
<p>🦅 <strong>Redis 如何做大量数据插入？</strong></p>
<p>Redis 2.6 开始，Redis-cli 支持一种新的被称之为 pipe mode 的新模式用于执行大量数据插入工作。</p>
<p>具体可见 <a href="http://www.redis.cn/topics/mass-insert.html">《Redis 大量数据插入》</a> 文章。</p>
<h2 id="什么是-Redis-事务？"><a href="#什么是-Redis-事务？" class="headerlink" title="什么是 Redis 事务？"></a>什么是 Redis 事务？</h2><p>和众多其它数据库一样，Redis 作为 NoSQL 数据库也同样提供了事务机制。在 Redis 中，MULTI / EXEC /  DISCARD / WATCH  这四个命令是我们实现事务的基石。相信对有关系型数据库开发经验的开发者而言这一概念并不陌生，即便如此，我们还是会简要的列出 Redis  中事务的实现特征：</p>
<ul>
<li><p>1、在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis 不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行。</p>
<blockquote>
<p>Lua 脚本，也能实现该功能。</p>
</blockquote>
</li>
<li><p>2、和关系型数据库中的事务相比，在 Redis 事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行。</p>
<blockquote>
<p>这一点，非常重要。回答错了，就回家面壁思过，一天不许喝可乐。</p>
<p>这一点，是 Lua 脚本不具备的。</p>
</blockquote>
</li>
<li><p>3、我们可以通过 MULTI 命令开启一个事务，有关系型数据库开发经验的人可以将其理解为 <code>&quot;BEGIN TRANSACTION&quot;</code> 语句。在该语句之后执行的命令，都将被视为事务之内的操作，最后我们可以通过执行 EXEC / DISCARD 命令来提交 / 回滚该事务内的所有操作。这两个 Redis 命令，可被视为等同于关系型数据库中的 COMMIT / ROLLBACK 语句。</p>
<blockquote>
<p>开启事务后，所有语句，发送给 Redis Server ，都会暂存在 Server 中。</p>
</blockquote>
</li>
<li><p>4、在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行 EXEC 命令之后，那么该事务中的所有命令都会被服务器执行。</p>
</li>
</ul>
<p>🦅 <strong>如何实现 Redis CAS 操作？</strong></p>
<p>在 Redis 的事务中，WATCH 命令可用于提供 CAS(check-and-set) 功能。</p>
<p>假设我们通过 WATCH 命令在事务执行之前监控了多个 keys ，倘若在 WATCH 之后有任何 Key 的值发生了变化，EXEC 命令执行的事务都将被放弃，同时返回 <code>nil</code> 应答以通知调用者事务执行失败。</p>
<p>具体的示例，可以看看 <a href="https://www.jianshu.com/p/0244a875aa26">《Redis 事务锁 CAS 实现以及深入误区》</a> 。</p>
<h2 id="Redis-集群都有哪些方案？"><a href="#Redis-集群都有哪些方案？" class="headerlink" title="Redis 集群都有哪些方案？"></a>Redis 集群都有哪些方案？</h2><p>Redis 集群方案如下：</p>
<ul>
<li>1、Redis Sentinel</li>
<li>2、Redis Cluster</li>
<li>3、Twemproxy</li>
<li>4、Codis</li>
<li>5、客户端分片</li>
</ul>
<p>关于前四种，可以看看 <a href="http://blog.720ui.com/2016/redis_action_04_cluster/">《Redis 实战（四）集群机制》</a> 这篇文章。</p>
<p>关于最后一种，客户端分片，在 Redis Cluster 出现之前使用较多，目前已经使用比较少了。实现方式如下：</p>
<blockquote>
<p>在业务代码层实现，起几个毫无关联的 Redis 实例，在代码层，对 Key 进行 hash 计算，然后去对应的 Redis 实例操作数据。</p>
<p>这种方式对 hash 层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。</p>
</blockquote>
<p>🦅 <strong>选择</strong></p>
<p>目前一般在选型上来说：</p>
<ul>
<li><p>体量较小时，选择 Redis Sentinel ，单主 Redis 足以支撑业务。</p>
</li>
<li><p>体量较大时，选择 Redis Cluster ，通过分片，使用更多内存。</p>
<blockquote>
<p>关于这个问题，多大体量需要使用 Redis Cluster 呢？朋友的建议是 10G+ 的时候。主要原因是：</p>
<ul>
<li>1、一次 RDB 时间随着内存越大，会变大越来越久。同时，一次 fork 的时间也会变久。还有，重启通过 RDB 文件，或者 AOF 日志，恢复时间都会变长。</li>
<li>2、体量大之后，读写的 QPS 势必比体量小的时候打的多，那么使用 Redis Cluster 相比 Redis Sentinel ，可以分散读写压力到不同的集群中。</li>
</ul>
</blockquote>
</li>
</ul>
<p>🦅 <strong>Redis 集群如何扩容？</strong></p>
<ul>
<li><p>如果 Redis 被当做<strong>缓存</strong>使用，使用一致性哈希实现动态扩容缩容。</p>
<blockquote>
<p>删除的原因是，不考虑客户端分片的情况，目前基本已经不在用了。</p>
</blockquote>
</li>
<li><p>如果 Redis 被当做一个<strong>持久化存</strong>储使用，必须使用固定的 keys-to-nodes 映射关系，节点的数量一旦确定不能变化。否则的话(即 Redis 节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有 Redis Cluster、Codis 可以做到这样。</p>
</li>
</ul>
<p>如果是 Redis Cluster 集群的扩容，可以看看 <a href="https://u.jd.com/lDNJa9">《Redis 开发与运维》</a> 的「10.4 集群 —— 集群伸缩」小节。简单来说，一共三步：</p>
<ul>
<li>1、准备新节点。</li>
<li>2、加入集群。</li>
<li>3、迁移槽和数据。</li>
</ul>
<h2 id="什么是-Redis-主从同步？"><a href="#什么是-Redis-主从同步？" class="headerlink" title="什么是 Redis 主从同步？"></a>什么是 Redis 主从同步？</h2><p><strong>Redis 主从同步</strong></p>
<p>Redis 的主从同步(replication)机制，允许 Slave 从 Master 那里，通过网络传输拷贝到完整的数据备份，从而达到主从机制。</p>
<ul>
<li>主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据。</li>
<li>一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。</li>
<li>第一次同步时，主节点做一次 bgsave 操作，并同时将后续修改操作记录到内存 buffer ，待完成后将 RDB  文件全量同步到复制节点，复制节点接受完成后将 RDB  镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</li>
</ul>
<p><strong>好处</strong></p>
<p>通过 Redis 的复制功，能可以很好的实现数据库的读写分离，提高服务器的负载能力。主数据库主要进行写操作，而从数据库负责读操作。</p>
<blockquote>
<p>实际上，我们不是非常推荐在 Redis 中，使用读写分离。主要有两个原因：</p>
<ul>
<li>Redis Sentinel 只保证主节点的故障的失效转移，而例如说 Jedis  库，也只监听了主节点的变化，但是从节点故障的情况，Jedis 是不进行处理的。这就会导致，Jedis  读会访问到从节点，导致问题。当然，Redisson 库的功能比较强大，已经支持从节点的故障监听。</li>
<li>如果到达需要读写分离的体量，一般写操作也不一定会少，可以考虑上 Redis Cluster 方案，更加可靠。</li>
</ul>
</blockquote>
<hr>
<p>Redis 主从同步，是很多 Redis 集群方案的基础，例如 Redis Sentinel、Redis Cluster 等等。</p>
<p>更多详细，可以看看如下：</p>
<blockquote>
<p>因为主从复制的内容很多，艿艿这里就不详细哔哔了。实际场景下，对于开发的面试，我们也不会特别问，毕竟更偏运维的内容。</p>
</blockquote>
<ul>
<li><a href="http://redis.cn/topics/replication.html">《Redis 官方文档 —— 复制》</a></li>
<li><a href="https://u.jd.com/lDNJa9">《Redis 开发与运维》</a> 的「6. 复制」章节，更加详细完整。</li>
</ul>
<!--[《Redis 主从架构》](https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-master-slave.md) 。-->

<h2 id="如何使用-Redis-Sentinel-实现高可用？"><a href="#如何使用-Redis-Sentinel-实现高可用？" class="headerlink" title="如何使用 Redis Sentinel 实现高可用？"></a>如何使用 Redis Sentinel 实现高可用？</h2><p>详细，可以看看如下：</p>
<blockquote>
<p>因为 Redis Sentinel 的内容很多，艿艿这里就不详细哔哔了。实际场景下，对于开发的面试，我们也不会特别问，毕竟更偏运维的内容。</p>
</blockquote>
<ul>
<li><a href="http://redis.cn/topics/sentinel.html">《Redis 官方文档 —— Sentinel 高可用》</a></li>
<li><a href="https://u.jd.com/lDNJa9">《Redis 开发与运维》</a> 的「9. 哨兵」章节，更加详细完整。</li>
</ul>
<!--[《Redis 哨兵集群实现高可用》](https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-sentinel.md) 。-->

<h2 id="如果使用-Redis-Cluster-实现高可用？"><a href="#如果使用-Redis-Cluster-实现高可用？" class="headerlink" title="如果使用 Redis Cluster 实现高可用？"></a>如果使用 Redis Cluster 实现高可用？</h2><p>详细，可以看看如下：</p>
<blockquote>
<p>因为 Redis Sentinel 的内容很多，艿艿这里就不详细哔哔了。实际场景下，对于开发的面试，我们也不会特别问，毕竟更偏运维的内容。</p>
</blockquote>
<ul>
<li><a href="http://redis.cn/topics/cluster-tutorial.html">《Redis 官方文档 —— Redis Cluster 集群》</a></li>
<li><a href="https://u.jd.com/lDNJa9">《Redis 开发与运维》</a> 的「10. 集群」章节，更加详细完整。</li>
</ul>
<!--[《Redis 集群模式的工作原理能说一下么？》](https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-cluster.md) 精简版-->

<p>🦅 <strong>说说 Redis 哈希槽的概念？</strong></p>
<p>Redis Cluster 没有使用一致性 hash ，而是引入了哈希槽的概念。</p>
<p>Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。</p>
<p>因为最大是 16384 个哈希槽，所以考虑 Redis 集群中的每个节点都能分配到一个哈希槽，所以最多支持 16384 个 Redis 节点。</p>
<p>为什么是 16384 呢？主要考虑集群内的网络带宽，而 16384 刚好是 2K 字节大小。</p>
<p>🦅 <strong>Redis Cluster 的主从复制模型是怎样的？</strong></p>
<p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了<strong>主从复制</strong>模型，每个节点都会有 N-1 个复制节点。</p>
<p>所以，Redis Cluster 可以说是 Redis Sentinel 带分片的加强版。也可以说：</p>
<ul>
<li>Redis Sentinel 着眼于高可用，在 master 宕机时会自动将 slave 提升为 master ，继续提供服务。</li>
<li>Redis Cluster 着眼于扩展性，在单个 Redis 内存不足时，使用 Cluster 进行分片存储。</li>
</ul>
<p>🦅 <strong>Redis Cluster 方案什么情况下会导致整个集群不可用？</strong></p>
<p>有 A，B，C 三个节点的集群，在没有复制模型的情况下，如果节点 B 宕机了，那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用。当然，这种情况也可以配置 <code>cluster-require-full-coverage=no</code> ，整个集群无需所有槽位覆盖。</p>
<p>🦅 <strong>Redis Cluster 会有写操作丢失吗？为什么？</strong></p>
<p>Redis 并不能保证数据的强一致性，而是【异步复制】，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p>
<blockquote>
<p>艿艿：一定一定一定要注意，无论对于 Redis Sentinel 还是 Redis Cluster 方案，都是通过主从复制，所以在数据的复制方面，都存在相同的情况。</p>
</blockquote>
<p>🦅 <strong>Redis 集群如何选择数据库？</strong></p>
<p>Redis 集群目前无法做数据库选择，默认在 0 数据库。</p>
<p>🦅 <strong>请说说生产环境中的 Redis 是怎么部署的？</strong></p>
<blockquote>
<p>重点问题，仔细理解。</p>
</blockquote>
<ul>
<li><p>Redis Cluster ，10 台机器，5 台机器部署了 Redis 主实例，另外 5 台机器部署了 Redis  的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰 qps 可能可以达到每秒 5 万，5 台机器最多是 25  万读写请求每秒。</p>
</li>
<li><p>机器是什么配置？32G 内存 + 8 核 CPU + 1T 磁盘，但是分配给 Redis 进程的是 10G 内存，一般线上生产环境，Redis 的内存尽量不要超过 10G，超过 10G 可能会有问题。那么，5 台机器对外提供读写，一共有 50G 内存。</p>
</li>
<li><p>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，Redis 从实例会自动变成主实例继续提供读写服务。</p>
</li>
<li><p>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb 。100 条数据是 1mb ，10 万条数据是 1G  。常驻内存的是 200 万条商品数据，占用内存是 20G ，仅仅不到总内存的 50% 。目前高峰期每秒就是 3500 左右的请求量。</p>
<blockquote>
<p>一般来说，当公司体量大了之后，建议是一个业务线独占一个或多个 Redis Cluster 集群，实现好业务线与业务线之间的隔离。</p>
</blockquote>
</li>
<li><p>其实大型的公司，会有基础架构的 Team 负责缓存集群的运维。</p>
</li>
</ul>
<h2 id="什么是-Redis-分区？"><a href="#什么是-Redis-分区？" class="headerlink" title="什么是 Redis 分区？"></a>什么是 Redis 分区？</h2><blockquote>
<p>这个问题，和 <a href="http://svip.iocoder.cn/Redis/Interview/#">「Redis 集群都有哪些方案？」</a> 是同类问题。</p>
<p>简单看看即可，重点还是去理解 Redis Cluster 集群方案。</p>
</blockquote>
<p>🦅 关于如下四个问题，直接看 <a href="http://www.runoob.com/redis/redis-partitioning.html">《Redis 分区》</a> 文章。</p>
<ul>
<li>Redis 分区是什么？</li>
<li>分区的优势？</li>
<li>分区的不足？</li>
<li>分区类型？</li>
</ul>
<p>可能有胖友会懵逼，又是 Redis 主从复制，又是 Redis 分区，又是 Redis 集群。傻傻分不清啊！</p>
<ul>
<li><p>Redis 分区是一种模式，将数据分区到不同的 Redis 节点上，而 Redis 集群的 Redis Cluster、Twemproxy、Codis、客户端分片( 不包括 Redis Sentinel ) 这四种方案，是 Redis 分区的具体实现。</p>
<blockquote>
<p>注意，Redis Sentinel 实现的是 Redis 的高可用，一定要分清楚。实际上，胖友可以对比 MySQL 和 MongoDB 的高可用、集群的方案，发现思路都是一致的。</p>
</blockquote>
</li>
<li><p>Redis 每个分区，如果想要实现高可用，需要使用到 Redis 主从复制。</p>
</li>
</ul>
<p>🦅 <strong>你知道有哪些 Redis 分区实现方案</strong>？</p>
<p>Redis 分区方案，主要分成两种类型：</p>
<ul>
<li>客户端分区，就是在客户端就已经决定数据会被存储到哪个 Redis 节点或者从哪个 Redis 节点读取。大多数客户端已经实现了客户端分区。<ul>
<li>案例：Redis Cluster 和客户端分区。</li>
</ul>
</li>
<li>代理分区，意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些 Redis 实例，然后根据 Redis 的响应结果返回给客户端。<ul>
<li>案例：Twemproxy 和 Codis 。</li>
</ul>
</li>
</ul>
<p>查询路由(Query routing)的意思，是客户端随机地请求任意一个 Redis 实例，然后由 Redis 将请求转发给正确的  Redis 节点。Redis Cluster 实现了一种混合形式的查询路由，但并不是直接将请求从一个Redis 节点转发到另一个 Redis  节点，而是在客户端的帮助下直接 Redirect 到正确的 Redis 节点。</p>
<blockquote>
<p>Redis Cluster 的重定向，可以认真看看 <a href="https://u.jd.com/lDNJa9">《Redis 开发与运维》</a> 的「10.5 集群 - 请求路由」章节。</p>
</blockquote>
<p>🦅 <strong>分布式 Redis 是前期做还是后期规模上来了再做好？为什么？？</strong></p>
<p>如下是网络上的一个答案：</p>
<blockquote>
<p>既然 Redis 是如此的轻量，为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让 Redis 以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p>
<p>一开始就多设置几个 Redis 实例，例如 32 或者 64 个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</p>
<p>这样的话，当你的数据不断增长，需要更多的 Redis 服务器时，你需要做的就是仅仅将 Redis 实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的 Redis 实例从第一台机器迁移到第二台机器。</p>
</blockquote>
<ul>
<li>和飞哥沟通了下，这个操作不是很合理。</li>
<li>无论怎么说，建议，需要搭建下 Redis Sentinel 高可用，至于拓展性，根据自己的情况，是否使用 Redis Cluster  集群。同时， Redis Cluster 集群会有运维的复杂性，同时会存在跨分片操作（例如说 mget 等等）、事务等操作是不支持的。</li>
</ul>
<h2 id="Redis-有哪些重要的健康指标？"><a href="#Redis-有哪些重要的健康指标？" class="headerlink" title="Redis 有哪些重要的健康指标？"></a>Redis 有哪些重要的健康指标？</h2><p>推荐阅读 <a href="https://mp.weixin.qq.com/s/D_khsApGkRckEoV75pYpDA">《Redis 几个重要的健康指标》</a></p>
<ul>
<li>存活情况</li>
<li>连接数</li>
<li>阻塞客户端数量</li>
<li>使用内存峰值</li>
<li>内存碎片率</li>
<li>缓存命中率</li>
<li>OPS</li>
<li>持久化</li>
<li>失效KEY</li>
<li>慢日志</li>
</ul>
<p><strong>如何提高 Redis 命中率？</strong></p>
<p>推荐阅读 <a href="http://www.cnblogs.com/shamo89/p/8383915.html">《如何提高缓存命中率（Redis）》</a> 。</p>
<h2 id="怎么优化-Redis-的内存占用？"><a href="#怎么优化-Redis-的内存占用？" class="headerlink" title="怎么优化 Redis 的内存占用？"></a>怎么优化 Redis 的内存占用？</h2><p>推荐阅读 <a href="https://www.jianshu.com/p/8677603d3865">《Redis 的内存优化》</a></p>
<ul>
<li>redisObject 对象</li>
<li>缩减键值对象</li>
<li>共享对象池</li>
<li>字符串优化</li>
<li>编码优化</li>
<li>控制 key 的数量</li>
</ul>
<p>🦅 <strong>一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素？</strong></p>
<p>一个 Redis 实例，最多能存放多少的 keys ，List、Set、Sorted Set 他们最多能存放多少元素。</p>
<p>理论上，Redis 可以处理多达 2^32 的 keys ，并且在实际中进行了测试，每个实例至少存放了 2 亿 5 千万的 keys。</p>
<p>任何 list、set、和 sorted set 都可以放 2^32 个元素。</p>
<p>🦅 <strong>假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</strong></p>
<p>使用 <code>keys</code> 指令可以扫出指定模式的 key 列表。</p>
<ul>
<li>对方接着追问：如果这个 Redis 正在给线上的业务提供服务，那使用 <code>keys</code> 指令会有什么问题？</li>
<li>这个时候你要回答 Redis 关键的一个特性：Redis 的单线程的。<code>keys</code> 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 <code>scan</code> 指令，<code>scan</code> 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 <code>keys</code> 指令长。</li>
</ul>
<h2 id="Redis-常见的性能问题都有哪些？如何解决？"><a href="#Redis-常见的性能问题都有哪些？如何解决？" class="headerlink" title="Redis 常见的性能问题都有哪些？如何解决？"></a>Redis 常见的性能问题都有哪些？如何解决？</h2><ul>
<li><p>1、<strong>Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件</strong>。</p>
<blockquote>
<p>经过和朋友讨论，主节点开启 AOF 日志功能，尽量避免 AOF 重写。</p>
</blockquote>
<ul>
<li>Master 写内存快照，save 命令调度 rdbSave 函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以 Master 最好不要写内存快照。</li>
<li>Master AOF 持久化，如果不重写 AOF 文件，这个持久化方式对性能的影响是最小的，但是 AOF 文件会不断增大，AOF 文件过大会影响 Master 重启的恢复速度。</li>
<li>所以，Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化。如果数据比较关键，某个 Slave 开启AOF备份数据，策略为每秒同步一次。</li>
</ul>
</li>
<li><p>2、Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。</p>
<ul>
<li>一般来说，出现这个问题，很多时候是因为 Master 的内存过大，一次 AOF 重写需要占用的 CPU 和内存的资源较多，此时可以考虑 Redis Cluster 方案。</li>
</ul>
</li>
<li><p>3、尽量避免在压力很大的主库上增加过多的从库。</p>
<ul>
<li>可以考虑在从上挂载其它的从。</li>
</ul>
</li>
<li><p>4、主从复制不要用图状结构，用单向链表结构更为稳定，即：<code>Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3...</code> 。</p>
<ul>
<li><p>这样的结构，也方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master挂了，可以立刻启用 Slave1 做 Master ，其他不变。</p>
<blockquote>
<p>从节点在切换主节点作为复制源的时候，会重新发起全量复制。所以此处通过 Slave1 挂在 Slave 下，可以规避这个问题。同时，也减少了 Master 的复制压力。当然，坏处就是 Slave1 的延迟可能会高一些些，所以还是需要取舍。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>5、Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。</p>
</li>
</ul>
<hr>
<p>和飞哥沟通过后，他们主节点开启 AOF ，从节点开启 AOF + RDB 。</p>
<p>和晓峰沟通后，他们主节点开启 AOF ，从节点开启 RDB 居多，也有开启 AOF + RDB 的。</p>
<h2 id="修改配置不重启-Redis-会实时生效吗？"><a href="#修改配置不重启-Redis-会实时生效吗？" class="headerlink" title="修改配置不重启 Redis 会实时生效吗？"></a>修改配置不重启 Redis 会实时生效吗？</h2><p>针对运行实例，有许多配置选项可以通过 <code>CONFIG SET</code> 命令进行修改，而无需执行任何形式的重启。</p>
<p>从 Redis 2.2 开始，可以从 AOF 切换到 RDB 的快照持久性或其他方式而不需要重启 Redis。检索 <code>CONFIG GET *</code> 命令获取更多信息。</p>
<p>但偶尔重新启动是必须的，如为升级 Redis 程序到新的版本，或者当你需要修改某些目前 CONFIG 命令还不支持的配置参数的时候。</p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>有些比较凶残的面试官，可能会问我们一些 Redis 数据结构的问题，例如：</p>
<ul>
<li><p>Skiplist 插入和查询原理？</p>
</li>
<li><p>压缩列表的原理？</p>
</li>
<li><p>Redis 底层为什么使用跳跃表而不是红黑树？</p>
<blockquote>
<p>跳跃表在范围查找的时候性能比较高。</p>
</blockquote>
</li>
</ul>
<p>想要了解这块，需要花一定的时间去撸一撸源码，推荐可以看如下两块内容：</p>
<ul>
<li><a href="https://juejin.im/book/5afc2e5f6fb9a07a9b362527?referrer=5904c637b123db3ee479d923">《Redis 深度历险：核心原理与应用实践》</a></li>
<li><a href="https://u.jd.com/Fl5NTt">《Redis 设计与实现》</a></li>
</ul>
<p>推荐先读第一本，可以深入浅出的了解 Redis 原理和源码。然后在读第二本，硬核了解 Redis 的设计与实现（源码）。</p>
<h2 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h2><p>哇哦，爽。虽然过程痛苦，但是中间请教了蛮多人问题，收获颇多哈。</p>
<p>嘿嘿，在回答问题的过程中，胖友会发现一直在推荐 <a href="https://u.jd.com/lDNJa9">《Redis 开发与运维》</a> 这本书。在艿艿整理完第一版 Redis 面试题后，发现对有些 Redis 的面试题，理解还是有所欠缺（当然现在可能也是，哈哈哈），重新翻看了下这本书，发现很多问题都得到了非常不错的解答。所以，推荐再推荐。</p>
<p>参考与推荐如下文章：</p>
<ul>
<li>JeffreyLcm <a href="https://segmentfault.com/a/1190000014507534">《Redis 面试题》</a></li>
<li>烙印99 <a href="https://www.imooc.com/article/36399">《史上最全 Redis 面试题及答案》</a></li>
<li>yanglbme <a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-single-thread-model.md">《Redis 和 Memcached 有什么区别？Redis 的线程模型是什么？为什么单线程的 Redis 比多线程的 Memcached 效率要高得多？》</a></li>
<li>老钱 <a href="https://zhuanlan.zhihu.com/p/32540678">《天下无难试之 Redis 面试题刁难大全》</a></li>
<li>yanglbme <a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-persistence.md">《Redis 的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？》</a></li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>精尽 Spring 面试题</title>
    <url>/2016/10/12/%E7%B2%BE%E5%B0%BD%20Spring%20%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="精尽-Spring-面试题"><a href="#精尽-Spring-面试题" class="headerlink" title="精尽 Spring 面试题"></a>精尽 Spring 面试题</h1><p>以下面试题，基于网络整理，和自己编辑。具体参考的文章，会在文末给出所有的链接。</p>
<p>如果胖友有自己的疑问，欢迎在星球提问，我们一起整理吊吊的 Spring 面试题的大保健。</p>
<p>而题目的难度，艿艿尽量按照从容易到困难的顺序，逐步下去。</p>
<blockquote>
<p>注意 1 ，这个面试题，暂时不包括 Spring MVC 部分。主要以 Spring IoC、Spring AOP、Spring Transaction 为主。</p>
<p>注意 2 ，T T Spring 怎么会有这么多问题，艿艿自己面试很多都不太问，跟背书一样。所以整理的过程，真的是痛苦万分。</p>
</blockquote>
<p>Spring 是一个很庞大的技术体系，可以说包容一切，所以本文我们按照下面的顺序，罗列各种面试题：</p>
<ul>
<li>Spring <strong>整体</strong>相关的面试</li>
<li>Spring <strong>IoC</strong> 相关的面试题</li>
<li>Spring <strong>AOP</strong> 相关的面试题</li>
<li>Spring <strong>Transaction</strong> 相关的面试题</li>
<li>Spring <strong>Data Access</strong> 相关的面试题</li>
</ul>
<h1 id="Spring-整体"><a href="#Spring-整体" class="headerlink" title="Spring 整体"></a>Spring 整体</h1><h2 id="什么是-Spring-Framework？"><a href="#什么是-Spring-Framework？" class="headerlink" title="什么是 Spring Framework？"></a>什么是 Spring Framework？</h2><p>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</p>
<ul>
<li><p>它是轻量级、松散耦合的。</p>
<blockquote>
<p>它的轻量级主要是相对于 EJB 。随着 Spring 的体系越来越庞大，大家被 Spring 的配置搞懵逼了，所以后来出了 Spring Boot 。</p>
</blockquote>
</li>
<li><p>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。</p>
</li>
<li><p>它可以集成其他框架，如 Spring MVC、Hibernate、MyBatis 等，所以又称为框架的框架( 粘合剂、脚手架 )。</p>
</li>
</ul>
<h2 id="Spring-Framework-中有多少个模块，它们分别是什么？"><a href="#Spring-Framework-中有多少个模块，它们分别是什么？" class="headerlink" title="Spring Framework 中有多少个模块，它们分别是什么？"></a>Spring Framework 中有多少个模块，它们分别是什么？</h2><p>如下是一张比较早期版本的 Spring Framework 的模块图：</p>
<blockquote>
<p>艿艿：因为它的配色比较好看，哈哈哈哈。所以，没自己画一个最新的。</p>
</blockquote>
<p><img src="http://cdn.tuwenbin.vip/hyxytp5m.bmp" alt="hyxytp5m">Spring Framework</p>
<p>我们按照一个一个分块来说。</p>
<p><strong>Spring 核心容器</strong></p>
<blockquote>
<p>对应图中，Core Container 。</p>
</blockquote>
<p>该层基本上是 Spring Framework 的核心。它包含以下模块：</p>
<ul>
<li><p>Spring Core</p>
</li>
<li><p>Spring Bean</p>
<blockquote>
<p>核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC）模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 </p>
</blockquote>
</li>
<li><p>Spring Context</p>
<blockquote>
<p>Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、事件机制、校验和调度功能。  </p>
</blockquote>
</li>
<li><p>SpEL (Spring Expression Language)</p>
<blockquote>
<p>Spring 表达式语言全称为 “Spring Expression Language”，缩写为 “SpEL” ，类似于 Struts2  中使用的 OGNL 表达式语言，能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与 Spring 功能完美整合，如能用来配置  Bean 定义。</p>
</blockquote>
</li>
</ul>
<p>或者说，这块就是 Spring IoC 。</p>
<p><strong>数据访问</strong></p>
<blockquote>
<p>对应图中，Data Access 。</p>
</blockquote>
<p>该层提供与数据库交互的支持。它包含以下模块：</p>
<ul>
<li><p>JDBC (Java DataBase Connectivity)</p>
<blockquote>
<p>Spring 对 JDBC 的封装模块，提供了对关系数据库的访问。</p>
</blockquote>
</li>
<li><p>ORM (Object Relational Mapping)</p>
<blockquote>
<p>Spring ORM 模块，提供了对 hibernate5 和 JPA 的集成。</p>
<ul>
<li>hibernate5 是一个 ORM 框架。</li>
<li>JPA 是一个 Java 持久化 API 。</li>
</ul>
</blockquote>
</li>
<li><p>OXM (Object XML Mappers)</p>
<blockquote>
<p>Spring 提供了一套类似 ORM 的映射机制，用来将 Java 对象和 XML 文件进行映射。这就是 Spring 的对象 XML 映射功能，有时候也成为 XML 的序列化和反序列化。</p>
<p>用的比较少，胖友了解下即可。</p>
</blockquote>
</li>
<li><p>Transaction</p>
<blockquote>
<p>Spring 简单而强大的事务管理功能，包括声明式事务和编程式事务。 </p>
</blockquote>
</li>
</ul>
<p><strong>Web</strong></p>
<p>该层提供了创建 Web 应用程序的支持。它包含以下模块：</p>
<ul>
<li><p>WebMVC</p>
<blockquote>
<p>MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。 </p>
</blockquote>
</li>
<li><p>WebFlux</p>
<blockquote>
<p>基于 Reactive 库的响应式的 Web 开发框架 </p>
<p>不了解的胖友，可以看看 <a href="https://www.ibm.com/developerworks/cn/java/spring5-webflux-reactive/index.html">《使用 Spring 5 的 WebFlux 开发反应式 Web 应用》</a></p>
</blockquote>
</li>
<li><p>WebSocket</p>
<blockquote>
<p>Spring 4.0 的一个最大更新是增加了对 Websocket 的支持。</p>
<p>Websocket 提供了一个在 Web 应用中实现高效、双向通讯，需考虑客户端(浏览器)和服务端之间高频和低延时消息交换的机制。</p>
<p>一般的应用场景有：在线交易、网页聊天、游戏、协作、数据可视化等。</p>
</blockquote>
</li>
<li><p><del>Portlet</del> 已经废弃</p>
</li>
</ul>
<p><strong>AOP</strong></p>
<p>该层支持面向切面编程。它包含以下模块：</p>
<ul>
<li><p>AOP</p>
<blockquote>
<p>通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。</p>
<p>Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。 </p>
</blockquote>
</li>
<li><p>Aspects </p>
<blockquote>
<p>该模块为与 AspectJ 的集成提供支持。</p>
</blockquote>
</li>
<li><p>Instrumentation</p>
<blockquote>
<p>该层为类检测和类加载器实现提供支持。</p>
<p>用的比较少，胖友了解下即可。</p>
</blockquote>
</li>
</ul>
<p><strong>其它</strong></p>
<ul>
<li><p>JMS (Java Messaging Service)</p>
<blockquote>
<p>提供了一个 JMS 集成框架，简化了 JMS API 的使用。</p>
<p>可能有胖友不太了解 JMS ，可以看看 <a href="https://www.cnblogs.com/chenpi/p/5559349.html">《JMS(Java消息服务)入门教程》</a> 。</p>
</blockquote>
</li>
<li><p>Test</p>
<blockquote>
<p>该模块为使用 JUnit 和 TestNG 进行测试提供支持。</p>
</blockquote>
</li>
<li><p>Messaging</p>
<blockquote>
<p>该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。</p>
</blockquote>
</li>
</ul>
<h2 id="使用-Spring-框架能带来哪些好处？"><a href="#使用-Spring-框架能带来哪些好处？" class="headerlink" title="使用 Spring 框架能带来哪些好处？"></a>使用 Spring 框架能带来哪些好处？</h2><p>下面列举了一些使用 Spring 框架带来的主要好处：</p>
<blockquote>
<p>艿艿：注意，下文中加粗的内容，这是本句话的关键。</p>
</blockquote>
<ul>
<li><strong>DI</strong> ：**<a href="http://howtodoinjava.com/2013/03/19/inversion-of-control-ioc-and-dependency-injection-di-patterns-in-spring-framework-and-related-interview-questions/">Dependency Injection(DI)</a>** 方法，使得构造器和 JavaBean、properties 文件中的依赖关系一目了然。</li>
<li><strong>轻量级</strong>：与 EJB 容器相比较，IoC 容器更加趋向于<strong>轻量级</strong>。这样一来 IoC 容器在有限的内存和 CPU 资源的情况下，进行应用程序的开发和发布就变得十分有利。</li>
<li><strong>面向切面编程(AOP)**： Spring 支持面向</strong>切面编程**，同时把应用的业务逻辑与系统的服务分离开来。</li>
<li><strong>集成主流框架</strong>：Spring 并没有闭门造车，Spring <strong>集成</strong>了已有的技术栈，比如 ORM 框架、Logging 日期框架、J2EE、Quartz 和 JDK Timer ，以及其他视图技术。</li>
<li>模块化：Spring 框架是按照<strong>模块</strong>的形式来组织的。由包和类的命名，就可以看出其所属的模块，开发者仅仅需要选用他们需要的模块即可。</li>
<li><strong>便捷的测试</strong>：要 <a href="http://howtodoinjava.com/2013/04/19/how-to-unit-test-spring-security-authentication-with-junit/">测试一项用Spring开发的应用程序</a> 十分简单，因为<strong>测试</strong>相关的环境代码都已经囊括在框架中了。更加简单的是，利用 JavaBean 形式的 POJO 类，可以很方便的利用依赖注入来写入测试数据。</li>
<li><strong>Web 框架</strong>：Spring 的 <strong>Web 框架</strong>亦是一个精心设计的 Web MVC 框架，为开发者们在 Web 框架的选择上提供了一个除了主流框架比如 Struts 、过度设计的、不流行 Web 框架的以外的有力选项。</li>
<li><strong>事务管理</strong>：Spring 提供了一个便捷的<strong>事务管理</strong>接口，适用于小型的本地事物处理（比如在单 DB 的环境下）和复杂的共同事物处理（比如利用 JTA 的复杂 DB 环境）。</li>
<li><strong>异常处理</strong>：Spring 提供一个方便的 API ，将特定技术的异常(由JDBC, Hibernate, 或 JDO 抛出)转化为一致的、Unchecked 异常。</li>
</ul>
<p>当然，Spring 代码优点的同时，一定会带来相应的缺点：</p>
<ul>
<li><p>每个框架都有的问题，调试阶段不直观，后期的 bug 对应阶段，不容易判断问题所在。要花一定的时间去理解它。</p>
</li>
<li><p>把很多 JavaEE 的东西封装了，在满足快速开发高质量程序的同时，隐藏了实现细节。</p>
<blockquote>
<p>这就导致，很多工程师，离开了 Spring 之后，就不知道怎么工作了。从 Java 工程师，变成了 Spring 工程师。对于有追求的我们，还是需要知其然，知其所以然。</p>
</blockquote>
</li>
</ul>
<h2 id="Spring-框架中都用到了哪些设计模式？"><a href="#Spring-框架中都用到了哪些设计模式？" class="headerlink" title="Spring 框架中都用到了哪些设计模式？"></a>Spring 框架中都用到了哪些设计模式？</h2><p>Spring 框架中使用到了大量的设计模式，下面列举了比较有代表性的：</p>
<ul>
<li>代理模式 — 在 AOP 和 remoting 中被用的比较多。</li>
<li>单例模式 — 在 Spring 配置文件中定义的 Bean 默认为单例模式。</li>
<li>模板方法 — 用来解决代码重复的问题。比如 <a href="http://howtodoinjava.com/2015/02/20/spring-restful-client-resttemplate-example/">RestTemplate</a>、JmsTemplate、JdbcTemplate 。</li>
<li>前端控制器 — Spring提供了 DispatcherServlet 来对请求进行分发。</li>
<li>视图帮助(View Helper) — Spring 提供了一系列的 JSP 标签，高效宏来辅助将分散的代码整合在视图里。</li>
<li>依赖注入 — 贯穿于 BeanFactory / ApplicationContext 接口的核心理念。</li>
<li>工厂模式 — BeanFactory 用来创建对象的实例。</li>
</ul>
<p>当然，感兴趣的胖友，觉得不过瘾，可以看看艿艿基友知秋写的几篇文章：</p>
<ul>
<li><a href="http://www.iocoder.cn/Spring/DesignPattern-1">《Spring 框架中的设计模式(一)》</a></li>
<li><a href="http://www.iocoder.cn/Spring/DesignPattern-2">《Spring 框架中的设计模式(二)》</a></li>
<li><a href="http://www.iocoder.cn/Spring/DesignPattern-3">《Spring 框架中的设计模式(三)》</a></li>
<li><a href="http://www.iocoder.cn/Spring/DesignPattern-4">《Spring 框架中的设计模式(四)》</a></li>
<li><a href="http://www.iocoder.cn/Spring/DesignPattern-5">《Spring 框架中的设计模式(五)》</a></li>
</ul>
<h1 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h1><blockquote>
<p>下面，我们会将分成 IoC 和 Bean 两部分来分享 Spring 容器的内容。</p>
<ul>
<li>IoC ，侧重在于容器。</li>
<li>Bean ，侧重在于被容器管理的 Bean 。</li>
</ul>
</blockquote>
<h2 id="什么是-Spring-IoC-容器？"><a href="#什么是-Spring-IoC-容器？" class="headerlink" title="什么是 Spring IoC 容器？"></a>什么是 Spring IoC 容器？</h2><blockquote>
<p>注意，正确的拼写是 IoC 。</p>
</blockquote>
<p>Spring 框架的核心是 Spring IoC 容器。容器创建 Bean 对象，将它们装配在一起，配置它们并管理它们的完整生命周期。</p>
<ul>
<li>Spring 容器使用<strong>依赖注入</strong>来管理组成应用程序的 Bean 对象。</li>
<li>容器通过读取提供的<strong>配置元数据</strong> Bean Definition 来接收对象进行实例化，配置和组装的指令。</li>
<li>该配置元数据 Bean Definition 可以通过 XML，Java 注解或 Java Config 代码<strong>提供</strong>。</li>
</ul>
<blockquote>
<p>艿艿，注意上面三段段话的<strong>加粗</strong>部分的内容。</p>
</blockquote>
<p><img src="http://cdn.tuwenbin.vip/hlvdxl2z.bmp" alt="hlvdxl2z">Spring IoC</p>
<h2 id="什么是依赖注入？"><a href="#什么是依赖注入？" class="headerlink" title="什么是依赖注入？"></a>什么是依赖注入？</h2><p>在依赖注入中，你不必主动、手动创建对象，但必须描述如何创建它们。</p>
<ul>
<li>你不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。</li>
<li>然后，再由 IoC 容器将它们装配在一起。</li>
</ul>
<p>另外，依赖注入的英文缩写是 Dependency Injection ，简称 DI 。</p>
<h2 id="IoC-和-DI-有什么区别？"><a href="#IoC-和-DI-有什么区别？" class="headerlink" title="IoC 和 DI 有什么区别？"></a>IoC 和 DI 有什么区别？</h2><blockquote>
<p>艿艿的吐槽，最怕这种概念题。下面引用知乎上的一个讨论：<a href="https://www.zhihu.com/question/25392984">《IoC 和DI 有什么区别？》</a></p>
</blockquote>
<p>IoC 是个更宽泛的概念，DI 是更具体的。引用郑烨的一篇博客，引用郑烨的一篇博客，<a href="https://link.zhihu.com/?target=http://dreamhead.blogbus.com/logs/125334.html">我眼中的Spring</a></p>
<blockquote>
<p><strong>Dependency Injection</strong><br>原来，它叫 IoC 。<br>Martin Flower 发话了，是个框架都有 IoC ，这不足以新生容器反转的“如何定位插件的具体实现”，于是，它有了个新名字，Dependency Injection 。</p>
<p>其实，它就是一种将调用者与被调用者分离的思想，Uncle Bob 管它叫DIP（Dependency Inversion Principle），并把它归入OO设计原则。<br>同 Spring 相比，它更早进入我的大脑。一切都是那么朦胧，直至 Spring 出现。  </p>
<p>慢慢的，我知道了它还分为三种：</p>
<ul>
<li>Interface Injection（type 1）</li>
<li>Setter Injection（type 2）</li>
<li>Constructor Injection（type 3）。</li>
</ul>
<p>Martin Flower那篇为它更名的大作让我心目关于它的一切趋于完整。</p>
<p>在 Spring 中，它是一切的基础。Spring 的种种优势随之而来。<br>于我而言，它为我带来更多的是思维方式的转变，恐怕以后我再也无法写出那种一大块的全功能程序了。</p>
</blockquote>
<h2 id="可以通过多少种方式完成依赖注入？"><a href="#可以通过多少种方式完成依赖注入？" class="headerlink" title="可以通过多少种方式完成依赖注入？"></a>可以通过多少种方式完成依赖注入？</h2><p>通常，依赖注入可以通过<strong>三种</strong>方式完成，即：</p>
<blockquote>
<p>上面一个问题的三种方式的英文，下面是三种方式的中文。</p>
</blockquote>
<ul>
<li>接口注入</li>
<li>构造函数注入</li>
<li>setter 注入</li>
</ul>
<p>目前，在 Spring Framework 中，仅使用构造函数和 setter 注入这<strong>两种</strong>方式。</p>
<p>那么这两种方式各有什么优缺点呢？胖友可以简单阅读 <a href="https://my.oschina.net/itblog/blog/203746">《Spring两种依赖注入方式的比较》</a>，不用太较真。综述来说：</p>
<table>
<thead>
<tr>
<th>构造函数注入</th>
<th>setter 注入</th>
</tr>
</thead>
<tbody><tr>
<td>没有部分注入</td>
<td>有部分注入</td>
</tr>
<tr>
<td>不会覆盖 setter 属性</td>
<td>会覆盖 setter 属性</td>
</tr>
<tr>
<td>任意修改都会创建一个新实例</td>
<td>任意修改不会创建一个新实例</td>
</tr>
<tr>
<td>适用于设置很多属性</td>
<td>适用于设置少量属性</td>
</tr>
</tbody></table>
<ul>
<li>实际场景下，setting 注入使用的更多。</li>
</ul>
<h2 id="Spring-中有多少种-IoC-容器？"><a href="#Spring-中有多少种-IoC-容器？" class="headerlink" title="Spring 中有多少种 IoC 容器？"></a>Spring 中有多少种 IoC 容器？</h2><p>Spring 提供了两种( 不是“个” ) IoC 容器，分别是 BeanFactory、ApplicationContext 。</p>
<p><strong>BeanFactory</strong></p>
<blockquote>
<p>BeanFactory 在 <code>spring-beans</code> 项目提供。</p>
</blockquote>
<p>BeanFactory ，就像一个包含 Bean 集合的工厂类。它会在客户端要求时实例化 Bean 对象。</p>
<p><strong>ApplicationContext</strong></p>
<blockquote>
<p>ApplicationContext 在 <code>spring-context</code> 项目提供。</p>
</blockquote>
<p>ApplicationContext 接口扩展了 BeanFactory 接口，它在 BeanFactory 基础上提供了一些额外的功能。内置如下功能：</p>
<ul>
<li>MessageSource ：管理 message ，实现国际化等功能。</li>
<li>ApplicationEventPublisher ：事件发布。</li>
<li>ResourcePatternResolver ：多资源加载。</li>
<li>EnvironmentCapable ：系统 Environment（profile + Properties）相关。</li>
<li>Lifecycle ：管理生命周期。</li>
<li>Closable ：关闭，释放资源</li>
<li>InitializingBean：自定义初始化。</li>
<li>BeanNameAware：设置 beanName 的 Aware 接口。</li>
</ul>
<p>另外，ApplicationContext 会自动初始化非懒加载的 Bean 对象们。</p>
<p>详细的内容，感兴趣的胖友，可以看看 <a href="http://svip.iocoder.cn/Spring/ApplicationContext/">《【死磕 Spring】—— ApplicationContext 相关接口架构分析》</a> 一文。源码之前无秘密。简单总结下 BeanFactory 与 ApplicationContext 两者的差异：</p>
<blockquote>
<p>艿艿：可能很多胖友没看过源码，所以会比较难。</p>
</blockquote>
<table>
<thead>
<tr>
<th>BeanFactory</th>
<th>ApplicationContext</th>
</tr>
</thead>
<tbody><tr>
<td>它使用懒加载</td>
<td>它使用即时加载</td>
</tr>
<tr>
<td>它使用语法显式提供资源对象</td>
<td>它自己创建和管理资源对象</td>
</tr>
<tr>
<td>不支持国际化</td>
<td>支持国际化</td>
</tr>
<tr>
<td>不支持基于依赖的注解</td>
<td>支持基于依赖的注解</td>
</tr>
</tbody></table>
<p>另外，BeanFactory 也被称为<strong>低级</strong>容器，而 ApplicationContext 被称为<strong>高级</strong>容器。</p>
<h2 id="请介绍下常用的-BeanFactory-容器？"><a href="#请介绍下常用的-BeanFactory-容器？" class="headerlink" title="请介绍下常用的 BeanFactory 容器？"></a>请介绍下常用的 BeanFactory 容器？</h2><p>BeanFactory 最常用的是 XmlBeanFactory 。它可以根据 XML 文件中定义的内容，创建相应的 Bean。</p>
<h2 id="请介绍下常用的-ApplicationContext-容器？"><a href="#请介绍下常用的-ApplicationContext-容器？" class="headerlink" title="请介绍下常用的 ApplicationContext 容器？"></a>请介绍下常用的 ApplicationContext 容器？</h2><p>以下是三种较常见的 ApplicationContext 实现方式：</p>
<ul>
<li><p>1、ClassPathXmlApplicationContext ：从 ClassPath 的 XML 配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(“bean.xml”);<br></code></pre></td></tr></table></figure>
</li>
<li><p>2、FileSystemXmlApplicationContext ：由文件系统中的XML配置文件读取上下文。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ApplicationContext context &#x3D; new FileSystemXmlApplicationContext(“bean.xml”);<br></code></pre></td></tr></table></figure>
</li>
<li><p>3、XmlWebApplicationContext ：由 Web 应用的XML文件读取上下文。例如我们在 Spring MVC 使用的情况。</p>
</li>
</ul>
<p>当然，目前我们更多的是使用 Spring Boot 为主，所以使用的是第四种 ApplicationContext 容器，ConfigServletWebServerApplicationContext 。</p>
<h2 id="列举一些-IoC-的一些好处？"><a href="#列举一些-IoC-的一些好处？" class="headerlink" title="列举一些 IoC 的一些好处？"></a>列举一些 IoC 的一些好处？</h2><ul>
<li>它将最小化应用程序中的代码量。</li>
<li>它以最小的影响和最少的侵入机制促进松耦合。</li>
<li>它支持即时的实例化和延迟加载 Bean 对象。</li>
<li>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</li>
</ul>
<h2 id="简述-Spring-IoC-的实现机制？"><a href="#简述-Spring-IoC-的实现机制？" class="headerlink" title="简述 Spring IoC 的实现机制？"></a>简述 Spring IoC 的实现机制？</h2><p>简单来说，Spring 中的 IoC 的实现原理，就是<strong>工厂模式</strong>加<strong>反射机制</strong>。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">interface Fruit &#123;<br><br>     public abstract void eat();<br>     <br>&#125;<br>class Apple implements Fruit &#123;<br><br>    public void eat()&#123;<br>        System.out.println(&quot;Apple&quot;);<br>    &#125;<br>    <br>&#125;<br>class Orange implements Fruit &#123;<br>    public void eat()&#123;<br>        System.out.println(&quot;Orange&quot;);<br>    &#125;<br>&#125;<br><br>class Factory &#123;<br><br>    public static Fruit getInstance(String className) &#123;<br>        Fruit f &#x3D; null;<br>        try &#123;<br>            f &#x3D; (Fruit) Class.forName(className).newInstance();<br>        &#125; catch (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        return f;<br>    &#125;<br>    <br>&#125;<br><br>class Client &#123;<br><br>    public static void main(String[] args) &#123;<br>        Fruit f &#x3D; Factory.getInstance(&quot;io.github.dunwu.spring.Apple&quot;);<br>        if(f !&#x3D; null)&#123;<br>            f.eat();<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Fruit 接口，有 Apple 和 Orange 两个实现类。</li>
<li>Factory 工厂，通过反射机制，创建 <code>className</code> 对应的 Fruit 对象。</li>
<li>Client 通过 Factory 工厂，获得对应的 Fruit 对象。</li>
<li>😈 实际情况下，Spring IoC 比这个复杂很多很多，例如单例 Bean 对象，Bean 的属性注入，相互依赖的 Bean 的处理，以及等等。</li>
</ul>
<p>在基友 <a href="http://www.iocoder.cn/Fight/Interview-poorly-asked-Spring-IOC-process-1/">《面试问烂的 Spring IoC 过程》</a> 的文章中，把 Spring IoC 相关的内容，讲的非常不错。</p>
<h2 id="Spring-框架中有哪些不同类型的事件？"><a href="#Spring-框架中有哪些不同类型的事件？" class="headerlink" title="Spring 框架中有哪些不同类型的事件？"></a>Spring 框架中有哪些不同类型的事件？</h2><p>Spring 的 ApplicationContext 提供了支持事件和代码中监听器的功能。</p>
<p>我们可以创建 Bean 用来监听在 ApplicationContext 中发布的事件。如果一个 Bean 实现了 ApplicationListener 接口，当一个ApplicationEvent 被发布以后，Bean 会自动被通知。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class AllApplicationEventListener implements ApplicationListener&lt;ApplicationEvent&gt; &#123;  <br>    <br>    @Override  <br>    public void onApplicationEvent(ApplicationEvent applicationEvent) &#123;  <br>        &#x2F;&#x2F; process event  <br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>Spring 提供了以下五种标准的事件：</p>
<ol>
<li>上下文更新事件（ContextRefreshedEvent）：该事件会在ApplicationContext 被初始化或者更新时发布。也可以在调用ConfigurableApplicationContext 接口中的 <code>#refresh()</code> 方法时被触发。</li>
<li>上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext 的 <code>#start()</code> 方法开始/重新开始容器时触发该事件。</li>
<li>上下文停止事件（ContextStoppedEvent）：当容器调用 ConfigurableApplicationContext 的 <code>#stop()</code> 方法停止容器时触发该事件。</li>
<li>上下文关闭事件（ContextClosedEvent）：当ApplicationContext 被关闭时触发该事件。容器被关闭时，其管理的所有单例 Bean 都被销毁。</li>
<li>请求处理事件（RequestHandledEvent）：在 We b应用中，当一个HTTP 请求（request）结束触发该事件。</li>
</ol>
<hr>
<p>除了上面介绍的事件以外，还可以通过扩展 ApplicationEvent 类来开发<strong>自定义</strong>的事件。</p>
<p>① 示例自定义的事件的类，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class CustomApplicationEvent extends ApplicationEvent&#123;  <br><br>    public CustomApplicationEvent(Object source, final String msg) &#123;  <br>        super(source);<br>    &#125;  <br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>② 为了监听这个事件，还需要创建一个监听器。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class CustomEventListener implements ApplicationListener&lt;CustomApplicationEvent&gt; &#123;<br><br>    @Override  <br>    public void onApplicationEvent(CustomApplicationEvent applicationEvent) &#123;  <br>        &#x2F;&#x2F; handle event  <br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>③ 之后通过 ApplicationContext 接口的 <code>#publishEvent(Object event)</code> 方法，来发布自定义事件。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 创建 CustomApplicationEvent 事件<br>CustomApplicationEvent customEvent &#x3D; new CustomApplicationEvent(applicationContext, &quot;Test message&quot;);<br>&#x2F;&#x2F; 发布事件<br>applicationContext.publishEvent(customEvent);<br></code></pre></td></tr></table></figure>

<h1 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h1><h2 id="什么是-Spring-Bean-？"><a href="#什么是-Spring-Bean-？" class="headerlink" title="什么是 Spring Bean ？"></a>什么是 Spring Bean ？</h2><ul>
<li>Bean 由 Spring IoC 容器实例化，配置，装配和管理。</li>
<li>Bean 是基于用户提供给 IoC 容器的配置元数据 Bean Definition 创建。</li>
</ul>
<p>这个问题，胖友可以在回过头看 <a href="http://svip.iocoder.cn/Spring/Interview/#">「什么是 Spring IoC 容器？」</a> 问题，相互对照。</p>
<h2 id="Spring-有哪些配置方式"><a href="#Spring-有哪些配置方式" class="headerlink" title="Spring 有哪些配置方式"></a>Spring 有哪些配置方式</h2><p>单纯从 Spring Framework 提供的方式，一共有三种：</p>
<ul>
<li><p>1、XML 配置文件。</p>
<p>Bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;bean id&#x3D;&quot;studentBean&quot; class&#x3D;&quot;org.edureka.firstSpring.StudentBean&quot;&gt;<br>    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;Edureka&quot;&gt;&lt;&#x2F;property&gt;<br>&lt;&#x2F;bean&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>2、注解配置。</p>
<p>您可以通过在相关的类，方法或字段声明上使用注解，将 Bean 配置为组件类本身，而不是使用 XML 来描述 Bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;beans&gt;<br>&lt;context:annotation-config&#x2F;&gt;<br>&lt;!-- bean definitions go here --&gt;<br>&lt;&#x2F;beans&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>3、Java Config 配置。</p>
<p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p>
<ul>
<li><p><code>@Bean</code> 注解扮演与 <code>&lt;bean /&gt;</code> 元素相同的角色。</p>
</li>
<li><p><code>@Configuration</code> 类允许通过简单地调用同一个类中的其他 <code>@Bean</code> 方法来定义 Bean 间依赖关系。</p>
</li>
<li><p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Configuration<br>public class StudentConfig &#123;<br>    <br>    @Bean<br>    public StudentBean myStudent() &#123;<br>        return new StudentBean();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>是不是很熟悉 😈</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>目前主要使用 <strong>Java Config</strong> 配置为主。当然，三种配置方式是可以混合使用的。例如说：</p>
<ul>
<li>Dubbo 服务的配置，艿艿喜欢使用 XML 。</li>
<li>Spring MVC 请求的配置，艿艿喜欢使用 <code>@RequestMapping</code> 注解。</li>
<li>Spring MVC 拦截器的配置，艿艿喜欢 Java Config 配置。</li>
</ul>
<hr>
<p>另外，现在已经是 Spring Boot 的天下，所以更加是 <strong>Java Config</strong> 配置为主。</p>
<h2 id="Spring-支持几种-Bean-Scope-？"><a href="#Spring-支持几种-Bean-Scope-？" class="headerlink" title="Spring 支持几种 Bean Scope ？"></a>Spring 支持几种 Bean Scope ？</h2><blockquote>
<p>艿艿，这个是一个比较小众的题目，简单了解即可。</p>
</blockquote>
<p>Spring Bean 支持 5 种 Scope ，分别如下：</p>
<ul>
<li>Singleton - 每个 Spring IoC 容器仅有一个单 Bean 实例。<strong>默认</strong></li>
<li>Prototype - 每次请求都会产生一个新的实例。</li>
<li>Request - 每一次 HTTP 请求都会产生一个新的 Bean 实例，并且该 Bean 仅在当前 HTTP 请求内有效。</li>
<li>Session - 每一个的 Session 都会产生一个新的 Bean 实例，同时该 Bean 仅在当前 HTTP Session 内有效。</li>
<li>Application - 每一个 Web Application 都会产生一个新的 Bean ，同时该 Bean 仅在当前 Web Application 内有效。</li>
</ul>
<blockquote>
<p>另外，网络上很多文章说有 Global-session 级别，它是 Portlet 模块独有，目前已经废弃，在 Spring5 中是找不到的。</p>
</blockquote>
<p>仅当用户使用支持 Web 的 ApplicationContext 时，<strong>最后三个才可用</strong>。</p>
<p>再补充一点，开发者是可以<strong>自定义</strong> Bean Scope ，具体可参见 <a href="https://blog.csdn.net/elim168/article/details/75581670">《Spring（10）—— Bean 作用范围（二）—— 自定义 Scope》</a> 。</p>
<p>不错呢，还是那句话，这个题目简单了解下即可，实际常用的只有 Singleton 和 Prototype 两种级别，甚至说，只有 Singleton 级别。😈</p>
<h2 id="Spring-Bean-在容器的生命周期是什么样的？"><a href="#Spring-Bean-在容器的生命周期是什么样的？" class="headerlink" title="Spring Bean 在容器的生命周期是什么样的？"></a>Spring Bean 在容器的生命周期是什么样的？</h2><blockquote>
<p>艿艿说：这是一个比较高级的 Spring 的面试题，非常常见，并且答对比较加分。当然，如果实际真正弄懂，需要对 Spring Bean 的源码，有比较好的理解，所以 <a href="http://svip.iocoder.cn/categories/Spring/">《精尽 Spring 源码》</a> 系列，该读还是读吧。</p>
</blockquote>
<blockquote>
<p>艿艿：要注意下面每段话，艿艿进行加粗的地方。</p>
</blockquote>
<p>Spring Bean 的<strong>初始化</strong>流程如下：</p>
<ul>
<li><p>实例化 Bean 对象</p>
<ul>
<li><p>Spring 容器根据配置中的 Bean Definition(定义)中<strong>实例化</strong> Bean 对象。</p>
<blockquote>
<p>Bean Definition 可以通过 XML，Java 注解或 Java Config 代码提供。</p>
</blockquote>
</li>
<li><p>Spring 使用依赖注入<strong>填充</strong>所有属性，如 Bean 中所定义的配置。</p>
</li>
</ul>
</li>
<li><p>Aware 相关的属性，注入到 Bean 对象</p>
<ul>
<li>如果 Bean 实现 <strong>BeanNameAware</strong> 接口，则工厂通过传递 Bean 的 beanName 来调用 <code>#setBeanName(String name)</code> 方法。 </li>
<li>如果 Bean 实现 <strong>BeanFactoryAware</strong> 接口，工厂通过传递自身的实例来调用 <code>#setBeanFactory(BeanFactory beanFactory)</code> 方法。</li>
</ul>
</li>
<li><p>调用相应的方法，进一步初始化 Bean 对象</p>
<ul>
<li>如果存在与 Bean 关联的任何 <strong>BeanPostProcessor</strong> 们，则调用 <code>#preProcessBeforeInitialization(Object bean, String beanName)</code> 方法。 </li>
<li>如果 Bean 实现 <strong>InitializingBean</strong> 接口，则会调用 <code>#afterPropertiesSet()</code> 方法。</li>
<li>如果为 Bean 指定了 <strong>init</strong> 方法（例如 <code>&lt;bean /&gt;</code> 的 <code>init-method</code> 属性），那么将调用该方法。</li>
<li>如果存在与 Bean 关联的任何 <strong>BeanPostProcessor</strong> 们，则将调用 <code>#postProcessAfterInitialization(Object bean, String beanName)</code> 方法。</li>
</ul>
</li>
</ul>
<p>Spring Bean 的<strong>销毁</strong>流程如下：</p>
<ul>
<li>如果 Bean 实现 <strong>DisposableBean</strong> 接口，当 spring 容器关闭时，会调用 <code>#destroy()</code> 方法。</li>
<li>如果为 bean 指定了 <strong>destroy</strong> 方法（例如 <code>&lt;bean /&gt;</code> 的 <code>destroy-method</code> 属性），那么将调用该方法。</li>
</ul>
<p>整体如下图：<img src="http://cdn.tuwenbin.vip/qkhgsvo4.bmp" alt="qkhgsvo4">流程图</p>
<p>无意中，艿艿又翻到一张有趣的整体图，如下图：</p>
<p><img src="http://cdn.tuwenbin.vip/t1but0ou.bmp" alt="t1but0ou">流程图</p>
<h2 id="什么是-Spring-的内部-bean？"><a href="#什么是-Spring-的内部-bean？" class="headerlink" title="什么是 Spring 的内部 bean？"></a>什么是 Spring 的内部 bean？</h2><p>只有将 Bean <strong>仅</strong>用作另一个 Bean 的属性时，才能将 Bean 声明为内部 Bean。</p>
<ul>
<li>为了定义 Bean，Spring 提供基于 XML 的配置元数据在 <code>&lt;property&gt;</code>或 <code>&lt;constructor-arg&gt;</code> 中提供了 <code>&lt;bean&gt;</code>元素的使用。</li>
<li>内部 Bean 总是<strong>匿名</strong>的，并且它们总是作为<strong>原型 Prototype</strong> 。</li>
</ul>
<p>例如，假设我们有一个 Student 类，其中引用了 Person 类。这里我们将只创建一个 Person 类实例并在 Student 中使用它。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; Student.java<br><br>public class Student &#123;<br><br>    private Person person;<br>    <br>    &#x2F;&#x2F; ... Setters and Getters<br>&#125;<br><br>&#x2F;&#x2F; Person.java<br><br>public class Person &#123;<br><br>    private String name;<br>    private String address;<br>    <br>    &#x2F;&#x2F; ... Setters and Getters<br>&#125;<br>&lt;!-- bean.xml --&gt;<br><br>&lt;bean id&#x3D;“StudentBean&quot; class&#x3D;&quot;com.edureka.Student&quot;&gt;<br>    &lt;property name&#x3D;&quot;person&quot;&gt;<br>        &lt;!--This is inner bean --&gt;<br>        &lt;bean class&#x3D;&quot;com.edureka.Person&quot;&gt;<br>            &lt;property name&#x3D;&quot;name&quot; value&#x3D;“Scott&quot;&gt;&lt;&#x2F;property&gt;<br>            &lt;property name&#x3D;&quot;address&quot; value&#x3D;“Bangalore&quot;&gt;&lt;&#x2F;property&gt;<br>        &lt;&#x2F;bean&gt;<br>    &lt;&#x2F;property&gt;<br>&lt;&#x2F;bean&gt;<br></code></pre></td></tr></table></figure>

<h2 id="什么是-Spring-装配？"><a href="#什么是-Spring-装配？" class="headerlink" title="什么是 Spring 装配？"></a>什么是 Spring 装配？</h2><p>当 Bean 在 Spring 容器中组合在一起时，它被称为<strong>装配</strong>或 <strong>Bean 装配</strong>。Spring 容器需要知道需要什么 Bean 以及容器应该如何使用依赖注入来将 Bean 绑定在一起，同时装配 Bean 。</p>
<blockquote>
<p>装配，和上文提到的 DI 依赖注入，实际是一个东西。</p>
</blockquote>
<p><strong>自动装配有哪些方式？</strong></p>
<p>Spring 容器能够自动装配 Bean 。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 Bean 的协作者。</p>
<p>自动装配的不同模式：</p>
<ul>
<li>no - 这是默认设置，表示没有自动装配。应使用显式 Bean 引用进行装配。</li>
<li>byName - 它根据 Bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 Bean 。</li>
<li>【最常用】<strong>byType</strong> - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 Bean 类型匹配，则匹配并装配属性。</li>
<li>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li>
<li>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li>
</ul>
<p><strong>自动装配有什么局限？</strong></p>
<blockquote>
<p>艿艿：这个题目，了解下即可，也不是很准确。</p>
</blockquote>
<ul>
<li><p>覆盖的可能性 - 您始终可以使用 <code>&lt;constructor-arg&gt;</code> 和 <code>&lt;property&gt;</code> 设置指定依赖项，这将覆盖自动装配。</p>
</li>
<li><p>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。</p>
<blockquote>
<p>这种，严格来说，也不能称为局限。因为可以通过配置文件来解决。</p>
</blockquote>
</li>
<li><p>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。</p>
</li>
</ul>
<h2 id="解释什么叫延迟加载？"><a href="#解释什么叫延迟加载？" class="headerlink" title="解释什么叫延迟加载？"></a>解释什么叫延迟加载？</h2><p>默认情况下，容器启动之后会将所有作用域为<strong>单例</strong>的 Bean 都创建好，但是有的业务场景我们并不需要它提前都创建好。此时，我们可以在Bean 中设置 <code>lzay-init = &quot;true&quot;</code> 。</p>
<ul>
<li>这样，当容器启动之后，作用域为单例的 Bean ，就不在创建。</li>
<li>而是在获得该 Bean 时，才真正在创建加载。</li>
</ul>
<h2 id="Spring-框架中的单例-Bean-是线程安全的么？"><a href="#Spring-框架中的单例-Bean-是线程安全的么？" class="headerlink" title="Spring 框架中的单例 Bean 是线程安全的么？"></a>Spring 框架中的单例 Bean 是线程安全的么？</h2><p>Spring 框架并没有对<a href="http://howtodoinjava.com/2012/10/22/singleton-design-pattern-in-java/">单例</a> Bean 进行任何多线程的封装处理。</p>
<ul>
<li>关于单例 Bean 的<a href="http://howtodoinjava.com/2014/06/02/what-is-thread-safety/">线程安全</a>和并发问题，需要开发者自行去搞定。</li>
<li>并且，单例的线程安全问题，也不是 Spring 应该去关心的。Spring 应该做的是，提供根据配置，创建单例 Bean 或多例 Bean 的功能。</li>
</ul>
<p>当然，但实际上，大部分的 Spring Bean 并没有可变的状态(比如Serview 类和 DAO 类)，所以在某种程度上说 Spring 的单例 Bean 是线程安全的。</p>
<p>如果你的 Bean 有多种状态的话，就需要自行保证线程安全。最浅显的解决办法，就是将多态 Bean 的作用域( Scope )由 Singleton 变更为 Prototype 。</p>
<h2 id="Spring-Bean-怎么解决循环依赖的问题？"><a href="#Spring-Bean-怎么解决循环依赖的问题？" class="headerlink" title="Spring Bean 怎么解决循环依赖的问题？"></a>Spring Bean 怎么解决循环依赖的问题？</h2><blockquote>
<p>艿艿说：能回答出这个问题的，一般是比较厉害的。</p>
</blockquote>
<p>这是个比较复杂的问题，有能力的胖友，建议看下 <a href="http://svip.iocoder.cn/Spring/IoC-get-Bean-createBean-5/">《【死磕 Spring】—— IoC 之加载 Bean：创建 Bean（五）之循环依赖处理》</a></p>
<p>感觉，不通过源码，很难解释清楚这个问题。如果看不懂的胖友，可以在认真看完，在星球里，我们一起多交流下。好玩的。</p>
<h1 id="Spring-注解"><a href="#Spring-注解" class="headerlink" title="Spring 注解"></a>Spring 注解</h1><p>这块内容，实际写在 <a href="http://svip.iocoder.cn/Spring/Interview/#">「Spring Bean」</a> 中比较合适，考虑到后续的问题，都是关于注解的，所以单独起一个大的章节。</p>
<h2 id="什么是基于注解的容器配置？"><a href="#什么是基于注解的容器配置？" class="headerlink" title="什么是基于注解的容器配置？"></a>什么是基于注解的容器配置？</h2><p>不使用 XML 来描述 Bean 装配，开发人员通过在相关的类，方法或字段声明上使用<strong>注解</strong>将配置移动到组件类本身。它可以作为 XML 设置的替代方案。例如：</p>
<p>Spring 的 Java 配置是通过使用 <code>@Bean</code> 和 <code>@Configuration</code> 来实现。</p>
<ul>
<li><code>@Bean</code> 注解，扮演与 <code>&lt;bean /&gt;</code> 元素相同的角色。</li>
<li><code>@Configuration</code> 注解的类，允许通过简单地调用同一个类中的其他 <code>@Bean</code> 方法来定义 Bean 间依赖关系。</li>
</ul>
<p>示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Configuration<br>public class StudentConfig &#123;<br><br>    @Bean<br>    public StudentBean myStudent() &#123;<br>        return new StudentBean();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="如何在-Spring-中启动注解装配？"><a href="#如何在-Spring-中启动注解装配？" class="headerlink" title="如何在 Spring 中启动注解装配？"></a>如何在 Spring 中启动注解装配？</h2><p>默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置 <code>&lt;context：annotation-config /&gt;</code> 元素在 Spring 配置文件中启用它。</p>
<p>当然，如果胖友是使用 Spring Boot ，默认情况下已经开启。</p>
<h2 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h2><ul>
<li><code>@Component</code> ：它将 Java 类标记为 Bean 。它是任何 Spring 管理组件的<strong>通用</strong>构造型。</li>
<li><code>@Controller</code> ：它将一个类标记为 Spring Web MVC <strong>控制器</strong>。</li>
<li><code>@Service</code> ：此注解是组件注解的特化。它不会对 <code>@Component</code> 注解提供任何其他行为。您可以在<strong>服务层</strong>类中使用 @Service 而不是 <code>@Component</code> ，因为它以更好的方式指定了意图。</li>
<li><code>@Repository</code> ：这个注解是具有类似用途和功能的 <code>@Component</code> 注解的特化。它为 <strong>DAO</strong> 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException 。</li>
</ul>
<h2 id="Required-注解有什么用？"><a href="#Required-注解有什么用？" class="headerlink" title="@Required 注解有什么用？"></a>@Required 注解有什么用？</h2><p><code>@Required</code> 注解，应用于 Bean 属性 setter 方法。  </p>
<ul>
<li>此注解仅指示必须在配置时使用 Bean 定义中的显式属性值或使用自动装配填充受影响的 Bean 属性。</li>
<li>如果尚未填充受影响的 Bean 属性，则容器将抛出 BeanInitializationException 异常。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class Employee &#123;<br><br>    private String name;<br>    <br>    @Required<br>    public void setName(String name)&#123;<br>        this.name&#x3D;name;<br>    &#125;<br>    <br>    public string getName()&#123;<br>        return name;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>T T 貌似平时很少用这个注解噢。</li>
</ul>
<h2 id="Autowired-注解有什么用？"><a href="#Autowired-注解有什么用？" class="headerlink" title="@Autowired 注解有什么用？"></a>@Autowired 注解有什么用？</h2><p><code>@Autowired</code> 注解，可以更准确地控制应该在何处以及如何进行自动装配。</p>
<ul>
<li>此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 Bean。</li>
<li>默认情况下，它是类型驱动的注入。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class EmpAccount &#123;<br>    <br>    @Autowired<br>    private Employee emp;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Qualifier-注解有什么用？"><a href="#Qualifier-注解有什么用？" class="headerlink" title="@Qualifier 注解有什么用？"></a>@Qualifier 注解有什么用？</h2><p>当你创建多个<strong>相同类型</strong>的 Bean ，并希望仅使用属性装配<strong>其中一个</strong> Bean 时，您可以使用 <code>@Qualifier</code> 注解和 <code>@Autowired</code> 通过指定 ID 应该装配哪个<strong>确切的</strong> Bean 来消除歧义。</p>
<p>例如，应用中有两个类型为 Employee 的 Bean ID 为 <code>&quot;emp1&quot;</code> 和 <code>&quot;emp2&quot;</code> ，此处，我们希望 EmployeeAccount Bean 注入 <code>&quot;emp1&quot;</code> 对应的 Bean 对象。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class EmployeeAccount &#123;<br><br>    @Autowired<br>    @Qualifier(emp1)<br>    private Employee emp;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><blockquote>
<p>Spring AOP 的面试题中，大多数都是概念题，主要是对切面的理解。概念点主要有：</p>
<ul>
<li>AOP</li>
<li>Aspect</li>
<li>JoinPoint</li>
<li>PointCut</li>
<li>Advice</li>
<li>Target</li>
<li>AOP Proxy</li>
<li>Weaving</li>
</ul>
</blockquote>
<ul>
<li>在阅读完 <a href="http://svip.iocoder.cn/Spring/Interview/#">「Spring AOP」</a> 的面试题后，在回过头思考下这些概念点，到底理解了多少。注意，不是背，理解！</li>
</ul>
<p>非常推荐阅读如下两篇文章：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000007469968">《彻底征服 Spring AOP 之理论篇》</a></li>
<li><a href="https://segmentfault.com/a/1190000007469982">《彻底征服 Spring AOP 之实战篇》</a></li>
</ul>
<h2 id="什么是-AOP-？"><a href="#什么是-AOP-？" class="headerlink" title="什么是 AOP ？"></a>什么是 AOP ？</h2><p>AOP(Aspect-Oriented Programming)，即<strong>面向切面编程</strong>, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成， 提供了与 OOP 不同的抽象软件结构的视角。</p>
<ul>
<li>在 OOP 中，以类( Class )作为基本单元</li>
<li>在 AOP 中，以**切面( Aspect )**作为基本单元。</li>
</ul>
<h2 id="什么是-Aspect-？"><a href="#什么是-Aspect-？" class="headerlink" title="什么是 Aspect ？"></a>什么是 Aspect ？</h2><p>Aspect 由 <strong>PointCut</strong> 和 <strong>Advice</strong> 组成。</p>
<ul>
<li>它既包含了横切逻辑的定义，也包括了连接点的定义。</li>
<li>Spring AOP 就是负责实施切面的框架，它将切面所定义的横切逻辑编织到切面所指定的连接点中。</li>
</ul>
<p>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p>
<ol>
<li>如何通过 PointCut 和 Advice 定位到特定的 <strong>JoinPoint</strong> 上。</li>
<li>如何在 Advice 中编写切面代码。</li>
</ol>
<p><strong>可以简单地认为, 使用 @Aspect 注解的类就是切面</strong></p>
<p><img src="http://cdn.tuwenbin.vip/iddff34h.bmp" alt="iddff34h">流程图</p>
<h2 id="什么是-JoinPoint"><a href="#什么是-JoinPoint" class="headerlink" title="什么是 JoinPoint ?"></a>什么是 JoinPoint ?</h2><p>JoinPoint ，<strong>切点</strong>，程序运行中的一些时间点, 例如：</p>
<ul>
<li>一个方法的执行。</li>
<li>或者是一个异常的处理。</li>
</ul>
<p>在 Spring AOP 中，JoinPoint 总是方法的执行点。</p>
<h2 id="什么是-PointCut-？"><a href="#什么是-PointCut-？" class="headerlink" title="什么是 PointCut ？"></a>什么是 PointCut ？</h2><p>PointCut ，<strong>匹配</strong> JoinPoint 的谓词(a predicate that matches join points)。</p>
<blockquote>
<p>简单来说，PointCut 是匹配 JoinPoint 的条件。</p>
</blockquote>
<ul>
<li>Advice 是和特定的 PointCut 关联的，并且在 PointCut 相匹配的 JoinPoint 中执行。即 <code>Advice =&gt; PointCut =&gt; JoinPoint</code> 。</li>
<li>在 Spring 中, 所有的方法都可以认为是 JoinPoint ，但是我们并不希望在所有的方法上都添加 Advice 。<strong>而 PointCut 的作用</strong>，就是提供一组规则(使用 AspectJ PointCut expression language 来描述) 来匹配 JoinPoint ，给满足规则的 JoinPoint 添加 Advice 。</li>
</ul>
<p>😈 是不是觉得有点绕，实际场景下，其实也不会弄的这么清楚~~</p>
<h2 id="关于-JoinPoint-和-PointCut-的区别"><a href="#关于-JoinPoint-和-PointCut-的区别" class="headerlink" title="关于 JoinPoint 和 PointCut 的区别"></a>关于 JoinPoint 和 PointCut 的区别</h2><p>JoinPoint 和 PointCut 本质上就是<strong>两个不同纬度上</strong>的东西。</p>
<ul>
<li>在 Spring AOP 中，所有的方法执行都是 JoinPoint 。而 PointCut 是一个描述信息，它修饰的是 JoinPoint ，通过 PointCut ，我们就可以确定哪些 JoinPoint 可以被织入 Advice 。</li>
<li>Advice 是在 JoinPoint 上执行的，而 PointCut 规定了哪些 JoinPoint 可以执行哪些 Advice 。</li>
</ul>
<p>或者，我们在换一种说法：</p>
<ol>
<li>首先，Advice 通过 PointCut 查询需要被织入的 JoinPoint 。</li>
<li>然后，Advice 在查询到 JoinPoint 上执行逻辑。</li>
</ol>
<h2 id="什么是-Advice-？"><a href="#什么是-Advice-？" class="headerlink" title="什么是 Advice ？"></a>什么是 Advice ？</h2><p>Advice ，<strong>通知</strong>。</p>
<ul>
<li>特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice 。</li>
<li>Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的<strong>拦截器</strong>。</li>
</ul>
<p><strong>有哪些类型的 Advice？</strong></p>
<ul>
<li>Before - 这些类型的 Advice 在 JoinPoint 方法之前执行，并使用 <code>@Before</code> 注解标记进行配置。</li>
<li>After Returning - 这些类型的 Advice 在连接点方法正常执行后执行，并使用 <code>@AfterReturning</code> 注解标记进行配置。</li>
<li>After Throwing - 这些类型的 Advice 仅在 JoinPoint 方法通过抛出异常退出并使用 <code>@AfterThrowing</code> 注解标记配置时执行。</li>
<li>After Finally - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 <code>@After</code> 注解标记进行配置。</li>
<li>Around - 这些类型的 Advice 在连接点之前和之后执行，并使用 <code>@Around</code> 注解标记进行配置。</li>
</ul>
<p>😈 看起来，是不是和拦截器的执行时间，有几分相似。实际上，用于拦截效果的各种实现，大体都是类似的。</p>
<h2 id="什么是-Target-？"><a href="#什么是-Target-？" class="headerlink" title="什么是 Target ？"></a>什么是 Target ？</h2><p>Target ，织入 Advice 的<strong>目标对象</strong>。目标对象也被称为 <strong>Advised Object</strong> 。</p>
<ul>
<li>因为 Spring AOP 使用运行时代理的方式来实现 Aspect ，因此 Advised Object 总是一个代理对象(Proxied Object) 。</li>
<li><strong>注意, Advised Object 指的不是原来的对象，而是织入 Advice 后所产生的代理对象</strong>。</li>
<li>Advice + Target Object = Advised Object = Proxy 。</li>
</ul>
<h2 id="AOP-有哪些实现方式？"><a href="#AOP-有哪些实现方式？" class="headerlink" title="AOP 有哪些实现方式？"></a>AOP 有哪些实现方式？</h2><p>实现 AOP 的技术，主要分为两大类：</p>
<ul>
<li><p>① <strong>静态代理</strong> - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强。</p>
<ul>
<li><p>编译时编织（特殊编译器实现）</p>
</li>
<li><p>类加载时编织（特殊的类加载器实现）。</p>
<blockquote>
<p>例如，SkyWalking 基于 Java Agent 机制，配置上 ByteBuddy 库，实现类加载时编织时增强，从而实现链路追踪的透明埋点。</p>
<p>感兴趣的胖友，可以看看 <a href="http://www.kailing.pub/article/index/arcid/178.html">《SkyWalking 源码分析之 JavaAgent 工具 ByteBuddy 的应用》</a> 。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>② <strong>动态代理</strong> - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。目前 Spring 中使用了两种动态代理库：</p>
<ul>
<li>JDK 动态代理</li>
<li>CGLIB</li>
</ul>
</li>
</ul>
<p>那么 Spring 什么时候使用 JDK 动态代理，什么时候使用 CGLIB 呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; From 《Spring 源码深度解析》P172<br>&#x2F;&#x2F; Spring AOP 部分使用 JDK 动态代理或者 CGLIB 来为目标对象创建代理。（建议尽量使用 JDK 的动态代理）<br>&#x2F;&#x2F; 如果被代理的目标对象实现了至少一个接口，则会使用 JDK 动态代理。所有该目标类型实现的接口都讲被代理。<br>&#x2F;&#x2F; 若该目标对象没有实现任何接口，则创建一个 CGLIB 代理。<br>&#x2F;&#x2F; 如果你希望强制使用 CGLIB 代理，（例如希望代理目标对象的所有方法，而不只是实现自接口的方法）那也可以。但是需要考虑以下两个方法：<br>&#x2F;&#x2F;      1&gt; 无法通知(advise) Final 方法，因为它们不能被覆盖。<br>&#x2F;&#x2F;      2&gt; 你需要将 CGLIB 二进制发型包放在 classpath 下面。<br>&#x2F;&#x2F; 为什么 Spring 默认使用 JDK 的动态代理呢？笔者猜测原因如下：<br>&#x2F;&#x2F;      1&gt; 使用 JDK 原生支持，减少三方依赖<br>&#x2F;&#x2F;      2&gt; JDK8 开始后，JDK 代理的性能差距 CGLIB 的性能不会太多。可参见：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;haiq&#x2F;p&#x2F;4304615.html<br></code></pre></td></tr></table></figure>

<ul>
<li>实际上，Spring AOP 的代码量不大，与其在窗户外面不清不楚，不如捅破它！感兴趣的胖友，可以撸一撸 <a href="http://svip.iocoder.cn/Spring/aop-simple-intro/">《精尽 Spring 源码分析 —— AOP 源码简单导读》</a> 。</li>
</ul>
<p>或者，我们来换一个解答答案：</p>
<p>Spring AOP 中的动态代理主要有两种方式，</p>
<ul>
<li><p>JDK 动态代理</p>
<p>JDK 动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是 InvocationHandler 接口和 Proxy 类。</p>
</li>
<li><p>CGLIB 动态代理</p>
<p>如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类。当然，Spring 也支持配置，<strong>强制</strong>使用 CGLIB 动态代理。<br>CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 <code>final</code> ，那么它是无法使用 CGLIB 做动态代理的。  </p>
</li>
</ul>
<h2 id="Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？"></a>Spring AOP and AspectJ AOP 有什么区别？</h2><ul>
<li>代理方式不同<ul>
<li>Spring AOP 基于动态代理方式实现。</li>
<li>AspectJ AOP 基于静态代理方式实现。</li>
</ul>
</li>
<li>PointCut 支持力度不同<ul>
<li>Spring AOP <strong>仅</strong>支持方法级别的 PointCut 。</li>
<li>AspectJ AOP 提供了完全的 AOP 支持，它还支持属性级别的 PointCut 。</li>
</ul>
</li>
</ul>
<h2 id="什么是编织（Weaving）？"><a href="#什么是编织（Weaving）？" class="headerlink" title="什么是编织（Weaving）？"></a>什么是编织（Weaving）？</h2><p>Weaving ，<strong>编织</strong>。</p>
<ul>
<li>为了创建一个 Advice 对象而链接一个 Aspect 和其它应用类型或对象，称为编织（Weaving）。</li>
<li>在 Spring AOP 中，编织在运行时执行，即动态代理。请参考下图：<img src="http://cdn.tuwenbin.vip/nv5yvktr.bmp" alt="nv5yvktr">Proxy</li>
</ul>
<h2 id="Spring-如何使用-AOP-切面？"><a href="#Spring-如何使用-AOP-切面？" class="headerlink" title="Spring 如何使用 AOP 切面？"></a>Spring 如何使用 AOP 切面？</h2><p>在 Spring AOP 中，有两种方式配置 AOP 切面：</p>
<ul>
<li>基于 <strong>XML</strong> 方式的切面实现。</li>
<li>基于 <strong>注解</strong> 方式的切面实现。</li>
</ul>
<p>目前，主流喜欢使用 <strong>注解</strong> 方式。胖友可以看看 <a href="https://segmentfault.com/a/1190000007469982">《彻底征服 Spring AOP 之实战篇》</a> 。</p>
<h1 id="Spring-Transaction"><a href="#Spring-Transaction" class="headerlink" title="Spring Transaction"></a>Spring Transaction</h1><p>非常推荐阅读如下文章：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247484702&idx=1&sn=c04261d63929db09ff6df7cadc7cca21&chksm=fa497aafcd3ef3b94082da7bca841b5b7b528eb2a52dbc4eb647b97be63a9a1cf38a9e71bf90&token=165108535&lang=zh_CN#rd">《可能是最漂亮的 Spring 事务管理详解》</a></li>
</ul>
<h2 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h2><p>事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。</p>
<p>这样可以防止出现脏数据，防止数据库数据出现问题。</p>
<h2 id="事务的特性指的是？"><a href="#事务的特性指的是？" class="headerlink" title="事务的特性指的是？"></a>事务的特性指的是？</h2><p>指的是 <strong>ACID</strong> ，如下图所示：</p>
<p><img src="http://cdn.tuwenbin.vip/8i4h2cu4.bmp" alt="8i4h2cu4">事务的特性</p>
<ol>
<li><strong>原子性</strong> Atomicity  ：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>
<li><strong>一致性</strong> Consistency ：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7">约束</a>、<a href="https://zh.wikipedia.org/wiki/%E8%A7%A6%E5%8F%91%E5%99%A8_(%E6%95%B0%E6%8D%AE%E5%BA%93)">触发器</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E7%BA%A7%E8%81%94%E5%9B%9E%E6%BB%9A&action=edit&redlink=1">级联回滚</a>等。</li>
<li><strong>隔离性</strong> Isolation  ：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable  read）和串行化（Serializable）。</li>
<li><strong>持久性</strong> Durability ：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ol>
<h2 id="列举-Spring-支持的事务管理类型？"><a href="#列举-Spring-支持的事务管理类型？" class="headerlink" title="列举 Spring 支持的事务管理类型？"></a>列举 Spring 支持的事务管理类型？</h2><p>目前 Spring 提供两种类型的事务管理：</p>
<ul>
<li><strong>声明式</strong>事务：通过使用注解或基于 XML 的配置事务，从而事务管理与业务代码分离。</li>
<li><strong>编程式</strong>事务：通过编码的方式实现事务管理，需要在代码中显式的调用事务的获得、提交、回滚。它为您提供极大的灵活性，但维护起来非常困难。</li>
</ul>
<p>实际场景下，我们一般使用 Spring Boot + 注解的<strong>声明式</strong>事务。具体的示例，胖友可以看看 <a href="https://www.jianshu.com/p/cddeca2c9245">《Spring Boot 事务注解详解》</a> 。</p>
<p>另外，也推荐看看 <a href="https://blog.csdn.net/xktxoo/article/details/77919508">《Spring 事务管理 － 编程式事务、声明式事务》</a> 一文。</p>
<h2 id="Spring-事务如何和不同的数据持久层框架做集成？"><a href="#Spring-事务如何和不同的数据持久层框架做集成？" class="headerlink" title="Spring 事务如何和不同的数据持久层框架做集成？"></a>Spring 事务如何和不同的数据持久层框架做集成？</h2><p>① 首先，我们先明确下，这里数据持久层框架，指的是 Spring JDBC、Hibernate、Spring JPA、MyBatis 等等。</p>
<p>② 然后，Spring 事务的管理，是通过 <code>org.springframework.transaction.PlatformTransactionManager</code> 进行管理，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; PlatformTransactionManager.java<br><br>public interface PlatformTransactionManager &#123;<br><br>    &#x2F;&#x2F; 根据事务定义 TransactionDefinition ，获得 TransactionStatus 。 <br>    TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;<br><br>    &#x2F;&#x2F; 根据情况，提交事务<br>    void commit(TransactionStatus status) throws TransactionException;<br>    <br>    &#x2F;&#x2F; 根据情况，回滚事务<br>    void rollback(TransactionStatus status) throws TransactionException;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>PlatformTransactionManager 是负责事务管理的接口，一共有三个接口方法，分别负责事务的获得、提交、回滚。</p>
</li>
<li><p><code>#getTransaction(TransactionDefinition definition)</code>方法，根据事务定义 TransactionDefinition ，获得 TransactionStatus 。</p>
<ul>
<li>为什么不是创建事务呢？因为如果当前如果已经有事务，则不会进行创建，一般来说会跟当前线程进行绑定。如果不存在事务，则进行创建。</li>
<li>为什么返回的是 TransactionStatus 对象？在 TransactionStatus 中，不仅仅包含事务属性，还包含事务的其它信息，例如是否只读、是否为新创建的事务等等。😈 下面，也会详细解析 TransactionStatus 。</li>
</ul>
</li>
<li><p>事务 TransactionDefinition 是什么？😈 下面，也会详细解析 TransactionStatus 。</p>
</li>
<li><p><code>#commit(TransactionStatus status)</code>方法，根据 TransactionStatus 情况，提交事务。</p>
<ul>
<li><p>为什么根据 TransactionStatus 情况，进行提交？例如说，带<code>@Transactional</code>注解的的 A 方法，会调用 <code>@Transactional</code>注解的的 B 方法。</p>
</li>
<li><p>在 B 方法结束调用后，会执行 <code>PlatformTransactionManager#commit(TransactionStatus status)</code> 方法，此处事务<strong>是不能</strong>、<strong>也不会</strong>提交的。</p>
<ul>
<li>而是在 A 方法结束调用后，执行 <code>PlatformTransactionManager#commit(TransactionStatus status)</code> 方法，提交事务。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>#rollback(TransactionStatus status)</code>方法，根据 TransactionStatus 情况，回滚事务。</p>
<ul>
<li>为什么根据 TransactionStatus 情况，进行回滚？原因同 <code>#commit(TransactionStatus status)</code> 方法。</li>
</ul>
</li>
</ul>
<p>③ 再之后，PlatformTransactionManager 有<strong>抽象子</strong>类 <code>org.springframework.transaction.support.AbstractPlatformTransactionManager</code> ，基于 <a href="https://blog.csdn.net/carson_ho/article/details/54910518">模板方法模式</a> ，实现事务整体逻辑的骨架，而抽象 <code>#doCommit(DefaultTransactionStatus status)</code>、<code>#doRollback(DefaultTransactionStatus status)</code> 等等方法，交由子类类来实现。</p>
<blockquote>
<p>前方高能，即将进入关键的 ④ 步骤。</p>
</blockquote>
<p>④ 最后，不同的数据持久层框架，会有其对应的 PlatformTransactionManager 实现类，如下图所示：<img src="http://cdn.tuwenbin.vip/6y2o9r32.bmp" alt="6y2o9r32">事务的特性</p>
<ul>
<li>所有的实现类，都基于 AbstractPlatformTransactionManager 这个骨架类。</li>
<li>HibernateTransactionManager ，和 Hibernate5 的事务管理做集成。</li>
<li>DataSourceTransactionManager ，和 JDBC 的事务管理做集成。所以，它也适用于 MyBatis、Spring JDBC 等等。</li>
<li>JpaTransactionManager ，和 JPA 的事务管理做集成。</li>
</ul>
<p>如下，是一个比较常见的 XML 方式来配置的事务管理器，使用的是 DataSourceTransactionManager 。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!-- 事务管理器 --&gt;<br>&lt;bean id&#x3D;&quot;transactionManager&quot;<br>class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;<br>    &lt;!-- 数据源 --&gt;<br>    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;<br>&lt;&#x2F;bean&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>正如上文所说，它适用于 MyBatis、Spring JDBC 等等。</li>
</ul>
<hr>
<p>😈 是不是很有趣，更多详细的解析，可见如下几篇文章：</p>
<ul>
<li><a href="http://svip.iocoder.cn/categories/Spring/">《精尽 Spring 源码分析 —— Transaction 源码简单导读》</a></li>
<li><a href="http://svip.iocoder.cn/MyBatis/transaction-package/">《精尽 MyBatis 源码分析 —— 事务模块》</a></li>
<li><a href="http://svip.iocoder.cn/MyBatis/Spring-Integration-4/">《精尽 MyBatis 源码解析 —— Spring 集成（四）之事务》</a></li>
</ul>
<h2 id="为什么在-Spring-事务中不能切换数据源？"><a href="#为什么在-Spring-事务中不能切换数据源？" class="headerlink" title="为什么在 Spring 事务中不能切换数据源？"></a>为什么在 Spring 事务中不能切换数据源？</h2><p>做过 Spring 多数据源的胖友，都会有个惨痛的经历，为什么在开启事务的 Service 层的方法中，无法切换数据源呢？因为，在 Spring 的事务管理中，<strong>所使用的数据库连接会和当前线程所绑定</strong>，即使我们设置了另外一个数据源，使用的还是当前的数据源连接。</p>
<p>另外，多个数据源且需要事务的场景，本身会带来<strong>多事务一致性</strong>的问题，暂时没有特别好的解决方案。</p>
<p>所以一般一个应用，推荐除非了读写分离所带来的多数据源，其它情况下，建议只有一个数据源。并且，随着微服务日益身形，一个服务对应一个 DB 是比较常见的架构选择。</p>
<h2 id="Transactional-注解有哪些属性？如何使用？"><a href="#Transactional-注解有哪些属性？如何使用？" class="headerlink" title="@Transactional 注解有哪些属性？如何使用？"></a>@Transactional 注解有哪些属性？如何使用？</h2><p><code>@Transactional</code> 注解的<strong>属性</strong>如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>String</td>
<td>可选的限定描述符，指定使用的事务管理器</td>
</tr>
<tr>
<td>propagation</td>
<td>enum: Propagation</td>
<td>可选的事务传播行为设置</td>
</tr>
<tr>
<td>isolation</td>
<td>enum: Isolation</td>
<td>可选的事务隔离级别设置</td>
</tr>
<tr>
<td>readOnly</td>
<td>boolean</td>
<td>读写或只读事务，默认读写</td>
</tr>
<tr>
<td>timeout</td>
<td>int (in seconds granularity)</td>
<td>事务超时时间设置</td>
</tr>
<tr>
<td>rollbackFor</td>
<td>Class对象数组，必须继承自Throwable</td>
<td>导致事务回滚的异常类数组</td>
</tr>
<tr>
<td>rollbackForClassName</td>
<td>类名数组，必须继承自Throwable</td>
<td>导致事务回滚的异常类名字数组</td>
</tr>
<tr>
<td>noRollbackFor</td>
<td>Class对象数组，必须继承自Throwable</td>
<td>不会导致事务回滚的异常类数组</td>
</tr>
<tr>
<td>noRollbackForClassName</td>
<td>类名数组，必须继承自Throwable</td>
<td>不会导致事务回滚的异常类名字数组</td>
</tr>
</tbody></table>
<ul>
<li>一般情况下，我们直接使用 <code>@Transactional</code> 的所有属性默认值即可。</li>
</ul>
<p>具体<strong>用法</strong>如下：</p>
<ul>
<li><code>@Transactional</code> 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 <code>public</code> 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。</li>
<li>虽然 <code>@Transactional</code> 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， <strong><code>@Transactional</code> 注解应该只被应用到 <code>public</code> 方法上，这是由 Spring AOP 的本质决定的</strong>。如果你在 <code>protected</code>、<code>private</code> 或者默认可见性的方法上使用 <code>@Transactional</code> 注解，这将被忽略，也不会抛出任何异常。<strong>这一点，非常需要注意</strong>。</li>
</ul>
<hr>
<p>下面，我们来简单说下<strong>源码</strong>相关的东西。</p>
<p><code>@Transactional</code> 注解的属性，会解析成 <code>org.springframework.transaction.TransactionDefinition</code> 对象，即事务定义。TransactionDefinition 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public interface TransactionDefinition &#123;<br><br>	int getPropagationBehavior(); &#x2F;&#x2F; 事务的传播行为<br>	int getIsolationLevel(); &#x2F;&#x2F; 事务的隔离级别<br>	int getTimeout(); &#x2F;&#x2F; 事务的超时时间<br>	boolean isReadOnly(); &#x2F;&#x2F; 事务是否只读<br>	@Nullable<br>	String getName(); &#x2F;&#x2F; 事务的名字<br><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>可能会胖友有以后，<code>@Transactional</code> 注解的 <code>rollbackFor</code>、<code>rollbackForClassName</code>、<code>noRollbackFor</code>、<code>noRollbackForClassName</code> 属性貌似没体现出来？它们提现在 TransactionDefinition 的实现类 RuleBasedTransactionAttribute 中。</li>
<li><code>#getPropagationBehavior()</code> 方法，返回事务的<strong>传播行为</strong>，该值是个枚举，在下面来说。</li>
<li><code>#getIsolationLevel()</code> 方法，返回事务的<strong>隔离级别</strong>，该值是个枚举，在下面来说。</li>
</ul>
<h2 id="什么是事务的隔离级别？分成哪些隔离级别？"><a href="#什么是事务的隔离级别？分成哪些隔离级别？" class="headerlink" title="什么是事务的隔离级别？分成哪些隔离级别？"></a>什么是事务的隔离级别？分成哪些隔离级别？</h2><p>关于这个问题，涉及的内容会比较多，胖友直接看如下两篇文章：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/25419593">《数据库四大特性以及事务隔离级别》</a></li>
<li><a href="https://www.jianshu.com/p/4e3edbedb9a8">《五分钟搞清楚 MySQL 事务隔离级别》</a></li>
</ul>
<p>另外，有一点非常重要，不同数据库对四个隔离级别的支持和实现略有不同。因为我们目前互联网主要使用 MySQL 为主，所以至少要搞懂 MySQL 对隔离级别的支持和实现情况。</p>
<p>在 TransactionDefinition 接口中，定义了“<strong>四种</strong>”的隔离级别枚举。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; TransactionDefinition.java<br><br>&#x2F;**<br> * 【Spring 独有】使用后端数据库默认的隔离级别<br> *<br> * MySQL 默认采用的 REPEATABLE_READ隔离级别<br> * Oracle 默认采用的 READ_COMMITTED隔离级别<br> *&#x2F;<br>int ISOLATION_DEFAULT &#x3D; -1;<br><br>&#x2F;**<br> * 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读<br> *&#x2F;<br>int ISOLATION_READ_UNCOMMITTED &#x3D; Connection.TRANSACTION_READ_UNCOMMITTED;<br><br>&#x2F;**<br> * 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生<br> *&#x2F;<br>int ISOLATION_READ_COMMITTED &#x3D; Connection.TRANSACTION_READ_COMMITTED;<br>&#x2F;**<br> * 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。<br> *&#x2F;<br>int ISOLATION_REPEATABLE_READ &#x3D; Connection.TRANSACTION_REPEATABLE_READ;<br>&#x2F;**<br> * 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。<br> *<br> * 但是这将严重影响程序的性能。通常情况下也不会用到该级别。<br> *&#x2F;<br>int ISOLATION_SERIALIZABLE &#x3D; Connection.TRANSACTION_SERIALIZABLE;<br></code></pre></td></tr></table></figure>

<h2 id="什么是事务的传播级别？分成哪些传播级别？"><a href="#什么是事务的传播级别？分成哪些传播级别？" class="headerlink" title="什么是事务的传播级别？分成哪些传播级别？"></a>什么是事务的传播级别？分成哪些传播级别？</h2><p>事务的<strong>传播行为</strong>，指的是当前带有事务配置的方法，需要怎么处理事务。</p>
<ul>
<li><p>例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p>
</li>
<li><p>有一点需要注意，事务的传播级别，并不是数据库事务规范中的名词，<strong>而是 Spring 自身所定义的</strong>。通过事务的传播级别，Spring 才知道如何处理事务，是创建一个新事务呢，还是继续使用当前的事务。</p>
<blockquote>
<p>艿艿的自我吐槽：是不是有种背概念背的想哭</p>
</blockquote>
</li>
</ul>
<p>在 TransactionDefinition 接口中，定义了<strong>三类七种</strong>传播级别。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; TransactionDefinition.java<br><br>&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 支持当前事务的情况 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; <br><br>&#x2F;**<br> * 如果当前存在事务，则使用该事务。<br> * 如果当前没有事务，则创建一个新的事务。<br> *&#x2F;<br>int PROPAGATION_REQUIRED &#x3D; 0;<br>&#x2F;**<br> * 如果当前存在事务，则使用该事务。<br> * 如果当前没有事务，则以非事务的方式继续运行。<br> *&#x2F;<br>int PROPAGATION_SUPPORTS &#x3D; 1;<br>&#x2F;**<br> * 如果当前存在事务，则使用该事务。<br> * 如果当前没有事务，则抛出异常。<br> *&#x2F;<br>int PROPAGATION_MANDATORY &#x3D; 2;<br><br>&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 不支持当前事务的情况 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; <br><br>&#x2F;**<br> * 创建一个新的事务。<br> * 如果当前存在事务，则把当前事务挂起。<br> *&#x2F;<br>int PROPAGATION_REQUIRES_NEW &#x3D; 3;<br>&#x2F;**<br> * 以非事务方式运行。<br> * 如果当前存在事务，则把当前事务挂起。<br> *&#x2F;<br>int PROPAGATION_NOT_SUPPORTED &#x3D; 4;<br>&#x2F;**<br> * 以非事务方式运行。<br> * 如果当前存在事务，则抛出异常。<br> *&#x2F;<br>int PROPAGATION_NEVER &#x3D; 5;<br><br>&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 其他情况 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; <br><br>&#x2F;**<br> * 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行。<br> * 如果当前没有事务，则等价于 &#123;@link TransactionDefinition#PROPAGATION_REQUIRED&#125;<br> *&#x2F;<br>int PROPAGATION_NESTED &#x3D; 6;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>分类之后，其实还是比较好记的。当然，绝大数场景，我们只用 <code>PROPAGATION_REQUIRED</code> 传播级别。</p>
</li>
<li><p>这里需要指出的是，前面的六种事务传播行为是 Spring 从 EJB 中引入的，他们共享相同的概念。而 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">PROPAGATION_NESTED<br></code></pre></td></tr></table></figure>

<p> 是 Spring 所特有的。</p>
<ul>
<li>以 <code>PROPAGATION_NESTED</code>  启动的事务内嵌于外部事务中（如果存在外部事务的话），此时，内嵌事务并不是一个独立的事务，它依赖于外部事务的存在，只有通过外部的事务提交，才能引起内部事务的提交，嵌套的子事务不能单独提交。如果熟悉 JDBC  中的保存点（SavePoint）的概念，那嵌套事务就很容易理解了，其实嵌套的子事务就是保存点的一个应用，一个事务中可以包括多个保存点，每一个嵌套子事务。另外，外部事务的回滚也会导致嵌套子事务的回滚。</li>
<li>😈 当然，虽然上面 <code>PROPAGATION_NESTED</code> 文字很长，实际我们基本没用过。或者说，去掉基本，我们根本没用过。</li>
</ul>
</li>
</ul>
<h2 id="什么是事务的超时属性？"><a href="#什么是事务的超时属性？" class="headerlink" title="什么是事务的超时属性？"></a>什么是事务的超时属性？</h2><p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。</p>
<p>在 TransactionDefinition 中以 <code>int</code> 的值来表示超时时间，其单位是秒。</p>
<p>当然，这个属性，貌似我们基本也没用过。</p>
<h2 id="什么是事务的只读属性？"><a href="#什么是事务的只读属性？" class="headerlink" title="什么是事务的只读属性？"></a>什么是事务的只读属性？</h2><p>事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。</p>
<ul>
<li>所谓事务性资源就是指那些被事务管理的资源，比如数据源、JMS 资源，以及自定义的事务性资源等等。</li>
<li>如果确定只对事务性资源进行只读操作，那么我们可以将事务标志为只读的，以提高事务处理的性能。感兴趣的胖友，可以看看 <a href="https://my.oschina.net/uniquejava/blog/80954">《不使用事务和使用只读事务的区别 》</a> 。</li>
</ul>
<p>在 TransactionDefinition 中以 <code>boolean</code> 类型来表示该事务是否只读。</p>
<h2 id="什么是事务的回滚规则？"><a href="#什么是事务的回滚规则？" class="headerlink" title="什么是事务的回滚规则？"></a>什么是事务的回滚规则？</h2><p>回滚规则，定义了哪些异常会导致事务回滚而哪些不会。</p>
<ul>
<li>默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的）。 </li>
<li>但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。</li>
</ul>
<p>注意，事务的回滚规则，并不是数据库事务规范中的名词，<strong>而是 Spring 自身所定义的</strong>。</p>
<h2 id="简单介绍-TransactionStatus-？"><a href="#简单介绍-TransactionStatus-？" class="headerlink" title="简单介绍 TransactionStatus ？"></a>简单介绍 TransactionStatus ？</h2><blockquote>
<p>艿艿：这个可能不是一个面试题，主要满足下大家的好奇心。</p>
</blockquote>
<p>TransactionStatus 接口，记录事务的状态，不仅仅包含事务本身，还包含事务的其它信息。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; TransactionStatus.java<br><br>public interface TransactionStatus extends SavepointManager, Flushable &#123;<br><br>    &#x2F;**<br>     * 是否是新创建的事务<br>     *&#x2F;<br>    boolean isNewTransaction();<br><br>    &#x2F;**<br>     * 是否有 Savepoint<br>     *<br>     * 在 &#123;@link TransactionDefinition#PROPAGATION_NESTED&#125; 传播级别使用。<br>     *&#x2F;<br>    boolean hasSavepoint();<br><br>    &#x2F;**<br>     * 设置为只回滚<br>     *&#x2F;<br>    void setRollbackOnly();<br>    &#x2F;**<br>     * 是否为只回滚<br>     *&#x2F;<br>    boolean isRollbackOnly();<br><br>    &#x2F;**<br>     * 执行 flush 操作<br>     *&#x2F;<br>    @Override<br>    void flush();<br><br>    &#x2F;**<br>     * 是否事务已经完成<br>     *&#x2F;<br>    boolean isCompleted();<br><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>为什么没有事务对象呢？在 TransactionStatus 的实现类 DefaultTransactionStatus 中，有个 <code>Object transaction</code> 属性，表示事务对象。</li>
<li><code>#isNewTransaction()</code> 方法，表示是否是新创建的事务。有什么用呢？答案结合 <a href="http://svip.iocoder.cn/Spring/Interview/#">「Spring 事务如何和不同的数据持久层框架做集成？」</a> 问题，我们对 <code>#commit(TransactionStatus status)</code> 方法的解释。通过该方法，我们可以判断，当前事务是否当前方法所创建的，只有创建事务的方法，<strong>才能且应该真正的提交事务</strong>。</li>
</ul>
<h2 id="使用-Spring-事务有什么优点？"><a href="#使用-Spring-事务有什么优点？" class="headerlink" title="使用 Spring 事务有什么优点？"></a>使用 Spring 事务有什么优点？</h2><ol>
<li>通过 PlatformTransactionManager ，为不同的数据层持久框架提供统一的 API ，无需关心到底是原生 JDBC、Spring JDBC、JPA、Hibernate 还是 MyBatis 。</li>
<li>通过使用声明式事务，使业务代码和事务管理的逻辑分离，更加清晰。</li>
</ol>
<p>从倾向上来说，艿艿比较喜欢<strong>注解</strong> + 声明式事务。</p>
<h1 id="Spring-Data-Access"><a href="#Spring-Data-Access" class="headerlink" title="Spring Data Access"></a>Spring Data Access</h1><blockquote>
<p>艿艿：这块的问题，感觉面试问的不多，至少我很少问。哈哈哈。就当做下了解，万一问了呢。</p>
</blockquote>
<h2 id="Spring-支持哪些-ORM-框架？"><a href="#Spring-支持哪些-ORM-框架？" class="headerlink" title="Spring 支持哪些 ORM 框架？"></a>Spring 支持哪些 ORM 框架？</h2><ul>
<li>Hibernate</li>
<li>JPA</li>
<li>MyBatis</li>
<li><a href="https://docs.spring.io/spring/docs/3.0.0.M4/reference/html/ch13s04.html">JDO</a></li>
<li><a href="https://db.apache.org/ojb/docu/howtos/howto-use-spring.html">OJB</a></li>
</ul>
<p>可能会有胖友说，不是应该还有 Spring JDBC 吗。注意，Spring JDBC 不是 ORM 框架。</p>
<h2 id="在-Spring-框架中如何更有效地使用-JDBC-？"><a href="#在-Spring-框架中如何更有效地使用-JDBC-？" class="headerlink" title="在 Spring 框架中如何更有效地使用 JDBC ？"></a>在 Spring 框架中如何更有效地使用 JDBC ？</h2><p>Spring 提供了 Spring JDBC 框架，方便我们使用 JDBC 。</p>
<p>对于开发者，只需要使用 JdbcTemplate 类，它提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p>
<p>没有使用过的胖友，可以看看 <a href="https://www.tianmaying.com/tutorial/spring-jdbc-data-accessing">《Spring JDBC 访问关系型数据库》</a> 文章。</p>
<h2 id="Spring-数据数据访问层有哪些异常？"><a href="#Spring-数据数据访问层有哪些异常？" class="headerlink" title="Spring 数据数据访问层有哪些异常？"></a>Spring 数据数据访问层有哪些异常？</h2><p>通过使用 Spring 数据数据访问层，它统一了各个数据持久层框架的不同异常，统一进行提供 <code>org.springframework.dao.DataAccessException</code> 异常及其子类。如下图所示：</p>
<p><img src="http://cdn.tuwenbin.vip/hrq2vhvj.bmp" alt="hrq2vhvj">流程图</p>
<h2 id="使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="使用 Spring 访问 Hibernate 的方法有哪些？"></a>使用 Spring 访问 Hibernate 的方法有哪些？</h2><blockquote>
<p>艿艿：这个问题很灵异，因为艿艿已经好久不使用 Hibernate 了，所以答案是直接复制的。</p>
</blockquote>
<p>我们可以通过两种方式使用 Spring 访问 Hibernate：</p>
<ul>
<li>使用 Hibernate 模板和回调进行控制反转。</li>
<li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点。</li>
</ul>
<blockquote>
<p>艿艿：不过我记得，12 年我用过 Spring JPA 的方式，操作 Hibernate 。具体可参考 <a href="http://www.iocoder.cn/Spring-Boot/battcn/v2-orm-jpa/">《一起来学 SpringBoot 2.x | 第六篇：整合 Spring Data JPA》</a> 。 </p>
</blockquote>
<p>当然，我们可以再来看一道 <a href="https://www.cnblogs.com/xiaoheike/p/5150553.html">《JPA 规范与 ORM 框架之间的关系是怎样的呢？》</a> 。这个问题，我倒是问过面试的候选人，哈哈哈哈。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>整理 Spring 面试题的过程中，又把 Spring 的知识点又复习了一遍。我突然有点想念，那本被我翻烂的 <a href="https://book.douban.com/subject/26767354/">《Spring 实战》</a> 。😈 我要买一本原版的！！！</p>
<p>参考与推荐如下文章：</p>
<ul>
<li>Java 架构 <a href="https://yq.aliyun.com/articles/669702">《Spring 面试题》</a></li>
<li>永顺 <a href="https://segmentfault.com/a/1190000007469968">《彻底征服 Spring AOP 之理论篇》</a></li>
<li>陌上桑花开花 <a href="https://blog.csdn.net/u014079773/article/details/52453002">《Java 面试题集（七）– Spring常见面试问题》</a></li>
<li>一人浅醉 <a href="https://www.cnblogs.com/yepei/p/4716112.html">《Spring 的 @Transactional 注解详细用法》</a></li>
<li>dalaoyang <a href="https://juejin.im/post/5b065000f265da0de45235e6">《Spring 面试题》</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>精尽计算机网络面试题</title>
    <url>/2016/10/12/%E7%B2%BE%E5%B0%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="精尽计算机网络面试题"><a href="#精尽计算机网络面试题" class="headerlink" title="精尽计算机网络面试题"></a>精尽计算机网络面试题</h1><p>以下面试题，基于网络整理，和自己编辑。具体参考的文章，会在文末给出所有的链接。</p>
<p>如果胖友有自己的疑问，欢迎在星球提问，我们一起整理吊吊的【网络】面试题的大保健。</p>
<p>而题目的难度，艿艿尽量按照从容易到困难的顺序，逐步下去。</p>
<p>因为网络是个很大的话题，所以本文以常见的 TCP 和 HTTP 题目为主，例如：</p>
<ul>
<li>TCP 三次握手、四次挥手是什么？</li>
<li>HTTP1.0、HTTP1.1、HTTP2 等的区别？</li>
<li>…</li>
</ul>
<p><strong>注意，经常问的问题，会在前面加【重要】标识</strong>。</p>
<h1 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h1><p>强烈推荐阅读两篇文章：</p>
<blockquote>
<p>艿艿：可以后续回过头来看。</p>
</blockquote>
<ul>
<li><a href="https://blog.csdn.net/justloveyou_/article/details/69611328">《计算机网络体系结构综述（上）》</a></li>
<li><a href="https://blog.csdn.net/justloveyou_/article/details/69612153">《计算机网络体系结构综述（下）》</a></li>
</ul>
<p>简单一瞥：</p>
<ul>
<li><strong>OSI 七层体系结构</strong>具有概念清楚、理论完整的特点，是一个理论上的国际标准，但却不是事实上的国际标准。</li>
<li>具有简单易用特点的 <strong>TCP/IP 四层体系结构</strong>则是事实上的标准。</li>
<li>需要指出的是，<strong>五层体系结构</strong>虽然综合了 OSI 和 TCP/IP 的优点，但其只是为了学术学习研究而提出的，没有具体的实际意义。</li>
<li>三者结构示意图如下所示：<img src="http://cdn.tuwenbin.vip/d6f64b4331cc61156c5a098c18ce05a9.png" alt="1">原理体系结构 VS OS VS TCP/IP</li>
</ul>
<h2 id="简述-OSI-七层体系结构"><a href="#简述-OSI-七层体系结构" class="headerlink" title="简述 OSI 七层体系结构"></a>简述 OSI 七层体系结构</h2><blockquote>
<p>艿艿：比较复杂，至少要说出有哪些层。</p>
</blockquote>
<p>自上而下是：</p>
<ul>
<li>应用层（数据）：确定进程之间通信的性质以满足用户需要以及提供网络与用户应用</li>
<li>表示层（数据）：主要解决用户信息的语法表示问题，如加密解密</li>
<li>会话层（数据）：提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制，如服务器验证用户登录便是由会话层完成的</li>
<li>传输层（段）：实现网络不同主机上用户进程之间的数据通信，可靠<br>与不可靠的传输，传输层的错误检测，流量控制等</li>
<li>网络层（包）：提供逻辑地址（IP）、选路，数据从源端到目的端的<br>传输</li>
<li>数据链路层（帧）：将上层数据封装成帧，用MAC地址访问媒介，错误检测与修正</li>
<li>物理层（比特流）：设备之间比特流的传输，物理接口，电气特性等</li>
</ul>
<p>详细可以看 <a href="https://blog.csdn.net/justloveyou_/article/details/69612153">《计算机网络体系结构综述（下）》</a> 的 <a href="http://svip.iocoder.cn/Net/Interview/#">「二. OSI 七层体系结构简述」</a> 小节。</p>
<p><a href="https://user-gold-cdn.xitu.io/2018/7/29/164e529309f0fa33?imageslim">OSI 七层体系结构</a></p>
<h2 id="简述-TCP-IP-四层体系结构"><a href="#简述-TCP-IP-四层体系结构" class="headerlink" title="简述 TCP/IP 四层体系结构"></a>简述 TCP/IP 四层体系结构</h2><blockquote>
<p>艿艿：比较复杂，至少要说出有哪些层。</p>
</blockquote>
<p>自上而下是：</p>
<blockquote>
<p>实际上，如果我们把一些 RPC 框架的分层套到 TCP/IP 四层体系结构，也是可以的。跳到 <a href="http://svip.iocoder.cn/Dubbo/Interview/">《精尽 Dubbo 面试题》</a> 的 <a href="http://svip.iocoder.cn/Dubbo/Interview/#Dubbo-%E6%A1%86%E6%9E%B6%E7%9A%84%E5%88%86%E5%B1%82%E8%AE%BE%E8%AE%A1">「Dubbo 框架的分层设计」</a> 问题瞅瞅噢。</p>
</blockquote>
<ul>
<li><p>应用层</p>
<blockquote>
<p>HTTP、TELNET、FTP、SMTP</p>
</blockquote>
</li>
<li><p>传输层</p>
<blockquote>
<p>TCP、UDP</p>
</blockquote>
</li>
<li><p>网络层</p>
<blockquote>
<p>IP、ICMP</p>
</blockquote>
</li>
<li><p>数据接口</p>
<blockquote>
<p>PPP</p>
</blockquote>
</li>
</ul>
<p>详细可以看 <a href="https://blog.csdn.net/justloveyou_/article/details/69612153">《计算机网络体系结构综述（下）》</a> 的 <a href="http://svip.iocoder.cn/Net/Interview/#">「三. TCP/IP 四层体系结构」</a> 小节。</p>
<h2 id="知道各个层使用的是哪个数据交换设备？"><a href="#知道各个层使用的是哪个数据交换设备？" class="headerlink" title="知道各个层使用的是哪个数据交换设备？"></a>知道各个层使用的是哪个数据交换设备？</h2><blockquote>
<p>这个问题，了解即可。</p>
</blockquote>
<ul>
<li><p>网关：应用层、传输层。</p>
<blockquote>
<p>网关在传输层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。</p>
<p>网关的结构也和路由器类似，不同的是互连层。网关既可以用于广域网互连，也可以用于局域网互连。</p>
</blockquote>
</li>
<li><p>【重点】路由器：网络层</p>
<blockquote>
<p>路由选择、存储转发</p>
</blockquote>
</li>
<li><p>【重点】交换机：数据链路层、网络层</p>
<blockquote>
<p>识别数据包中的 MAC 地址信息，根据 MAC 地址进行转发，并将这些 MAC 地址与对应的端口记录在自己内部的一个地址表中。</p>
</blockquote>
</li>
<li><p>网桥：数据链路层</p>
<blockquote>
<p>将两个 LAN 连起来，根据 MAC 地址来转发帧。</p>
</blockquote>
</li>
<li><p>集线器（Hub）：物理层</p>
<blockquote>
<p>纯硬件设备，主要用来连接计算机等网络终端。</p>
</blockquote>
</li>
<li><p>中继器：物理层</p>
<blockquote>
<p>在比特级别对网络信号进行再生和重定时，从而使得它们能够在网络上传输更长的距离。</p>
</blockquote>
</li>
</ul>
<p>🦅 <strong>交换机是什么？</strong></p>
<p>在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的 MAC（网卡的硬件地址）的 NIC（网卡）挂接在哪个端口上，通过内部交换矩阵迅速将数据包传送到目的端口。<strong>目的 MAC 若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表中</strong>。</p>
<p>交换机工作于 OSI 参考模型的第二层，即数据链路层。交换机内部的 CPU 会在每个端口成功连接时，通过 ARP 协议学习它的 MAC  地址，保存成一张 ARP 表。在今后的通讯中，发往该 MAC  地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不能划分网络层广播，即广播域。</p>
<p>🦅  <strong>路由器是什么？</strong></p>
<p>路由器（Router），是一种计算机网络设备，提供了路由与转发两种重要机制，可以决定数据包从来源端到目的端所经过的路由路径（host 到 host 之间的传输路径），这个过程称为<strong>路由</strong>；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为<strong>转发</strong>。所以，路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。</p>
<p>路由工作在 OSI 模型的第三层 —— 即网络层，例如 IP 协议。当然，这也是路由器与交换器的<strong>差别</strong>，路由器是属于 OSI 第三层的产品，交换器是 OSI 第二层的产品(这里特指二层交换机)。</p>
<p>🦅 <strong>常见的路由选择协议，以及它们的区别？</strong></p>
<p>常见的路由选择协议有：RIP 协议、OSPF 协议。</p>
<ul>
<li>RIP 协议：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是 15 跳。如果大于 15 跳，它就会丢弃数据包。</li>
<li>OSPF 协议：底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。</li>
</ul>
<p>🦅 <strong>什么是网关设备？</strong></p>
<p>这个我们就不在本文中多写，感兴趣的胖友，可以看看 <a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E5%85%B3">《维基百科 —— 网关》</a> 文章。</p>
<p>🦅 <strong>详细说明 Keepalived 的故障切换工作原理？</strong></p>
<p>这种故障切换，是通过 <strong>VRRP</strong> 协议来实现的。</p>
<ul>
<li>主节点会按一定的时间间隔发送心跳信息的广播包，告诉备节点自己的存活状态信息。</li>
<li>当主节点发生故障时，备节点在一段时间内就收到广播包，从而判断主节点出现故障，因此会调用自身的接管程序来接管主节点的 IP 资源及服务。</li>
<li>当主节点恢复时，备节点会主动释放资源，恢复到接管前的状态，从而来实现主备故障切换</li>
</ul>
<p>例如，MySQL 基于 Keepalived 实现高可用。详细的，可以看看 <a href="https://www.cnblogs.com/gomysql/p/3856484.html">《Keepalived + MySQL实现高可用》</a> 。</p>
<h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><h2 id="IP-地址的分类？"><a href="#IP-地址的分类？" class="headerlink" title="IP 地址的分类？"></a>IP 地址的分类？</h2><p>IP 地址是指互联网协议地址，是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p>
<p>IP 地址编址方案将IP地址空间划分为 A、B、C、D、E 五类，其中 A、B、C 是基本类，D、E 类作为多播和保留使用，为特殊地址。</p>
<p>每个 IP 地址包括两个标识码（ID），即网络 ID 和主机 ID 。同一个物理网络上的所有主机都使用同一个网络 ID ，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机 ID 与其对应。A~E 类地址的特点如下：</p>
<p><img src="http://cdn.tuwenbin.vip/l7re66fk.bmp">五类互联网地址</p>
<ul>
<li>A 类地址：以 0 开头，第一个字节范围：0~127 。</li>
<li>B 类地址：以 10 开头，第一个字节范围：128~191 。</li>
<li>C 类地址：以 110 开头，第一个字节范围：192~223。</li>
<li>D 类地址：以 1110 开头，第一个字节范围：224~239 。</li>
<li>E 类地址：以 1111 开头，保留地址。</li>
</ul>
<p>详细的，可以看看 <a href="https://blog.csdn.net/kzadmxz/article/details/73658168">《IP 地址分类（A类 B类 C类 D类 E类）》</a> 文章。</p>
<p>🦅 <strong>IP 地址与物理地址的区别？</strong></p>
<ul>
<li>物理地址(MAC 地址)，是数据链路层和物理层使用的地址。</li>
<li>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。</li>
<li>其中 ARP 协议用于 IP 地址与物理地址的对应。</li>
</ul>
<p>详细的，可以看看 <a href="http://blog.sciencenet.cn/blog-411071-1037673.html">《即生瑜，何生亮 —— MAC 地址与 IP 地址》</a> 文章。</p>
<h2 id="网络层的-ARP-协议工作原理？"><a href="#网络层的-ARP-协议工作原理？" class="headerlink" title="网络层的 ARP 协议工作原理？"></a>网络层的 ARP 协议工作原理？</h2><p>网络层的 ARP 协议完成了 IP 地址与物理地址的映射。</p>
<ul>
<li>首先，每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。</li>
<li>当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP 列表中是否存在该 IP 地址对应的 MAC 地址：<ul>
<li>如果有，就直接将数据包发送到这个 MAC 地址。</li>
<li>如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的 MAC 地址。此 ARP 请求数据包里包括源主机的 IP  地址、硬件地址、以及目的主机的 IP 地址。网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 I P地址一致。<ul>
<li>如果不相同，就忽略此数据包。</li>
<li>如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中(如果 ARP 表中已经存在该 IP 的信息，则将其覆盖)，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址。<ul>
<li>源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。</li>
<li>如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意，在 OSI 模型中 ARP 协议属于链路层；而在 TCP/IP 模型中，ARP 协议属于网络层。</p>
</blockquote>
<h2 id="如何划分子网、超网？"><a href="#如何划分子网、超网？" class="headerlink" title="如何划分子网、超网？"></a>如何划分子网、超网？</h2><p>🦅 <strong>如何划分子网？</strong></p>
<blockquote>
<p>艿艿：可选了解。</p>
</blockquote>
<p>划分子网（变长子网掩码 VLSM）：划分子网的方法是从网络的主机号借用若干位作为子网号 subnet-id ，与此同时主机号也减少相应位数（总位数 32 位不变）。</p>
<p>由此两级 IP 地址可变为三级 IP 地址：<code>IP地址 ::= &#123;&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;&#125;</code> ，划分子网只是把 IP 地址的主机号这部分进行再划分，并不改变 IP 地址原来的网络号。</p>
<p>🦅 <strong>如何划分超网？</strong></p>
<blockquote>
<p>艿艿：可选了解。</p>
</blockquote>
<p>构造超网（无分类编址 CIDR）：CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，把 32 位的 IP 地址划分为两个部分。</p>
<p>例如：<code>128.14.35.7/20</code> 是某个 CIDR 地址块中的一个地址，其前 20 位是网络前缀（用下划线表示的部分），后面的 12 位为主机号</p>
<p>🦅 <strong>子网掩码的作用？</strong></p>
<p>子网掩码只有一个作用，就是将某个 IP 地址划分成<strong>网络地址</strong>和<strong>主机地址</strong>两部分。</p>
<p>用于子网掩码的位数，决定于可能的子网数目和每个子网的主机数目。</p>
<h2 id="什么是单播、组播-多播-、广播、任播？"><a href="#什么是单播、组播-多播-、广播、任播？" class="headerlink" title="什么是单播、组播(多播)、广播、任播？"></a>什么是单播、组播(多播)、广播、任播？</h2><blockquote>
<p>艿艿：这个问题，一般面试应该不问，主要是为了大家扩充下知识面吧。</p>
</blockquote>
<ul>
<li><strong>单播</strong>(unicast): 是指封包在计算机网络的传输中，目的地址为单一目标的一种传输方式。它是现今网络应用最为广泛，通常所使用的网络协议或服务大多采用单播传输，例如一切基于TCP的协议。</li>
<li><strong>组播</strong>(multicast): 也叫多播， 多点广播或群播。 指把信息同时传递给一组目的地址。它使用策略是最高效的，因为消息在每条网络链路上只需传递一次，而且只有在链路分叉的时候，消息才会被复制。</li>
<li><strong>广播</strong>(broadcast):是指封包在计算机网络中传输时，目的地址为网络中所有设备的一种传输方式。实际上，这里所说的“所有设备”也是限定在一个范围之中，称为“广播域”。</li>
<li><strong>任播</strong>(anycast):是一种网络寻址和路由的策略，使得资料可以根据路由拓朴来决定送到“最近”或“最好”的目的地。</li>
</ul>
<p>感兴趣的胖友，可以详细看 <a href="https://colobu.com/2014/10/21/udp-and-unicast-multicast-broadcast-anycast/">《单播，组播(多播)，广播以及任播》</a> 文章。</p>
<h2 id="区别-IPv4-和-IPv6-？"><a href="#区别-IPv4-和-IPv6-？" class="headerlink" title="区别 IPv4 和 IPv6 ？"></a>区别 IPv4 和 IPv6 ？</h2><ul>
<li>我们大多数人使用的是第二代互联网 IPv4 技术，它的最大问题是网络地址资源有限，从理论上讲能编址 1600 万个网络、链接 40 亿台主机。而根据相关数据，全球 IPv4 的 IP 地址已经即将用完。</li>
<li>而 IPv6 是作为 IETF 设计的用于替代现行版本 IP 协议(IPv4)的下一代 IP 协议，其 IPV6 地址长度为 12 8位，地址空间增大了 2^98 次方倍，几乎可以说是用之不竭的。所以随着 IPv4 不足，支持 IPv6 的网络势必会增长。</li>
</ul>
<h1 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h1><blockquote>
<p>艿艿：这个小节，可以快速看。因为，面试不一定问的很多。</p>
</blockquote>
<h2 id="ICMP-协议的主要功能？"><a href="#ICMP-协议的主要功能？" class="headerlink" title="ICMP 协议的主要功能？"></a>ICMP 协议的主要功能？</h2><p>用于在 IP 主机、路由器之间传递控制消息。</p>
<p>如下图所示：<img src="http://cdn.tuwenbin.vip/2tktfu0r.bmp" alt="2tktfu0r">ICMP 协议</p>
<h2 id="简述一下-ping-的原理？"><a href="#简述一下-ping-的原理？" class="headerlink" title="简述一下 ping 的原理？"></a>简述一下 ping 的原理？</h2><p>一般在网络不通的时候，大家会用 ping 测一下网络是否通畅。</p>
<p>ping 是基于 ICMP 协议工作的。ICMP 全称 Internet Control Message Protocol ，就是互联网<strong>控制</strong>报文协议。这里的关键词是“控制”，那具体是怎么控制的呢？ 网络包在异常负责的网络环境中传输时，会遇到各种问题，当遇到问题时，要传出消息，报告情况，这样才能调整传输策略。</p>
<p>ICMP 报文是封装在 IP 包里面的。因为传输指令的时候，肯定需要源地址和目标地址。如下图：<img src="http://cdn.tuwenbin.vip/sk250l8t.bmp" alt="sk250l8t">ICMP 报文</p>
<h2 id="什么是-Traceroute-？"><a href="#什么是-Traceroute-？" class="headerlink" title="什么是 Traceroute ？"></a>什么是 Traceroute ？</h2><blockquote>
<p>Traceroute 是构建在 ICMP 协议之上的应用。</p>
</blockquote>
<p>Traceroute ，是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。</p>
<blockquote>
<p>前面说到，尽管 ping 工具也可以进行侦测，但是，因为 IP 头的限制，ping 不能完全的记录下所经过的路由器。所以Traceroute 正好就填补了这个缺憾。</p>
</blockquote>
<p>Traceroute 的<strong>原理</strong>是非常非常的有意思。</p>
<blockquote>
<ul>
<li>它受到目的主机的 IP 后，首先给目的主机发送一个 TTL=1（还记得 TTL 是什么吗？）的 UDP(后面就知道  UDP是什么了)数据包，而经过的第一个路由器收到这个数据包以后，就自动把 TTL 减1，而 TTL 变为 0  以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的 ICMP 数据报给主机。</li>
<li>主机收到这个数据报以后再发一个 TTL=2 的 UDP 数据报给目的主机，然后刺激第二个路由器给主机发 ICMP 数据 报。如此往复直到到达目的主机。</li>
</ul>
<p>这样，traceroute 就拿到了所有的路由器 IP 。从而避开了 IP 头只能记录有限路由 IP 的问题。</p>
</blockquote>
<p>有人要问，我怎么知道 UDP 到没到达目的主机呢？</p>
<blockquote>
<p>这就涉及一个技巧的问题，TCP 和 UDP 协议有一个端口号定义，而普通的网络程序只监控少数的几个号码较小的端口，比如说 80、23  等等。而 traceroute 发送的是端口号 &gt;30000(真变态) 的 UDP  包，所以到达目的主机的时候，目的主机只能发送一个端口不可达的 ICMP 数据报给主机。主机接到这个报告以后就知道，目标主机到了。</p>
</blockquote>
<p>😈 很多情况下，在我们 ping 不通目标地址时，会尝试使用 traceroute 命令，看看是否在中间哪个 IP 无法访问。</p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="TCP-是什么？"><a href="#TCP-是什么？" class="headerlink" title="TCP 是什么？"></a>TCP 是什么？</h2><p>TCP(Transmission Control Protocol)，传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。主要特点如下：</p>
<ul>
<li><p>TCP 是面向连接的。</p>
<blockquote>
<p>就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接</p>
</blockquote>
</li>
<li><p>每一条 TCP 连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）。</p>
</li>
<li><p>TCP 提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达。</p>
</li>
<li><p>TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据。</p>
</li>
<li><p>面向字节流。</p>
<blockquote>
<p>TCP 中的“流”（Stream），指的是流入进程或从进程流出的字节序列。</p>
<p>“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</p>
</blockquote>
</li>
</ul>
<h2 id="TCP-对应的应用层协议？"><a href="#TCP-对应的应用层协议？" class="headerlink" title="TCP 对应的应用层协议？"></a>TCP 对应的应用层协议？</h2><ul>
<li>FTP ：定义了文件传输协议，使用 21 端口。常说某某计算机开了 FTP 服务便是启动了文件传输服务。下载文件，上传主页，都要用到 FTP 服务。</li>
<li>Telnet ：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于 DOS 模式下的通信服务。如以前的 BBS 是纯字符界面的，支持 BBS 的服务器将 23 端口打开，对外提供服务。</li>
<li>邮箱<ul>
<li>SMTP ：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么 SMTP 端口设置这个栏，服务器开放的是 25 号端口。</li>
<li>POP3 ：它是和 SMTP 对应，POP3 用于接收邮件。通常情况下，POP3 协议所用的是 110 端口。也是说，只要你有相应的使用 POP3 协议的程序（例如 Foxmail 或 Outlook），就可以不以 Web 方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是  163 邮箱就没有必要先进入网易网站，再进入自己的邮箱来收信）。</li>
</ul>
</li>
<li>HTTP ：从 Web 服务器传输超文本到本地浏览器的传送协议。</li>
</ul>
<h2 id="TCP-头部是怎么样的？"><a href="#TCP-头部是怎么样的？" class="headerlink" title="TCP 头部是怎么样的？"></a>TCP 头部是怎么样的？</h2><ul>
<li><a href="https://github.com/jawil/blog/issues/14">《通俗大白话来理解 TCP 协议的三次握手和四次分手》</a> 的 <a href="http://svip.iocoder.cn/Net/Interview/#">「TCP头部」</a> 小节。</li>
<li><a href="https://blog.csdn.net/qq_34501940/article/details/51073691">《TCP 协议的学习    （二）TCP 头部信息》</a></li>
</ul>
<h2 id="【重要】什么是-TCP-三次握手？"><a href="#【重要】什么是-TCP-三次握手？" class="headerlink" title="【重要】什么是 TCP 三次握手？"></a>【重要】什么是 TCP 三次握手？</h2><p>三次握手，简单来说，就是：</p>
<p><a href="https://camo.githubusercontent.com/91cee189ca7c400e3be6aa35cdda000ecbb58930/687474703a2f2f6f6f327239726e7a702e626b742e636c6f7564646e2e636f6d2f3630363537332d32303137303331373139313333363933322d313635343735313132332e706e67">TCP 三次握手的漫画</a></p>
<ul>
<li>发送方：我要和你建立链接？</li>
<li>接收方：你真的要和我建立链接么？</li>
<li>发送方：我真的要和你建立链接，成功。</li>
</ul>
<p>详细来说，步骤如下：</p>
<p><img src="http://cdn.tuwenbin.vip/hfd2awzv.bmp" alt="hfd2awzv">TCP 三次握手的干货</p>
<ul>
<li><p>第一次握手：Client 将标志位 <code>SYN=1</code> ，随机产生一个值 <code>seq=J</code> ，并将该数据包发送给 Server 。此时，Client 进入SYN_SENT 状态，等待 Server 确认。</p>
</li>
<li><p>第二次握手：Server 收到数据包后由标志位 <code>SYN=1</code> 知道Client请求建立连接，Server 将标志位 <code>SYN</code> 和 <code>ACK</code> 都置为 1 ，<code>ack=J+1</code>，随机产生一个值 <code>seq=K</code> ，并将该数据包发送给 Client 以确认连接请求，Server 进入 <code>SYN_RCVD</code> 状态。此时，Server 进入 SYC_RCVD 状态。</p>
</li>
<li><p>第三次握手：Client 收到确认后，检查 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ack<br></code></pre></td></tr></table></figure>

<p> 是否为 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">J+1<br></code></pre></td></tr></table></figure>

<p> ，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ACK<br></code></pre></td></tr></table></figure>

<p> 是否为 1 。</p>
<ul>
<li>如果正确，则将标志位 <code>ACK</code> 置为 1 ，<code>ack=K+1</code> ，并将该数据包发送给 Server 。此时，Client 进入 ESTABLISHED 状态。</li>
<li>Server 检查 <code>ack</code> 是否为 <code>K+1</code> ，<code>ACK</code> 是否为 1 ，如果正确则连接建立成功。此时 Server 进入 ESTABLISHED 状态，完成三次握手，随后 Client 与 Server 之间可以开始传输数据了。</li>
</ul>
</li>
<li><p>仔细看来，Client 会发起两次数据包，分别是 <code>SYNC</code> 和 <code>ACK</code> ；Server 会发起一次数据包，包含 <code>SYNC</code> 和 <code>ACK</code> 。也就是说，三次握手的过程中，Client 和 Server 互相做了一次 <code>SYNC</code> 和 <code>ACK</code> 。</p>
</li>
</ul>
<p>🦅 <strong>为什么 TCP 连接需要三次握手，两次不可以么，为什么？</strong></p>
<p>为了防止<strong>已失效的连接请求</strong>报文突然又传送到了服务端，因而产生错误。</p>
<blockquote>
<p>客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达 Server 。</p>
<ul>
<li>若不采用“三次握手”，那么只要 Server 发出确认数据包，新的连接就建立了。由于 Client  此时并未发出建立连接的请求，所以其不会理睬 Server 的确认，也不与 Server 通信；而这时 Server 一直在等待 Client  的请求，这样 Server 就白白浪费了一定的资源。</li>
<li>若采用“三次握手”，在这种情况下，由于 Server 端没有收到来自客户端的确认，则就会知道 Client 并没有要求建立请求，就不会建立连接。</li>
</ul>
</blockquote>
<p>在 <a href="https://github.com/jawil/blog/issues/14">《通俗大白话来理解 TCP 协议的三次握手和四次挥手》</a> 中，搜 <a href="http://svip.iocoder.cn/Net/Interview/#">“为什么要三次握手”</a> 关键字，也有非常好的解答。</p>
<ul>
<li><strong>这就很明白了，防止了服务器端的一直等待而浪费资源</strong>。</li>
</ul>
<p><strong>🦅 客户端不断进行请求链接会怎样？</strong></p>
<p>服务器端准备为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认后创建。如果此时客户端一直不确认，会造成 SYN 攻击，即：</p>
<blockquote>
<p>SYN 攻击，英文为 SYN Flood ，是一种典型的 DoS/DDoS 攻击。</p>
</blockquote>
<ul>
<li><p>1、客户端向服务端发送请求连接数据包。</p>
</li>
<li><p>2、服务端向客户端发送确认数据包。</p>
</li>
<li><p>3、客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认。</p>
<blockquote>
<p>这是这一步！！！</p>
</blockquote>
</li>
</ul>
<p>🚀 如何检测 SYN 攻击？检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。在 Linux/Unix 上可以使用系统自带的 netstat 命令来检测 SYN 攻击。</p>
<p>🚀 怎么解决 SYN 攻击呢？答案是<strong>只能预防</strong>，没有彻底根治的办法，除非不使用 TCP 。方式如下：</p>
<ul>
<li><p>1、限制同时打开 SYN 半链接的数目</p>
<blockquote>
<p>艿艿：是不是很像我们常用的“限流”。</p>
</blockquote>
</li>
<li><p>2、缩短 SYN 半链接的 Timeout 时间</p>
<blockquote>
<p>艿艿：是不是很像我们常用的“超时”。</p>
</blockquote>
</li>
<li><p>3、关闭不必要的服务。</p>
<blockquote>
<p>艿艿：酱紫，这个服务就不会被 SYN 攻击连接。</p>
</blockquote>
</li>
<li><p>4、增加最大半连接数。</p>
</li>
<li><p>5、过滤网关防护。</p>
</li>
<li><p>6、</p>
<p>SYN cookie</p>
<p> 技术。</p>
<blockquote>
<p>艿艿：有一点点重新“设计” TCP 的味道，或者可以理解成对 TCP 的增强。</p>
</blockquote>
</li>
</ul>
<h2 id="【重要】什么是-TCP-四次挥手？"><a href="#【重要】什么是-TCP-四次挥手？" class="headerlink" title="【重要】什么是 TCP 四次挥手？"></a>【重要】什么是 TCP 四次挥手？</h2><p>四次挥手，简单来说，就是：</p>
<ul>
<li>发送方：我要和你断开连接！</li>
<li>接收方：好的，断吧。</li>
<li>接收方：我也要和你断开连接！</li>
<li>发送方：好的，断吧。</li>
</ul>
<p>详细来说，步骤如下：</p>
<p><img src="http://cdn.tuwenbin.vip/q4pj31zz.bmp" alt="q4pj31zz"></p>
<p>TCP 四次挥手的干货</p>
<blockquote>
<p>如下使用 Client 和 Server 的方式，仅仅是为了方便，也是可以从 Server 向 Client 发起。</p>
</blockquote>
<ul>
<li>第一次挥手：Client 发送一个 <code>FIN=M</code> ，用来关闭 Client 到 Server 的数据传送。此时，Client 进入 FIN_WAIT_1 状态。</li>
<li>第二次挥手，Server 收到 <code>FIN</code> 后，发送一个 <code>ACK</code> 给 Client ，确认序号为 <code>M+1</code>（与 <code>SYN</code> 相同，一个 <code>FIN</code> 占用一个序号）。此时，Server 进入 CLOSE_WAIT 状态。注意，TCP 链接处于<strong>半关闭</strong>状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。</li>
<li>第三次挥手，Server 发送一个 <code>FIN=N</code> ，用来关闭 Server 到 Client 的数据传送。此时 Server 进入 LAST_ACK 状态。</li>
<li>第四次挥手，Client 收到 <code>FIN</code> 后，此时 Client 进入 TIME_WAIT 状态。接着，Client 发送一个 <code>ACK</code> 给 Server ，确认序号为 <code>N+1</code> 。Server 接收到后，此时 Server 进入 CLOSED 状态，完成四次挥手。</li>
</ul>
<p>🦅 <strong>为什么要四次挥手？</strong></p>
<p>TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。<strong>TCP 是全双工模式</strong>，这就意味着：</p>
<ul>
<li><p>当主机 1 发出 <code>FIN</code> 报文段时，只是表示主机 1 已经没有数据要发送了，主机 1 告诉主机 2 ，它的数据已经全部发送完毕了；<strong>但是，这个时候主机 1 还是可以接受来自主机 2 的数据；</strong>当主机 2 返回 <code>ACK</code> 报文段时，表示它已经知道主机 1 没有数据发送了，但是主机 2 还是可以发送数据到主机 1 的。</p>
<blockquote>
<p>艿艿：因为主机 2 此时可能还有数据想要发送给主机 1 ，所以挥手不能像握手只有三次，而是多了那么“一次”！</p>
</blockquote>
</li>
<li><p>当主机 2 也发送了 <code>FIN</code> 报文段时，这个时候就表示主机 2 也没有数据要发送了，就会告诉主机 1 ，我也没有数据要发送了，之后彼此就会愉快的中断这次 TCP 连接。</p>
<blockquote>
<p>艿艿：我们把四次挥手，理解成一次和平的挥手~</p>
</blockquote>
</li>
</ul>
<p>如果要正确的理解四次的原理，就需要了解四次挥手过程中的状态变化。</p>
<blockquote>
<p>主动方=发送方；被动方=接收方。</p>
<p>状态前面的（主动方）（被动方），表示该状态属于谁。</p>
</blockquote>
<ul>
<li><p>（主动方）FIN_WAIT_1 ：这个状态要好好解释一下，其实 FIN_WAIT_1 和 FIN_WAIT_2 状态的真正含义都是表示等待对方的 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">FIN<br></code></pre></td></tr></table></figure>

<p> 报文。而这两种状态的区别是：</p>
<ul>
<li>FIN_WAIT_1 状态实际上是当 Socket 在 ESTABLISHED 状态时，它想主动关闭连接，向对方发送了 <code>FIN</code> 报文，此时该 Socket 即进入到 FIN_WAIT_1 状态。</li>
<li>而当对方回应 <code>ACK</code> 报文后，则进入到 FIN_WAIT_2 状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应<code>ACK</code> 报文。所以， FIN_WAIT_1 状态一般是比较难见到的，而 FIN_WAIT_2 状态还有时常常可以用 netstat 看到。</li>
</ul>
</li>
<li><p>（主动方）FIN_WAIT_2 ：上面已经详细解释了这种状态，实际上 FIN_WAIT_2 状态下的 Socket，表示半连接，也即有一方要求 close 连接，但另外还告诉对方，我暂时还有点数据需要传送给你(<code>ACK</code> 信息)，稍后再关闭连接。</p>
</li>
<li><p>（被动方）CLOSE_WAIT ：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方 close 一个 Socket 后发送 <code>FIN</code> 报文给自己，你系统毫无疑问地会回应一个 <code>ACK</code> 报文给对方，此时则进入到 CLOSE_WAIT 状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close 这个 Socket ，发送 <code>FIN</code> 报文给对方，也即关闭连接。所以你在 CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。</p>
</li>
<li><p>（被动方）LAST_ACK ：这个状态还是比较容易好理解的，它是被动关闭一方在发送 <code>FIN</code> 报文后，最后等待对方的 <code>ACK</code> 报文。当收到 <code>ACK</code> 报文后，也即可以进入到 CLOSED 可用状态了。</p>
</li>
<li><p>（主动方）TIME_WAIT ：表示收到了对方的 <code>FIN</code> 报文，并发送出了 <code>ACK</code> 报文，就等 <a href="https://blog.csdn.net/xiaofei0859/article/details/6044694">2MSL</a> 后即可回到 CLOSED 可用状态了。如果 FIN_WAIT_1 状态下，收到了对方同时带 <code>FIN</code> 标志和 <code>ACK</code> 标志的报文时，可以直接进入到 TIME_WAIT 状态，而无须经过 FIN_WAIT_2 状态。</p>
<blockquote>
<p><strong>为何一定要等 2MSL ？</strong></p>
<p>如果不等，释放的端口可能会重连刚断开的服务器端口，这样依然存活在网络里的老的 TCP 报文可能与新 TCP 连接报文冲突，造成数据冲突，为避免此种情况，需要耐心等待网络老的 TCP 连接的活跃报文全部死翘翘，2MSL 时间可以满足这个需求（尽管非常保守）！</p>
<p>更多，可以看看知乎 <a href="https://www.zhihu.com/question/67013338">《为什么 TCP 4 次挥手时等待为 2MSL？》</a> 的讨论。</p>
</blockquote>
</li>
<li><p>CLOSED ：表示连接中断。</p>
</li>
</ul>
<p>另外，关于 TIME_WAIT 和 CLOSE_WAIT 状态的区别，胖友可以在细看下 <a href="https://blog.csdn.net/kobejayandy/article/details/17655739">《TIME_WAIT 和 CLOSE_WAIT 状态区别》</a> 。</p>
<h2 id="【重要】TCP-数据如何传输？"><a href="#【重要】TCP-数据如何传输？" class="headerlink" title="【重要】TCP 数据如何传输？"></a>【重要】TCP 数据如何传输？</h2><p>建立连接后，两台主机就可以相互传输数据了。如下图所示：![2n6prj62](D:\新建文件夹 (3)\2n6prj62.bmp)TCP 套接字的数据交换过程</p>
<ul>
<li><p>上图给出了主机 A 分 2 次（分 2 个数据包）向主机 B 传递 200 字节的过程。</p>
</li>
<li><p>首先，主机 A 通过 1 个数据包发送 100 个字节的数据，数据包的 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Seq<br></code></pre></td></tr></table></figure>

<p> 号设置为 1200 。主机 B 为了确认这一点，向主机 A 发送 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ACK<br></code></pre></td></tr></table></figure>

<p> 包，并将 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Ack<br></code></pre></td></tr></table></figure>

<p> 号设置为 1301 。</p>
<ul>
<li><p>为了保证数据准确到达，目标机器在收到数据包（包括 <code>SYN</code> 包、<code>FIN</code> 包、普通数据包等）包后必须立即回传 <code>ACK</code> 包，这样发送方才能确认数据传输成功。</p>
</li>
<li><p>此时 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Ack<br></code></pre></td></tr></table></figure>

<p> 号为 1301 而不是 1201，原因在于 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Ack<br></code></pre></td></tr></table></figure>

<p> 号的增量为传输的数据字节数。假设每次 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Ack<br></code></pre></td></tr></table></figure>

<p> 号不加传输的字节数，这样虽然可以确认数据包的传输，但无法明确 100 字节全部正确传递还是丢失了一部分，比如只传递了 80 字节。因此按如下的公式确认 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Ack<br></code></pre></td></tr></table></figure>

<p> 号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Ack<br></code></pre></td></tr></table></figure>

<p> 号 = </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Seq<br></code></pre></td></tr></table></figure>

<p> 号 + 传递的字节数 + 1 。</p>
<ul>
<li>与三次握手协议相同，最后加 1 是为了告诉对方要传递的 <code>Seq</code> 号。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>OK，让我们重新来看下 TCP 的整个过程。如下图所示：<a href="https://camo.githubusercontent.com/36cf7d4e1598683fe72a5e1c3e837b16840f4085/687474703a2f2f6f6f327239726e7a702e626b742e636c6f7564646e2e636f6d2f6a656c6c797468696e6b544350342e6a7067">TCP 过程</a></p>
<p>🦅 <strong>TCP 数据传输丢失怎么办？</strong></p>
<blockquote>
<p>艿艿：这个问题，也可以改成提问，什么是 TCP 重传。</p>
</blockquote>
<p>因为各种原因，TCP 数据包可能存在丢失的情况，TCP 会进行数据重传。如下图所示：</p>
<p><img src="http://cdn.tuwenbin.vip/ig9iz01q.bmp" alt="ig9iz01q">TCP套接字数据传输过程中发生错误</p>
<ul>
<li><p>上图表示通过 <code>Seq</code> 1301 数据包向主机 B 传递 100 字节的数据，但中间发生了错误，主机 B 未收到。经过一段时间后，主机 A 仍未收到对于 <code>Seq</code> 1301 的 <code>ACK</code> 确认，因此尝试重传数据。为了完成数据包的重传，TCP 套接字每次发送数据包时都会<strong>启动定时器</strong>，如果在一定时间内没有收到目标机器传回的 <code>ACK</code> 包，那么定时器超时，数据包会重传。上图演示的是数据包丢失的情况，也会有 <code>ACK</code> 包丢失的情况，一样会重传。</p>
</li>
<li><p>重传超时时间(RTO，Retransmission Time Out)</p>
<blockquote>
<p>这个值太大了会导致不必要的等待，太小会导致不必要的重传，理论上最好是网络 RTT 时间，但又受制于网络距离与瞬态时延变化，所以实际上使用自适应的动态算法（例如 Jacobson 算法和 Karn 算法等）来确定超时时间。</p>
<p>往返时间（RTT，Round-Trip Time）表示从发送端发送数据开始，到发送端收到来自接收端的 <code>ACK</code> 确认包（接收端收到数据后便立即确认），总共经历的时延。</p>
</blockquote>
</li>
<li><p>重传次数</p>
<blockquote>
<p>TCP 数据包重传次数，根据系统设置的不同而有所区别。有些系统，一个数据包只会被重传 3 次，如果重传 3 次后还未收到该数据包的 <code>ACK</code> 确认，就不再尝试重传。但有些要求很高的业务系统，会不断地重传丢失的数据包，以尽最大可能保证业务数据的正常交互。</p>
<p>最后需要说明的是，发送端只有在收到对方的 <code>ACK</code> 确认包后，才会清空输出缓冲区中的数据。</p>
</blockquote>
</li>
</ul>
<p><strong>ps：TCP 数据传输的过程，和 MQ Broker 投递消息给 Consumer 是一样的，只有在 Consumer Ack 确认消息已经消费，该消息才不会再被投递给 Consumer 。</strong></p>
<p>另外，也推荐阅读 <a href="https://wizardforcel.gitbooks.io/network-basic/content/8.html">《网络基本功（九）：细说TCP重传》</a> 。</p>
<h2 id="【重要】什么是-TCP-滑动窗口？"><a href="#【重要】什么是-TCP-滑动窗口？" class="headerlink" title="【重要】什么是 TCP 滑动窗口？"></a>【重要】什么是 TCP 滑动窗口？</h2><p>在看 TCP 滑动窗口的概念之前，我们先来看看它出现的<strong>背景</strong>？</p>
<blockquote>
<p>将 TCP 与 UDP 这样的简单传输协议区分开来的是，它传输数据的质量。TCP 对于发送数据进行跟踪，这种数据管理需要协议有以下两大关键功能：</p>
<ul>
<li>可靠性：保证数据确实到达目的地。如果未到达，能够发现并重传。</li>
<li>数据流控：管理数据的发送速率，以使接收设备不致于过载。</li>
</ul>
<p>要完成这些任务，整个协议操作是围绕<strong>滑动窗口</strong> + <strong>确认机制</strong>来进行的。因此，理解了滑动窗口，也就是理解了 TCP 。</p>
</blockquote>
<p>那么，到底什么是 TCP 滑动窗口呢？</p>
<blockquote>
<p>滑动窗口协议，是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。</p>
<p>TCP 的滑动窗口解决了端到端的流量控制问题，允许接受方对传输进行限制，直到它拥有足够的缓冲空间来容纳更多的数据。</p>
</blockquote>
<p>可能这么描述之后，胖友会有点懵逼，那么建议看下面三篇文章，耐心~</p>
<ul>
<li><p><a href="https://www.cnblogs.com/luoquan/p/4886345.html">《TCP 滑动窗口控制流量的原理》</a></p>
<blockquote>
<p>比较易懂的一篇文章。</p>
</blockquote>
</li>
<li><p><a href="https://wizardforcel.gitbooks.io/network-basic/content/7.html">《网络基本功（八）：细说 TCP 滑动窗口》</a></p>
<blockquote>
<p>更为详细的一篇文章。</p>
</blockquote>
</li>
<li><p><a href="https://www.zhihu.com/question/32255109">《TCP 协议的滑动窗口具体是怎样控制流量的？》</a></p>
<blockquote>
<p>知乎上的讨论，重点看「wuxinliulei」和「安静的木小昊」的回答。特别是后者的，回答很生动形象。</p>
</blockquote>
</li>
</ul>
<h2 id="TCP-协议如何来保证传输的可靠性？"><a href="#TCP-协议如何来保证传输的可靠性？" class="headerlink" title="TCP 协议如何来保证传输的可靠性？"></a>TCP 协议如何来保证传输的可靠性？</h2><p>TCP 提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用 TCP 的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个 TCP 连接。</p>
<ul>
<li>在一个 TCP 连接中，仅有两方进行彼此通信。</li>
<li>而字节流服务意味着两个应用程序通过 TCP 链接交换 8bit 字节构成的字节流，TCP 不在字节流中插入记录标识符。</li>
</ul>
<p>对于可靠性，TCP 通过以下方式进行保证：</p>
<ul>
<li>数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据。</li>
<li>对失序数据包重排序：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TC P报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层。</li>
<li>丢弃重复数据：对于重复数据，能够丢弃重复数据。</li>
<li>应答机制：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。</li>
<li>超时重发：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
<li>流量控制：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP 使用的流量控制协议是可变大小的<strong>滑动窗口协议</strong>。</li>
</ul>
<h2 id="什么是-TCP-拥堵？"><a href="#什么是-TCP-拥堵？" class="headerlink" title="什么是 TCP 拥堵？"></a>什么是 TCP 拥堵？</h2><p>计算机网络中的带宽、交换结点中的缓存及处理机等都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做<strong>拥塞</strong>。</p>
<p>🦅 <strong>怎么解决 TCP 拥堵？</strong></p>
<p>通过拥塞控制来解决。拥堵控制，就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。注意，拥塞控制和流量控制不同，前者是一个<strong>全局性</strong>的过程，而后者指<strong>点对点</strong>通信量的控制。</p>
<p>拥塞控制的方法主要有以下四种：</p>
<ul>
<li>1、慢开始。</li>
<li>2、拥塞避免。</li>
<li>3、快重传。</li>
<li>4、快恢复。</li>
</ul>
<p><strong>1）慢开始</strong></p>
<p>不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。</p>
<p><strong>2）拥塞避免</strong></p>
<p>拥塞避免算法，让拥塞窗口缓慢增长，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1 ，而不是加倍，这样拥塞窗口按线性规律缓慢增长。</p>
<p><img src="http://cdn.tuwenbin.vip/8opvlv8d.bmp" alt="8opvlv8d">慢开始和拥塞避免算法的实现举例</p>
<p><strong>3）快重传</strong></p>
<p>快重传，要求接收方在收到一个<strong>失序的报文段</strong>后就立即发出<strong>重复确认</strong>（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时捎带确认。</p>
<p>快重传算法规定，发送方只要一连收到三个重复确认，就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>
<p><img src="http://cdn.tuwenbin.vip/txe7yfox.bmp" alt="txe7yfox">快重传的示意图</p>
<p><strong>4）快恢复</strong></p>
<p>快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把 ssthresh 门限减半。</p>
<ul>
<li>但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。</li>
<li>所以此时不执行慢开始算法，而是将 cwnd 设置为 ssthresh 的大小，然后执行拥塞避免算法。</li>
</ul>
<p><img src="http://cdn.tuwenbin.vip/lxqlfqfm.bmp" alt="lxqlfqfm">从连续收到三个重复的确认转入拥堵避免</p>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><h2 id="UDP-是什么？"><a href="#UDP-是什么？" class="headerlink" title="UDP 是什么？"></a>UDP 是什么？</h2><p>UDP（User Data Protocol，用户数据报协议），是与 TCP 相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去。</p>
<p>主要特点如下：</p>
<ul>
<li><p>UDP 是无连接的。</p>
</li>
<li><p>UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）。</p>
</li>
<li><p>UDP 是面向报文的。</p>
</li>
<li><p>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。</p>
<blockquote>
<p>对实时应用很有用，如 直播，实时视频会议等</p>
</blockquote>
</li>
<li><p>UDP 支持一对一、一对多、多对一和多对多的交互通信。</p>
</li>
<li><p>UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。</p>
</li>
</ul>
<h2 id="UDP-对应的应用层协议？"><a href="#UDP-对应的应用层协议？" class="headerlink" title="UDP 对应的应用层协议？"></a>UDP 对应的应用层协议？</h2><ul>
<li>DNS ：用于域名解析服务，将域名地址转换为 IP 地址。DNS 用的是 53 号端口。</li>
<li>SNMP ：简单网络管理协议，使用 161 号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</li>
<li>TFTP(Trivial File Transfer Protocol)：简单文件传输协议，该协议在熟知端口 69 上使用 UDP 服务。</li>
</ul>
<h2 id="【重要】TCP-与-UDP-的区别"><a href="#【重要】TCP-与-UDP-的区别" class="headerlink" title="【重要】TCP 与 UDP 的区别"></a>【重要】TCP 与 UDP 的区别</h2><blockquote>
<p>这个问题，上面在介绍 TCP 和 UDP 都提到了，就是做了整合哈。</p>
</blockquote>
<p>TCP(Transmission Control Protocol)和 UDP(User Datagram Protocol) 协议属于传输层协议，它们之间的区别包括：</p>
<p><img src="http://cdn.tuwenbin.vip/fv7et7b4.bmp" alt="fv7et7b4"></p>
<p>TCP 与 UDP 的区别</p>
<ul>
<li>TCP 是面向连接的；UDP 是无连接的。</li>
<li>TCP 是可靠的；UDP 是不可靠的。</li>
<li>TCP 只支持点对点通信；UDP 支持一对一、一对多、多对一、多对多的通信模式。</li>
<li>TCP 是面向字节流的；UDP 是面向报文的。</li>
<li>TCP 有拥塞控制机制；UDP 没有拥塞控制，适合媒体通信。</li>
<li>TCP 首部开销(20 个字节)，比 UDP 的首部开销(8 个字节)要大。</li>
</ul>
<p>🦅 <strong>为什么 TCP 叫数据流模式？ UDP 叫数据报模式？</strong></p>
<p>所谓的<strong>“流模式”</strong>，是指<strong>TCP 发送端发送几次数据和接收端接收几次数据是没有必然联系的</strong>。</p>
<ul>
<li>比如你通过 TCP 连接给另一端发送数据，你只调用了一次 write ，发送了 100 个字节，但是对方可以分 10 次收完，每次 10 个字节；你也可以调用 10 次 write ，每次 10 个字节，但是对方可以一次就收完。</li>
<li>原因：这是因为 TCP 是面向连接的，一个 Socket 中收到的数据都是由同一台主机发出，且有序地到达，所以每次读取多少数据都可以。</li>
</ul>
<p>所谓的<strong>“数据报模式”</strong>，是指 <strong>UDP 发送端调用了几次 write ，接收端必须用相同次数的 read 读完</strong>。</p>
<ul>
<li>UDP 是基于报文的，在接收的时候，每次最多只能读取一个报文，报文和报文是不会合并的，如果缓冲区小于报文长度，则多出的部分会被丢弃。</li>
<li>原因：这是因为 UDP 是无连接的，只要知道接收端的 IP 和端口，任何主机都可以向接收端发送数据。这时候，如果一次能读取超过一个报文的数据，则会乱套。</li>
</ul>
<h2 id="UDP-报文的格式"><a href="#UDP-报文的格式" class="headerlink" title="UDP 报文的格式"></a>UDP 报文的格式</h2><p>UDP 报文格式</p>
<p><img src="http://cdn.tuwenbin.vip/6yf91kke.bmp" alt="6yf91kke"></p>
<ul>
<li>16 位 * 4 = 64 位 = 8 字节。</li>
</ul>
<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h2 id="DNS-是什么？"><a href="#DNS-是什么？" class="headerlink" title="DNS 是什么？"></a>DNS 是什么？</h2><ul>
<li>域名解析，<a href="http://www.xxx.com/">www.xxx.com</a> 转换成 IP ，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。</li>
<li>DNS 协议运行在 UDP 协议之上，使用端口号 53 。</li>
</ul>
<h2 id="主机解析域名的顺序？"><a href="#主机解析域名的顺序？" class="headerlink" title="主机解析域名的顺序？"></a>主机解析域名的顺序？</h2><ol>
<li>浏览器缓存</li>
<li>找本机的 hosts 文件</li>
<li>路由缓存</li>
<li>找 DNS 服务器(本地域名、顶级域名、根域名)<ul>
<li><a href="https://blog.csdn.net/wuchuanpingstone/article/details/6720723">迭代查询</a></li>
<li><a href="https://blog.csdn.net/wuchuanpingstone/article/details/6720723">递归查询</a></li>
</ul>
</li>
</ol>
<h2 id="DNS-使用什么协议？"><a href="#DNS-使用什么协议？" class="headerlink" title="DNS 使用什么协议？"></a>DNS 使用什么协议？</h2><blockquote>
<p>参见 <a href="https://benbenxiongyuan.iteye.com/blog/1088085">《DNS使用的是 TCP 协议还是 UDP 协议》</a> 文章。</p>
</blockquote>
<p>既使用 TCP 又使用 UDP 。</p>
<ul>
<li><p>区域传送时使用 TCP 协议。</p>
<blockquote>
<ul>
<li>辅域名服务器会定时（一般时 3 小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用 TCP 而不是 UDP ，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。</li>
<li>TCP 是一种可靠的连接，保证了数据的准确性。</li>
</ul>
</blockquote>
</li>
<li><p>域名解析时使用 UDP 协议。</p>
<blockquote>
<ul>
<li><p>客户端向 DNS 服务器查询域名，一般返回的内容都不超过 512 字节，用 UDP 传输即可。</p>
<blockquote>
<p>UDP 报文的最大长度为 512 字节。</p>
</blockquote>
</li>
<li><p>不用经过 TCP 三次握手，这样 DNS 服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向 DNS 服务器查询的时候使用 TCP ，但事实上，很多 DNS 服务器进行配置的时候，仅支持 UDP 查询包。</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="HTTP-是什么？"><a href="#HTTP-是什么？" class="headerlink" title="HTTP 是什么？"></a>HTTP 是什么？</h2><p>HTTP 协议，是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p>
<p>主要特点如下：</p>
<ul>
<li><p>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST 等等。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。</p>
</li>
<li><p>数据格式灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由Content-Type 加以标记。</p>
</li>
<li><p>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>
<blockquote>
<p>主要指的是不使用 Keep-Alive 机制的情况下。</p>
</blockquote>
</li>
<li><p>无状态：HTTP 协议是无状态协议。无状态，是指协议对于事务处理没有记忆能力。无状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
<blockquote>
<p>无状态，所以更容易做服务的扩容，支撑更大的访问量。</p>
</blockquote>
</li>
<li><p>支持 B/S 及 C/S 模式。</p>
<blockquote>
<p>另外，HTTP 协议已经不仅仅使用在浏览器上。在前后端分离的架构中，又或者微服务架构的内部通信中，HTTP 因为其数据格式的通用性，和语言无关，被大规模使用。</p>
</blockquote>
</li>
</ul>
<h2 id="HTTP-基本格式"><a href="#HTTP-基本格式" class="headerlink" title="HTTP 基本格式"></a>HTTP 基本格式</h2><blockquote>
<p>艿艿：详细的，可以看看 <a href="https://github.com/kaiye/kaiye.github.com/issues/3">《猫哥网络编程系列：详解 BAT 面试题》</a> 文章。</p>
</blockquote>
<p>🦅 <strong>HTTP 请求格式</strong></p>
<p><img src="http://cdn.tuwenbin.vip/60wx40i3.bmp" alt="60wx40i3">HTTP 请求格式</p>
<ul>
<li>请求行：用来说明请求类型，要访问的资源以及所使用的 HTTP 版本。</li>
<li>请求头部：紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息从第二行起为请求头部。<ul>
<li>HOST ，将指出请求的目的地。</li>
<li>User-Agent ，服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础。该信息由你的浏览器来定义，并且在每个请求中自动发送等等</li>
<li>…</li>
</ul>
</li>
<li>空行：请求头部后面的空行是必须的。</li>
<li>请求数据：也叫主体，可以添加任意的其他数据。</li>
</ul>
<p>🦅 <strong>HTTP 响应格式</strong></p>
<p><img src="http://cdn.tuwenbin.vip/wbgf4n3x.bmp" alt="wbgf4n3x">HTTP 响应格式</p>
<ul>
<li>状态行：由 HTTP 协议版本号、状态码、状态消息三部分组成。</li>
<li>消息报头：用来说明客户端要使用的一些附加信息。</li>
<li>空行：消息报头后面的空行是必须的。</li>
<li>响应正文：服务器返回给客户端的文本信息。</li>
</ul>
<p>🦅 <strong>URI 和 URL 的区别？</strong></p>
<p>见 <a href="https://www.jianshu.com/p/ba15d066f777">《URI 和 URL 的区别》</a> 文章。</p>
<h2 id="HTTP-协议包括哪些请求？"><a href="#HTTP-协议包括哪些请求？" class="headerlink" title="HTTP 协议包括哪些请求？"></a>HTTP 协议包括哪些请求？</h2><ul>
<li>GET: 对服务器资源的简单请求。</li>
<li>POST: 用于发送包含用户提交数据的请求。</li>
<li>HEAD：类似于 GET 请求，不过返回的响应中没有具体内容，用于获取报头。</li>
<li>PUT：传说中请求文档的一个版本。</li>
<li>DELETE：发出一个删除指定文档的请求。</li>
<li>TRACE：发送一个请求副本，以跟踪其处理进程。</li>
<li>OPTIONS：返回所有可用的方法，检查服务器支持哪些方法。</li>
<li>CONNECT：用于 SSL 隧道的基于代理的请求。</li>
</ul>
<p>🦅 <strong>GET 和 POST 的区别？</strong></p>
<table>
<thead>
<tr>
<th>请求方式</th>
<th>数据位置</th>
<th>明文密文</th>
<th>数据安全</th>
<th>长度限制</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>HTTP 请求的 path 中</td>
<td>明文</td>
<td>不安全</td>
<td>长度较小，一般 2k</td>
<td>查询数据</td>
</tr>
<tr>
<td>POST</td>
<td>HTTP 请求 body 中</td>
<td>可明可密</td>
<td>安全</td>
<td>支持较大数据传输</td>
<td>修改数据</td>
</tr>
</tbody></table>
<ul>
<li><p>GET 请求可被缓存；POST 请求不会被缓存。</p>
</li>
<li><p>GET 请求可被收藏为书签；POST 不能被收藏为书签。</p>
</li>
<li><p>【非常有趣】参见 <a href="https://www.oschina.net/news/77354/http-get-post-different">《99%的人理解错 HTTP 中 GET 与 POST 的区别》</a></p>
<blockquote>
<ul>
<li>对于 GET 方式的请求，浏览器会把 HTTP header 和 data 一并发送出去，服务器响应 200（返回数据）。</li>
<li>而对于 POST，浏览器先发送 header ，服务器响应 100 continue ，浏览器再发送 data ，服务器响应 200 ok（返回数据）。</li>
</ul>
<p>也就是说，GET 只需要汽车跑一趟就把货送到了，而 POS T得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。</p>
<p>ps：不过要注意，POST 具体发几次，也和浏览器的实现有关系。例如：Firefox 只发一次。<br>ps2：据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的 TCP 在验证数据包完整性上，有非常大的优点。</p>
</blockquote>
</li>
</ul>
<h2 id="HTTP-有哪些状态码？"><a href="#HTTP-有哪些状态码？" class="headerlink" title="HTTP 有哪些状态码？"></a>HTTP 有哪些状态码？</h2><ul>
<li>1×× : 请求处理中，请求已被接受，正在处理</li>
<li>2×× : 请求成功，请求被成功处理<ul>
<li>200 OK // 客户端请求成功</li>
</ul>
</li>
<li>3×× : 重定向，要完成请求必须进行进一步处理<ul>
<li>301 Moved Permanently // 永久重定向,使用域名跳转</li>
<li>302 Found // 临时重定向,未登陆的用户访问用户中心重定向到登录页面</li>
</ul>
</li>
<li>4×× : 客户端错误，请求不合法<ul>
<li>400 Bad Request // 客户端请求有语法错误，不能被服务器所理解</li>
<li>401 Unauthorized // 请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用</li>
<li>403 Forbidden // 服务器收到请求，但是拒绝提供服务</li>
<li>404 Not Found // 请求资源不存在，eg：输入了错误的 URL</li>
</ul>
</li>
<li>5×× : 服务器端错误，服务器不能处理合法请求<ul>
<li>500 Internal Server Error // 服务器发生不可预期的错误</li>
<li>503 Server Unavailable // 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li>
</ul>
</li>
</ul>
<p>完整的状态码列表，可以看看 <a href="https://zh.wikipedia.org/zh-hans/HTTP%E7%8A%B6%E6%80%81%E7%A0%81">《HTTP 状态码》</a> 文章。</p>
<p>🦅 <strong>forward 和 redirect 的区别？</strong></p>
<ul>
<li>直接转发方式（Forward），客户端和浏览器只发出一次请求，Servlet、HTML、JSP 或其它信息资源，由第二个信息资源响应该请求，在请求对象 request 中，保存的对象对于每个信息资源是共享的。</li>
<li>间接转发方式（Redirect），实际是两次 HTTP 请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个 URL 发出请求，从而达到转发的目的。</li>
</ul>
<p>详细的，请看 <a href="https://www.cnblogs.com/Qian123/p/5345527.html">《请求转发（Forward）和重定向（Redirect）的区别》</a> 。</p>
<p>🦅 <strong>HTTP 返回码中 301 与 302 的区别？</strong></p>
<p>301，302 都是 HTTP 状态的编码，都代表着某个 URL 发生了转移，不同之处在于：</p>
<ul>
<li>301 redirect: 301 代表永久性转移(Permanently Moved)。</li>
<li>302 redirect: 302 代表暂时性转移(Temporarily Moved)。</li>
</ul>
<p>详细的，请看 <a href="https://blog.csdn.net/qmhball/article/details/7838989">《HTTP 返回码中 301 与 302 的区别》</a> 文章。</p>
<h2 id="HTTP、TCP、Socket-的关系是什么？"><a href="#HTTP、TCP、Socket-的关系是什么？" class="headerlink" title="HTTP、TCP、Socket 的关系是什么？"></a>HTTP、TCP、Socket 的关系是什么？</h2><ul>
<li>TCP/IP 代表传输控制协议/网际协议，指的是一系列协议族。</li>
<li>HTTP 本身就是一个协议，是从 Web 服务器传输超文本到本地浏览器的传送协议。</li>
<li>Socket 是 TCP/IP 网络的 API ，其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面。对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。</li>
</ul>
<p>综上所述：</p>
<ul>
<li>需要 IP 协议来连接网络</li>
<li>TCP 是一种允许我们安全传输数据的机制，使用 TCP 协议来传输数据的 HTTP 是 Web 服务器和客户端使用的特殊协议。</li>
<li>HTTP 基于 TCP 协议，所以可以使用 Socket 去建立一个 TCP 连接。</li>
</ul>
<h2 id="Cookies-和-Session-的区别"><a href="#Cookies-和-Session-的区别" class="headerlink" title="Cookies 和 Session 的区别"></a>Cookies 和 Session 的区别</h2><ul>
<li><p>Session 在服务器端，Cookie 在客户端（浏览器）。</p>
<blockquote>
<p>Session 默认被存在在服务器的一个文件里（不是内存）。</p>
</blockquote>
</li>
<li><p>Session 的运行依赖 sessionid ，而 sessionid 是存在 Cookie 中的，也就是说，如果浏览器禁用了 Cookie ，同时 session 也会失效。但是，可以通过其它方式实现，比如在 url 参数中传递 sessionid 。</p>
</li>
<li><p>Session 可以放在文件、数据库、或内存中都可以。</p>
</li>
<li><p>【关键】<strong>用户验证这种场合一般会用 Session</strong> 。</p>
</li>
</ul>
<h2 id="【重要】一次完整的-HTTP-请求所经历的步骤"><a href="#【重要】一次完整的-HTTP-请求所经历的步骤" class="headerlink" title="【重要】一次完整的 HTTP 请求所经历的步骤"></a>【重要】一次完整的 HTTP 请求所经历的步骤</h2><blockquote>
<p>这里的客户端，更多指的是浏览器。</p>
</blockquote>
<ul>
<li><p>1、DNS 解析(通过访问的域名找出其 IP 地址，递归搜索)。</p>
</li>
<li><p>2、HTTP 请求，当输入一个请求时，建立一个 Socket 连接发起 TCP的 3 次握手。</p>
<blockquote>
<p>如果是 HTTPS 请求，会略微有不同。等到 HTTPS 小节，我们在来讲。</p>
</blockquote>
</li>
<li><p>3.1、客户端向服务器发送请求命令（一般是 GET 或 POST 请求）。</p>
<blockquote>
<p>这个是补充内容，面试一般不用回答。</p>
<p>客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。</p>
<p>客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定 IP 地址的 MAC 地址，然后发送 ARP 请求查找目的地址，如果得到回应后就可以使用 ARP 的请求应答交换的 IP 数据包现在就可以传输了，然后发送 IP 数据包到达服务器的地址。</p>
</blockquote>
</li>
<li><p>3.2、客户端发送请求头信息和数据。</p>
</li>
<li><p>4.1、服务器发送应答头信息。</p>
</li>
<li><p>4.2、服务器向客户端发送数据。</p>
</li>
<li><p>5、服务器关闭 TCP 连接（4次挥手）。</p>
<blockquote>
<p>这里是否关闭 TCP 连接，也根据 HTTP Keep-Alive 机制有关。</p>
<p>同时，客户端也可以主动发起关闭 TCP 连接。</p>
</blockquote>
</li>
<li><p>6、客户端根据返回的 HTML、CSS、JS 进行渲染。</p>
</li>
</ul>
<p>如下是《图解HTTP》提供的图片：<img src="http://cdn.tuwenbin.vip/5cupel3h.bmp" alt="5cupel3h">HTTP 请求所经历的步骤</p>
<h2 id="HTTP1-0-和-HTTP1-1-有什么区别？"><a href="#HTTP1-0-和-HTTP1-1-有什么区别？" class="headerlink" title="HTTP1.0 和 HTTP1.1 有什么区别？"></a>HTTP1.0 和 HTTP1.1 有什么区别？</h2><p>主要是如下 8 点：</p>
<ul>
<li><p>1、可扩展性</p>
</li>
<li><p>2、缓存</p>
</li>
<li><p>3、带宽优化</p>
<blockquote>
<p>带来了<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81">分块传输</a> 。可能的话，面试也会问。</p>
</blockquote>
</li>
<li><p>【最重要】4、长连接</p>
</li>
<li><p>5、消息传递</p>
</li>
<li><p>6、Host 头域</p>
</li>
<li><p>7、错误提示</p>
</li>
<li><p>8、内容协商</p>
</li>
</ul>
<p>详细的每一点的说明，可以看 <a href="https://blog.csdn.net/ForgotAboutGirl/article/details/6936982">《HTTP1.0 与 HTTP1.1 的区别》</a> 文章，特别是第 4 点【长连接】。</p>
<blockquote>
<p>HTTP1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）。</p>
<ul>
<li>长连接（PersistentConnection）：处理在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。在 HTTP1.1中 默认开启<code>Connection：keep-alive</code> ，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。</li>
<li>请求的流水线（Pipelining）：HTTP1.1  还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。</li>
</ul>
<p>推荐，在看看 <a href="http://www.nowamagic.net/academy/detail/23350305">《HTTP Keep-Alive 是什么？如何工作？》</a> 文章。</p>
<p>关于这一点，可能演变的问题有：</p>
<ul>
<li>HTTP 的长连接是什么意思？</li>
<li>HTTP Keep-Alive 机制是什么？</li>
<li>HTTP Keep-Alive 机制和 TCP Keep-Alive 有什么区别？</li>
</ul>
</blockquote>
<h2 id="SPDY-是什么？"><a href="#SPDY-是什么？" class="headerlink" title="SPDY 是什么？"></a>SPDY 是什么？</h2><blockquote>
<p>艿艿：关于这个问题，了解就好。</p>
<p>HTTP Working-Group 最终决定以 SPDY/2 为基础，开发 HTTP/2 。</p>
</blockquote>
<p>2012 年，Google 如一声惊雷提出了 SPDY 的方案，优化了 HTTP1.X 的请求延迟，解决了 HTTP1.X 的安全性，具体如下：</p>
<ul>
<li><p>1、降低延迟</p>
<blockquote>
<p>针对 HTTP 高延迟的问题，SPDY 优雅的采取了多路复用（multiplexing）。多路复用通过多个请求 Stream 共享一个 Tcp连 接的方式，解决了 HOL blocking 的问题，降低了延迟同时提高了带宽的利用率。</p>
</blockquote>
</li>
<li><p>2、请求优先级（request prioritization）</p>
<blockquote>
<p>多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY 允许给每个 request 设置优先级，这样重要的请求就会优先得到响应。</p>
<p>比如浏览器加载首页，首页的 html 内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</p>
</blockquote>
</li>
<li><p>3、header 压缩</p>
<blockquote>
<p>前面提到 HTTP1.x 的 header 很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</p>
</blockquote>
</li>
<li><p>4、基于 HTTPS 的加密协议传输</p>
<blockquote>
<p>大大提高了传输数据的安全性。</p>
</blockquote>
</li>
<li><p>5、服务端推送（server push）</p>
<blockquote>
<p>采用了 SPDY 的网页，例如我的网页有一个 <code>sytle.css</code> 的请求，在客户端收到 <code>sytle.css</code> 数据的同时，服务端会将 <code>sytle.js</code> 的文件推送给客户端。当客户端再次尝试获取 <code>sytle.js</code> 时就可以直接从缓存中获取到，不用再发请求了。</p>
<p>🙂 和我们理解的服务端推送，有点（非常）不一样哈。</p>
</blockquote>
</li>
</ul>
<p>🚀 SPDY 构成图如下：<img src="http://cdn.tuwenbin.vip/wknsy7np.bmp" alt="wknsy7np">SPDY 构成图</p>
<ul>
<li>SPDY 位于 HTTP 之下，TCP 和 SSL 之上，这样可以轻松兼容老版本的 HTTP 协议(将 HTTP1.x 的内容封装成一种新的 frame 格式)，同时可以使用已有的 SSL 功能。</li>
</ul>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>推荐先看下 <a href="http://juejin.im/post/58c5268a61ff4b005d99652a">《九个问题从入门到熟悉 HTTPS》</a> 文章，写的很有趣~</p>
<p>另外，也看看 <a href="https://blog.csdn.net/ustccw/article/details/76691248">《SSL/TLS 双向认证(一) – SSL/TLS工作原理》</a> 文章，写的更技术向~</p>
<p>下面的面试题的答案，我们会基于上述文章来整理。</p>
<h2 id="HTTPS-是什么？"><a href="#HTTPS-是什么？" class="headerlink" title="HTTPS 是什么？"></a>HTTPS 是什么？</h2><p>HTTPS ，实际就是在 TCP 层与 HTTP 层之间加入了 SSL/TLS 来为上层的安全保驾护航，主要用到对称加密、非对称加密、证书，等技术进行客户端与服务器的数据加密传输，最终达到保证整个通信的安全性。</p>
<p><img src="http://cdn.tuwenbin.vip/49rb21xy.bmp" alt="49rb21xy"></p>
<p>一句话概括：<strong>HTTP + 加密 + 认证 + 完整性保护 = HTTPS</strong> 。</p>
<p>🦅 <strong>什么是 SSL 呢？什么是 TLS 呢？</strong></p>
<p>官方定义，SSL 是安全套接层(secure sockets layer)；TLS 是 SSL 的继任者，叫传输层安全(transport layer security)。</p>
<p>它们存在的唯一目的就是保证上层通讯安全的一套机制。它的发展依次经历了下面几个时期，像手机软件升级一样，每次更新都添加或去除功能，比如引进新的加密算法，修改握手方式等。</p>
<ul>
<li>SSL1.0: 已废除</li>
<li>SSL2.0: RFC6176 ，已废除</li>
<li>SSL3.0: RFC6101 ，基本废除</li>
<li><strong>TLS1.0</strong>: RFC2246 ，目前大都采用此种方式</li>
<li>TLS1.1: RFC4346</li>
<li>TLS1.2: RFC5246 ，没有广泛使用</li>
<li>TLS1.3: IETF 正在酝酿中</li>
</ul>
<blockquote>
<p>艿艿：为了下面描述方便，统一先叫 SSL 。</p>
</blockquote>
<p>🦅 <strong>SSL/TLS 协议作用？</strong></p>
<ol>
<li><p>认证用户和服务器，确保数据发送到正确的客户机和服务器。</p>
<blockquote>
<p>客户端必须避免中间人攻击，即除了真正的服务器，任何第三方都无法冒充服务器。</p>
</blockquote>
</li>
<li><p>加密数据以防止数据中途被窃取。</p>
</li>
<li><p>维护数据的完整性，确保数据在传输过程中不被改变。</p>
</li>
</ol>
<h2 id="HTTP-和-HTTPS-的区别？"><a href="#HTTP-和-HTTPS-的区别？" class="headerlink" title="HTTP 和 HTTPS 的区别？"></a>HTTP 和 HTTPS 的区别？</h2><ul>
<li><p>端口不同：HTTP 与 HTTPS 使用不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</p>
<blockquote>
<p>艿艿：个人的想法，实际 HTTPS 也是可以使用 80 端口，但是考虑继续保持 HTTP 的兼容，只好退而求其次，使用 443 端口。</p>
</blockquote>
</li>
<li><p>资源消耗：和 HTTP 通信相比，HTTPS 通信会由于加解密处理消耗更多的 CPU 和内存资源。</p>
</li>
<li><p>开销：HTTPS 通信需要证书，而证书一般需要向认证机构申请免费或者付费购买。</p>
<blockquote>
<p>HTTPS 可以有效的防止运营商劫持，解决了防劫持的一个大问题。</p>
</blockquote>
</li>
</ul>
<h2 id="SSL-加密方式是什么？"><a href="#SSL-加密方式是什么？" class="headerlink" title="SSL 加密方式是什么？"></a>SSL 加密方式是什么？</h2><blockquote>
<ul>
<li>对称密钥加密，是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方。</li>
<li>非对称加密，指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。</li>
</ul>
</blockquote>
<p>SSL 协议，即用到了对称加密也用到了非对称加密，如下图所示：<img src="http://cdn.tuwenbin.vip/sbh9hdy2.bmp">SSL 加密过程</p>
<blockquote>
<p>TODO 这个配图有问题。原图我在翻，貌似不小心被我删除了。。。。</p>
</blockquote>
<ul>
<li><p>在建立传输链路时，SSL 首先对对称加密的密钥使用公钥进行非对称加密。</p>
<blockquote>
<p>艿艿：注意哟，这里 Server 返回给 Client 的不是公钥( <code>server.pub</code> )，而是 <code>server.crt</code> 。Client 需要使用 <code>ca.key</code> 从 <code>server.crt</code> 中解密出公钥( <code>server.pub</code> ) 。</p>
</blockquote>
</li>
<li><p>链路建立好之后，SSL 对传输内容使用公钥( <code>server.pub</code> )对称加密。</p>
</li>
</ul>
<p>🦅 <strong>为什么公钥传输的步骤这么复杂呢？</strong></p>
<p>答案请看 <a href="http://juejin.im/post/58c5268a61ff4b005d99652a">《九个问题从入门到熟悉 HTTPS》</a> 文章的如下问题：</p>
<ul>
<li>Q5: 那公钥怎么传输</li>
<li>Q6: 你在逗我么。。。。</li>
<li>Q7: 怎么知道证书有没有被篡改？</li>
<li>Q8: 这样可以防止第三方冒充服务器么</li>
</ul>
<p>也就是说，通过 CA 来保证。至于 <code>server.crt</code> 证书是怎么申请的呢？请看 <a href="https://blog.csdn.net/ustccw/article/details/76691248">《SSL/TLS 双向认证(一) – SSL/TLS工作原理》</a> 文章的 <a href="http://svip.iocoder.cn/Net/Interview/#">「CA 的证书 ca.crt 和 SSL Server 的证书 server.crt  是什么关系呢？ 」</a> 问题的解答。</p>
<blockquote>
<p>艿艿：看这块，我已经要被绕晕了！！！耐心~胖友，理解后会很爽。</p>
</blockquote>
<h2 id="什么是单向认证、双向认证？"><a href="#什么是单向认证、双向认证？" class="headerlink" title="什么是单向认证、双向认证？"></a>什么是单向认证、双向认证？</h2><ul>
<li><p>单向认证，指的是只有一个对象校验对端的证书合法性。</p>
<blockquote>
<p>通常都是 Client 来校验服务器的合法性。那么 Client 需要一个<code>ca.crt</code> ，服务器需要 <code>server.crt</code> 和 <code>server.key</code> 。</p>
</blockquote>
</li>
<li><p>双向认证，指的是相互校验，Server 需要校验每个 Client ，Client 也需要校验服务器。</p>
<blockquote>
<ul>
<li>Server 需要 <code>server.key</code>、<code>server.crt</code>、<code>ca.crt</code> 。</li>
<li>Client 需要 <code>client.key</code>、<code>client.crt</code>、<code>ca.crt</code> 。</li>
</ul>
</blockquote>
</li>
</ul>
<p>🦅 <strong>1）单向认证的过程？</strong></p>
<p>![AVFY_SQWK{Z4`$IXLDKXN$9](<a href="http://cdn.tuwenbin.vip/20200927233916.png)%E5%8D%95%E5%90%91%E8%AE%A4%E8%AF%81">http://cdn.tuwenbin.vip/20200927233916.png)单向认证</a></p>
<ul>
<li><p>1、客户端向服务端发送 SSL 协议版本号、加密算法种类、随机数等信息。</p>
</li>
<li><p>2、服务端给客户端返回 SSL 协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书。</p>
</li>
<li><p>3、客户端使用服务端返回的信息验证服务器的合法性，包括：</p>
<ul>
<li><p>证书是否过期。</p>
</li>
<li><p>发型服务器证书的 CA 是否可靠。</p>
</li>
<li><p>返回的公钥是否能正确解开返回证书中的数字签名。</p>
</li>
<li><p>服务器证书上的域名是否和服务器的实际域名相匹配</p>
<blockquote>
<p>验证通过后，将继续进行通信；否则，终止通信。</p>
</blockquote>
</li>
<li><p>4、客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择。</p>
</li>
<li><p>5、服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。</p>
</li>
</ul>
</li>
<li><p>6、服务器将选择好的加密方案通过明文方式返回给客户端。</p>
</li>
<li><p>7、客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器。</p>
</li>
<li><p>8、服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。</p>
<blockquote>
<p><strong>在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全</strong>。</p>
</blockquote>
</li>
</ul>
<p>🦅 <strong>2）双向认证的过程？</strong></p>
<p>双向认证和单向认证原理基本差不多，只是除了客户端需要认证服务端以外，增加了服务端对客户端的认证，具体过程如下：</p>
<p><img src="http://cdn.tuwenbin.vip/20200927235121.png">双向认证</p>
<ul>
<li><p>1、客户端向服务端发送 SSL 协议版本号、加密算法种类、随机数等信息。</p>
</li>
<li><p>2、服务端给客户端返回 SSL 协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书。</p>
</li>
<li><p>3、客户端使用服务端返回的信息验证服务器的合法性，包括：</p>
<ul>
<li><p>证书是否过期。</p>
</li>
<li><p>发型服务器证书的 CA 是否可靠。</p>
</li>
<li><p>返回的公钥是否能正确解开返回证书中的数字签名。</p>
</li>
<li><p>服务器证书上的域名是否和服务器的实际域名相匹配</p>
<blockquote>
<p>验证通过后，将继续进行通信；否则，终止通信。</p>
</blockquote>
</li>
<li><p><strong>【新增】4、服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端。</strong></p>
</li>
<li><p><strong>【新增】5、验证客户端的证书，通过验证后，会获得客户端的公钥。</strong></p>
</li>
<li><p>6、客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择。</p>
</li>
<li><p>7、服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。</p>
</li>
</ul>
</li>
<li><p>8、服务器将选择好的加密方案通过明文方式返回给客户端。</p>
</li>
<li><p>9、客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器。</p>
</li>
<li><p>10、服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。</p>
<blockquote>
<p><strong>在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全</strong>。</p>
</blockquote>
</li>
</ul>
<p>🦅 <strong>如何选择单向认证还是双向认证</strong></p>
<ul>
<li><p>一般一个站点很多用户访问就用单向认证。</p>
</li>
<li><p>企业接口对接就用双向认证。</p>
<blockquote>
<p>如果想要提高 APP 的安全级别，也可以考虑双向认证。因为，APP 天然方便放入客户端证书，从而提高安全级别。</p>
</blockquote>
</li>
</ul>
<h2 id="为什么抓包工具还能抓到-HTTPS-数据包并解密成功呢"><a href="#为什么抓包工具还能抓到-HTTPS-数据包并解密成功呢" class="headerlink" title="为什么抓包工具还能抓到 HTTPS 数据包并解密成功呢"></a>为什么抓包工具还能抓到 HTTPS 数据包并解密成功呢</h2><p>不是说HTTPS在网络中传输的是密文吗？这个问题就是<strong>中间者攻击</strong>（man in zhe middle）。</p>
<p><img src="http://cdn.tuwenbin.vip/20200927235159.png" alt="img">中间者攻击原理图</p>
<ul>
<li>解决办法，就是 HTTPS 单向验证。在客户端中内置服务器公钥，在第三步服务器返回的公钥，除了验证公钥的有效性之外，再比对公钥是不是和内置的公钥一样，不一样说明被中间者攻击了，就断开链接不在请求了。</li>
<li>这个原理的前提是服务器的私钥没有泄露，客户端的代码不会被破解，道高一尺魔高一丈。信息安全就是在合理的范围内，选择比较合适的加密方法，没有绝对论，只有相对论。在某个范围内比较安全。</li>
</ul>
<h2 id="HTTPS-握手会影响性能么？"><a href="#HTTPS-握手会影响性能么？" class="headerlink" title="HTTPS 握手会影响性能么？"></a>HTTPS 握手会影响性能么？</h2><p>TCP 有三次握手，再加上 HTTPS 的四次握手，影响肯定有，但是可以接受。</p>
<ul>
<li>首先，HTTPS 肯定会更慢一点，时间主要花费在两组 SSL 之间的耗时和证书的读取验证上，对称算法的加解密时间几乎可以忽略不计。</li>
<li>而且如果不是首次握手，后续的请求并不需要完整的握手过程。客户端可以把上次的加密情况直接发送给服务器从而快速恢复，具体细节可以参考 <a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html">《图解 SSL/TLS 协议》</a> 。</li>
<li>除此以外，SSL 握手的时间并不是只能用来传递加密信息，还可以承担起客户端和服务器沟通 HTTP2 兼容情况的任务。因此从 HTTPS 切换到 HTTP2.0 不会有任何性能上的开销，反倒是得益于 HTTP2.0 的多路复用等技术，后续可以节约大量时间。</li>
<li>如果把 HTTPS2.0 当做目标，那么 HTTPS 的性能损耗就更小了，远远比不上它带来的安全性提升。</li>
</ul>
<h1 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h1><p><img src="http://cdn.tuwenbin.vip/20200927235254.png" alt="img">HTTP2 和 HTTP1.1 的区别</p>
<h2 id="什么是-HTTP2-0-？"><a href="#什么是-HTTP2-0-？" class="headerlink" title="什么是 HTTP2.0 ？"></a>什么是 HTTP2.0 ？</h2><p>HTTP2.0 ，可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，如下：</p>
<ul>
<li>HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS 。</li>
<li>HTTP2.0 消息头的压缩算法采用 <a href="https://link.jianshu.com/?t=http://http2.github.io/http2-spec/compression.html">HPACK</a>，而非 SPDY 采用的 <a href="https://link.jianshu.com/?t=http://zh.wikipedia.org/wiki/DEFLATE">DEFLATE</a> 。</li>
</ul>
<h2 id="HTTP2-0-和-HTTP1-X-相比的新特性？"><a href="#HTTP2-0-和-HTTP1-X-相比的新特性？" class="headerlink" title="HTTP2.0 和 HTTP1.X 相比的新特性？"></a>HTTP2.0 和 HTTP1.X 相比的新特性？</h2><ul>
<li><p>1、新的二进制格式（Binary Format）</p>
<blockquote>
<p>HTTP1.x 的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 0 和 1 的组合。基于这种考虑 HTTP2.0 的协议解析决定采用二进制格式，实现方便且健壮。</p>
</blockquote>
</li>
<li><p>同 SPDY 对 HTTP1.1 的改进。</p>
<ul>
<li>2、降低延迟</li>
<li>3、多路复用（MultiPlexing）</li>
<li>4、header 压缩</li>
<li>5、服务端推送（server push）</li>
</ul>
</li>
</ul>
<h2 id="Nginx-怎么做-HTTP2-0-的升级改造？"><a href="#Nginx-怎么做-HTTP2-0-的升级改造？" class="headerlink" title="Nginx 怎么做 HTTP2.0 的升级改造？"></a>Nginx 怎么做 HTTP2.0 的升级改造？</h2><ul>
<li>1、虽然 HTTP2.0 其实可以支持非 HTTPS 的，但是现在主流的浏览器像 Chrome，Firefox 表示还是只支持基于 TLS 部署的 HTTP2.0协议，所以要想升级成 HTTP2.0 还是先升级 HTTPS 为好。</li>
<li>2、当你的网站已经升级 HTTPS 之后，那么升级 HTTP2.0 就简单很多，如果你使用 NGINX ，只要在配置文件中启动相应的协议就可以了，可以参考 <a href="https://link.jianshu.com/?t=https://www.nginx.com/wp-content/uploads/2015/09/NGINX_HTTP2_White_Paper_v4.pdf">NGINX白皮书</a>，<a href="https://link.jianshu.com/?t=https://www.nginx.com/blog/nginx-1-9-5/">NGINX配置HTTP2.0官方指南</a> 。</li>
<li>3、使用了 HTTP2.0 那么，原本的 HTTP1.x 怎么办？这个问题其实不用担心，HTTP2.0 完全兼容 HTTP1.x 的语义，对于不支持 HTTP2.0 的浏览器，NGINX 会自动向下兼容的。</li>
</ul>
<p>在我们内部的微服务 API 接口，也可以做 HTTP2 的改造，可以参考如下文章：</p>
<blockquote>
<p>艿艿：选读，作为知识的扩充</p>
</blockquote>
<ul>
<li><a href="https://www.jianshu.com/p/ed3f8f983764">《Spring Cloud 使用 HTTP2》</a></li>
<li><a href="https://www.jianshu.com/p/7ddcdd3847d6">《再说 SpringBoot2.0 与 HTTP/2》</a></li>
</ul>
<h2 id="HTTP2-0-的多路复用和-HTTP1-X-中的长连接复用有什么区别？"><a href="#HTTP2-0-的多路复用和-HTTP1-X-中的长连接复用有什么区别？" class="headerlink" title="HTTP2.0 的多路复用和 HTTP1.X 中的长连接复用有什么区别？"></a>HTTP2.0 的多路复用和 HTTP1.X 中的长连接复用有什么区别？</h2><ul>
<li>HTTP/1.0：一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接。</li>
<li>HTTP/1.1：Pipeling 解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会。一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞。</li>
<li>HTTP/2：多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行。</li>
</ul>
<p>如下图所示：<img src="http://cdn.tuwenbin.vip/20200927235520.png">HTTP/1.1 对比 HTTP/2</p>
<p>🦅  <strong>HTTP2.0 多路复用有多好？</strong></p>
<blockquote>
<p>艿艿：最近重新看了 TCP ，发现再看这个问题，真的是有趣！</p>
</blockquote>
<p>HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP  连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP  慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。</p>
<p>HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。</p>
<h2 id="服务器推送到底是什么？"><a href="#服务器推送到底是什么？" class="headerlink" title="服务器推送到底是什么？"></a>服务器推送到底是什么？</h2><p>服务端推送能把客户端所需要的资源伴随着 <code>index.html</code> 一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。具体如下：</p>
<ul>
<li>普通的客户端请求过程：<img src="http://cdn.tuwenbin.vip/20200927235753.png" alt="135531513513">普通的客户端请求过程</li>
<li>服务端推送的过程：<img src="http://cdn.tuwenbin.vip/20200927235843.png" alt="462552542">服务端推送的过程</li>
</ul>
<h2 id="为什么需要头部-header-压缩？"><a href="#为什么需要头部-header-压缩？" class="headerlink" title="为什么需要头部(header)压缩？"></a>为什么需要头部(header)压缩？</h2><p>假定一个页面有 100 个资源需要加载（这个数量对于今天的 Web 而言还是挺保守的），而每一次请求都有 1kb 的消息头（这同样也并不少见，因为  Cookie 和引用等东西的存在），则至少需要多消耗 100kb 来获取这些消息头。HTTP2.0 可以维护一个字典，差量更新 HTTP  头部，大大降低因头部传输产生的流量。</p>
<p>具体参考：<a href="https://link.jianshu.com/?t=https://imququ.com/post/header-compression-in-http2.html">《HTTP/2 头部压缩技术介绍》</a> 文章。</p>
<ul>
<li>维护一份相同的静态字典（Static Table），包含常见的头部名称，以及特别常见的头部名称与值的组合。</li>
<li>维护一份相同的动态字典（Dynamic Table），可以动态地添加内容。</li>
<li>支持基于静态哈夫曼码表的哈夫曼编码（Huffman Coding）。</li>
</ul>
<h1 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h1><p>感觉，大学丢掉的网络知识，又一次回到我的脑子中了。好开心，又可以遗忘一轮啦，哈哈哈哈。</p>
<p>参考与推荐如下文章：</p>
<ul>
<li><a href="https://blog.csdn.net/duanbokan/article/details/50847612">《Https 单向认证和双向认证》</a></li>
<li><a href="https://blog.csdn.net/Maybe_ch/article/details/82598782">《【网络协议】ping 的工作原理》</a></li>
<li><a href="https://www.jianshu.com/p/be29d679cbff">《HTTP1.0、HTTP1.1 和 HTTP2.0 的区别》</a></li>
<li><a href="https://segmentfault.com/a/1190000010819141">《计算机网络常见面试题》</a></li>
<li><a href="https://www.jianshu.com/p/a1f5daf7ada5">《总结的网络面试题》</a></li>
<li><a href="https://blog.csdn.net/justloveyou_/article/details/78303617">《面试/笔试第一弹 —— 计算机网络面试问题集锦》</a></li>
<li><a href="https://github.com/jawil/blog/issues/14">《通俗大白话来理解 TCP 协议的三次握手和四次挥手》</a></li>
<li><a href="https://www.jianshu.com/p/b71ec62b6eb5">《TCP 数据的传输过程》</a></li>
<li><a href="https://juejin.im/post/5b7be0b2e51d4538db34a51e">《搞定计算机网络面试，看这篇就够了（补充版）》</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
