<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>10</title>
    <url>/2016/10/12/10/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>12</title>
    <url>/2016/10/12/12/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>13</title>
    <url>/2016/10/12/13/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>11</title>
    <url>/2016/10/12/11/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>14</title>
    <url>/2016/10/12/14/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>15</title>
    <url>/2016/10/12/15/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>17</title>
    <url>/2016/10/12/17/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>16</title>
    <url>/2016/10/12/16/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>19</title>
    <url>/2016/10/12/19/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>18</title>
    <url>/2016/10/12/18/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>20</title>
    <url>/2016/10/12/20/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>21</title>
    <url>/2016/10/12/21/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>22</title>
    <url>/2016/10/12/22/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>23</title>
    <url>/2016/10/12/23/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>24</title>
    <url>/2016/10/12/24/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>25</title>
    <url>/2016/10/12/25/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>26</title>
    <url>/2016/10/12/26/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>27</title>
    <url>/2016/10/12/27/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>28</title>
    <url>/2016/10/12/28/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>29</title>
    <url>/2016/10/12/29/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>30</title>
    <url>/2016/10/12/30/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>31</title>
    <url>/2016/10/12/31/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>32</title>
    <url>/2016/10/12/32/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>33</title>
    <url>/2016/10/12/33/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>34</title>
    <url>/2016/10/12/34/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>35</title>
    <url>/2016/10/12/35/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>36</title>
    <url>/2016/10/12/36/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>38</title>
    <url>/2016/10/12/38/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>37</title>
    <url>/2016/10/12/37/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>39</title>
    <url>/2016/10/12/39/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>40</title>
    <url>/2016/10/12/40/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/41/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/42/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/43/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/44/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/45/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/47/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/49/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/46/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>My awesome title</title>
    <url>/2016/10/12/48/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>50</title>
    <url>/2016/10/12/50/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>52</title>
    <url>/2016/10/12/52/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>51</title>
    <url>/2016/10/12/51/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>54</title>
    <url>/2016/10/12/54/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>53</title>
    <url>/2016/10/12/53/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>55</title>
    <url>/2016/10/12/55/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>56</title>
    <url>/2016/10/12/56/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>57</title>
    <url>/2016/10/12/57/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>58</title>
    <url>/2016/10/12/58/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>6</title>
    <url>/2016/10/12/6/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>59</title>
    <url>/2016/10/12/59/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>60</title>
    <url>/2016/10/12/60/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>7</title>
    <url>/2016/10/12/7/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>8</title>
    <url>/2016/10/12/8/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>9</title>
    <url>/2016/10/12/9/</url>
    <content><![CDATA[<p>11111111</p>
]]></content>
      <categories>
        <category>分类1</category>
        <category>分类2</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title>2</title>
    <url>/2018/10/12/2/</url>
    <content><![CDATA[<h1 id="精尽-Spring-MVC-面试题"><a href="#精尽-Spring-MVC-面试题" class="headerlink" title="精尽 Spring MVC 面试题"></a>精尽 Spring MVC 面试题</h1><p>以下面试题，基于网络整理，和自己编辑。具体参考的文章，会在文末给出所有的链接。</p>
<p>如果胖友有自己的疑问，欢迎在星球提问，我们一起整理吊吊的 Spring MVC 面试题的大保健。</p>
<p>而题目的难度，艿艿尽量按照从容易到困难的顺序，逐步下去。</p>
<p>当然，艿艿还是非常推荐胖友去撸一撸 Spring MVC 的源码，特别是如下两篇：</p>
<ul>
<li><a href="http://svip.iocoder.cn/Spring-MVC/Components-intro/">《精尽 Spring MVC 源码分析 —— 组件一览》</a></li>
<li><a href="http://svip.iocoder.cn/Spring-MVC/DispatcherServlet-process-request-intro/">《精尽 Spring MVC 源码分析 —— 请求处理一览》</a></li>
</ul>
<p>考虑到 Spring MVC 和 Rest 关系比较大，所以本文一共分成两大块：</p>
<ul>
<li>Spring MVC</li>
<li>REST</li>
</ul>
<h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h2 id="Spring-MVC-框架有什么用？"><a href="#Spring-MVC-框架有什么用？" class="headerlink" title="Spring MVC 框架有什么用？"></a>Spring MVC 框架有什么用？</h2><p>Spring Web MVC 框架提供”模型-视图-控制器”( Model-View-Controller )架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。</p>
<p>MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。</p>
<h2 id="介绍下-Spring-MVC-的核心组件？"><a href="#介绍下-Spring-MVC-的核心组件？" class="headerlink" title="介绍下 Spring MVC 的核心组件？"></a>介绍下 Spring MVC 的核心组件？</h2><p>Spring MVC 一共有九大核心组件，分别是：</p>
<ul>
<li>MultipartResolver</li>
<li>LocaleResolver</li>
<li>ThemeResolver</li>
<li>HandlerMapping</li>
<li>HandlerAdapter</li>
<li>HandlerExceptionResolver</li>
<li>RequestToViewNameTranslator</li>
<li>ViewResolver</li>
<li>FlashMapManager</li>
</ul>
<p>虽然很多，但是在前后端分离的架构中，在 <a href="http://svip.iocoder.cn/Spring-MVC/Interview/#">「描述一下 DispatcherServlet 的工作流程？」</a> 问题中，我们会明白，最关键的只有 HandlerMapping + HandlerAdapter + HandlerExceptionResolver 。</p>
<p>关于每个组件的说明，直接看 <a href="http://svip.iocoder.cn/Spring-MVC/Components-intro/">《精尽 Spring MVC 源码分析 —— 组件一览》</a> 。</p>
<h2 id="描述一下-DispatcherServlet-的工作流程？"><a href="#描述一下-DispatcherServlet-的工作流程？" class="headerlink" title="描述一下 DispatcherServlet 的工作流程？"></a>描述一下 DispatcherServlet 的工作流程？</h2><p>DispatcherServlet 的工作流程可以用一幅图来说明：</p>
<p><a href="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15300766829012.jpg">![DispatcherServlet 的工作流程](D:\新建文件夹 (3)\15300766829012.jpg)</a>DispatcherServlet 的工作流程</p>
<p>① <strong>发送请求</strong></p>
<p>用户向服务器发送 HTTP 请求，请求被 Spring MVC 的调度控制器  DispatcherServlet 捕获。</p>
<p>② <strong>映射处理器</strong></p>
<p>DispatcherServlet 根据请求 URL ，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 <strong>Handler</strong> 对象以及 Handler 对象对应的<strong>拦截器</strong>），最后以 HandlerExecutionChain 对象的形式返回。</p>
<ul>
<li>即 HandlerExecutionChain 中，包含对应的 <strong>Handler</strong> 对象和<strong>拦截器</strong>们。</li>
</ul>
<blockquote>
<p>此处，对应的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; &#x2F;&#x2F; HandlerMapping.java<br>&gt; <br>&gt; @Nullable<br>&gt; HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception;<br>&gt;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>③ <strong>处理器适配</strong></p>
<p>DispatcherServlet 根据获得的 Handler，选择一个合适的HandlerAdapter 。（附注：如果成功获得 HandlerAdapter 后，此时将开始执行拦截器的 <code>#preHandler(...)</code> 方法）。</p>
<p>提取请求 Request 中的模型数据，填充 Handler 入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：</p>
<ul>
<li>HttpMessageConverter ：会将请求消息（如 JSON、XML 等数据）转换成一个对象。</li>
<li>数据转换：对请求消息进行数据转换。如 String 转换成 Integer、Double 等。</li>
<li>数据格式化：对请求消息进行数据格式化。如将字符串转换成格式化数字或格式化日期等。</li>
<li>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到 BindingResult 或 Error 中。</li>
</ul>
<p>Handler(Controller) 执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象。</p>
<blockquote>
<p>此处，对应的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; &#x2F;&#x2F; HandlerAdapter.java<br>&gt; <br>&gt; @Nullable<br>&gt; ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;<br>&gt;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>.</p>
<blockquote>
<p>图中没有 ④ 。</p>
</blockquote>
<p>⑤ <strong>解析视图</strong></p>
<p>根据返回的 ModelAndView ，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的 ViewResolver)，解析出 View 对象，然后返回给 DispatcherServlet。</p>
<blockquote>
<p>此处，对应的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; &#x2F;&#x2F; ViewResolver.java<br>&gt; <br>&gt; @Nullable<br>&gt; View resolveViewName(String viewName, Locale locale) throws Exception;<br>&gt;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>⑥ ⑦ <strong>渲染视图</strong> + <strong>响应请求</strong></p>
<p>ViewResolver 结合 Model 和 View，来渲染视图，并写回给用户( 浏览器 )。</p>
<blockquote>
<p>此处，对应的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; &#x2F;&#x2F; View.java<br>&gt; <br>&gt; void render(@Nullable Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception;<br>&gt;<br></code></pre></td></tr></table></figure>
</blockquote>
<hr>
<p>这样一看，胖友可能有点懵逼，所以还是推荐看看：</p>
<ul>
<li><a href="http://svip.iocoder.cn/Spring-MVC/Components-intro/">《精尽 Spring MVC 源码分析 —— 组件一览》</a></li>
<li><a href="http://svip.iocoder.cn/Spring-MVC/DispatcherServlet-process-request-intro/">《精尽 Spring MVC 源码分析 —— 请求处理一览》</a></li>
</ul>
<p><strong>但是 Spring MVC 的流程真的一定是酱紫么</strong>？</p>
<p>既然这么问，答案当然不是。对于目前主流的架构，前后端已经进行分离了，所以 Spring MVC 只负责 <strong>M</strong>odel 和 <strong>C</strong>ontroller 两块，而将 <strong>V</strong>iew 移交给了前端。所以，在上图中的步骤 ⑤ 和 ⑥ 两步，已经不在需要。</p>
<p>那么变成什么样了呢？在步骤 ③ 中，如果 Handler(Controller) 执行完后，如果判断方法有 <code>@ResponseBody</code> 注解，则直接将结果写回给用户( 浏览器 )。</p>
<p>但是 HTTP 是不支持返回 Java POJO 对象的，所以需要将结果使用 <a href="http://svip.iocoder.cn/Spring-MVC/HandlerAdapter-5-HttpMessageConverter/">HttpMessageConverter</a> 进行转换后，才能返回。例如说，大家所熟悉的 <a href="https://github.com/alibaba/fastjson/wiki/%E5%9C%A8-Spring-%E4%B8%AD%E9%9B%86%E6%88%90-Fastjson">FastJsonHttpMessageConverter</a> ，将 POJO 转换成 JSON 字符串返回。</p>
<p>😈 是不是略微有点复杂，还是那句话，撸下源码，捅破这个窗口。当然，如果胖友精力有限，只要看整体流程的几篇即可。 </p>
<hr>
<p>嘻嘻，再来补充两个图，这真的是 Spring MVC 非常关键的问题，所以要用心理解。</p>
<blockquote>
<p>FROM <a href="https://blog.csdn.net/J080624/article/details/77990164">《SpringMVC - 运行流程图及原理分析》</a></p>
<p><strong>流程示意图</strong>：</p>
<p><a href="http://static2.iocoder.cn/images/Spring/2022-02-21/01.png">![流程示意图](D:\新建文件夹 (3)\01.png)</a>流程示意图</p>
<p><strong>代码序列图</strong>：</p>
<p><a href="http://static2.iocoder.cn/images/Spring/2022-02-21/02.png">![代码序列图](D:\新建文件夹 (3)\02.png)</a>代码序列图</p>
<hr>
<p>FROM <a href="https://item.jd.com/11807414.html">《看透 Spring MVC：源代码分析与实践》</a> P123</p>
<p><strong>流程示意图</strong>：</p>
<p><a href="http://static2.iocoder.cn/images/Spring/2022-02-21/03.png">![《流程示意图》](D:\新建文件夹 (3)\03.png)</a>《流程示意图》</p>
</blockquote>
<h2 id="Controller-注解有什么用？"><a href="#Controller-注解有什么用？" class="headerlink" title="@Controller 注解有什么用？"></a>@Controller 注解有什么用？</h2><p><code>@Controller</code> 注解，它将一个类标记为 Spring Web MVC <strong>控制器</strong> Controller 。</p>
<h2 id="RestController-和-Controller-有什么区别？"><a href="#RestController-和-Controller-有什么区别？" class="headerlink" title="@RestController 和 @Controller 有什么区别？"></a>@RestController 和 @Controller 有什么区别？</h2><p><code>@RestController</code> 注解，在 <code>@Controller</code> 基础上，增加了 <code>@ResponseBody</code> 注解，更加适合目前前后端分离的架构下，提供 Restful API ，返回例如 JSON 数据格式。当然，返回什么样的数据格式，根据客户端的 <code>&quot;ACCEPT&quot;</code> 请求头来决定。</p>
<h2 id="RequestMapping-注解有什么用？"><a href="#RequestMapping-注解有什么用？" class="headerlink" title="@RequestMapping 注解有什么用？"></a>@RequestMapping 注解有什么用？</h2><p><code>@RequestMapping</code> 注解，用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注释可应用于两个级别：</p>
<ul>
<li>类级别：映射请求的 URL。</li>
<li>方法级别：映射 URL 以及 HTTP 请求方法。</li>
</ul>
<h2 id="RequestMapping-和-GetMapping-注解的不同之处在哪里？"><a href="#RequestMapping-和-GetMapping-注解的不同之处在哪里？" class="headerlink" title="@RequestMapping 和 @GetMapping 注解的不同之处在哪里？"></a>@RequestMapping 和 @GetMapping 注解的不同之处在哪里？</h2><ul>
<li><code>@RequestMapping</code> 可注解在类和方法上；<code>@GetMapping</code> 仅可注册在方法上。</li>
<li><code>@RequestMapping</code> 可进行 GET、POST、PUT、DELETE 等请求方法；<code>@GetMapping</code> 是 <code>@RequestMapping</code> 的 GET 请求方法的特例，目的是为了提高清晰度。</li>
</ul>
<h2 id="返回-JSON-格式使用什么注解？"><a href="#返回-JSON-格式使用什么注解？" class="headerlink" title="返回 JSON 格式使用什么注解？"></a>返回 JSON 格式使用什么注解？</h2><p>可以使用 <strong><code>@ResponseBody</code></strong> 注解，或者使用包含 <code>@ResponseBody</code> 注解的 <strong><code>@RestController</code></strong> 注解。</p>
<p>当然，还是需要配合相应的支持 JSON 格式化的 HttpMessageConverter 实现类。例如，Spring MVC 默认使用 MappingJackson2HttpMessageConverter 。</p>
<h2 id="介绍一下-WebApplicationContext-？"><a href="#介绍一下-WebApplicationContext-？" class="headerlink" title="介绍一下 WebApplicationContext ？"></a>介绍一下 WebApplicationContext ？</h2><p>WebApplicationContext 是实现ApplicationContext接口的子类，专门为 WEB 应用准备的。</p>
<ul>
<li>它允许从相对于 Web 根目录的路径中<strong>加载配置文件</strong>，<strong>完成初始化 Spring MVC 组件的工作</strong>。</li>
<li>从 WebApplicationContext 中，可以获取 ServletContext 引用，整个 Web 应用上下文对象将作为属性放置在 ServletContext 中，以便 Web 应用环境可以访问 Spring 上下文。</li>
</ul>
<p>关于这一块，如果想要详细了解，可以看看如下两篇文章：</p>
<ul>
<li><a href="http://svip.iocoder.cn/Spring-MVC/context-init-Root-WebApplicationContext/">《精尽 Spring MVC 源码分析 —— 容器的初始化（一）之 Root WebApplicationContext 容器》</a></li>
<li><a href="http://svip.iocoder.cn/Spring-MVC/context-init-Servlet-WebApplicationContext/">《精尽 Spring MVC 源码分析 —— 容器的初始化（二）之 Servlet WebApplicationContext 容器》</a></li>
</ul>
<h2 id="Spring-MVC-的异常处理？"><a href="#Spring-MVC-的异常处理？" class="headerlink" title="Spring MVC 的异常处理？"></a>Spring MVC 的异常处理？</h2><p>Spring MVC 提供了异常解析器 HandlerExceptionResolver 接口，将处理器( <code>handler</code> )执行时发生的异常，解析( 转换 )成对应的 ModelAndView 结果。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; HandlerExceptionResolver.java<br><br>public interface HandlerExceptionResolver &#123;<br><br>    &#x2F;**<br>     * 解析异常，转换成对应的 ModelAndView 结果<br>     *&#x2F;<br>    @Nullable<br>    ModelAndView resolveException(<br>            HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex);<br><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>也就是说，如果异常被解析成功，则会返回 ModelAndView 对象。</li>
<li>详细的源码解析，见 <a href="http://svip.iocoder.cn/Spring-MVC/HandlerExceptionResolver/">《精尽 Spring MVC 源码解析 —— HandlerExceptionResolver 组件》</a> 。</li>
</ul>
<p>一般情况下，我们使用 <code>@ExceptionHandler</code> 注解来实现过异常的处理，可以先看看 <a href="https://www.jianshu.com/p/12e1a752974d">《Spring 异常处理 ExceptionHandler 的使用》</a> 。</p>
<ul>
<li>一般情况下，艿艿喜欢使用<strong>第三种</strong>。</li>
</ul>
<h2 id="Spring-MVC-有什么优点？"><a href="#Spring-MVC-有什么优点？" class="headerlink" title="Spring MVC 有什么优点？"></a>Spring MVC 有什么优点？</h2><ol>
<li>使用真的真的真的非常<strong>方便</strong>，无论是添加 HTTP 请求方法映射的方法，还是不同数据格式的响应。</li>
<li>提供<strong>拦截器机制</strong>，可以方便的对请求进行拦截处理。</li>
<li>提供<strong>异常机制</strong>，可以方便的对异常做统一处理。</li>
<li>可以任意使用各种<strong>视图</strong>技术，而不仅仅局限于 JSP ，例如 Freemarker、Thymeleaf 等等。</li>
<li>不依赖于 Servlet API (目标虽是如此，但是在实现的时候确实是依赖于 Servlet 的，当然仅仅依赖 Servlet ，而不依赖 Filter、Listener )。</li>
</ol>
<h2 id="Spring-MVC-怎样设定重定向和转发-？"><a href="#Spring-MVC-怎样设定重定向和转发-？" class="headerlink" title="Spring MVC 怎样设定重定向和转发 ？"></a>Spring MVC 怎样设定重定向和转发 ？</h2><ul>
<li>结果转发：在返回值的前面加 <code>&quot;forward:/&quot;</code> 。</li>
<li>重定向：在返回值的前面加上 <code>&quot;redirect:/&quot;</code> 。</li>
</ul>
<p>当然，目前前后端分离之后，我们作为后端开发，已经很少有机会用上这个功能了。</p>
<h2 id="Spring-MVC-的-Controller-是不是单例？"><a href="#Spring-MVC-的-Controller-是不是单例？" class="headerlink" title="Spring MVC 的 Controller 是不是单例？"></a>Spring MVC 的 Controller 是不是单例？</h2><p>绝绝绝大多数情况下，Controller 是<strong>单例</strong>。</p>
<p>那么，Controller 里一般不建议存在<strong>共享的变量</strong>。实际场景下，艿艿也没碰到需要使用共享变量的情况。</p>
<h2 id="Spring-MVC-和-Struts2-的异同？"><a href="#Spring-MVC-和-Struts2-的异同？" class="headerlink" title="Spring MVC 和 Struts2 的异同？"></a>Spring MVC 和 Struts2 的异同？</h2><ol>
<li><p>入口</p>
<p>不同</p>
<ul>
<li>Spring MVC 的入门是一个 Servlet <strong>控制器</strong>。</li>
<li>Struts2 入门是一个 Filter <strong>过滤器</strong>。</li>
</ul>
</li>
<li><p>配置映射</p>
<p>不同，</p>
<ul>
<li>Spring MVC 是基于<strong>方法</strong>开发，传递参数是通过<strong>方法形参</strong>，一般设置为<strong>单例</strong>。</li>
<li>Struts2 是基于<strong>类</strong>开发，传递参数是通过<strong>类的属性</strong>，只能设计为<strong>多例</strong>。 </li>
</ul>
</li>
</ol>
<ul>
<li><p>视图</p>
<p>不同</p>
<ul>
<li>Spring MVC 通过参数解析器是将 Request 对象内容进行解析成方法形参，将响应数据和页面封装成 <strong>ModelAndView</strong> 对象，最后又将模型数据通过 <strong>Request</strong> 对象传输到页面。其中，如果视图使用 JSP 时，默认使用 <strong>JSTL</strong> 。</li>
<li>Struts2 采用<strong>值栈</strong>存储请求和响应的数据，通过 <strong>OGNL</strong> 存取数据。</li>
</ul>
</li>
</ul>
<p>当然，更详细的也可以看看 <a href="http://www.voidcn.com/article/p-ylualwcj-c.html">《面试题：Spring MVC 和 Struts2 的区别》</a> 一文。</p>
<h2 id="详细介绍下-Spring-MVC-拦截器？"><a href="#详细介绍下-Spring-MVC-拦截器？" class="headerlink" title="详细介绍下 Spring MVC 拦截器？"></a>详细介绍下 Spring MVC 拦截器？</h2><p><code>org.springframework.web.servlet.HandlerInterceptor</code> ，拦截器接口。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; HandlerInterceptor.java<br><br>&#x2F;**<br> * 拦截处理器，在 &#123;@link HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行之前<br> *&#x2F;<br>default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)<br>		throws Exception &#123;<br>	return true;<br>&#125;<br><br>&#x2F;**<br> * 拦截处理器，在 &#123;@link HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行成功之后<br> *&#x2F;<br>default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,<br>		@Nullable ModelAndView modelAndView) throws Exception &#123;<br>&#125;<br><br>&#x2F;**<br> * 拦截处理器，在 &#123;@link HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行完之后，无论成功还是失败<br> *<br> * 并且，只有该处理器 &#123;@link #preHandle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行成功之后，才会被执行<br> *&#x2F;<br>default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,<br>		@Nullable Exception ex) throws Exception &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>一共有三个方法，分别为：</p>
<ul>
<li><p><code>#preHandle(...)</code> 方法，调用 Controller 方法之<strong>前</strong>执行。 </p>
</li>
<li><p><code>#postHandle(...)</code> 方法，调用 Controller 方法之<strong>后</strong>执行。</p>
</li>
<li><pre><code>#afterCompletion(...)</code></pre>
<p> 方法，处理完 Controller 方法返回结果之</p>
<p>后</p>
<p>执行。</p>
<ul>
<li>例如，页面渲染后。</li>
<li><strong>当然，要注意，无论调用 Controller 方法是否成功，都会执行</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p>举个例子：</p>
<ul>
<li>当俩个拦截器都实现放行操作时，执行顺序为 <code>preHandle[1] =&gt;  preHandle[2] =&gt; postHandle[2] =&gt; postHandle[1] =&gt; afterCompletion[2] =&gt; afterCompletion[1]</code> 。</li>
<li>当第一个拦截器 <code>#preHandle(...)</code> 方法返回 <code>false</code> ，也就是对其进行拦截时，第二个拦截器是完全不执行的，第一个拦截器只执行 <code>#preHandle(...)</code> 部分。</li>
<li>当第一个拦截器 <code>#preHandle(...)</code> 方法返回 <code>true</code> ，第二个拦截器 <code>#preHandle(...)</code> 返回 <code>false</code> ，执行顺序为 <code>preHandle[1] =&gt; preHandle[2] =&gt; afterCompletion[1]</code> 。</li>
</ul>
</li>
<li><p>总结来说：</p>
<ul>
<li><code>#preHandle(...)</code> 方法，按拦截器定义<strong>顺序</strong>调用。若任一拦截器返回 <code>false</code> ，则 Controller 方法不再调用。</li>
<li><code>#postHandle(...)</code> 和 <code>#afterCompletion(...)</code> 方法，按拦截器定义<strong>逆序</strong>调用。</li>
<li><code>#postHandler(...)</code> 方法，在调用 Controller 方法之<strong>后</strong>执行。</li>
<li><code>#afterCompletion(...)</code> 方法，只有该拦截器在 <code>#preHandle(...)</code> 方法返回 <code>true</code> 时，才能够被调用，且一定会被调用。为什么“且一定会被调用”呢？即使 <code>#afterCompletion(...)</code> 方法，按拦截器定义<strong>逆序</strong>调用时，前面的拦截器发生异常，后面的拦截器还能够调用，<strong>即无视异常</strong>。</li>
</ul>
</li>
</ul>
<hr>
<p>关于这块，可以看看如下两篇文章：</p>
<ul>
<li><a href="https://blog.csdn.net/amaxiaochen/article/details/77210880">《Spring MVC 多个拦截器执行顺序及拦截器使用方法》</a> 文章，通过<strong>实践</strong>更加理解。</li>
<li><a href="http://svip.iocoder.cn/Spring-MVC/HandlerMapping-2-HandlerInterceptor/">《精尽 Spring MVC 源码分析 —— HandlerMapping 组件（二）之 HandlerInterceptor》</a> 文章，通过<strong>源码</strong>更加理解。</li>
</ul>
<h2 id="Spring-MVC-的拦截器可以做哪些事情？"><a href="#Spring-MVC-的拦截器可以做哪些事情？" class="headerlink" title="Spring MVC 的拦截器可以做哪些事情？"></a>Spring MVC 的拦截器可以做哪些事情？</h2><p>拦截器能做的事情非常非常非常多，例如：</p>
<ul>
<li>记录访问日志。</li>
<li>记录异常日志。</li>
<li>需要登陆的请求操作，拦截未登陆的用户。</li>
<li>…</li>
</ul>
<h2 id="Spring-MVC-的拦截器和-Filter-过滤器有什么差别？"><a href="#Spring-MVC-的拦截器和-Filter-过滤器有什么差别？" class="headerlink" title="Spring MVC 的拦截器和 Filter 过滤器有什么差别？"></a>Spring MVC 的拦截器和 Filter 过滤器有什么差别？</h2><p>看了文章 <a href="https://blog.csdn.net/xiaodanjava/article/details/32125687">《过滤器( Filter )和拦截器( Interceptor )的区别》</a> ，感觉对比的怪怪的。艿艿觉得主要几个点吧：</p>
<ul>
<li><strong>功能相同</strong>：拦截器和 Filter都能实现相应的功能，谁也不比谁强。</li>
<li><strong>容器不同</strong>：拦截器构建在 Spring MVC 体系中；Filter 构建在 Servlet 容器之上。</li>
<li><strong>使用便利性不同</strong>：拦截器提供了三个方法，分别在不同的时机执行；过滤器仅提供一个方法，当然也能实现拦截器的执行时机的效果，就是麻烦一些。</li>
</ul>
<p>另外，😈 再补充一点小知识。我们会发现，拓展性好的框架，都会提供相应的拦截器或过滤器机制，方便的我们做一些拓展。例如：</p>
<ul>
<li>Dubbo 的 Filter 机制。</li>
<li>Spring Cloud Gateway 的 Filter 机制。</li>
<li>Struts2 的拦截器机制。</li>
</ul>
<h1 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h1><p>本小节的内容，基本是基于 <a href="http://www.spring4all.com/article/1445">《排名前 20 的 REST 和 Spring MVC 面试题》</a> 之上，做增补。</p>
<h2 id="REST-代表着什么"><a href="#REST-代表着什么" class="headerlink" title="REST 代表着什么?"></a>REST 代表着什么?</h2><p>REST 代表着抽象状态转移，它是根据 HTTP 协议从客户端发送数据到服务端，例如：服务端的一本书可以以 XML 或 JSON 格式传递到客户端。</p>
<p>然而，假如你不熟悉REST，我建议你先看看 <a href="http://bit.ly/2zIGzWK">REST API design and development</a> 这篇文章来更好的了解它。不过对于大多数胖友的英语，可能不太好，所以也可以阅读知乎上的 <a href="https://www.zhihu.com/question/28557115">《怎样用通俗的语言解释 REST，以及 RESTful？》</a> 讨论。</p>
<h2 id="资源是什么"><a href="#资源是什么" class="headerlink" title="资源是什么?"></a>资源是什么?</h2><p>资源是指数据在 REST 架构中如何显示的。将实体作为资源公开 ，它允许客户端通过 HTTP 方法如：<a href="http://javarevisited.blogspot.sg/2012/03/get-post-method-in-http-and-https.html">GET</a>, <a href="http://www.java67.com/2014/08/difference-between-post-and-get-request.html">POST</a>,<a href="http://www.java67.com/2016/09/when-to-use-put-or-post-in-restful-web-services.html">PUT</a>, DELETE 等读，写，修改和创建资源。</p>
<h2 id="什么是安全的-REST-操作"><a href="#什么是安全的-REST-操作" class="headerlink" title="什么是安全的 REST 操作?"></a>什么是安全的 REST 操作?</h2><p>REST 接口是通过 HTTP 方法完成操作。</p>
<ul>
<li>一些HTTP操作是安全的，如 GET 和 HEAD ，它不能在服务端修改资源</li>
<li>换句话说，PUT,POST 和 DELETE 是不安全的，因为他们能修改服务端的资源。</li>
</ul>
<p>所以，是否安全的界限，在于<strong>是否修改</strong>服务端的资源。</p>
<h2 id="什么是幂等操作-为什么幂等操作如此重要"><a href="#什么是幂等操作-为什么幂等操作如此重要" class="headerlink" title="什么是幂等操作? 为什么幂等操作如此重要?"></a>什么是幂等操作? 为什么幂等操作如此重要?</h2><p>有一些HTTP方法，如：GET，不管你使用多少次它都能产生相同的结果，在没有任何一边影响的情况下，发送多个 GET 请求到相同的<a href="http://www.java67.com/2013/01/difference-between-url-uri-and-urn.html">URI</a> 将会产生相同的响应结果。因此，这就是所谓<strong>幂等</strong>操作。</p>
<p>换句话说，<a href="http://javarevisited.blogspot.sg/2016/05/what-are-idempotent-and-safe-methods-of-HTTP-and-REST.html">POST方法不是幂等操作</a> ，因为如果发送多个 POST 请求，它将在服务端创建不同的资源。但是，假如你用PUT更新资源，它将是幂等操作。</p>
<p>甚至多个 PUT 请求被用来更新服务端资源，将得到相同的结果。你可以通过 Pluralsight 学习 <a href="http://pluralsight.pxf.io/c/1193463/424552/7490?u=https://www.pluralsight.com/courses/xhttp-fund">HTTP Fundamentals</a> 课程来了解 HTTP 协议和一般的 HTTP 的更多幂等操作。</p>
<h2 id="REST-是可扩展的或说是协同的吗"><a href="#REST-是可扩展的或说是协同的吗" class="headerlink" title="REST 是可扩展的或说是协同的吗?"></a>REST 是可扩展的或说是协同的吗?</h2><p>是的，<a href="http://javarevisited.blogspot.sg/2015/08/difference-between-soap-and-restfull-webservice-java.html">REST</a> 是可扩展的和可协作的。它既不托管一种特定的技术选择，也不定在客户端或者服务端。你可以用 <a href="http://javarevisited.blogspot.sg/2017/11/top-5-free-java-courses-for-beginners.html">Java</a>, <a href="http://www.java67.com/2018/02/5-free-cpp-courses-to-learn-programming.html">C++</a>, <a href="http://www.java67.com/2018/02/5-free-python-online-courses-for-beginners.html">Python</a>, 或 <a href="http://www.java67.com/2018/04/top-5-free-javascript-courses-to-learn.html">JavaScript</a> 来创建 RESTful Web 服务，也可以在客户端使用它们。</p>
<p>我建议你读一本关于REST接口的书来了解更多，如：<a href="http://javarevisited.blogspot.sg/2017/02/top-5-books-to-learn-rest-and-restful-web-services-in-java.html">RESTful Web Services</a> 。</p>
<blockquote>
<p>艿艿：所以这里的“可拓展”、“协同”对应到我们平时常说的，“跨语言”、“语言无关”。</p>
</blockquote>
<h2 id="REST-用哪种-HTTP-方法呢"><a href="#REST-用哪种-HTTP-方法呢" class="headerlink" title="REST 用哪种 HTTP 方法呢?"></a>REST 用哪种 HTTP 方法呢?</h2><p>REST 能用任何的 HTTP 方法，但是，最受欢迎的是：</p>
<ul>
<li>用 GET 来检索服务端资源</li>
<li>用 POST 来创建服务端资源</li>
<li><a href="http://javarevisited.blogspot.sg/2016/04/what-is-purpose-of-http-request-types-in-RESTful-web-service.html#axzz56WGunSwy">用 PUT 来更新服务端资源</a> </li>
<li>用 DELETE 来删除服务端资源。</li>
</ul>
<p>恰好，这四个操作，对上我们日常逻辑的 CRUD 操作。</p>
<blockquote>
<p>艿艿：经常能听到胖友抱怨自己做的都是 CRUD 的功能。看了这个面试题，有没觉得原来 CRUD 也能玩的稍微高级一点？！</p>
<p>实际上，每个 CRUD 也是可以通过不断的打磨，玩的很高级。例如说 DDD 领域驱动，完整的单元测试，可扩展的设计。</p>
</blockquote>
<h2 id="删除的-HTTP-状态返回码是什么"><a href="#删除的-HTTP-状态返回码是什么" class="headerlink" title="删除的 HTTP 状态返回码是什么 ?"></a>删除的 HTTP 状态返回码是什么 ?</h2><p>在删除成功之后，您的 REST API 应该返回什么状态代码，并没有严格的规则。它可以返回 200 或 204 没有内容。</p>
<ul>
<li>一般来说，如果删除操作成功，响应主体为空，返回 <a href="http://www.netingcn.com/http-status-204.html">204</a> 。</li>
<li>如果删除请求成功且响应体不是空的，则返回 200 。</li>
</ul>
<h2 id="REST-API-是无状态的吗"><a href="#REST-API-是无状态的吗" class="headerlink" title="REST API 是无状态的吗?"></a>REST API 是无状态的吗?</h2><p><strong>是的</strong>，REST API 应该是无状态的，因为它是基于 HTTP 的，它也是无状态的。</p>
<p>REST API 中的请求应该包含处理它所需的所有细节。它<strong>不应该</strong>依赖于以前或下一个请求或服务器端维护的一些数据，例如会话。</p>
<p><strong>REST 规范为使其无状态设置了一个约束，在设计 REST API 时，您应该记住这一点</strong>。</p>
<h2 id="REST安全吗-你能做什么来保护它"><a href="#REST安全吗-你能做什么来保护它" class="headerlink" title="REST安全吗? 你能做什么来保护它?"></a>REST安全吗? 你能做什么来保护它?</h2><p>安全是一个宽泛的术语。它可能意味着消息的安全性，这是通过认证和授权提供的加密或访问限制提供的。</p>
<p>REST 通常不是安全的，但是您可以通过使用 Spring Security 来保护它。</p>
<ul>
<li>至少，你可以通过在 Spring Security 配置文件中使用 HTTP 来启用 HTTP Basic Auth 基本认证。</li>
<li>类似地，如果底层服务器支持 HTTPS ，你可以使用 HTTPS 公开 REST API 。</li>
</ul>
<h2 id="RestTemplate-的优势是什么"><a href="#RestTemplate-的优势是什么" class="headerlink" title="RestTemplate 的优势是什么?"></a>RestTemplate 的优势是什么?</h2><p>在 Spring Framework 中，RestTemplate 类是 <a href="http://www.java67.com/2012/09/top-10-java-design-pattern-interview-question-answer.html">模板方法模式</a> 的实现。跟其他主流的模板类相似，如 JdbcTemplate 或 JmsTempalte ，它将在客户端简化跟 RESTful Web  服务的集成。正如在 RestTemplate 例子中显示的一样，你能非常容易地用它来调用 RESTful Web 服务。</p>
<blockquote>
<p>艿艿：当然，实际场景我还是更喜欢使用 <a href="http://square.github.io/okhttp/">OkHttp</a> 作为 HTTP 库，因为更好的性能，使用也便捷，并且无需依赖 Spring 库。</p>
</blockquote>
<h2 id="HttpMessageConverter-在-Spring-REST-中代表什么"><a href="#HttpMessageConverter-在-Spring-REST-中代表什么" class="headerlink" title="HttpMessageConverter 在 Spring REST 中代表什么?"></a>HttpMessageConverter 在 Spring REST 中代表什么?</h2><p>HttpMessageConverter 是一种<a href="http://www.java67.com/2014/12/strategy-pattern-in-java-with-example.html">策略接口</a> ，它指定了一个转换器，它可以转换 HTTP 请求和响应。Spring REST 用这个接口转换 HTTP 响应到多种格式，例如：JSON 或 XML 。</p>
<p>每个 HttpMessageConverter 实现都有一种或几种相关联的MIME协议。Spring 使用 <code>&quot;Accept&quot;</code> 的标头来确定客户端所期待的内容类型。</p>
<p>然后，它将尝试找到一个注册的 HTTPMessageConverter ，它能够处理特定的内容类型，并使用它将响应转换成这种格式，然后再将其发送给客户端。</p>
<p>如果胖友对 HttpMessageConverter 不了解，可以看看 <a href="https://leokongwq.github.io/2017/06/14/spring-MessageConverter.html">《Spring 中 HttpMessageConverter 详解》</a> 。</p>
<h2 id="如何创建-HttpMessageConverter-的自定义实现来支持一种新的请求-响应？"><a href="#如何创建-HttpMessageConverter-的自定义实现来支持一种新的请求-响应？" class="headerlink" title="如何创建 HttpMessageConverter 的自定义实现来支持一种新的请求/响应？"></a>如何创建 HttpMessageConverter 的自定义实现来支持一种新的请求/响应？</h2><p>我们仅需要创建自定义的 AbstractHttpMessageConverter 的实现，并使用 WebMvcConfigurerAdapter 的 <code>#extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</code> 方法注中册它，该方法可以生成一种新的请求 / 响应类型。</p>
<p>具体的示例，可以学习 <a href="https://github.com/alibaba/fastjson/wiki/%E5%9C%A8-Spring-%E4%B8%AD%E9%9B%86%E6%88%90-Fastjson">《在 Spring 中集成 Fastjson》</a> 文章。</p>
<h2 id="PathVariable-注解，在-Spring-MVC-做了什么-为什么-REST-在-Spring-中如此有用？"><a href="#PathVariable-注解，在-Spring-MVC-做了什么-为什么-REST-在-Spring-中如此有用？" class="headerlink" title="@PathVariable 注解，在 Spring MVC 做了什么? 为什么 REST 在 Spring 中如此有用？"></a>@PathVariable 注解，在 Spring MVC 做了什么? 为什么 REST 在 Spring 中如此有用？</h2><p><code>@PathVariable</code> 注解，是 Spring MVC 中有用的注解之一，它允许您从 URI 读取值，比如查询参数。它在使用 Spring 创建 RESTful Web 服务时特别有用，因为在 REST 中，资源标识符是 URI 的一部分。</p>
<p>具体的使用示例，胖友如果不熟悉，可以看看 <a href="https://blog.csdn.net/cx361006796/article/details/52829759">《Spring MVC 的 @RequestParam 注解和 @PathVariable 注解的区别》</a> 。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>文末的文末，艿艿还是那句话！！！！还是非常推荐胖友去撸一撸 Spring MVC 的源码，特别是如下两篇：</p>
<ul>
<li><a href="http://svip.iocoder.cn/Spring-MVC/Components-intro/">《精尽 Spring MVC 源码分析 —— 组件一览》</a></li>
<li><a href="http://svip.iocoder.cn/Spring-MVC/DispatcherServlet-process-request-intro/">《精尽 Spring MVC 源码分析 —— 请求处理一览》</a></li>
</ul>
<p>参考和推荐如下文章：</p>
<ul>
<li><a href="http://www.spring4all.com/article/1445">《排名前 20 的 REST 和 Spring MVC 面试题》</a></li>
<li><a href="http://www.iocoder.cn/Fight/Learn-Restful-HTTP-API-design-from-Github/">《跟着 Github 学习 Restful HTTP API 的优雅设计》</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring MVC</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>4</title>
    <url>/2016/10/12/4/</url>
    <content><![CDATA[<h1 id="精尽-Spring-Boot-面试题"><a href="#精尽-Spring-Boot-面试题" class="headerlink" title="精尽 Spring Boot 面试题"></a>精尽 Spring Boot 面试题</h1><p>以下面试题，基于网络整理，和自己编辑。具体参考的文章，会在文末给出所有的链接。</p>
<p>如果胖友有自己的疑问，欢迎在星球提问，我们一起整理吊吊的 Spring Boot 面试题的大保健。</p>
<p>而题目的难度，艿艿尽量按照从容易到困难的顺序，逐步下去。</p>
<p>在内容上，我们会分成两大块：</p>
<ul>
<li>核心技术篇，分享 Spring Boot 的核心技术相关的内容。</li>
<li>整合篇，分享 Spring Boot 整合一些框架的面试题，例如 JPA 如何集成到 Spring Boot 中。</li>
</ul>
<h1 id="核心技术篇"><a href="#核心技术篇" class="headerlink" title="核心技术篇"></a>核心技术篇</h1><h2 id="Spring-Boot-是什么？"><a href="#Spring-Boot-是什么？" class="headerlink" title="Spring Boot 是什么？"></a>Spring Boot 是什么？</h2><p><a href="https://github.com/spring-projects/spring-boot">Spring Boot</a> 是 Spring 的<strong>子项目</strong>，正如其名字，提供 Spring 的引导( <strong>Boot</strong> )的功能。</p>
<p>通过 Spring Boot ，我们开发者可以快速配置 Spring 项目，引入各种 Spring MVC、Spring  Transaction、Spring AOP、MyBatis 等等框架，而无需不断重复编写繁重的 Spring 配置，降低了 Spring  的使用成本。</p>
<blockquote>
<p>艿艿：犹记当年，Spring XML 为主的时代，大晚上各种搜索 Spring 的配置，苦不堪言。现在有了 Spring Boot 之后，生活真美好。</p>
</blockquote>
<p>Spring Boot 提供了各种 Starter 启动器，提供标准化的默认配置。例如：</p>
<ul>
<li><a href="https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web/2.1.1.RELEASE"><code>spring-boot-starter-web</code></a> 启动器，可以快速配置 Spring MVC 。</li>
<li><a href="https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter/1.3.2"><code>mybatis-spring-boot-starter</code></a> 启动器，可以快速配置 MyBatis 。 </li>
</ul>
<p>并且，Spring Boot 基本已经一统 Java 项目的开发，大量的开源项目都实现了其的 Starter 启动器。例如：</p>
<ul>
<li><a href="https://github.com/apache/incubator-dubbo-spring-boot-project"><code>incubator-dubbo-spring-boot-project</code></a> 启动器，可以快速配置 Dubbo 。</li>
<li><a href="https://github.com/maihaoche/rocketmq-spring-boot-starter"><code>rocketmq-spring-boot-starter</code></a> 启动器，可以快速配置 RocketMQ 。</li>
</ul>
<h2 id="Spring-Boot-提供了哪些核心功能？"><a href="#Spring-Boot-提供了哪些核心功能？" class="headerlink" title="Spring Boot 提供了哪些核心功能？"></a>Spring Boot 提供了哪些核心功能？</h2><ul>
<li><p>1、独立运行 Spring 项目</p>
<p>  Spring Boot 可以以 jar 包形式独立运行，运行一个 Spring Boot 项目只需要通过 <code>java -jar xx.jar</code> 来运行。</p>
</li>
<li><p>2、内嵌 Servlet 容器</p>
<p>  Spring Boot 可以选择内嵌 Tomcat、Jetty 或者 Undertow，这样我们无须以 war 包形式部署项目。</p>
<blockquote>
<p>第 2 点是对第 1 点的补充，在 Spring Boot 未出来的时候，大多数 Web 项目，是打包成 war 包，部署到 Tomcat、Jetty 等容器。</p>
</blockquote>
</li>
<li><p>3、提供 Starter 简化 Maven 配置</p>
<p>  Spring 提供了一系列的 starter pom 来简化 Maven 的依赖加载。例如，当你使用了 <code>spring-boot-starter-web</code> ，会自动加入如下依赖：<a href="http://static2.iocoder.cn/images/Spring/2018-12-26/01.png">![<code>spring-boot-starter-web</code> 的 pom 文件](D:\新建文件夹 (3)\01.png)</a><code>spring-boot-starter-web</code> 的 pom 文件</p>
</li>
<li><p>4、<a href="https://www.jianshu.com/p/ddb6e32e3faf">自动配置 Spring Bean</a></p>
<p>  Spring Boot 检测到特定类的存在，就会针对这个应用做一定的配置，进行自动配置 Bean ，这样会极大地减少我们要使用的配置。</p>
<p>  当然，Spring Boot 只考虑大多数的开发场景，并不是所有的场景，若在实际开发中我们需要配置Bean ，而 Spring Boot 没有提供支持，则可以自定义自动配置进行解决。</p>
</li>
<li><p>5、<a href="https://blog.csdn.net/wangshuang1631/article/details/72810412">准生产的应用监控</a></p>
<p>  Spring Boot 提供基于 HTTP、JMX、SSH 对运行时的项目进行监控。</p>
</li>
<li><p>6、无代码生成和 XML 配置</p>
<p>  Spring Boot 没有引入任何形式的代码生成，它是使用的 Spring 4.0 的条件 <code>@Condition</code> 注解以实现根据条件进行配置。同时使用了  Maven /Gradle 的<strong>依赖传递解析机制</strong>来实现 Spring 应用里面的自动配置。</p>
<blockquote>
<p>第 6 点是第 3 点的补充。</p>
</blockquote>
</li>
</ul>
<h2 id="Spring-Boot-有什么优缺点？"><a href="#Spring-Boot-有什么优缺点？" class="headerlink" title="Spring Boot 有什么优缺点？"></a>Spring Boot 有什么优缺点？</h2><blockquote>
<p>艿艿：任何技术栈，有优点必有缺点，没有银弹。</p>
<p>另外，这个问题的回答，我们是基于 <a href="https://blog.csdn.net/fly_zhyu/article/details/76407830">《Spring Boot浅谈(是什么/能干什么/优点和不足)》</a> 整理，所以胖友主要看下这篇文章。</p>
</blockquote>
<p><strong>Spring Boot 的优点</strong></p>
<blockquote>
<p>艿艿：优点和 <a href="http://svip.iocoder.cn/Spring-Boot/Interview/#">「Spring Boot 提供了哪些核心功能？」</a> 问题的答案，是比较重叠的。</p>
</blockquote>
<ul>
<li>1、使【编码】变简单。</li>
<li>2、使【配置】变简单。</li>
<li>3、使【部署】变简单。</li>
<li>4、使【监控】变简单。</li>
</ul>
<p><strong>Spring Boot 的缺点</strong></p>
<blockquote>
<p>艿艿：如下的缺点，基于 <a href="https://blog.csdn.net/fly_zhyu/article/details/76407830">《Spring Boot浅谈(是什么/能干什么/优点和不足)》</a>，考虑的出发点是把 Spring Boot 作为微服务的框架的选型的角度进行考虑。</p>
</blockquote>
<ul>
<li><p>1、没有提供相应的【服务发现和注册】的配套功能。</p>
<blockquote>
<p>艿艿：当然，实际上 Spring Boot 本身是不需要提供这样的功能。服务发现和注册的功能，是在 Spring Cloud 中进行提供。</p>
</blockquote>
</li>
<li><p>2、自身的 acturator 所提供的【监控功能】，也需要与现有的监控对接。</p>
</li>
<li><p>3、没有配套的【安全管控】方案。</p>
<blockquote>
<p>艿艿：关于这一点，艿艿也有点迷糊，Spring Security 是可以比较方便的集成到 Spring Boot 中，所以不晓得这里的【安全管控】的定义是什么。所以这一点，面试的时候回答，可以暂时先省略。</p>
</blockquote>
</li>
<li><p>4、对于 REST 的落地，还需要自行结合实际进行 URI 的规范化工作    </p>
<blockquote>
<p>艿艿：这个严格来说，不算缺点。本身，是规范的范畴。</p>
</blockquote>
</li>
</ul>
<p>所以，上面的缺点，严格来说可能不太适合在面试中回答。艿艿认为，Spring Boot 的缺点主要是，因为自动配置 Spring Bean  的功能，我们可能无法知道，哪些 Bean 被进行创建了。这个时候，如果我们想要自定义一些 Bean ，可能存在冲突，或者不知道实际注入的情况。</p>
<h2 id="Spring-Boot、Spring-MVC-和-Spring-有什么区别？"><a href="#Spring-Boot、Spring-MVC-和-Spring-有什么区别？" class="headerlink" title="Spring Boot、Spring MVC 和 Spring 有什么区别？"></a>Spring Boot、Spring MVC 和 Spring 有什么区别？</h2><p>Spring 的完整名字，应该是 Spring Framework 。它提供了多个模块，Spring IoC、Spring AOP、Spring MVC 等等。所以，Spring MVC 是 Spring Framework 众多模块中的一个。</p>
<p>而 Spring Boot 是构造在 Spring Framework 之上的 Boot 启动器，旨在更容易的配置一个 Spring 项目。</p>
<p>总结说来，如下图所示：<a href="http://static2.iocoder.cn/images/Spring/2018-12-26/02.png">![Spring Boot 对比 Spring MVC 对比 Spring ？](D:\新建文件夹 (3)\02.png)</a>Spring Boot 对比 Spring MVC 对比 Spring ？</p>
<h2 id="Spring-Boot-中的-Starter-是什么？"><a href="#Spring-Boot-中的-Starter-是什么？" class="headerlink" title="Spring Boot 中的 Starter 是什么？"></a>Spring Boot 中的 Starter 是什么？</h2><p>比较<strong>通俗</strong>的说法：</p>
<blockquote>
<p>FROM <a href="https://www.cnblogs.com/EasonJim/p/7615801.html">《Spring Boot 中 Starter 是什么》</a></p>
<p>比如我们要在 Spring Boot 中引入 Web MVC 的支持时，我们通常会引入这个模块 <code>spring-boot-starter-web</code> ，而这个模块如果解压包出来会发现里面什么都没有，只定义了一些 <strong>POM</strong> 依赖。如下图所示：<a href="http://static2.iocoder.cn/images/Spring/2018-12-26/03.png">![<code>spring-boot-starter-web</code>](D:\新建文件夹 (3)\03.png)</a><code>spring-boot-starter-web</code></p>
<p>经过研究，Starter 主要用来简化依赖用的。比如我们之前做MVC时要引入日志组件，那么需要去找到log4j的版本，然后引入，现在有了Starter之后，直接用这个之后，log4j就自动引入了，也不用关心版本这些问题。</p>
</blockquote>
<p>比较<strong>书名</strong>的说法：</p>
<blockquote>
<p>FROM <a href="http://www.importnew.com/27101.html">《Spring Boot Starter 介绍》</a></p>
<p>依赖管理是任何复杂项目的关键部分。以手动的方式来实现依赖管理不太现实，你得花更多时间，同时你在项目的其他重要方面能付出的时间就会变得越少。</p>
<p>Spring Boot Starter 就是为了解决这个问题而诞生的。Starter <strong>POM</strong> 是一组方便的依赖描述符，您可以将其包含在应用程序中。您可以获得所需的所有 Spring 和相关技术的一站式服务，无需通过示例代码搜索和复制粘贴依赖。</p>
</blockquote>
<h2 id="Spring-Boot-常用的-Starter-有哪些？"><a href="#Spring-Boot-常用的-Starter-有哪些？" class="headerlink" title="Spring Boot 常用的 Starter 有哪些？"></a>Spring Boot 常用的 Starter 有哪些？</h2><ul>
<li><code>spring-boot-starter-web</code> ：提供 Spring MVC + 内嵌的 Tomcat 。</li>
<li><code>spring-boot-starter-data-jpa</code> ：提供 Spring JPA + Hibernate 。</li>
<li><code>spring-boot-starter-data-redis</code> ：提供 Redis 。</li>
<li><code>mybatis-spring-boot-starter</code> ：提供 MyBatis 。</li>
</ul>
<h2 id="创建一个-Spring-Boot-Project-的最简单的方法是什么？"><a href="#创建一个-Spring-Boot-Project-的最简单的方法是什么？" class="headerlink" title="创建一个 Spring Boot Project 的最简单的方法是什么？"></a>创建一个 Spring Boot Project 的最简单的方法是什么？</h2><p>Spring Initializr 是创建 Spring Boot Projects 的一个很好的工具。打开 <code>&quot;https://start.spring.io/&quot;</code> 网站，我们可以看到 Spring Initializr 工具，如下图所示：</p>
<p><a href="http://static2.iocoder.cn/images/Spring/2018-12-26/04.png">![Spring Initializr](D:\新建文件夹 (3)\04.png)</a>Spring Initializr</p>
<ul>
<li>图中的每一个<strong>红线</strong>，都可以填写相应的配置。相信胖友都很熟悉，就不哔哔了。</li>
<li>点击生 GenerateProject ，生成 Spring Boot Project 。</li>
<li>将项目导入 IDEA ，记得选择现有的 Maven 项目。</li>
</ul>
<hr>
<p>当然，我们以前使用 IDEA 创建 Spring 项目的方式，也一样能创建 Spring Boot Project 。Spring Initializr 更多的是，提供一个便捷的工具。</p>
<h2 id="如何统一引入-Spring-Boot-版本？"><a href="#如何统一引入-Spring-Boot-版本？" class="headerlink" title="如何统一引入 Spring Boot 版本？"></a>如何统一引入 Spring Boot 版本？</h2><p><strong>目前有两种方式</strong>。</p>
<p>① 方式一：继承 <code>spring-boot-starter-parent</code> 项目。配置代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;parent&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;1.5.1.RELEASE&lt;&#x2F;version&gt;<br>&lt;&#x2F;parent&gt;<br></code></pre></td></tr></table></figure>

<p>② 方式二：导入 spring-boot-dependencies 项目依赖。配置代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dependencyManagement&gt;<br>    &lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>            &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;<br>            &lt;version&gt;1.5.1.RELEASE&lt;&#x2F;version&gt;<br>            &lt;type&gt;pom&lt;&#x2F;type&gt;<br>            &lt;scope&gt;import&lt;&#x2F;scope&gt;<br>        &lt;&#x2F;dependency&gt;<br>    &lt;&#x2F;dependencies&gt;<br>&lt;&#x2F;dependencyManagement&gt;<br></code></pre></td></tr></table></figure>

<p><strong>如何选择？</strong></p>
<p>因为一般我们的项目中，都有项目自己的 Maven parent 项目，所以【方式一】显然会存在冲突。所以实际场景下，推荐使用【方式二】。</p>
<p>详细的，推荐阅读 <a href="https://blog.csdn.net/rainbow702/article/details/55046298">《Spring Boot 不使用默认的 parent，改用自己的项目的 parent》</a> 文章。</p>
<p>另外，在使用 Spring Cloud 的时候，也可以使用这样的方式。</p>
<h2 id="运行-Spring-Boot-有哪几种方式？"><a href="#运行-Spring-Boot-有哪几种方式？" class="headerlink" title="运行 Spring Boot 有哪几种方式？"></a>运行 Spring Boot 有哪几种方式？</h2><ul>
<li>1、打包成 Fat Jar ，直接使用 <code>java -jar</code> 运行。目前主流的做法，推荐。</li>
<li>2、在 IDEA 或 Eclipse 中，直接运行应用的 Spring Boot 启动类的 <code>#main(String[] args)</code> 启动。适用于开发调试场景。</li>
<li>3、如果是 Web 项目，可以打包成 War 包，使用外部 Tomcat 或 Jetty 等容器。</li>
</ul>
<h2 id="如何打包-Spring-Boot-项目？"><a href="#如何打包-Spring-Boot-项目？" class="headerlink" title="如何打包 Spring Boot 项目？"></a>如何打包 Spring Boot 项目？</h2><p>通过引入 <code>spring-boot-maven-plugin</code> 插件，执行 <code>mvn clean package</code> 命令，将 Spring Boot 项目打成一个 Fat Jar 。后续，我们就可以直接使用 <code>java -jar</code> 运行。</p>
<p>关于 <code>spring-boot-maven-plugin</code> 插件，更多详细的可以看看 [《创建可执行 jar》](<a href="https://qbgbook.gitbooks.io/spring-boot-reference-guide-zh/II">https://qbgbook.gitbooks.io/spring-boot-reference-guide-zh/II</a>. Getting started/11.5. Creating an executable jar.html) 。</p>
<h2 id="如果更改内嵌-Tomcat-的端口？"><a href="#如果更改内嵌-Tomcat-的端口？" class="headerlink" title="如果更改内嵌 Tomcat 的端口？"></a>如果更改内嵌 Tomcat 的端口？</h2><ul>
<li><p>方式一，修改 <code>application.properties</code> 配置文件的 <code>server.port</code> 属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">server.port&#x3D;9090<br></code></pre></td></tr></table></figure>
</li>
<li><p>方式二，通过启动命令增加 <code>server.port</code> 参数进行修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">java -jar xxx.jar --server.port&#x3D;9090<br></code></pre></td></tr></table></figure>

</li>
</ul>
<p>当然，以上的方式，不仅仅适用于 Tomcat ，也适用于 Jetty、Undertow 等服务器。</p>
<h2 id="如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？"><a href="#如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？" class="headerlink" title="如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？"></a>如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？</h2><p>一共有三种方式，可以实现效果：</p>
<ul>
<li><p>【推荐】<code>spring-boot-devtools</code> 插件。注意，这个工具需要配置 IDEA 的自动编译。</p>
</li>
<li><p>Spring Loaded 插件。</p>
<blockquote>
<p>Spring Boot 2.X 后，官方宣布不再支持 Spring Loaded 插件 的更新，所以基本可以无视它了。</p>
</blockquote>
</li>
<li><p><a href="https://www.jianshu.com/p/bab43eaa4e14">JRebel</a> 插件，需要付费。</p>
</li>
</ul>
<p>关于如何使用 <code>spring-boot-devtools</code> 和 Spring Loaded 插件，胖友可以看看 <a href="https://segmentfault.com/a/1190000014488100">《Spring Boot 学习笔记：Spring Boot Developer Tools 与热部署》</a> 。</p>
<h2 id="Spring-Boot-的配置文件有哪几种格式？"><a href="#Spring-Boot-的配置文件有哪几种格式？" class="headerlink" title="Spring Boot 的配置文件有哪几种格式？"></a>Spring Boot 的配置文件有哪几种格式？</h2><p>Spring Boot 目前支持两种格式的配置文件：</p>
<ul>
<li><p><code>.properties</code> 格式。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">server.port &#x3D; 9090<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>.yaml</code> 格式。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">server:<br>    port: 9090<br></code></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<p>可能有胖友不了解 <strong>YAML 格式</strong>？</p>
<p>YAML 是一种人类可读的数据序列化语言，它通常用于配置文件。</p>
<ul>
<li><p>与 Properties 文件相比，如果我们想要在配置文件中添加复杂的属性 YAML 文件就更加<strong>结构化</strong>。从上面的示例，我们可以看出 YAML 具有<strong>分层</strong>配置数据。</p>
</li>
<li><p>当然 YAML 在 Spring 会存在一个缺陷，</p>
<p><code>@PropertySource</code></p>
<p> 注解不支持读取 YAML 配置文件，仅支持 Properties 配置文件。</p>
<ul>
<li>不过这个问题也不大，可以麻烦一点使用 <a href="https://blog.csdn.net/lafengwnagzi/article/details/74178374"><code>@Value</code></a> 注解，来读取 YAML 配置项。</li>
</ul>
</li>
</ul>
<p>实际场景下，艿艿相对比较喜欢使用 Properties 配置文件。个人喜欢~当然，YAML 已经越来越流行了。</p>
<h2 id="Spring-Boot-默认配置文件是什么？"><a href="#Spring-Boot-默认配置文件是什么？" class="headerlink" title="Spring Boot 默认配置文件是什么？"></a>Spring Boot 默认配置文件是什么？</h2><p>对于 Spring Boot 应用，默认的配置文件根目录下的 <strong>application</strong> 配置文件，当然可以是 Properties 格式，也可以是 YAML 格式。</p>
<p>可能有胖友说，我在网上看到面试题中，说还有一个根目录下的 <strong>bootstrap</strong> 配置文件。这个是 Spring Cloud 新增的启动配置文件，<a href="https://my.oschina.net/freeskyjs/blog/1843048">需要引入 <code>spring-cloud-context</code> 依赖后，才会进行加载</a>。它的特点和用途主要是：</p>
<blockquote>
<p>参考 <a href="https://my.oschina.net/neverforget/blog/1525947">《Spring Cloud 中配置文件名 bootstrap.yml 和 application.yml 区别》</a> 文章。</p>
</blockquote>
<ul>
<li>【特点】因为 bootstrap 由父 ApplicationContext 加载，比 application 优先加载。</li>
<li>【特点】因为 bootstrap 优先于 application 加载，所以不会被它覆盖。 </li>
<li>【用途】使用配置中心 Spring Cloud Config 时，需要在 bootstrap 中配置配置中心的地址，从而实现父 ApplicationContext 加载时，从配置中心拉取相应的配置到应用中。</li>
</ul>
<p>另外，<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html">《Appendix A. Common application properties》</a> 中，有 application 配置文件的通用属性列表。</p>
<h2 id="Spring-Boot-如何定义多套不同环境配置？"><a href="#Spring-Boot-如何定义多套不同环境配置？" class="headerlink" title="Spring Boot 如何定义多套不同环境配置？"></a>Spring Boot 如何定义多套不同环境配置？</h2><p>可以参考 <a href="https://blog.csdn.net/top_code/article/details/78570047">《Spring Boot 教程 - Spring Boot Profiles 实现多环境下配置切换》</a> 一文。</p>
<p>但是，需要考虑一个问题，生产环境的配置文件的安全性，显然我们不能且不应该把生产的配置放到项目的 Git 仓库中进行管理。那么应该怎么办呢？</p>
<ul>
<li>方案一，生产环境的配置文件放在生产环境的服务器中，以 <code>java -jar myproject.jar --spring.config.location=/xxx/yyy/application-prod.properties</code> 命令，设置 参数 <code>spring.config.location</code> 指向配置文件。</li>
<li>方案二，使用 Jenkins 在执行打包，配置上 Maven Profile 功能，使用服务器上的配置文件。😈 整体来说，和【方案一】的差异是，将配置文件打包进了 Jar 包中。</li>
<li>方案三，使用配置中心。</li>
</ul>
<h2 id="Spring-Boot-配置加载顺序？"><a href="#Spring-Boot-配置加载顺序？" class="headerlink" title="Spring Boot 配置加载顺序？"></a>Spring Boot 配置加载顺序？</h2><p>在 Spring Boot 中，除了我们常用的 application 配置文件之外，还有：</p>
<ul>
<li>系统环境变量</li>
<li>命令行参数</li>
<li>等等…</li>
</ul>
<p>参考 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html">《Externalized Configuration》</a> 文档，我们整理顺序如下：</p>
<ol>
<li><pre><code>spring-boot-devtools
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>依赖的 <br><br></code></pre></td></tr></table></figure>
spring-boot-devtools.properties
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>    配置文件。<br><br>   &gt; 这个灰常小众，具体说明可以看看 [《Spring Boot参考文档（12）开发者工具》](https:&#x2F;&#x2F;blog.csdn.net&#x2F;u011499747&#x2F;article&#x2F;details&#x2F;71746325) ，建议无视。<br><br>2. 单元测试上的 <br><br></code></pre></td></tr></table></figure>
@TestPropertySource
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>和 <br><br></code></pre></td></tr></table></figure>
@SpringBootTest
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>    注解指定的参数。<br><br>   &gt; 前者的优先级高于后者。可以看看 [《Spring、Spring Boot 和TestNG 测试指南 - @TestPropertySource》](https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000010854607) 一文。<br><br>3. 命令行指定的参数。例如 &#96;java -jar springboot.jar --server.port&#x3D;9090&#96; 。<br><br>4. 命令行中的 &#96;spring.application.json&#96; 指定参数。例如 &#96;java -Dspring.application.json&#x3D;&#39;&#123;&quot;name&quot;:&quot;Java&quot;&#125;&#39; -jar springboot.jar&#96; 。<br><br>5. ServletConfig 初始化参数。<br><br>6. ServletContext 初始化参数。<br><br>7. JNDI 参数。例如 &#96;java:comp&#x2F;env&#96; 。<br><br>8. Java 系统变量，即 &#96;System#getProperties()&#96; 方法对应的。<br><br>9. 操作系统环境变量。<br><br>10. RandomValuePropertySource 配置的 &#96;random.*&#96; 属性对应的值。<br><br>11. Jar **外部**的带指定 profile 的 application 配置文件。例如 &#96;application-&#123;profile&#125;.yaml&#96; 。<br><br>12. Jar **内部**的带指定 profile 的 application 配置文件。例如 &#96;application-&#123;profile&#125;.yaml&#96; 。<br><br>13. Jar **外部** application 配置文件。例如 &#96;application.yaml&#96; 。<br><br>14. Jar **内部** application 配置文件。例如 &#96;application.yaml&#96; 。<br><br>15. 在自定义的 &#96;@Configuration&#96; 类中定于的 &#96;@PropertySource&#96; 。<br><br>16. 启动的 main 方法中，定义的默认配置。即通过 &#96;SpringApplication#setDefaultProperties(Map&lt;String, Object&gt; defaultProperties)&#96; 方法进行设置。<br><br>嘿嘿，是不是很多很长，不用真的去记住。<br><br>- 一般来说，面试官不会因为这个题目回答的不好，对你扣分。<br>- 实际使用时，做下测试即可。<br>- 每一种配置方式的详细说明，可以看看 [《Spring Boot 参考指南（外部化配置）》](https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000015069140) 。<br><br>## Spring Boot 有哪些配置方式？<br><br>和 Spring 一样，一共提供了三种方式。<br><br>- 1、XML 配置文件。<br><br>    Bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：<br><br></code></pre></td></tr></table></figure>
&lt;bean id=&quot;studentBean&quot; class=&quot;org.edureka.firstSpring.StudentBean&quot;&gt;
   &lt;property name=&quot;name&quot; value=&quot;Edureka&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>- 2、注解配置。<br><br>    您可以通过在相关的类，方法或字段声明上使用注解，将 Bean 配置为组件类本身，而不是使用 XML 来描述 Bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：<br><br></code></pre></td></tr></table></figure>
&lt;beans&gt;
&lt;context:annotation-config/&gt;
&lt;!-- bean definitions go here --&gt;
&lt;/beans&gt;
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>- 3、Java Config 配置。<br><br>    Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。<br><br>  - &#96;@Bean&#96; 注解扮演与 &#96;&lt;bean &#x2F;&gt;&#96; 元素相同的角色。<br><br>  - &#96;@Configuration&#96; 类允许通过简单地调用同一个类中的其他 &#96;@Bean&#96; 方法来定义 Bean 间依赖关系。<br><br>  - 例如：<br><br></code></pre></td></tr></table></figure>
 @Configuration
 public class StudentConfig &#123;

     @Bean
     public StudentBean myStudent() &#123;
         return new StudentBean();
     &#125;

 &#125;
 <figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>    - 是不是很熟悉 😈<br><br>目前主要使用 **Java Config** 配置为主。当然，三种配置方式是可以混合使用的。例如说：<br><br>- Dubbo 服务的配置，艿艿喜欢使用 XML 。<br>- Spring MVC 请求的配置，艿艿喜欢使用 &#96;@RequestMapping&#96; 注解。<br>- Spring MVC 拦截器的配置，艿艿喜欢 Java Config 配置。<br><br>------<br><br>另外，现在已经是 Spring Boot 的天下，所以更加是 **Java Config** 配置为主。<br><br>## Spring Boot 的核心注解是哪个？<br><br></code></pre></td></tr></table></figure>
package cn.iocoder.skywalking.web01;
</code></pre>
</li>
</ol>
<p>import org.springframework.boot.SpringApplication;<br>import org.springframework.boot.autoconfigure.SpringBootApplication;</p>
<p>@SpringBootApplication<br>public class Web01Application {</p>
<pre><code>public static void main(String[] args) &#123;
    SpringApplication.run(Web01Application.class, args);
&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>- &#96;@SpringBootApplication&#96; 注解，就是 Spring Boot 的核心注解。<br><br>&#96;org.springframework.boot.autoconfigure.@SpringBootApplication&#96; 注解的代码如下：<br><br></code></pre></td></tr></table></figure>
<p>// SpringBootApplication.java</p>
<p>@Target({ElementType.TYPE})<br>@Retention(RetentionPolicy.RUNTIME)<br>@Documented<br>@Inherited<br>@SpringBootConfiguration<br>@EnableAutoConfiguration<br>@ComponentScan(<br>    excludeFilters = {@Filter(<br>    type = FilterType.CUSTOM,<br>    classes = {TypeExcludeFilter.class}<br>), @Filter(<br>    type = FilterType.CUSTOM,<br>    classes = {AutoConfigurationExcludeFilter.class}<br>)}<br>)<br>public @interface SpringBootApplication {<br>    @AliasFor(<br>        annotation = EnableAutoConfiguration.class<br>    )<br>    Class&lt;?&gt;[] exclude() default {};</p>
<pre><code>@AliasFor(
    annotation = EnableAutoConfiguration.class
)
String[] excludeName() default &#123;&#125;;

@AliasFor(
    annotation = ComponentScan.class,
    attribute = &quot;basePackages&quot;
)
String[] scanBasePackages() default &#123;&#125;;

@AliasFor(
    annotation = ComponentScan.class,
    attribute = &quot;basePackageClasses&quot;
)
Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>- 它组合了 3 个注解，详细说明，胖友看看 [《Spring Boot 系列：@SpringBootApplication 注解》](https:&#x2F;&#x2F;blog.csdn.net&#x2F;claram&#x2F;article&#x2F;details&#x2F;75125749) 。<br><br>- &#96;@Configuration&#96; 注解，指定类是 **Bean 定义**的配置类。<br><br>  &gt; &#96;@Configuration&#96; 注解，来自 &#96;spring-context&#96; 项目，用于 Java Config ，不是 Spring Boot 新带来的。<br><br>- &#96;#ComponentScan&#96; 注解，扫描指定包下的 Bean 们。<br><br>  &gt; &#96;@ComponentScan&#96; 注解，来自 &#96;spring-context&#96; 项目，用于 Java Config ，不是 Spring Boot 新带来的。<br><br>- &#96;@EnableAutoConfiguration&#96; 注解，打开自动配置的功能。如果我们想要关闭某个类的自动配置，可以设置注解的 &#96;exclude&#96; 或 &#96;excludeName&#96; 属性。<br><br>  &gt; &#96;@EnableAutoConfiguration&#96; 注解，来自 &#96;spring-boot-autoconfigure&#96; 项目，**它才是 Spring Boot 新带来的**。<br><br>## 什么是 Spring Boot 自动配置？<br><br>在 [「Spring Boot 的核心注解是哪个？」](http:&#x2F;&#x2F;svip.iocoder.cn&#x2F;Spring-Boot&#x2F;Interview&#x2F;#) 中，我们已经看到，使用 &#96;@@EnableAutoConfiguration&#96; 注解，打开 Spring Boot 自动配置的功能。具体如何实现的，可以看看如下两篇文章：<br><br>- [《@EnableAutoConfiguration 注解的工作原理》](https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;464d04c36fb1) 。<br>- [《一个面试题引起的 Spring Boot 启动解析》](https:&#x2F;&#x2F;juejin.im&#x2F;post&#x2F;5b679fbc5188251aad213110)<br>- 建议，能一边调试，一边看这篇文章。调试很简单，任一搭建一个 Spring Boot 项目即可。<br><br>如下是一个比较简单的总结：<br><br>1. Spring Boot 在启动时扫描项目所依赖的 jar 包，寻找包含&#96;spring.factories&#96; 文件的 jar 包。<br>2. 根据 &#96;spring.factories&#96; 配置加载 AutoConfigure 类。<br>3. 根据 [&#96;@Conditional&#96; 等条件注解](http:&#x2F;&#x2F;svip.iocoder.cn&#x2F;Spring-Boot&#x2F;Interview&#x2F;Spring Boot 条件注解) 的条件，进行自动配置并将 Bean 注入 Spring IoC 中。<br><br>## Spring Boot 有哪几种读取配置的方式？<br><br>Spring Boot 目前支持 **2** 种读取配置：<br><br>1. &#96;@Value&#96; 注解，读取配置到属性。最最最常用。<br><br>   &gt; 另外，支持和 &#96;@PropertySource&#96; 注解一起使用，指定使用的配置文件。<br><br>2. &#96;@ConfigurationProperties&#96; 注解，读取配置到类上。<br><br>   &gt; 另外，支持和 &#96;@PropertySource&#96; 注解一起使用，指定使用的配置文件。<br><br>详细的使用方式，可以参考 [《Spring Boot 读取配置的几种方式》](https:&#x2F;&#x2F;aoyouzi.iteye.com&#x2F;blog&#x2F;2422837) 。<br><br>## 使用 Spring Boot 后，项目结构是怎么样的呢？<br><br>我们先来说说项目的分层。一般来说，主流的有两种方式：<br><br>- 方式一，&#96;controller&#96;、&#96;service&#96;、&#96;dao&#96; 三个包，每个包下面添加相应的 XXXController、YYYService、ZZZDAO 。<br>- 方式二，按照业务模块分包，每个包里面放 Controller、Service、DAO 类。例如，业务模块分成 &#96;user&#96;、&#96;order&#96;、&#96;item&#96; 等等包，在 &#96;user&#96; 包里放 UserController、UserService、UserDAO 类。<br><br>那么，使用 Spring Boot 的项目怎么分层呢？艿艿自己的想法<br><br>- 现在项目都会进行服务化分拆，每个项目不会特别复杂，所以建议使用【方式一】。<br>- 以前的项目，大多是单体的项目，动则项目几万到几十万的代码，当时多采用【方式二】。<br><br>下面是一个简单的 Spring Boot 项目的 Demo ，如下所示：[![Spring Boot 项目的 Demo](D:\新建文件夹 (3)\05.png)](http:&#x2F;&#x2F;static2.iocoder.cn&#x2F;images&#x2F;Spring&#x2F;2018-12-26&#x2F;05.png)Spring Boot 项目的 Demo<br><br>## 如何在 Spring Boot 启动的时候运行一些特殊的代码？<br><br>如果需要在 SpringApplication 启动后执行一些特殊的代码，你可以实现 ApplicationRunner 或 CommandLineRunner 接口，这两个接口工作方式相同，都只提供单一的 run 方法，该方法仅在 &#96;SpringApplication#run(...)&#96; 方法**完成之前调用**。<br><br>一般情况下，我们不太会使用该功能。如果真需要，胖友可以详细看看 [《使用 ApplicationRunner 或 CommandLineRunner 》](https:&#x2F;&#x2F;qbgbook.gitbooks.io&#x2F;spring-boot-reference-guide-zh&#x2F;IV. Spring Boot features&#x2F;23.8 Using the ApplicationRunner or CommandLineRunner.html) 。<br><br>## Spring Boot 2.X 有什么新特性？<br><br>1. 起步 JDK 8 和支持 JDK 9<br>2. 第三方库的升级<br>3. Reactive Spring<br>4. HTTP&#x2F;2 支持<br>5. 配置属性的绑定<br>6. Gradle 插件<br>7. Actuator 改进<br>8. 数据支持的改进<br>9. Web 的改进<br>10. 支持 Quartz 自动配置<br>11. 测试的改进<br>12. 其它…<br><br>详细的说明，可以看看 [《Spring Boot 2.0系列文章(二)：Spring Boot 2.0 新特性详解》](http:&#x2F;&#x2F;www.54tianzhisheng.cn&#x2F;2018&#x2F;03&#x2F;06&#x2F;SpringBoot2-new-features) 。<br><br># 整合篇<br><br>## 如何将内嵌服务器换成 Jetty ？<br><br>默认情况下，&#96;spring-boot-starter-web&#96; 模块使用 Tomcat 作为内嵌的服务器。所以需要去除对 &#96;spring-boot-starter-tomcat&#96; 模块的引用，添加 &#96;spring-boot-starter-jetty&#96; 模块的引用。代码如下：<br><br></code></pre></td></tr></table></figure>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <exclusion> <!-- 去除 Tomcat -->
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
        </exclusion>
    </exclusions>
</dependency>
<dependency> <!-- 引入 Jetty -->
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jetty</artifactId>
</dependency>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>## Spring Boot 中的监视器 Actuator 是什么？<br><br>&#96;spring-boot-actuator&#96; 提供 Spring Boot 的监视器功能，可帮助我们访问生产环境中正在运行的应用程序的**当前状态**。<br><br>- 关于 Spring Boot Actuator 的教程，可以看看 [《Spring Boot Actuator 使用》](https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;af9738634a21) 。<br>- 上述教程是基于 Spring Boot 1.X 的版本，如果胖友使用 Spring Boot 2.X 的版本，你将会发现 &#96;&#x2F;beans&#96; 等 Endpoint 是不存在的，参考 [《Spring boot 2 - Actuator endpoint, where is &#x2F;beans endpoint》](https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;49174700&#x2F;spring-boot-2-actuator-endpoint-where-is-beans-endpoint) 问题来解决。<br><br>**安全性**<br><br>Spring Boot 2.X 默认情况下，&#96;spring-boot-actuator&#96; 产生的 Endpoint 是没有安全保护的，但是 Actuator 可能暴露敏感信息。<br><br>所以一般的做法是，引入 &#96;spring-boot-start-security&#96; 依赖，使用 Spring Security 对它们进行安全保护。<br><br>## 如何集成 Spring Boot 和 Spring MVC ？<br><br>1. 引入 &#96;spring-boot-starter-web&#96; 的依赖。<br><br>2. 实现 WebMvcConfigurer 接口，可添加自定义的 Spring MVC 配置。<br><br>   &gt; 因为 Spring Boot 2 基于 JDK 8 的版本，而 JDK 8 提供 &#96;default&#96; 方法，所以 Spring Boot 2 废弃了 WebMvcConfigurerAdapter 适配类，直接使用 WebMvcConfigurer 即可。<br><br></code></pre></td></tr></table></figure>
   // WebMvcConfigurer.java
   public interface WebMvcConfigurer {

<pre><code>   /** 配置路径匹配器 **/
   default void configurePathMatch(PathMatchConfigurer configurer) &#123;&#125;

   /** 配置内容裁决的一些选项 **/
   default void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123; &#125;

   /** 异步相关的配置 **/
   default void configureAsyncSupport(AsyncSupportConfigurer configurer) &#123; &#125;

   default void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; &#125;

   default void addFormatters(FormatterRegistry registry) &#123;
   &#125;

   /** 添加拦截器 **/
   default void addInterceptors(InterceptorRegistry registry) &#123; &#125;

   /** 静态资源处理 **/
   default void addResourceHandlers(ResourceHandlerRegistry registry) &#123; &#125;

   /** 解决跨域问题 **/
   default void addCorsMappings(CorsRegistry registry) &#123; &#125;

   default void addViewControllers(ViewControllerRegistry registry) &#123; &#125;

   /** 配置视图解析器 **/
   default void configureViewResolvers(ViewResolverRegistry registry) &#123; &#125;

   /** 添加参数解析器 **/
   default void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) &#123;
   &#125;

   /** 添加返回值处理器 **/
   default void addReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler&gt; handlers) &#123; &#125;

   /** 这里配置视图解析器 **/
   default void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; &#125;

   /** 配置消息转换器 **/
   default void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123; &#125;

  /** 配置异常处理器 **/
   default void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123; &#125;

   default void extendHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123; &#125;

   @Nullable
   default Validator getValidator() &#123; return null; &#125;

   @Nullable
   default MessageCodesResolver getMessageCodesResolver() &#123;  return null; &#125;</code></pre>
<p>   }</p>
<p>   ```</p>
<hr>
<p>在使用 Spring MVC 时，我们一般会做如下几件事情：</p>
<ol>
<li>实现自己项目需要的拦截器，并在 WebMvcConfigurer 实现类中配置。可参见 <a href="https://github.com/YunaiV/oceans/blob/2a2d3746905f1349e260e88049e7e28346c7648f/bff/webapp-bff/src/main/java/cn/iocoder/oceans/webapp/bff/config/MVCConfiguration.java">MVCConfiguration</a> 类。</li>
<li>配置 <code>@ControllerAdvice</code> + <code>@ExceptionHandler</code> 注解，实现全局异常处理。可参见 <a href="https://github.com/YunaiV/oceans/blob/2a2d3746905f1349e260e88049e7e28346c7648f/bff/webapp-bff/src/main/java/cn/iocoder/oceans/webapp/bff/config/GlobalExceptionHandler.java">GlobalExceptionHandler</a> 类。</li>
<li>配置 <code>@ControllerAdvice</code> ，实现 ResponseBodyAdvice 接口，实现全局统一返回。可参见 <a href="https://github.com/YunaiV/oceans/blob/2a2d3746905f1349e260e88049e7e28346c7648f/bff/webapp-bff/src/main/java/cn/iocoder/oceans/webapp/bff/config/GlobalResponseBodyAdvice.java">GlobalResponseBodyAdvice</a> 。</li>
</ol>
<p>当然，有一点需要注意，WebMvcConfigurer、ResponseBodyAdvice、<code>@ControllerAdvice</code>、<code>@ExceptionHandler</code> 接口，都是 Spring MVC 框架自身已经有的东西。</p>
<ul>
<li><code>spring-boot-starter-web</code> 的依赖，帮我们解决的是 Spring MVC 的依赖以及相关的 Tomcat 等组件。</li>
</ul>
<h2 id="如何集成-Spring-Boot-和-Spring-Security-？"><a href="#如何集成-Spring-Boot-和-Spring-Security-？" class="headerlink" title="如何集成 Spring Boot 和 Spring Security ？"></a>如何集成 Spring Boot 和 Spring Security ？</h2><p>目前比较主流的安全框架有两个：</p>
<ol>
<li>Spring Security</li>
<li>Apache Shiro</li>
</ol>
<p>对于任何项目来说，安全认证总是少不了，同样适用于使用 Spring Boot 的项目。相对来说，Spring Security 现在会比 Apache Shiro 更流行。</p>
<p>Spring Boot 和 Spring Security 的配置方式比较简单：</p>
<ol>
<li>引入 <code>spring-boot-starter-security</code> 的依赖。</li>
<li>继承 WebSecurityConfigurerAdapter ，添加<strong>自定义</strong>的安全配置。</li>
</ol>
<p>当然，每个项目的安全配置是不同的，需要胖友自己选择。更多详细的使用，建议认真阅读如下文章：</p>
<ul>
<li><a href="http://blog.didispace.com/springbootsecurity/">《Spring Boot中 使用 Spring Security 进行安全控制》</a> ，快速上手。</li>
<li><a href="http://www.iocoder.cn/Spring-Security/good-collection/">《Spring Security 实现原理与源码解析系统 —— 精品合集》</a> ，深入源码。</li>
</ul>
<p>另外，安全是一个很大的话题，感兴趣的胖友，可以看看 <a href="https://www.jdon.com/49653">《Spring Boot 十种安全措施》</a> 一文。</p>
<h2 id="如何集成-Spring-Boot-和-Spring-Security-OAuth2-？"><a href="#如何集成-Spring-Boot-和-Spring-Security-OAuth2-？" class="headerlink" title="如何集成 Spring Boot 和 Spring Security OAuth2 ？"></a>如何集成 Spring Boot 和 Spring Security OAuth2 ？</h2><p>参见 <a href="http://www.iocoder.cn/Spring-Security/OAuth2-learning/">《Spring Security OAuth2 入门》</a> 文章，内容有点多。</p>
<h2 id="如何集成-Spring-Boot-和-JPA-？"><a href="#如何集成-Spring-Boot-和-JPA-？" class="headerlink" title="如何集成 Spring Boot 和 JPA ？"></a>如何集成 Spring Boot 和 JPA ？</h2><ol>
<li>引入 <code>spring-boot-starter-data-jpa</code> 的依赖。</li>
<li>在 application 配置文件中，加入 JPA 相关的少量配置。当然，数据库的配置也要添加进去。</li>
<li>具体编码。</li>
</ol>
<p>详细的使用，胖友可以参考：</p>
<ul>
<li><a href="http://www.iocoder.cn/Spring-Boot/battcn/v2-orm-jpa/">《一起来学 SpringBoot 2.x | 第六篇：整合 Spring Data JPA》</a></li>
</ul>
<p>有两点需要注意：</p>
<ul>
<li>Spring Boot 2 默认使用的数据库连接池是 <a href="https://github.com/brettwooldridge/HikariCP">HikariCP</a> ，目前最好的性能的数据库连接池的实现。</li>
<li><code>spring-boot-starter-data-jpa</code> 的依赖，使用的默认 JPA 实现是 Hibernate 5.X 。</li>
</ul>
<h2 id="如何集成-Spring-Boot-和-MyBatis-？"><a href="#如何集成-Spring-Boot-和-MyBatis-？" class="headerlink" title="如何集成 Spring Boot 和 MyBatis ？"></a>如何集成 Spring Boot 和 MyBatis ？</h2><ol>
<li>引入 <code>mybatis-spring-boot-starter</code> 的依赖。</li>
<li>在 application 配置文件中，加入 MyBatis 相关的少量配置。当然，数据库的配置也要添加进去。</li>
<li>具体编码。</li>
</ol>
<p>详细的使用，胖友可以参考：</p>
<ul>
<li><a href="http://www.iocoder.cn/Spring-Boot/battcn/v2-orm-mybatis/">《一起来学 SpringBoot 2.x | 第七篇：整合 Mybatis》</a></li>
</ul>
<h2 id="如何集成-Spring-Boot-和-RabbitMQ-？"><a href="#如何集成-Spring-Boot-和-RabbitMQ-？" class="headerlink" title="如何集成 Spring Boot 和 RabbitMQ ？"></a>如何集成 Spring Boot 和 RabbitMQ ？</h2><ol>
<li>引入 <code>spring-boot-starter-amqp</code> 的依赖</li>
<li>在 application 配置文件中，加入 RabbitMQ 相关的少量配置。</li>
<li>具体编码。</li>
</ol>
<p>详细的使用，胖友可以参考：</p>
<ul>
<li><a href="http://www.iocoder.cn/Spring-Boot/battcn/v2-queue-rabbitmq/">《一起来学 SpringBoot 2.x | 第十二篇：初探 RabbitMQ 消息队列》</a></li>
<li><a href="http://www.iocoder.cn/Spring-Boot/battcn/v2-queue-rabbitmq-delay/">《一起来学 SpringBoot 2.x | 第十三篇：RabbitMQ 延迟队列》</a></li>
</ul>
<h2 id="如何集成-Spring-Boot-和-Kafka-？"><a href="#如何集成-Spring-Boot-和-Kafka-？" class="headerlink" title="如何集成 Spring Boot 和 Kafka ？"></a>如何集成 Spring Boot 和 Kafka ？</h2><ol>
<li>引入 <code>spring-kafka</code> 的依赖。</li>
<li>在 application 配置文件中，加入 Kafka 相关的少量配置。</li>
<li>具体编码。</li>
</ol>
<p>详细的使用，胖友可以参考：</p>
<ul>
<li><a href="http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/">《Spring Boot系列文章（一）：SpringBoot Kafka 整合使用》</a></li>
</ul>
<h2 id="如何集成-Spring-Boot-和-RocketMQ-？"><a href="#如何集成-Spring-Boot-和-RocketMQ-？" class="headerlink" title="如何集成 Spring Boot 和 RocketMQ ？"></a>如何集成 Spring Boot 和 RocketMQ ？</h2><ol>
<li>引入 <code>rocketmq-spring-boot</code> 的依赖。</li>
<li>在 application 配置文件中，加入 RocketMQ 相关的少量配置。</li>
<li>具体编码。</li>
</ol>
<p>详细的使用，胖友可以参考：</p>
<ul>
<li><a href="http://www.iocoder.cn/RocketMQ/start/spring-boot-example">《我用这种方法在 Spring 中实现消息的发送和消费》</a></li>
</ul>
<h2 id="Spring-Boot-支持哪些日志框架？"><a href="#Spring-Boot-支持哪些日志框架？" class="headerlink" title="Spring Boot 支持哪些日志框架？"></a>Spring Boot 支持哪些日志框架？</h2><p>Spring Boot 支持的日志框架有：</p>
<ul>
<li>Logback</li>
<li>Log4j2</li>
<li>Log4j</li>
<li>Java Util  Logging</li>
</ul>
<p>默认使用的是 Logback 日志框架，也是目前较为推荐的，具体配置，可以参见 <a href="http://www.iocoder.cn/Spring-Boot/battcn/v2-config-logs/">《一起来学 SpringBoot 2.x | 第三篇：SpringBoot 日志配置》</a> 。</p>
<p>因为 Log4j2 的性能更加优秀，也有人在生产上使用，可以参考 <a href="https://www.jianshu.com/p/f18a9cff351d">《Spring Boot Log4j2 日志性能之巅》</a> 配置。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>😈 看完之后，复习复习 Spring Boot 美滋滋。有一种奇怪的感觉，把面试题写成了 Spring 的学习指南。</p>
<p>当然，如果胖友有新的面试题，欢迎在星球一起探讨补充。</p>
<p>参考和推荐如下文章：</p>
<ul>
<li>我有面试宝典 [《<a href="http://www.wityx.com/post/242_1_1.html">经验分享] Spring Boot面试题总结》</a></li>
<li>Java 知音 <a href="https://cloud.tencent.com/developer/article/1348086">《Spring Boot 面试题精华》</a></li>
<li>祖大帅 <a href="https://juejin.im/post/5b679fbc5188251aad213110">《一个面试题引起的 Spring Boot 启动解析》</a></li>
<li>大胡子叔叔_ <a href="https://blog.csdn.net/panhaigang123/article/details/79587612">《Spring Boot + Spring Cloud 相关面试题》</a></li>
<li>墨斗鱼博客 <a href="https://www.mudouyu.com/article/26">《20 道 Spring Boot 面试题》</a></li>
<li>夕阳雨晴 <a href="https://blog.csdn.net/sun1021873926/article/details/78176354">《Spring Boot Starter 的面试题》</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring Boot</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>5</title>
    <url>/2016/10/12/5/</url>
    <content><![CDATA[<h1 id="精尽-MyBatis-面试题"><a href="#精尽-MyBatis-面试题" class="headerlink" title="精尽 MyBatis 面试题"></a>精尽 MyBatis 面试题</h1><p>以下面试题，基于网络整理，和自己编辑。具体参考的文章，会在文末给出所有的链接。</p>
<p>如果胖友有自己的疑问，欢迎在星球提问，我们一起整理吊吊的 MyBatis 面试题的大保健。</p>
<p>而题目的难度，艿艿尽量按照从容易到困难的顺序，逐步下去。</p>
<h2 id="MyBatis-编程步骤"><a href="#MyBatis-编程步骤" class="headerlink" title="MyBatis 编程步骤"></a>MyBatis 编程步骤</h2><ol>
<li>创建 SqlSessionFactory 对象。</li>
<li>通过 SqlSessionFactory 获取 SqlSession 对象。</li>
<li>通过 SqlSession 获得 Mapper 代理对象。</li>
<li>通过 Mapper 代理对象，执行数据库操作。</li>
<li>执行成功，则使用 SqlSession 提交事务。</li>
<li>执行失败，则使用 SqlSession 回滚事务。</li>
<li>最终，关闭会话。</li>
</ol>
<h2 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{} 和 ${} 的区别是什么？"></a><code>#&#123;&#125;</code> 和 <code>$&#123;&#125;</code> 的区别是什么？</h2><p><code>$&#123;&#125;</code> 是 Properties 文件中的变量占位符，它可以用于 XML 标签属性值和 SQL 内部，属于<strong>字符串替换</strong>。例如将 <code>$&#123;driver&#125;</code> 会被静态替换为 <code>com.mysql.jdbc.Driver</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dataSource type&#x3D;&quot;UNPOOLED&quot;&gt;<br>    &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;$&#123;driver&#125;&quot;&#x2F;&gt;<br>    &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;url&#125;&quot;&#x2F;&gt;<br>    &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;username&#125;&quot;&#x2F;&gt;<br>&lt;&#x2F;dataSource&gt;<br></code></pre></td></tr></table></figure>

<p><code>$&#123;&#125;</code> 也可以对传递进来的参数<strong>原样拼接</strong>在 SQL 中。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;select id&#x3D;&quot;getSubject3&quot; parameterType&#x3D;&quot;Integer&quot; resultType&#x3D;&quot;Subject&quot;&gt;<br>    SELECT * FROM subject<br>    WHERE id &#x3D; $&#123;id&#125;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>实际场景下，不推荐这么做。因为，可能有 SQL 注入的风险。</li>
</ul>
<hr>
<p><code>#&#123;&#125;</code> 是 SQL 的参数占位符，Mybatis 会将 SQL 中的 <code>#&#123;&#125;</code> 替换为 <code>?</code> 号，在 SQL 执行前会使用 PreparedStatement 的参数设置方法，按序给 SQL 的 <code>?</code> 号占位符设置参数值，比如 <code>ps.setInt(0, parameterValue)</code> 。 所以，<code>#&#123;&#125;</code> 是<strong>预编译处理</strong>，可以有效防止 SQL 注入，提高系统安全性。</p>
<hr>
<p>另外，<code>#&#123;&#125;</code> 和 <code>$&#123;&#125;</code> 的取值方式非常方便。例如：<code>#&#123;item.name&#125;</code> 的取值方式，为使用反射从参数对象中，获取 <code>item</code> 对象的 <code>name</code> 属性值，相当于 <code>param.getItem().getName()</code> 。</p>
<h2 id="当实体类中的属性名和表中的字段名不一样-，怎么办？"><a href="#当实体类中的属性名和表中的字段名不一样-，怎么办？" class="headerlink" title="当实体类中的属性名和表中的字段名不一样 ，怎么办？"></a>当实体类中的属性名和表中的字段名不一样 ，怎么办？</h2><p>第一种， 通过在查询的 SQL 语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;select id&#x3D;&quot;selectOrder&quot; parameterType&#x3D;&quot;Integer&quot; resultType&#x3D;&quot;Order&quot;&gt; <br>    SELECT order_id AS id, order_no AS orderno, order_price AS price <br>    FROM orders <br>    WHERE order_id &#x3D; #&#123;id&#125;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>这里，艿艿还有几点建议：<ul>
<li>1、数据库的关键字，统一使用大写，例如：<code>SELECT</code>、<code>AS</code>、<code>FROM</code>、<code>WHERE</code> 。</li>
<li>2、每 5 个查询字段换一行，保持整齐。</li>
<li>3、<code>,</code> 的后面，和 <code>=</code> 的前后，需要有空格，更加清晰。</li>
<li>4、<code>SELECT</code>、<code>FROM</code>、<code>WHERE</code> 等，单独一行，高端大气。</li>
</ul>
</li>
</ul>
<hr>
<p>第二种，是第一种的特殊情况。大多数场景下，数据库字段名和实体类中的属性名差，主要是前者为<strong>下划线风格</strong>，后者为<strong>驼峰风格</strong>。在这种情况下，可以直接配置如下，实现自动的下划线转驼峰的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;setting name&#x3D;&quot;logImpl&quot; value&#x3D;&quot;LOG4J&quot;&#x2F;&gt;<br>    &lt;setting name&#x3D;&quot;mapUnderscoreToCamelCase&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;<br>&lt;&#x2F;settings&gt;<br></code></pre></td></tr></table></figure>

<p>😈 也就说，约定大于配置。非常推荐！</p>
<hr>
<p>第三种，通过 <code>&lt;resultMap&gt;</code> 来映射字段名和实体类属性名的一一对应的关系。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;resultMap type&#x3D;&quot;me.gacl.domain.Order&quot; id&#x3D;”OrderResultMap”&gt; <br>    &lt;!–- 用 id 属性来映射主键字段 -–&gt; <br>    &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;order_id&quot;&gt; <br>    &lt;!–- 用 result 属性来映射非主键字段，property 为实体类属性名，column 为数据表中的属性 -–&gt; <br>    &lt;result property&#x3D;&quot;orderNo&quot; column &#x3D;&quot;order_no&quot; &#x2F;&gt; <br>    &lt;result property&#x3D;&quot;price&quot; column&#x3D;&quot;order_price&quot; &#x2F;&gt; <br>&lt;&#x2F;resultMap&gt;<br><br>&lt;select id&#x3D;&quot;getOrder&quot; parameterType&#x3D;&quot;Integer&quot; resultMap&#x3D;&quot;OrderResultMap&quot;&gt;<br>    SELECT * <br>    FROM orders <br>    WHERE order_id &#x3D; #&#123;id&#125;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>此处 <code>SELECT *</code> 仅仅作为示例只用，实际场景下，千万千万千万不要这么干。用多少字段，查询多少字段。</li>
<li>相比第一种，第三种的<strong>重用性</strong>会一些。</li>
</ul>
<h2 id="XML-映射文件中，除了常见的-select-insert-update-delete标-签之外，还有哪些标签？"><a href="#XML-映射文件中，除了常见的-select-insert-update-delete标-签之外，还有哪些标签？" class="headerlink" title="XML 映射文件中，除了常见的 select | insert | update | delete标 签之外，还有哪些标签？"></a>XML 映射文件中，除了常见的 select | insert | update | delete标 签之外，还有哪些标签？</h2><p>如下部分，可见 <a href="http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html">《MyBatis 文档 —— Mapper XML 文件》</a> ：</p>
<ul>
<li><pre><code>&lt;cache /&gt;
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>   标签，给定命名空间的缓存配置。<br><br>  - &#96;&lt;cache-ref &#x2F;&gt;&#96; 标签，其他命名空间缓存配置的引用。<br><br>- &#96;&lt;resultMap &#x2F;&gt;&#96; 标签，是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。<br><br>- ~~&#96;&#96; 标签，已废弃！老式风格的参数映射。内联参数是首选,这个元素可能在将来被移除，这里不会记录。~~<br><br>- &#96;&#96;&#96;<br>  &lt;sql &#x2F;&gt;<br></code></pre></td></tr></table></figure>

 标签，可被其他语句引用的可重用语句块。

- `&lt;include /&gt;` 标签，引用 `&lt;sql /&gt;` 标签的语句。</code></pre>
</li>
<li><p><code>&lt;selectKey /&gt;</code> 标签，不支持自增的主键生成策略标签。</p>
</li>
</ul>
<p>如下部分，可见 <a href="http://www.mybatis.org/mybatis-3/zh/dynamic-sql.html">《MyBatis 文档 —— 动态 SQL》</a> ：</p>
<ul>
<li><code>&lt;if /&gt;</code></li>
<li><code>&lt;choose /&gt;</code>、<code>&lt;when /&gt;</code>、<code>&lt;otherwise /&gt;</code></li>
<li><code>&lt;trim /&gt;</code>、<code>&lt;where /&gt;</code>、<code>&lt;set /&gt;</code></li>
<li><code>&lt;foreach /&gt;</code></li>
<li><code>&lt;bind /&gt;</code></li>
</ul>
<h2 id="Mybatis-动态-SQL-是做什么的？都有哪些动态-SQL-？能简述一下动态-SQL-的执行原理吗？"><a href="#Mybatis-动态-SQL-是做什么的？都有哪些动态-SQL-？能简述一下动态-SQL-的执行原理吗？" class="headerlink" title="Mybatis 动态 SQL 是做什么的？都有哪些动态 SQL ？能简述一下动态 SQL 的执行原理吗？"></a>Mybatis 动态 SQL 是做什么的？都有哪些动态 SQL ？能简述一下动态 SQL 的执行原理吗？</h2><ul>
<li>Mybatis 动态 SQL ，可以让我们在 XML 映射文件内，以 XML 标签的形式编写动态 SQL ，完成逻辑判断和动态拼接 SQL 的功能。</li>
<li>Mybatis 提供了 9 种动态 SQL 标签：<code>&lt;if /&gt;</code>、<code>&lt;choose /&gt;</code>、<code>&lt;when /&gt;</code>、<code>&lt;otherwise /&gt;</code>、<code>&lt;trim /&gt;</code>、<code>&lt;where /&gt;</code>、<code>&lt;set /&gt;</code>、<code>&lt;foreach /&gt;</code>、<code>&lt;bind /&gt;</code> 。</li>
<li>其执行原理为，使用 <strong>OGNL</strong> 的表达式，从 SQL 参数对象中计算表达式的值，根据表达式的值动态拼接 SQL ，以此来完成动态 SQL 的功能。</li>
</ul>
<p>如上的内容，更加详细的话，请看 <a href="http://www.mybatis.org/mybatis-3/zh/dynamic-sql.html">《MyBatis 文档 —— 动态 SQL》</a> 文档。</p>
<h2 id="最佳实践中，通常一个-XML-映射文件，都会写一个-Mapper-接口与之对应。请问，这个-Mapper-接口的工作原理是什么？Mapper-接口里的方法，参数不同时，方法能重载吗？"><a href="#最佳实践中，通常一个-XML-映射文件，都会写一个-Mapper-接口与之对应。请问，这个-Mapper-接口的工作原理是什么？Mapper-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="最佳实践中，通常一个 XML 映射文件，都会写一个 Mapper 接口与之对应。请问，这个 Mapper 接口的工作原理是什么？Mapper 接口里的方法，参数不同时，方法能重载吗？"></a>最佳实践中，通常一个 XML 映射文件，都会写一个 Mapper 接口与之对应。请问，这个 Mapper 接口的工作原理是什么？Mapper 接口里的方法，参数不同时，方法能重载吗？</h2><p>Mapper 接口，对应的关系如下：</p>
<ul>
<li>接口的全限名，就是映射文件中的 <code>&quot;namespace&quot;</code> 的值。</li>
<li>接口的方法名，就是映射文件中 MappedStatement 的 <code>&quot;id&quot;</code> 值。</li>
<li>接口方法内的参数，就是传递给 SQL 的参数。</li>
</ul>
<p>Mapper 接口是没有实现类的，当调用接口方法时，接口全限名 + 方法名拼接字符串作为 key 值，可唯一定位一个对应的 MappedStatement 。举例：<code>com.mybatis3.mappers.StudentDao.findStudentById</code> ，可以唯一找到 <code>&quot;namespace&quot;</code> 为 <code>com.mybatis3.mappers.StudentDao</code> 下面 <code>&quot;id&quot;</code> 为 <code>findStudentById</code> 的 MappedStatement 。</p>
<p>总结来说，在 Mybatis 中，每一个 <code>&lt;select /&gt;</code>、<code>&lt;insert /&gt;</code>、<code>&lt;update /&gt;</code>、<code>&lt;delete /&gt;</code> 标签，都会被解析为一个 MappedStatement 对象。</p>
<p>另外，Mapper 接口的实现类，通过 MyBatis 使用 <strong>JDK Proxy</strong> 自动生成其代理对象 Proxy ，而代理对象 Proxy 会拦截接口方法，从而“调用”对应的 MappedStatement 方法，最终执行 SQL ，返回执行结果。整体流程如下图：<a href="http://static2.iocoder.cn/images/MyBatis/2020_03_15/02.png">![流程](D:\新建文件夹 (3)\02.png)</a>流程</p>
<ul>
<li><p>其中，SqlSession 在调用 Executor 之前，会获得对应的 MappedStatement 方法。例如：<code>DefaultSqlSession#select(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler)</code> 方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; DefaultSqlSession.java<br><br>@Override<br>public void select(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler) &#123;<br>    try &#123;<br>        &#x2F;&#x2F; 获得 MappedStatement 对象<br>        MappedStatement ms &#x3D; configuration.getMappedStatement(statement);<br>        &#x2F;&#x2F; 执行查询<br>        executor.query(ms, wrapCollection(parameter), rowBounds, handler);<br>    &#125; catch (Exception e) &#123;<br>        throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + e, e);<br>    &#125; finally &#123;<br>        ErrorContext.instance().reset();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>完整的流程，胖友可以慢慢撸下 MyBatis 的源码。</li>
</ul>
</li>
</ul>
<hr>
<p>Mapper 接口里的方法，是不能重载的，因为是<strong>全限名 + 方法名</strong>的保存和寻找策略。😈 所以有时，想个 Mapper 接口里的方法名，还是蛮闹心的，嘿嘿。</p>
<h2 id="Mapper-接口绑定有几种实现方式-分别是怎么实现的"><a href="#Mapper-接口绑定有几种实现方式-分别是怎么实现的" class="headerlink" title="Mapper 接口绑定有几种实现方式,分别是怎么实现的?"></a>Mapper 接口绑定有几种实现方式,分别是怎么实现的?</h2><p>接口绑定有三种实现方式：</p>
<p>第一种，通过 <strong>XML Mapper</strong> 里面写 SQL 来绑定。在这种情况下，要指定 XML 映射文件里面的 <code>&quot;namespace&quot;</code> 必须为接口的全路径名。</p>
<p>第二种，通过<strong>注解</strong>绑定，就是在接口的方法上面加上 <code>@Select</code>、<code>@Update</code>、<code>@Insert</code>、<code>@Delete</code> 注解，里面包含 SQL 语句来绑定。</p>
<p>第三种，是第二种的特例，也是通过<strong>注解</strong>绑定，在接口的方法上面加上 <code>@SelectProvider</code>、<code>@UpdateProvider</code>、<code>@InsertProvider</code>、<code>@DeleteProvider</code> 注解，通过 Java 代码，生成对应的动态 SQL 。</p>
<hr>
<p>实际场景下，最最最推荐的是<strong>第一种</strong>方式。因为，SQL 通过注解写在 Java 代码中，会非常杂乱。而写在 XML 中，更加有整体性，并且可以更加方便的使用 OGNL 表达式。</p>
<h2 id="Mybatis-的-XML-Mapper文件中，不同的-XML-映射文件，id-是否可以重复？"><a href="#Mybatis-的-XML-Mapper文件中，不同的-XML-映射文件，id-是否可以重复？" class="headerlink" title="Mybatis 的 XML Mapper文件中，不同的 XML 映射文件，id 是否可以重复？"></a>Mybatis 的 XML Mapper文件中，不同的 XML 映射文件，id 是否可以重复？</h2><p>不同的 XML Mapper 文件，如果配置了 <code>&quot;namespace&quot;</code> ，那么 id 可以重复；如果没有配置 <code>&quot;namespace&quot;</code> ，那么 id 不能重复。毕竟<code>&quot;namespace&quot;</code> 不是必须的，只是最佳实践而已。</p>
<p>原因就是，<code>namespace + id</code> 是作为 <code>Map&lt;String, MappedStatement&gt;</code> 的 key 使用的。如果没有 <code>&quot;namespace&quot;</code>，就剩下 id ，那么 id 重复会导致数据互相覆盖。如果有了 <code>&quot;namespace&quot;</code>，自然 id 就可以重复，<code>&quot;namespace&quot;</code>不同，<code>namespace + id</code> 自然也就不同。</p>
<h2 id="如何获取自动生成的-主-键值"><a href="#如何获取自动生成的-主-键值" class="headerlink" title="如何获取自动生成的(主)键值?"></a>如何获取自动生成的(主)键值?</h2><p>不同的数据库，获取自动生成的(主)键值的方式是不同的。</p>
<p>MySQL 有两种方式，但是<strong>自增主键</strong>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 方式一，使用 useGeneratedKeys + keyProperty 属性<br>&lt;insert id&#x3D;&quot;insert&quot; parameterType&#x3D;&quot;Person&quot; useGeneratedKeys&#x3D;&quot;true&quot; keyProperty&#x3D;&quot;id&quot;&gt;<br>    INSERT INTO person(name, pswd)<br>    VALUE (#&#123;name&#125;, #&#123;pswd&#125;)<br>&lt;&#x2F;insert&gt;<br>    <br>&#x2F;&#x2F; 方式二，使用 &#96;&lt;selectKey &#x2F;&gt;&#96; 标签<br>&lt;insert id&#x3D;&quot;insert&quot; parameterType&#x3D;&quot;Person&quot;&gt;<br>    &lt;selectKey keyProperty&#x3D;&quot;id&quot; resultType&#x3D;&quot;long&quot; order&#x3D;&quot;AFTER&quot;&gt;<br>        SELECT LAST_INSERT_ID()<br>    &lt;&#x2F;selectKey&gt;<br>        <br>    INSERT INTO person(name, pswd)<br>    VALUE (#&#123;name&#125;, #&#123;pswd&#125;)<br>&lt;&#x2F;insert&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>其中，<strong>方式一</strong>较为常用。</li>
</ul>
<hr>
<p>Oracle 有两种方式，<strong>序列</strong>和<strong>触发器</strong>。因为艿艿自己不了解 Oracle ，所以问了银行的朋友，他们是使用<strong>序列</strong>。而基于<strong>序列</strong>，根据 <code>&lt;selectKey /&gt;</code> 执行的时机，也有两种方式，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 这个是创建表的自增序列<br>CREATE SEQUENCE student_sequence<br>INCREMENT BY 1<br>NOMAXVALUE<br>NOCYCLE<br>CACHE 10;<br><br>&#x2F;&#x2F; 方式一，使用 &#96;&lt;selectKey &#x2F;&gt;&#96; 标签 + BEFORE<br>&lt;insert id&#x3D;&quot;add&quot; parameterType&#x3D;&quot;Student&quot;&gt;<br>　　&lt;selectKey keyProperty&#x3D;&quot;student_id&quot; resultType&#x3D;&quot;int&quot; order&#x3D;&quot;BEFORE&quot;&gt;<br>      select student_sequence.nextval FROM dual<br>    &lt;&#x2F;selectKey&gt;<br>    <br>     INSERT INTO student(student_id, student_name, student_age)<br>     VALUES (#&#123;student_id&#125;,#&#123;student_name&#125;,#&#123;student_age&#125;)<br>&lt;&#x2F;insert&gt;<br><br>&#x2F;&#x2F; 方式二，使用 &#96;&lt;selectKey &#x2F;&gt;&#96; 标签 + AFTER<br>&lt;insert id&#x3D;&quot;save&quot; parameterType&#x3D;&quot;com.threeti.to.ZoneTO&quot; &gt;<br>    &lt;selectKey resultType&#x3D;&quot;java.lang.Long&quot; keyProperty&#x3D;&quot;id&quot; order&#x3D;&quot;AFTER&quot; &gt;<br>      SELECT SEQ_ZONE.CURRVAL AS id FROM dual<br>    &lt;&#x2F;selectKey&gt;<br>    <br>    INSERT INTO TBL_ZONE (ID, NAME ) <br>    VALUES (SEQ_ZONE.NEXTVAL, #&#123;name,jdbcType&#x3D;VARCHAR&#125;)<br>&lt;&#x2F;insert&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>他们使用第一种方式，没有具体原因，可能就没什么讲究吧。嘿嘿。</li>
</ul>
<p>至于为什么不用<strong>触发器</strong>呢？朋友描述如下：</p>
<blockquote>
<p>朋友：触发器不行啊，我们这边原来也有触发器，一有数据更改就会有问题了呀<br>艿艿：数据更改指的是？<br>朋友：就改线上某几条数据<br>艿艿：噢噢。手动改是吧？<br>朋友：不行~</p>
</blockquote>
<hr>
<p>当然，数据库还有 SQLServer、PostgreSQL、DB2、H2 等等，具体的方式，胖友自己 Google 下噢。</p>
<p>关于如何获取自动生成的(主)键值的<strong>原理</strong>，可以看看 <a href="http://svip.iocoder.cn/MyBatis/executor-3/">《精尽 MyBatis 源码分析 —— SQL 执行（三）之 KeyGenerator》</a> 。</p>
<h2 id="Mybatis-执行批量插入，能返回数据库主键列表吗？"><a href="#Mybatis-执行批量插入，能返回数据库主键列表吗？" class="headerlink" title="Mybatis 执行批量插入，能返回数据库主键列表吗？"></a>Mybatis 执行批量插入，能返回数据库主键列表吗？</h2><p>能，JDBC 都能做，Mybatis 当然也能做。</p>
<h2 id="在-Mapper-中如何传递多个参数"><a href="#在-Mapper-中如何传递多个参数" class="headerlink" title="在 Mapper 中如何传递多个参数?"></a>在 Mapper 中如何传递多个参数?</h2><p>第一种，使用 Map 集合，装载多个参数进行传递。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 调用方法<br>Map&lt;String, Object&gt; map &#x3D; new HashMap();<br>map.put(&quot;start&quot;, start);<br>map.put(&quot;end&quot;, end);<br>return studentMapper.selectStudents(map);<br><br>&#x2F;&#x2F; Mapper 接口<br>List&lt;Student&gt; selectStudents(Map&lt;String, Object&gt; map);<br><br>&#x2F;&#x2F; Mapper XML 代码<br>&lt;select id&#x3D;&quot;selectStudents&quot; parameterType&#x3D;&quot;Map&quot; resultType&#x3D;&quot;Student&quot;&gt;<br>    SELECT * <br>    FROM students <br>    LIMIT #&#123;start&#125;, #&#123;end&#125;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>显然，这不是一种优雅的方式。</li>
</ul>
<hr>
<p>第二种，保持传递多个参数，使用 <code>@Param</code> 注解。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 调用方法<br>return studentMapper.selectStudents(0, 10);<br><br>&#x2F;&#x2F; Mapper 接口<br>List&lt;Student&gt; selectStudents(@Param(&quot;start&quot;) Integer start, @Param(&quot;end&quot;) Integer end);<br><br>&#x2F;&#x2F; Mapper XML 代码<br>&lt;select id&#x3D;&quot;selectStudents&quot; resultType&#x3D;&quot;Student&quot;&gt;<br>    SELECT * <br>    FROM students <br>    LIMIT #&#123;start&#125;, #&#123;end&#125;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>推荐使用这种方式。</li>
</ul>
<hr>
<p>第三种，保持传递多个参数，不使用 <code>@Param</code> 注解。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 调用方法<br>return studentMapper.selectStudents(0, 10);<br><br>&#x2F;&#x2F; Mapper 接口<br>List&lt;Student&gt; selectStudents(Integer start, Integer end);<br><br>&#x2F;&#x2F; Mapper XML 代码<br>&lt;select id&#x3D;&quot;selectStudents&quot; resultType&#x3D;&quot;Student&quot;&gt;<br>    SELECT * <br>    FROM students <br>    LIMIT #&#123;param1&#125;, #&#123;param2&#125;<br>&lt;&#x2F;select&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>其中，按照参数在方法方法中的位置，从 1 开始，逐个为 <code>#&#123;param1&#125;</code>、<code>#&#123;param2&#125;</code>、<code>#&#123;param3&#125;</code> 不断向下。</li>
</ul>
<h2 id="Mybatis-是否可以映射-Enum-枚举类？"><a href="#Mybatis-是否可以映射-Enum-枚举类？" class="headerlink" title="Mybatis 是否可以映射 Enum 枚举类？"></a>Mybatis 是否可以映射 Enum 枚举类？</h2><p>Mybatis 可以映射枚举类，对应的实现类为 EnumTypeHandler 或 EnumOrdinalTypeHandler 。</p>
<ul>
<li>EnumTypeHandler ，基于 <code>Enum.name</code> 属性( String )。<strong>默认</strong>。</li>
<li>EnumOrdinalTypeHandler ，基于 <code>Enum.ordinal</code> 属性( <code>int</code> )。可通过 <code>&lt;setting name=&quot;defaultEnumTypeHandler&quot; value=&quot;EnumOrdinalTypeHandler&quot; /&gt;</code> 来设置。</li>
</ul>
<p>😈 当然，实际开发场景，我们很少使用 Enum 类型，更加的方式是，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class Dog &#123;<br><br>    public static final int STATUS_GOOD &#x3D; 1;<br>    public static final int STATUS_BETTER &#x3D; 2;<br>    public static final int STATUS_BEST &#x3D; 3；<br>    <br>    private int status;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<p>并且，不单可以映射枚举类，Mybatis 可以映射任何对象到表的一列上。映射方式为自定义一个 TypeHandler 类，实现 TypeHandler 的<code>#setParameter(...)</code> 和 <code>#getResult(...)</code> 接口方法。</p>
<p>TypeHandler 有两个作用：</p>
<ul>
<li>一是，完成从 javaType 至 jdbcType 的转换。</li>
<li>二是，完成 jdbcType 至 javaType 的转换。</li>
</ul>
<p>具体体现为 <code>#setParameter(...)</code> 和 <code>#getResult(..)</code> 两个方法，分别代表设置 SQL 问号占位符参数和获取列查询结果。</p>
<p>关于 TypeHandler 的<strong>原理</strong>，可以看看 <a href="http://svip.iocoder.cn/MyBatis/type-package/">《精尽 MyBatis 源码分析 —— 类型模块》</a> 。</p>
<h2 id="Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？"></a>Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h2><p>Mybatis 有四种 Executor 执行器，分别是 SimpleExecutor、ReuseExecutor、BatchExecutor、CachingExecutor 。</p>
<ul>
<li>SimpleExecutor ：每执行一次 update 或 select 操作，就创建一个 Statement 对象，用完立刻关闭 Statement 对象。</li>
<li>ReuseExecutor ：执行 update 或 select 操作，以 SQL 作为key 查找<strong>缓存</strong>的 Statement 对象，存在就使用，不存在就创建；用完后，不关闭 Statement 对象，而是放置于缓存 <code>Map&lt;String, Statement&gt;</code> 内，供下一次使用。简言之，就是重复使用 Statement 对象。</li>
<li>BatchExecutor ：执行 update 操作（没有 select 操作，因为 JDBC 批处理不支持 select  操作），将所有 SQL 都添加到批处理中（通过 addBatch 方法），等待统一执行（使用 executeBatch 方法）。它缓存了多个  Statement 对象，每个 Statement 对象都是调用 addBatch 方法完毕后，等待一次执行 executeBatch 批处理。<strong>实际上，整个过程与 JDBC 批处理是相同</strong>。</li>
<li>CachingExecutor ：在上述的三个执行器之上，增加<strong>二级缓存</strong>的功能。</li>
</ul>
<hr>
<p>通过设置 <code>&lt;setting name=&quot;defaultExecutorType&quot; value=&quot;&quot;&gt;</code> 的 <code>&quot;value&quot;</code> 属性，可传入 SIMPLE、REUSE、BATCH 三个值，分别使用 SimpleExecutor、ReuseExecutor、BatchExecutor 执行器。</p>
<p>通过设置 <code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;&quot;</code> 的 <code>&quot;value&quot;</code> 属性为 <code>true</code> 时，创建 CachingExecutor 执行器。</p>
<hr>
<p>这块的源码解析，可见 <a href="http://svip.iocoder.cn/MyBatis/executor-1">《精尽 MyBatis 源码分析 —— SQL 执行（一）之 Executor》</a> 。</p>
<h2 id="MyBatis-如何执行批量插入"><a href="#MyBatis-如何执行批量插入" class="headerlink" title="MyBatis 如何执行批量插入?"></a>MyBatis 如何执行批量插入?</h2><p>首先，在 Mapper XML 编写一个简单的 Insert 语句。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;insert id&#x3D;&quot;insertUser&quot; parameterType&#x3D;&quot;String&quot;&gt; <br>    INSERT INTO users(name) <br>    VALUES (#&#123;value&#125;) <br>&lt;&#x2F;insert&gt;<br></code></pre></td></tr></table></figure>

<p>然后，然后在对应的 Mapper 接口中，编写映射的方法。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public interface UserMapper &#123;<br>    <br>    void insertUser(@Param(&quot;name&quot;) String name);<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>最后，调用该 Mapper 接口方法。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">private static SqlSessionFactory sqlSessionFactory;<br><br>@Test<br>public void testBatch() &#123;<br>    &#x2F;&#x2F; 创建要插入的用户的名字的数组<br>    List&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;();<br>    names.add(&quot;占小狼&quot;);<br>    names.add(&quot;朱小厮&quot;);<br>    names.add(&quot;徐妈&quot;);<br>    names.add(&quot;飞哥&quot;);<br><br>    &#x2F;&#x2F; 获得执行器类型为 Batch 的 SqlSession 对象，并且 autoCommit &#x3D; false ，禁止事务自动提交<br>    try (SqlSession session &#x3D; sqlSessionFactory.openSession(ExecutorType.BATCH, false)) &#123;<br>        &#x2F;&#x2F; 获得 Mapper 对象<br>        UserMapper mapper &#x3D; session.getMapper(UserMapper.class);<br>        &#x2F;&#x2F; 循环插入<br>        for (String name : names) &#123;<br>            mapper.insertUser(name);<br>        &#125;<br>        &#x2F;&#x2F; 提交批量操作<br>        session.commit();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>代码比较简单，胖友仔细看看。当然，还有另一种方式，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">INSERT INTO [表名]([列名],[列名]) <br>VALUES<br>([列值],[列值])),<br>([列值],[列值])),<br>([列值],[列值]));<br></code></pre></td></tr></table></figure>

<ul>
<li>对于这种方式，需要保证单条 SQL 不超过语句的最大限制 <code>max_allowed_packet</code> 大小，默认为 1 M 。</li>
</ul>
<p>这两种方式的性能对比，可以看看 [《<a href="https://www.jianshu.com/p/cce617be9f9e">实验]mybatis批量插入方式的比较》</a> 。</p>
<h2 id="介绍-MyBatis-的一级缓存和二级缓存的概念和实现原理？"><a href="#介绍-MyBatis-的一级缓存和二级缓存的概念和实现原理？" class="headerlink" title="介绍 MyBatis 的一级缓存和二级缓存的概念和实现原理？"></a>介绍 MyBatis 的一级缓存和二级缓存的概念和实现原理？</h2><p>内容有些长，直接参见 <a href="https://tech.meituan.com/mybatis_cache.html">《聊聊 MyBatis 缓存机制》</a> 一文。</p>
<hr>
<p>这块的源码解析，可见 <a href="http://svip.iocoder.cn/MyBatis/cache-package">《精尽 MyBatis 源码分析 —— 缓存模块》</a> 。</p>
<h2 id="Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h2><p>Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载。其中，association 指的就是<strong>一对一</strong>，collection 指的就是<strong>一对多查询</strong>。</p>
<p>在 Mybatis 配置文件中，可以配置 <code>&lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot; /&gt;</code> 来启用延迟加载的功能。默认情况下，延迟加载的功能是<strong>关闭</strong>的。</p>
<hr>
<p>它的原理是，使用 CGLIB 或 Javassist( 默认 ) 创建目标对象的代理对象。当调用代理对象的延迟加载属性的 getting 方法时，进入拦截器方法。比如调用 <code>a.getB().getName()</code> 方法，进入拦截器的 <code>invoke(...)</code> 方法，发现 <code>a.getB()</code> 需要延迟加载时，那么就会单独发送事先保存好的查询关联 B 对象的 SQL ，把 B 查询上来，然后调用<code>a.setB(b)</code> 方法，于是 <code>a</code> 对象 <code>b</code> 属性就有值了，接着完成<code>a.getB().getName()</code> 方法的调用。这就是延迟加载的基本原理。</p>
<p>当然了，不光是 Mybatis，几乎所有的包括 Hibernate 在内，支持延迟加载的原理都是一样的。</p>
<hr>
<p>这块的源码解析，可见 <a href="http://svip.iocoder.cn/MyBatis/executor-5">《 精尽 MyBatis 源码分析 —— SQL 执行（五）之延迟加载》</a> 文章。</p>
<h2 id="Mybatis-能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"><a href="#Mybatis-能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。" class="headerlink" title="Mybatis 能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"></a>Mybatis 能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。</h2><blockquote>
<p>艿艿：这道题有点难度。理解倒是好理解，主要那块源码的实现，艿艿看的有点懵逼。大体的意思是懂的，但是一些细节没扣完。</p>
</blockquote>
<p>能，Mybatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询。</p>
<blockquote>
<p>艿艿：不过貌似，我自己实际开发中，还是比较喜欢自己去查询和拼接映射的数据。😈</p>
</blockquote>
<ul>
<li>多对一查询，其实就是一对一查询，只需要把 <code>selectOne(...)</code> 修改为 <code>selectList(...)</code> 即可。案例可见 <a href="https://blog.csdn.net/xzm_rainbow/article/details/15336959">《MyBatis：多对一表关系详解》</a> 。</li>
<li>多对多查询，其实就是一对多查询，只需要把 <code>#selectOne(...)</code> 修改为 <code>selectList(...)</code> 即可。案例可见 <a href="https://blog.csdn.net/eson_15/article/details/51655188">《【MyBatis学习10】高级映射之多对多查询》</a> 。</li>
</ul>
<hr>
<p>关联对象查询，有两种实现方式：</p>
<blockquote>
<p>艿艿：所有的技术方案，即会有好处，又会有坏处。很难出现，一个完美的银弹方案。</p>
</blockquote>
<ul>
<li>一种是单独发送一个 SQL 去查询关联对象，赋给主对象，然后返回主对象。好处是多条 SQL 分开，相对简单，坏处是发起的 SQL 可能会比较多。</li>
<li>另一种是使用嵌套查询，嵌套查询的含义为使用 <code>join</code> 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值。好处是只发一个 SQL 查询，就可以把主对象和其关联对象查出来，坏处是 SQL 可能比较复杂。</li>
</ul>
<p>那么问题来了，<code>join</code> 查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个呢？其去重复的原理是 <code>&lt;resultMap&gt;</code> 标签内的<code>&lt;id&gt;</code> 子标签，指定了唯一确定一条记录的 <code>id</code> 列。Mybatis 会根据<code>&lt;id&gt;</code> 列值来完成 100 条记录的去重复功能，<code>&lt;id&gt;</code> 可以有多个，代表了联合主键的语意。</p>
<p>同样主对象的关联对象，也是根据这个原理去重复的。尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。例如：下面 <code>join</code> 查询出来6条记录，一、二列是 Teacher 对象列，第三列为 Student 对象列。Mybatis 去重复处理后，结果为 1 个老师和 6 个学生，而不是 6 个老师和 6 个学生。</p>
<table>
<thead>
<tr>
<th>t_id</th>
<th>t_name</th>
<th>s_id</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>teacher</td>
<td>38</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>39</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>40</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>41</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>42</td>
</tr>
<tr>
<td>1</td>
<td>teacher</td>
<td>43</td>
</tr>
</tbody></table>
<h2 id="简述-Mybatis-的插件运行原理？以及如何编写一个插件？"><a href="#简述-Mybatis-的插件运行原理？以及如何编写一个插件？" class="headerlink" title="简述 Mybatis 的插件运行原理？以及如何编写一个插件？"></a>简述 Mybatis 的插件运行原理？以及如何编写一个插件？</h2><p>Mybatis 仅可以编写针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor 这 4 种接口的插件。</p>
<p>Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 <code>#invoke(...)</code>方法。当然，只会拦截那些你指定需要拦截的方法。</p>
<hr>
<p>编写一个 MyBatis 插件的步骤如下：</p>
<ol>
<li>首先，实现 Mybatis 的 Interceptor 接口，并实现 <code>#intercept(...)</code> 方法。</li>
<li>然后，在给插件编写注解，指定要拦截哪一个接口的哪些方法即可</li>
<li>最后，在配置文件中配置你编写的插件。</li>
</ol>
<p>具体的，可以参考 <a href="http://www.mybatis.org/mybatis-3/zh/configuration.html#plugins">《MyBatis 官方文档 —— 插件》</a> 。</p>
<hr>
<p>插件的详细解析，可以看看 <a href="http://svip.iocoder.cn/MyBatis/plugin-1">《精尽 MyBatis 源码分析 —— 插件体系（一）之原理》</a> 。</p>
<h2 id="Mybatis-是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis-是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis 是如何进行分页的？分页插件的原理是什么？"></a>Mybatis 是如何进行分页的？分页插件的原理是什么？</h2><p>Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的<strong>内存分页</strong>，而非<strong>数据库分页</strong>。</p>
<p>所以，实际场景下，不适合直接使用 MyBatis 原有的 RowBounds 对象进行分页。而是使用如下两种方案：</p>
<ul>
<li>在 SQL 内直接书写带有数据库分页的参数来完成数据库分页功能</li>
<li>也可以使用分页插件来完成数据库分页。</li>
</ul>
<p>这两者都是基于数据库分页，差别在于前者是工程师<strong>手动</strong>编写分页条件，后者是插件<strong>自动</strong>添加分页条件。</p>
<hr>
<p>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义分页插件。在插件的拦截方法内，拦截待执行的 SQL ，然后重写 SQL ，根据dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<p>举例：<code>SELECT * FROM student</code> ，拦截 SQL 后重写为：<code>select * FROM student LIMI 0，10</code> 。</p>
<p>目前市面上目前使用比较广泛的 MyBatis 分页插件有：</p>
<ul>
<li><a href="https://github.com/pagehelper/Mybatis-PageHelper">Mybatis-PageHelper</a></li>
<li><a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a></li>
</ul>
<p>从现在看来，<a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a> 逐步使用的更加广泛。</p>
<p>关于 MyBatis 分页插件的原理深入，可以看看 <a href="http://svip.iocoder.cn/MyBatis/plugin-2">《精尽 MyBatis 源码分析 —— 插件体系（二）之 PageHelper》</a> 。</p>
<h2 id="MyBatis-与-Hibernate-有哪些不同？"><a href="#MyBatis-与-Hibernate-有哪些不同？" class="headerlink" title="MyBatis 与 Hibernate 有哪些不同？"></a>MyBatis 与 Hibernate 有哪些不同？</h2><p>Mybatis 和 Hibernate 不同，它<strong>不完全是</strong>一个 ORM 框架，因为MyBatis 需要程序员自己编写 SQL 语句。不过 MyBatis 可以通过 XML 或注解方式灵活配置要运行的 SQL 语句，并将 Java 对象和 SQL 语句映射生成最终执行的 SQL ，最后将 SQL 执行的结果再映射生成 Java 对象。</p>
<p>Mybatis 学习门槛低，简单易学，程序员直接编写原生态 SQL ，可严格控制 SQL 执行性能，灵活度高。但是灵活的前提是 MyBatis 无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套 SQL 映射文件，工作量大。</p>
<p>Hibernate 对象/关系映射能力强，数据库无关性好。如果用 Hibernate 开发可以节省很多代码，提高效率。但是  Hibernate 的缺点是学习门槛高，要精通门槛更高，而且怎么设计 O/R 映射，在性能和对象模型之间如何权衡，以及怎样用好  Hibernate 需要具有很强的经验和能力才行。 </p>
<p>总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。简单总结如下：</p>
<ul>
<li>Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取。</li>
<li>Mybatis 属于半自动 ORM 映射工具，在查询关联对象或关联集合对象时，需要手动编写 SQL 来完成。</li>
</ul>
<p>另外，在 <a href="https://www.jianshu.com/p/96171e647885">《浅析 Mybatis 与 Hibernate 的区别与用途》</a> 文章，也是写的非常不错的。</p>
<p>当然，实际上，MyBatis 也可以搭配自动生成代码的工具，提升开发效率，还可以使用 <a href="http://mp.baomidou.com/">MyBatis-Plus</a> 框架，已经内置常用的 SQL 操作，也是非常不错的。</p>
<h2 id="JDBC-编程有哪些不足之处，MyBatis是如何解决这些问题的？"><a href="#JDBC-编程有哪些不足之处，MyBatis是如何解决这些问题的？" class="headerlink" title="JDBC 编程有哪些不足之处，MyBatis是如何解决这些问题的？"></a>JDBC 编程有哪些不足之处，MyBatis是如何解决这些问题的？</h2><p>问题一：SQL 语句写在代码中造成代码不易维护，且代码会比较混乱。</p>
<p>解决方式：将 SQL 语句配置在 Mapper XML 文件中，与 Java 代码分离。</p>
<hr>
<p>问题二：根据参数不同，拼接不同的 SQL 语句非常麻烦。例如 SQL 语句的 WHERE 条件不一定，可能多也可能少，占位符需要和参数一一对应。 </p>
<p>解决方式：MyBatis 提供 <code>&lt;where /&gt;</code>、<code>&lt;if /&gt;</code> 等等动态语句所需要的标签，并支持 OGNL 表达式，简化了动态 SQL 拼接的代码，提升了开发效率。</p>
<hr>
<p>问题三，对结果集解析麻烦，SQL 变化可能导致解析代码变化，且解析前需要遍历。</p>
<p>解决方式：Mybatis 自动将 SQL 执行结果映射成 Java 对象。</p>
<hr>
<p>问题四，数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。</p>
<p>解决方式：在 <code>mybatis-config.xml</code> 中，配置数据链接池，使用连接池管理数据库链接。</p>
<p>😈 当然，即使不使用 MyBatis ，也可以使用数据库连接池。<br>另外，MyBatis 默认提供了数据库连接池的实现，只是说，因为其它开源的数据库连接池性能更好，所以一般很少使用 MyBatis 自带的连接池实现。</p>
<h2 id="Mybatis-比-IBatis-比较大的几个改进是什么？"><a href="#Mybatis-比-IBatis-比较大的几个改进是什么？" class="headerlink" title="Mybatis 比 IBatis 比较大的几个改进是什么？"></a>Mybatis 比 IBatis 比较大的几个改进是什么？</h2><blockquote>
<p>这是一个选择性了解的问题，因为可能现在很多面试官，都没用过 IBatis 框架。</p>
</blockquote>
<ol>
<li>有接口绑定，包括注解绑定 SQL 和 XML 绑定 SQL 。</li>
<li>动态 SQL 由原来的节点配置变成 OGNL 表达式。</li>
<li>在一对一或一对多的时候，引进了 <code>association</code> ，在一对多的时候，引入了 <code>collection</code>节点，不过都是在 <code>&lt;resultMap /&gt;</code> 里面配置。</li>
</ol>
<h2 id="Mybatis-映射文件中，如果-A-标签通过-include-引用了B标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在A标签的前面？"><a href="#Mybatis-映射文件中，如果-A-标签通过-include-引用了B标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在A标签的前面？" class="headerlink" title="Mybatis 映射文件中，如果 A 标签通过 include 引用了B标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在A标签的前面？"></a>Mybatis 映射文件中，如果 A 标签通过 include 引用了B标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在A标签的前面？</h2><blockquote>
<p>老艿艿：这道题目，已经和源码实现，有点关系了。</p>
</blockquote>
<p>虽然 Mybatis 解析 XML 映射文件是<strong>按照顺序</strong>解析的。但是，被引用的 B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。<strong>也就是说，无需按照顺序，进行定义</strong>。</p>
<p>原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为<strong>未解析状态</strong>。然后，继续解析余下的标签，包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析A标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</p>
<p>可能有一些绕，胖友可以看看 <a href="http://svip.iocoder.cn/MyBatis/builder-package-1">《精尽 MyBatis 源码解析 —— MyBatis 初始化（一）之加载 mybatis-config》</a> 。</p>
<p>此处，我们在引申一个问题，Spring IOC 中，存在互相依赖的 Bean 对象，该如何解决呢？答案见 <a href="http://svip.iocoder.cn/Spring/IoC-get-Bean-createBean-5/">《【死磕 Spring】—— IoC 之加载 Bean：创建 Bean（五）之循环依赖处理》</a> 。</p>
<h2 id="简述-Mybatis-的-XML-映射文件和-Mybatis-内部数据结构之间的映射关系？"><a href="#简述-Mybatis-的-XML-映射文件和-Mybatis-内部数据结构之间的映射关系？" class="headerlink" title="简述 Mybatis 的 XML 映射文件和 Mybatis 内部数据结构之间的映射关系？"></a>简述 Mybatis 的 XML 映射文件和 Mybatis 内部数据结构之间的映射关系？</h2><blockquote>
<p>老艿艿：这道题目，已经和源码实现，有点关系了。</p>
</blockquote>
<p>Mybatis 将所有 XML 配置信息都封装到 All-In-One 重量级对象Configuration内部。</p>
<p>在 XML Mapper 文件中：</p>
<ul>
<li><code>&lt;parameterMap&gt;</code> 标签，会被解析为 ParameterMap 对象，其每个子元素会被解析为 ParameterMapping 对象。</li>
<li><code>&lt;resultMap&gt;</code> 标签，会被解析为 ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。</li>
<li>每一个 <code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code> 标签，均会被解析为一个 MappedStatement 对象，标签内的 SQL 会被解析为一个 BoundSql 对象。</li>
</ul>
<h2 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h2><p>参考与推荐如下文章：</p>
<ul>
<li>祖大俊 <a href="https://my.oschina.net/zudajun/blog/747682">《Mybatis3.4.x技术内幕（二十三）：Mybatis面试问题集锦（大结局）》</a></li>
<li>Java3y <a href="https://segmentfault.com/a/1190000013678579">《Mybatis 常见面试题》</a></li>
<li>Homiss <a href="https://github.com/Homiss/Java-interview-questions/blob/master/%E6%A1%86%E6%9E%B6/MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98.md">《MyBatis 面试题》</a></li>
</ul>
]]></content>
      <categories>
        <category>MyBatis</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习笔记</title>
    <url>/2019/10/12/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="MySQL学习笔记"><a href="#MySQL学习笔记" class="headerlink" title="MySQL学习笔记"></a>MySQL学习笔记</h1><h2 id="登录和退出MySQL服务器"><a href="#登录和退出MySQL服务器" class="headerlink" title="登录和退出MySQL服务器"></a>登录和退出MySQL服务器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 登录MySQL</span><br><span class="hljs-meta">$</span><span class="bash"> mysql -u root -p12345612</span><br><br><span class="hljs-meta">#</span><span class="bash"> 退出MySQL数据库服务器</span><br>exit;<br></code></pre></td></tr></table></figure>

<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 显示所有数据库<br>show databases;<br><br>-- 创建数据库<br>CREATE DATABASE test;<br><br>-- 切换数据库<br>use test;<br><br>-- 显示数据库中的所有表<br>show tables;<br><br>-- 创建数据表<br>CREATE TABLE pet (<br>    name VARCHAR(20),<br>    owner VARCHAR(20),<br>    species VARCHAR(20),<br>    sex CHAR(1),<br>    birth DATE,<br>    death DATE<br>);<br><br>-- 查看数据表结构<br>-- describe pet;<br>desc pet;<br><br>-- 查询表<br>SELECT * from pet;<br><br>-- 插入数据<br>INSERT INTO pet VALUES (&#39;puffball&#39;, &#39;Diane&#39;, &#39;hamster&#39;, &#39;f&#39;, &#39;1990-03-30&#39;, NULL);<br><br>-- 修改数据<br>UPDATE pet SET name &#x3D; &#39;squirrel&#39; where owner &#x3D; &#39;Diane&#39;;<br><br>-- 删除数据<br>DELETE FROM pet where name &#x3D; &#39;squirrel&#39;;<br><br>-- 删除表<br>DROP TABLE myorder;<br></code></pre></td></tr></table></figure>

<h2 id="建表约束"><a href="#建表约束" class="headerlink" title="建表约束"></a>建表约束</h2><h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 主键约束<br>-- 使某个字段不重复且不得为空，确保表内所有数据的唯一性。<br>CREATE TABLE user (<br>    id INT PRIMARY KEY,<br>    name VARCHAR(20)<br>);<br><br>-- 联合主键<br>-- 联合主键中的每个字段都不能为空，并且加起来不能和已设置的联合主键重复。<br>CREATE TABLE user (<br>    id INT,<br>    name VARCHAR(20),<br>    password VARCHAR(20),<br>    PRIMARY KEY(id, name)<br>);<br><br>-- 自增约束<br>-- 自增约束的主键由系统自动递增分配。<br>CREATE TABLE user (<br>    id INT PRIMARY KEY AUTO_INCREMENT,<br>    name VARCHAR(20)<br>);<br><br>-- 添加主键约束<br>-- 如果忘记设置主键，还可以通过SQL语句设置（两种方式）：<br>ALTER TABLE user ADD PRIMARY KEY(id);<br>ALTER TABLE user MODIFY id INT PRIMARY KEY;<br><br>-- 删除主键<br>ALTER TABLE user drop PRIMARY KEY;<br></code></pre></td></tr></table></figure>

<h3 id="唯一主键"><a href="#唯一主键" class="headerlink" title="唯一主键"></a>唯一主键</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 唯一约束可以为空，而主键约束不能为空<br><br>-- 建表时创建唯一主键<br>CREATE TABLE user (<br>    id INT,<br>    name VARCHAR(20),<br>    UNIQUE(name)<br>);<br><br>-- unique(id,name)表示两个键在一起不重复就行<br>CREATE TABLE user (<br>    id INT,<br>    name VARCHAR(20),<br>    UNIQUE(id,name)<br>);<br><br>-- 添加唯一主键<br>-- 如果建表时没有设置唯一建，还可以通过SQL语句设置（两种方式）：<br>ALTER TABLE user ADD UNIQUE(name);<br>ALTER TABLE user MODIFY name VARCHAR(20) UNIQUE;<br><br>-- 删除唯一主键<br>ALTER TABLE user DROP INDEX name;<br></code></pre></td></tr></table></figure>

<h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 建表时添加非空约束<br>-- 约束某个字段不能为空<br>CREATE TABLE user (<br>    id INT,<br>    name VARCHAR(20) NOT NULL<br>);<br><br>-- 移除非空约束<br>ALTER TABLE user MODIFY name VARCHAR(20);<br></code></pre></td></tr></table></figure>

<h3 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 建表时添加默认约束<br>-- 约束某个字段的默认值<br>CREATE TABLE user2 (<br>    id INT,<br>    name VARCHAR(20),<br>    age INT DEFAULT 10<br>);<br><br>-- 移除非空约束<br>ALTER TABLE user MODIFY age INT;<br></code></pre></td></tr></table></figure>

<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 班级<br>CREATE TABLE classes (<br>    id INT PRIMARY KEY,<br>    name VARCHAR(20)<br>);<br><br>-- 学生表<br>CREATE TABLE students (<br>    id INT PRIMARY KEY,<br>    name VARCHAR(20),<br>    -- 这里的 class_id 要和 classes 中的 id 字段相关联<br>    class_id INT,<br>    -- 表示 class_id 的值必须来自于 classes 中的 id 字段值<br>    FOREIGN KEY(class_id) REFERENCES classes(id)<br>);<br><br>-- 1. 主表（父表）classes 中没有的数据值，在副表（子表）students 中，是不可以使用的；<br>-- 2. 主表中的记录被副表引用时，主表不可以被删除。<br></code></pre></td></tr></table></figure>

<h2 id="数据库的三大设计范式"><a href="#数据库的三大设计范式" class="headerlink" title="数据库的三大设计范式"></a>数据库的三大设计范式</h2><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>只要字段值还可以继续拆分，就不满足第一范式。</p>
<p>范式设计得越详细，对某些实际操作可能会更好，但并非都有好处，需要对项目的实际情况进行设定。</p>
<h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p>在满足第一范式的前提下，其他列都必须完全依赖于主键列。如果出现不完全依赖，只可能发生在联合主键的情况下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 订单表<br>CREATE TABLE myorder (<br>    product_id INT,<br>    customer_id INT,<br>    product_name VARCHAR(20),<br>    customer_name VARCHAR(20),<br>    PRIMARY KEY (product_id, customer_id)<br>);<br></code></pre></td></tr></table></figure>

<p>实际上，在这张订单表中，<code>product_name</code> 只依赖于 <code>product_id</code> ，<code>customer_name</code> 只依赖于 <code>customer_id</code> 。也就是说，<code>product_name</code> 和 <code>customer_id</code> 是没用关系的，<code>customer_name</code> 和 <code>product_id</code> 也是没有关系的。</p>
<p>这就不满足第二范式：其他列都必须完全依赖于主键列！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE myorder (<br>    order_id INT PRIMARY KEY,<br>    product_id INT,<br>    customer_id INT<br>);<br><br>CREATE TABLE product (<br>    id INT PRIMARY KEY,<br>    name VARCHAR(20)<br>);<br><br>CREATE TABLE customer (<br>    id INT PRIMARY KEY,<br>    name VARCHAR(20)<br>);<br></code></pre></td></tr></table></figure>

<p>拆分之后，<code>myorder</code> 表中的 <code>product_id</code> 和 <code>customer_id</code> 完全依赖于 <code>order_id</code> 主键，而 <code>product</code> 和 <code>customer</code> 表中的其他字段又完全依赖于主键。满足了第二范式的设计！</p>
<h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p>在满足第二范式的前提下，除了主键列之外，其他列之间不能有传递依赖关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE myorder (<br>    order_id INT PRIMARY KEY,<br>    product_id INT,<br>    customer_id INT,<br>    customer_phone VARCHAR(15)<br>);<br></code></pre></td></tr></table></figure>

<p>表中的 <code>customer_phone</code> 有可能依赖于 <code>order_id</code> 、 <code>customer_id</code> 两列，也就不满足了第三范式的设计：其他列之间不能有传递依赖关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE myorder (<br>    order_id INT PRIMARY KEY,<br>    product_id INT,<br>    customer_id INT<br>);<br><br>CREATE TABLE customer (<br>    id INT PRIMARY KEY,<br>    name VARCHAR(20),<br>    phone VARCHAR(15)<br>);<br></code></pre></td></tr></table></figure>

<p>修改后就不存在其他列之间的传递依赖关系，其他列都只依赖于主键列，满足了第三范式的设计！</p>
<h2 id="查询练习"><a href="#查询练习" class="headerlink" title="查询练习"></a>查询练习</h2><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 创建数据库<br>CREATE DATABASE select_test;<br>-- 切换数据库<br>USE select_test;<br><br>-- 创建学生表<br>CREATE TABLE student (<br>    no VARCHAR(20) PRIMARY KEY,<br>    name VARCHAR(20) NOT NULL,<br>    sex VARCHAR(10) NOT NULL,<br>    birthday DATE, -- 生日<br>    class VARCHAR(20) -- 所在班级<br>);<br><br>-- 创建教师表<br>CREATE TABLE teacher (<br>    no VARCHAR(20) PRIMARY KEY,<br>    name VARCHAR(20) NOT NULL,<br>    sex VARCHAR(10) NOT NULL,<br>    birthday DATE,<br>    profession VARCHAR(20) NOT NULL, -- 职称<br>    department VARCHAR(20) NOT NULL -- 部门<br>);<br><br>-- 创建课程表<br>CREATE TABLE course (<br>    no VARCHAR(20) PRIMARY KEY,<br>    name VARCHAR(20) NOT NULL,<br>    t_no VARCHAR(20) NOT NULL, -- 教师编号<br>    -- 表示该 tno 来自于 teacher 表中的 no 字段值<br>    FOREIGN KEY(t_no) REFERENCES teacher(no) <br>);<br><br>-- 成绩表<br>CREATE TABLE score (<br>    s_no VARCHAR(20) NOT NULL, -- 学生编号<br>    c_no VARCHAR(20) NOT NULL, -- 课程号<br>    degree DECIMAL,	-- 成绩<br>    -- 表示该 s_no, c_no 分别来自于 student, course 表中的 no 字段值<br>    FOREIGN KEY(s_no) REFERENCES student(no),	<br>    FOREIGN KEY(c_no) REFERENCES course(no),<br>    -- 设置 s_no, c_no 为联合主键<br>    PRIMARY KEY(s_no, c_no)<br>);<br><br>-- 查看所有表<br>SHOW TABLES;<br><br>-- 添加学生表数据<br>INSERT INTO student VALUES(&#39;101&#39;, &#39;曾华&#39;, &#39;男&#39;, &#39;1977-09-01&#39;, &#39;95033&#39;);<br>INSERT INTO student VALUES(&#39;102&#39;, &#39;匡明&#39;, &#39;男&#39;, &#39;1975-10-02&#39;, &#39;95031&#39;);<br>INSERT INTO student VALUES(&#39;103&#39;, &#39;王丽&#39;, &#39;女&#39;, &#39;1976-01-23&#39;, &#39;95033&#39;);<br>INSERT INTO student VALUES(&#39;104&#39;, &#39;李军&#39;, &#39;男&#39;, &#39;1976-02-20&#39;, &#39;95033&#39;);<br>INSERT INTO student VALUES(&#39;105&#39;, &#39;王芳&#39;, &#39;女&#39;, &#39;1975-02-10&#39;, &#39;95031&#39;);<br>INSERT INTO student VALUES(&#39;106&#39;, &#39;陆军&#39;, &#39;男&#39;, &#39;1974-06-03&#39;, &#39;95031&#39;);<br>INSERT INTO student VALUES(&#39;107&#39;, &#39;王尼玛&#39;, &#39;男&#39;, &#39;1976-02-20&#39;, &#39;95033&#39;);<br>INSERT INTO student VALUES(&#39;108&#39;, &#39;张全蛋&#39;, &#39;男&#39;, &#39;1975-02-10&#39;, &#39;95031&#39;);<br>INSERT INTO student VALUES(&#39;109&#39;, &#39;赵铁柱&#39;, &#39;男&#39;, &#39;1974-06-03&#39;, &#39;95031&#39;);<br><br>-- 添加教师表数据<br>INSERT INTO teacher VALUES(&#39;804&#39;, &#39;李诚&#39;, &#39;男&#39;, &#39;1958-12-02&#39;, &#39;副教授&#39;, &#39;计算机系&#39;);<br>INSERT INTO teacher VALUES(&#39;856&#39;, &#39;张旭&#39;, &#39;男&#39;, &#39;1969-03-12&#39;, &#39;讲师&#39;, &#39;电子工程系&#39;);<br>INSERT INTO teacher VALUES(&#39;825&#39;, &#39;王萍&#39;, &#39;女&#39;, &#39;1972-05-05&#39;, &#39;助教&#39;, &#39;计算机系&#39;);<br>INSERT INTO teacher VALUES(&#39;831&#39;, &#39;刘冰&#39;, &#39;女&#39;, &#39;1977-08-14&#39;, &#39;助教&#39;, &#39;电子工程系&#39;);<br><br>-- 添加课程表数据<br>INSERT INTO course VALUES(&#39;3-105&#39;, &#39;计算机导论&#39;, &#39;825&#39;);<br>INSERT INTO course VALUES(&#39;3-245&#39;, &#39;操作系统&#39;, &#39;804&#39;);<br>INSERT INTO course VALUES(&#39;6-166&#39;, &#39;数字电路&#39;, &#39;856&#39;);<br>INSERT INTO course VALUES(&#39;9-888&#39;, &#39;高等数学&#39;, &#39;831&#39;);<br><br>-- 添加添加成绩表数据<br>INSERT INTO score VALUES(&#39;103&#39;, &#39;3-105&#39;, &#39;92&#39;);<br>INSERT INTO score VALUES(&#39;103&#39;, &#39;3-245&#39;, &#39;86&#39;);<br>INSERT INTO score VALUES(&#39;103&#39;, &#39;6-166&#39;, &#39;85&#39;);<br>INSERT INTO score VALUES(&#39;105&#39;, &#39;3-105&#39;, &#39;88&#39;);<br>INSERT INTO score VALUES(&#39;105&#39;, &#39;3-245&#39;, &#39;75&#39;);<br>INSERT INTO score VALUES(&#39;105&#39;, &#39;6-166&#39;, &#39;79&#39;);<br>INSERT INTO score VALUES(&#39;109&#39;, &#39;3-105&#39;, &#39;76&#39;);<br>INSERT INTO score VALUES(&#39;109&#39;, &#39;3-245&#39;, &#39;68&#39;);<br>INSERT INTO score VALUES(&#39;109&#39;, &#39;6-166&#39;, &#39;81&#39;);<br><br>-- 查看表结构<br>SELECT * FROM course;<br>SELECT * FROM score;<br>SELECT * FROM student;<br>SELECT * FROM teacher;<br></code></pre></td></tr></table></figure>

<h3 id="1-到-10"><a href="#1-到-10" class="headerlink" title="1 到 10"></a>1 到 10</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 查询 student 表的所有行<br>SELECT * FROM student;<br><br>-- 查询 student 表中的 name、sex 和 class 字段的所有行<br>SELECT name, sex, class FROM student;<br><br>-- 查询 teacher 表中不重复的 department 列<br>-- DISTINCT: 去重查询<br>SELECT DISTINCT department FROM teacher;<br><br>-- 查询 score 表中成绩在60-80之间的所有行（区间查询和运算符查询）<br>-- BETWEEN xx AND xx: 查询区间, AND 表示 &quot;并且&quot;<br>SELECT * FROM score WHERE degree BETWEEN 60 AND 80;<br>SELECT * FROM score WHERE degree &gt; 60 AND degree &lt; 80;<br><br>-- 查询 score 表中成绩为 85, 86 或 88 的行<br>-- IN: 查询规定中的多个值<br>SELECT * FROM score WHERE degree IN (85, 86, 88);<br><br>-- 查询 student 表中 &#39;95031&#39; 班或性别为 &#39;女&#39; 的所有行<br>-- or: 表示或者关系<br>SELECT * FROM student WHERE class &#x3D; &#39;95031&#39; or sex &#x3D; &#39;女&#39;;<br><br>-- 以 class 降序的方式查询 student 表的所有行<br>-- DESC: 降序，从高到低<br>-- ASC（默认）: 升序，从低到高<br>SELECT * FROM student ORDER BY class DESC;<br>SELECT * FROM student ORDER BY class ASC;<br><br>-- 以 c_no 升序、degree 降序查询 score 表的所有行<br>SELECT * FROM score ORDER BY c_no ASC, degree DESC;<br><br>-- 查询 &quot;95031&quot; 班的学生人数<br>-- COUNT: 统计<br>SELECT COUNT(*) FROM student WHERE class &#x3D; &#39;95031&#39;;<br><br>-- 查询 score 表中的最高分的学生学号和课程编号（子查询或排序查询）。<br>-- (SELECT MAX(degree) FROM score): 子查询，算出最高分<br>SELECT s_no, c_no FROM score WHERE degree &#x3D; (SELECT MAX(degree) FROM score);<br><br>--  排序查询<br>-- LIMIT r, n: 表示从第r行开始，查询n条数据<br>SELECT s_no, c_no, degree FROM score ORDER BY degree DESC LIMIT 0, 1;<br></code></pre></td></tr></table></figure>

<h3 id="分组计算平均成绩"><a href="#分组计算平均成绩" class="headerlink" title="分组计算平均成绩"></a>分组计算平均成绩</h3><p><strong>查询每门课的平均成绩。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- AVG: 平均值<br>SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;3-105&#39;;<br>SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;3-245&#39;;<br>SELECT AVG(degree) FROM score WHERE c_no &#x3D; &#39;6-166&#39;;<br><br>-- GROUP BY: 分组查询<br>SELECT c_no, AVG(degree) FROM score GROUP BY c_no;<br></code></pre></td></tr></table></figure>

<h3 id="分组条件与模糊查询"><a href="#分组条件与模糊查询" class="headerlink" title="分组条件与模糊查询"></a>分组条件与模糊查询</h3><p><strong>查询 <code>score</code> 表中至少有 2 名学生选修，并以 3 开头的课程的平均分数。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM score;<br>-- c_no 课程编号<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 103  | 3-105 |     92 |<br>| 103  | 3-245 |     86 |<br>| 103  | 6-166 |     85 |<br>| 105  | 3-105 |     88 |<br>| 105  | 3-245 |     75 |<br>| 105  | 6-166 |     79 |<br>| 109  | 3-105 |     76 |<br>| 109  | 3-245 |     68 |<br>| 109  | 6-166 |     81 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<p>分析表发现，至少有 2 名学生选修的课程是 <code>3-105</code> 、<code>3-245</code> 、<code>6-166</code> ，以 3 开头的课程是 <code>3-105</code> 、<code>3-245</code> 。也就是说，我们要查询所有 <code>3-105</code> 和 <code>3-245</code> 的 <code>degree</code> 平均分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 首先把 c_no, AVG(degree) 通过分组查询出来<br>SELECT c_no, AVG(degree) FROM score GROUP BY c_no<br>+-------+-------------+<br>| c_no  | AVG(degree) |<br>+-------+-------------+<br>| 3-105 |     85.3333 |<br>| 3-245 |     76.3333 |<br>| 6-166 |     81.6667 |<br>+-------+-------------+<br><br>-- 再查询出至少有 2 名学生选修的课程<br>-- HAVING: 表示持有<br>HAVING COUNT(c_no) &gt;&#x3D; 2<br><br>-- 并且是以 3 开头的课程<br>-- LIKE 表示模糊查询，&quot;%&quot; 是一个通配符，匹配 &quot;3&quot; 后面的任意字符。<br>AND c_no LIKE &#39;3%&#39;;<br><br>-- 把前面的SQL语句拼接起来，<br>-- 后面加上一个 COUNT(*)，表示将每个分组的个数也查询出来。<br>SELECT c_no, AVG(degree), COUNT(*) FROM score GROUP BY c_no<br>HAVING COUNT(c_no) &gt;&#x3D; 2 AND c_no LIKE &#39;3%&#39;;<br>+-------+-------------+----------+<br>| c_no  | AVG(degree) | COUNT(*) |<br>+-------+-------------+----------+<br>| 3-105 |     85.3333 |        3 |<br>| 3-245 |     76.3333 |        3 |<br>+-------+-------------+----------+<br></code></pre></td></tr></table></figure>

<h3 id="多表查询-1"><a href="#多表查询-1" class="headerlink" title="多表查询 - 1"></a>多表查询 - 1</h3><p><strong>查询所有学生的 <code>name</code>，以及该学生在 <code>score</code> 表中对应的 <code>c_no</code> 和 <code>degree</code> 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT no, name FROM student;<br>+-----+-----------+<br>| no  | name      |<br>+-----+-----------+<br>| 101 | 曾华      |<br>| 102 | 匡明      |<br>| 103 | 王丽      |<br>| 104 | 李军      |<br>| 105 | 王芳      |<br>| 106 | 陆军      |<br>| 107 | 王尼玛    |<br>| 108 | 张全蛋    |<br>| 109 | 赵铁柱    |<br>+-----+-----------+<br><br>SELECT s_no, c_no, degree FROM score;<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 103  | 3-105 |     92 |<br>| 103  | 3-245 |     86 |<br>| 103  | 6-166 |     85 |<br>| 105  | 3-105 |     88 |<br>| 105  | 3-245 |     75 |<br>| 105  | 6-166 |     79 |<br>| 109  | 3-105 |     76 |<br>| 109  | 3-245 |     68 |<br>| 109  | 6-166 |     81 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<p>通过分析可以发现，只要把 <code>score</code> 表中的 <code>s_no</code> 字段值替换成 <code>student</code> 表中对应的 <code>name</code> 字段值就可以了，如何做呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- FROM...: 表示从 student, score 表中查询<br>-- WHERE 的条件表示为，只有在 student.no 和 score.s_no 相等时才显示出来。<br>SELECT name, c_no, degree FROM student, score <br>WHERE student.no &#x3D; score.s_no;<br>+-----------+-------+--------+<br>| name      | c_no  | degree |<br>+-----------+-------+--------+<br>| 王丽      | 3-105 |     92 |<br>| 王丽      | 3-245 |     86 |<br>| 王丽      | 6-166 |     85 |<br>| 王芳      | 3-105 |     88 |<br>| 王芳      | 3-245 |     75 |<br>| 王芳      | 6-166 |     79 |<br>| 赵铁柱    | 3-105 |     76 |<br>| 赵铁柱    | 3-245 |     68 |<br>| 赵铁柱    | 6-166 |     81 |<br>+-----------+-------+--------+<br></code></pre></td></tr></table></figure>

<h3 id="多表查询-2"><a href="#多表查询-2" class="headerlink" title="多表查询 - 2"></a>多表查询 - 2</h3><p><strong>查询所有学生的 <code>no</code> 、课程名称 ( <code>course</code> 表中的 <code>name</code> ) 和成绩 ( <code>score</code> 表中的 <code>degree</code> ) 列。</strong></p>
<p>只有 <code>score</code> 关联学生的 <code>no</code> ，因此只要查询 <code>score</code> 表，就能找出所有和学生相关的 <code>no</code> 和 <code>degree</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT s_no, c_no, degree FROM score;<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 103  | 3-105 |     92 |<br>| 103  | 3-245 |     86 |<br>| 103  | 6-166 |     85 |<br>| 105  | 3-105 |     88 |<br>| 105  | 3-245 |     75 |<br>| 105  | 6-166 |     79 |<br>| 109  | 3-105 |     76 |<br>| 109  | 3-245 |     68 |<br>| 109  | 6-166 |     81 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<p>然后查询 <code>course</code> 表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">+-------+-----------------+<br>| no    | name            |<br>+-------+-----------------+<br>| 3-105 | 计算机导论      |<br>| 3-245 | 操作系统        |<br>| 6-166 | 数字电路        |<br>| 9-888 | 高等数学        |<br>+-------+-----------------+<br></code></pre></td></tr></table></figure>

<p>只要把 <code>score</code> 表中的 <code>c_no</code> 替换成 <code>course</code> 表中对应的 <code>name</code> 字段值就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 增加一个查询字段 name，分别从 score、course 这两个表中查询。<br>-- as 表示取一个该字段的别名。<br>SELECT s_no, name as c_name, degree FROM score, course<br>WHERE score.c_no &#x3D; course.no;<br>+------+-----------------+--------+<br>| s_no | c_name          | degree |<br>+------+-----------------+--------+<br>| 103  | 计算机导论      |     92 |<br>| 105  | 计算机导论      |     88 |<br>| 109  | 计算机导论      |     76 |<br>| 103  | 操作系统        |     86 |<br>| 105  | 操作系统        |     75 |<br>| 109  | 操作系统        |     68 |<br>| 103  | 数字电路        |     85 |<br>| 105  | 数字电路        |     79 |<br>| 109  | 数字电路        |     81 |<br>+------+-----------------+--------+<br></code></pre></td></tr></table></figure>

<h3 id="三表关联查询"><a href="#三表关联查询" class="headerlink" title="三表关联查询"></a>三表关联查询</h3><p><strong>查询所有学生的 <code>name</code> 、课程名 ( <code>course</code> 表中的 <code>name</code> ) 和 <code>degree</code> 。</strong></p>
<p>只有 <code>score</code> 表中关联学生的学号和课堂号，我们只要围绕着 <code>score</code> 这张表查询就好了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM score;<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 103  | 3-105 |     92 |<br>| 103  | 3-245 |     86 |<br>| 103  | 6-166 |     85 |<br>| 105  | 3-105 |     88 |<br>| 105  | 3-245 |     75 |<br>| 105  | 6-166 |     79 |<br>| 109  | 3-105 |     76 |<br>| 109  | 3-245 |     68 |<br>| 109  | 6-166 |     81 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<p>只要把 <code>s_no</code> 和 <code>c_no</code> 替换成 <code>student</code> 和 <code>srouse</code> 表中对应的 <code>name</code> 字段值就好了。</p>
<p>首先把 <code>s_no</code> 替换成 <code>student</code> 表中的 <code>name</code> 字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT name, c_no, degree FROM student, score WHERE student.no &#x3D; score.s_no;<br>+-----------+-------+--------+<br>| name      | c_no  | degree |<br>+-----------+-------+--------+<br>| 王丽      | 3-105 |     92 |<br>| 王丽      | 3-245 |     86 |<br>| 王丽      | 6-166 |     85 |<br>| 王芳      | 3-105 |     88 |<br>| 王芳      | 3-245 |     75 |<br>| 王芳      | 6-166 |     79 |<br>| 赵铁柱    | 3-105 |     76 |<br>| 赵铁柱    | 3-245 |     68 |<br>| 赵铁柱    | 6-166 |     81 |<br>+-----------+-------+--------+<br></code></pre></td></tr></table></figure>

<p>再把 <code>c_no</code> 替换成 <code>course</code> 表中的 <code>name</code> 字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 课程表<br>SELECT no, name FROM course;<br>+-------+-----------------+<br>| no    | name            |<br>+-------+-----------------+<br>| 3-105 | 计算机导论      |<br>| 3-245 | 操作系统        |<br>| 6-166 | 数字电路        |<br>| 9-888 | 高等数学        |<br>+-------+-----------------+<br><br>-- 由于字段名存在重复，使用 &quot;表名.字段名 as 别名&quot; 代替。<br>SELECT student.name as s_name, course.name as c_name, degree <br>FROM student, score, course<br>WHERE student.NO &#x3D; score.s_no<br>AND score.c_no &#x3D; course.no;<br></code></pre></td></tr></table></figure>

<h3 id="子查询加分组求平均分"><a href="#子查询加分组求平均分" class="headerlink" title="子查询加分组求平均分"></a>子查询加分组求平均分</h3><p><strong>查询 <code>95031</code> 班学生每门课程的平均成绩。</strong></p>
<p>在 <code>score</code> 表中根据 <code>student</code>  表的学生编号筛选出学生的课堂号和成绩：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- IN (..): 将筛选出的学生号当做 s_no 的条件查询<br>SELECT s_no, c_no, degree FROM score<br>WHERE s_no IN (SELECT no FROM student WHERE class &#x3D; &#39;95031&#39;);<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 105  | 3-105 |     88 |<br>| 105  | 3-245 |     75 |<br>| 105  | 6-166 |     79 |<br>| 109  | 3-105 |     76 |<br>| 109  | 3-245 |     68 |<br>| 109  | 6-166 |     81 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<p>这时只要将 <code>c_no</code> 分组一下就能得出 <code>95031</code> 班学生每门课的平均成绩：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT c_no, AVG(degree) FROM score<br>WHERE s_no IN (SELECT no FROM student WHERE class &#x3D; &#39;95031&#39;)<br>GROUP BY c_no;<br>+-------+-------------+<br>| c_no  | AVG(degree) |<br>+-------+-------------+<br>| 3-105 |     82.0000 |<br>| 3-245 |     71.5000 |<br>| 6-166 |     80.0000 |<br>+-------+-------------+<br></code></pre></td></tr></table></figure>

<h3 id="子查询-1"><a href="#子查询-1" class="headerlink" title="子查询 - 1"></a>子查询 - 1</h3><p><strong>查询在 <code>3-105</code> 课程中，所有成绩高于 <code>109</code> 号同学的记录。</strong></p>
<p>首先筛选出课堂号为 <code>3-105</code> ，在找出所有成绩高于 <code>109</code> 号同学的的行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM score <br>WHERE c_no &#x3D; &#39;3-105&#39;<br>AND degree &gt; (SELECT degree FROM score WHERE s_no &#x3D; &#39;109&#39; AND c_no &#x3D; &#39;3-105&#39;);<br></code></pre></td></tr></table></figure>

<h3 id="子查询-2"><a href="#子查询-2" class="headerlink" title="子查询 - 2"></a>子查询 - 2</h3><p><strong>查询所有成绩高于 <code>109</code> 号同学的 <code>3-105</code> 课程成绩记录。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 不限制课程号，只要成绩大于109号同学的3-105课程成绩就可以。<br>SELECT * FROM score<br>WHERE degree &gt; (SELECT degree FROM score WHERE s_no &#x3D; &#39;109&#39; AND c_no &#x3D; &#39;3-105&#39;);<br></code></pre></td></tr></table></figure>

<h3 id="YEAR-函数与带-IN-关键字查询"><a href="#YEAR-函数与带-IN-关键字查询" class="headerlink" title="YEAR 函数与带 IN 关键字查询"></a>YEAR 函数与带 IN 关键字查询</h3><p><strong>查询所有和 <code>101</code> 、<code>108</code> 号学生同年出生的 <code>no</code> 、<code>name</code> 、<code>birthday</code> 列。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- YEAR(..): 取出日期中的年份<br>SELECT no, name, birthday FROM student<br>WHERE YEAR(birthday) IN (SELECT YEAR(birthday) FROM student WHERE no IN (101, 108));<br></code></pre></td></tr></table></figure>

<h3 id="多层嵌套子查询"><a href="#多层嵌套子查询" class="headerlink" title="多层嵌套子查询"></a>多层嵌套子查询</h3><p><strong>查询 <code>&#39;张旭&#39;</code> 教师任课的学生成绩表。</strong></p>
<p>首先找到教师编号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT NO FROM teacher WHERE NAME &#x3D; &#39;张旭&#39;<br></code></pre></td></tr></table></figure>

<p>通过 <code>sourse</code> 表找到该教师课程号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT NO FROM course WHERE t_no &#x3D; ( SELECT NO FROM teacher WHERE NAME &#x3D; &#39;张旭&#39; );<br></code></pre></td></tr></table></figure>

<p>通过筛选出的课程号查询成绩表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM score WHERE c_no &#x3D; (<br>    SELECT no FROM course WHERE t_no &#x3D; ( <br>        SELECT no FROM teacher WHERE NAME &#x3D; &#39;张旭&#39; <br>    )<br>);<br></code></pre></td></tr></table></figure>

<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p><strong>查询某选修课程多于5个同学的教师姓名。</strong></p>
<p>首先在 <code>teacher</code> 表中，根据 <code>no</code> 字段来判断该教师的同一门课程是否有至少5名学员选修：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 查询 teacher 表<br>SELECT no, name FROM teacher;<br>+-----+--------+<br>| no  | name   |<br>+-----+--------+<br>| 804 | 李诚   |<br>| 825 | 王萍   |<br>| 831 | 刘冰   |<br>| 856 | 张旭   |<br>+-----+--------+<br><br>SELECT name FROM teacher WHERE no IN (<br>    -- 在这里找到对应的条件<br>);<br></code></pre></td></tr></table></figure>

<p>查看和教师编号有有关的表的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM course;<br>-- t_no: 教师编号<br>+-------+-----------------+------+<br>| no    | name            | t_no |<br>+-------+-----------------+------+<br>| 3-105 | 计算机导论      | 825  |<br>| 3-245 | 操作系统        | 804  |<br>| 6-166 | 数字电路        | 856  |<br>| 9-888 | 高等数学        | 831  |<br>+-------+-----------------+------+<br></code></pre></td></tr></table></figure>

<p>我们已经找到和教师编号有关的字段就在 <code>course</code> 表中，但是还无法知道哪门课程至少有5名学生选修，所以还需要根据 <code>score</code> 表来查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 在此之前向 score 插入一些数据，以便丰富查询条件。<br>INSERT INTO score VALUES (&#39;101&#39;, &#39;3-105&#39;, &#39;90&#39;);<br>INSERT INTO score VALUES (&#39;102&#39;, &#39;3-105&#39;, &#39;91&#39;);<br>INSERT INTO score VALUES (&#39;104&#39;, &#39;3-105&#39;, &#39;89&#39;);<br><br>-- 查询 score 表<br>SELECT * FROM score;<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 101  | 3-105 |     90 |<br>| 102  | 3-105 |     91 |<br>| 103  | 3-105 |     92 |<br>| 103  | 3-245 |     86 |<br>| 103  | 6-166 |     85 |<br>| 104  | 3-105 |     89 |<br>| 105  | 3-105 |     88 |<br>| 105  | 3-245 |     75 |<br>| 105  | 6-166 |     79 |<br>| 109  | 3-105 |     76 |<br>| 109  | 3-245 |     68 |<br>| 109  | 6-166 |     81 |<br>+------+-------+--------+<br><br>-- 在 score 表中将 c_no 作为分组，并且限制 c_no 持有至少 5 条数据。<br>SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5;<br>+-------+<br>| c_no  |<br>+-------+<br>| 3-105 |<br>+-------+<br></code></pre></td></tr></table></figure>

<p>根据筛选出来的课程号，找出在某课程中，拥有至少5名学员的教师编号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT t_no FROM course WHERE no IN (<br>    SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5<br>);<br>+------+<br>| t_no |<br>+------+<br>| 825  |<br>+------+<br></code></pre></td></tr></table></figure>

<p>在 <code>teacher</code> 表中，根据筛选出来的教师编号找到教师姓名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT name FROM teacher WHERE no IN (<br>    -- 最终条件<br>    SELECT t_no FROM course WHERE no IN (<br>        SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) &gt; 5<br>    )<br>);<br></code></pre></td></tr></table></figure>

<h3 id="子查询-3"><a href="#子查询-3" class="headerlink" title="子查询 - 3"></a>子查询 - 3</h3><p><strong>查询 “计算机系” 课程的成绩表。</strong></p>
<p>思路是，先找出 <code>course</code> 表中所有 <code>计算机系</code> 课程的编号，然后根据这个编号查询 <code>score</code> 表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 通过 teacher 表查询所有 &#96;计算机系&#96; 的教师编号<br>SELECT no, name, department FROM teacher WHERE department &#x3D; &#39;计算机系&#39;<br>+-----+--------+--------------+<br>| no  | name   | department   |<br>+-----+--------+--------------+<br>| 804 | 李诚   | 计算机系     |<br>| 825 | 王萍   | 计算机系     |<br>+-----+--------+--------------+<br><br>-- 通过 course 表查询该教师的课程编号<br>SELECT no FROM course WHERE t_no IN (<br>    SELECT no FROM teacher WHERE department &#x3D; &#39;计算机系&#39;<br>);<br>+-------+<br>| no    |<br>+-------+<br>| 3-245 |<br>| 3-105 |<br>+-------+<br><br>-- 根据筛选出来的课程号查询成绩表<br>SELECT * FROM score WHERE c_no IN (<br>    SELECT no FROM course WHERE t_no IN (<br>        SELECT no FROM teacher WHERE department &#x3D; &#39;计算机系&#39;<br>    )<br>);<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 103  | 3-245 |     86 |<br>| 105  | 3-245 |     75 |<br>| 109  | 3-245 |     68 |<br>| 101  | 3-105 |     90 |<br>| 102  | 3-105 |     91 |<br>| 103  | 3-105 |     92 |<br>| 104  | 3-105 |     89 |<br>| 105  | 3-105 |     88 |<br>| 109  | 3-105 |     76 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<h3 id="UNION-和-NOTIN-的使用"><a href="#UNION-和-NOTIN-的使用" class="headerlink" title="UNION 和 NOTIN 的使用"></a>UNION 和 NOTIN 的使用</h3><p><strong>查询 <code>计算机系</code> 与 <code>电子工程系</code> 中的不同职称的教师。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- NOT: 代表逻辑非<br>SELECT * FROM teacher WHERE department &#x3D; &#39;计算机系&#39; AND profession NOT IN (<br>    SELECT profession FROM teacher WHERE department &#x3D; &#39;电子工程系&#39;<br>)<br>-- 合并两个集<br>UNION<br>SELECT * FROM teacher WHERE department &#x3D; &#39;电子工程系&#39; AND profession NOT IN (<br>    SELECT profession FROM teacher WHERE department &#x3D; &#39;计算机系&#39;<br>);<br></code></pre></td></tr></table></figure>

<h3 id="ANY-表示至少一个-DESC-降序"><a href="#ANY-表示至少一个-DESC-降序" class="headerlink" title="ANY 表示至少一个 - DESC ( 降序 )"></a>ANY 表示至少一个 - DESC ( 降序 )</h3><p><strong>查询课程 <code>3-105</code> 且成绩 <u>至少</u> 高于 <code>3-245</code> 的 <code>score</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39;;<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 101  | 3-105 |     90 |<br>| 102  | 3-105 |     91 |<br>| 103  | 3-105 |     92 |<br>| 104  | 3-105 |     89 |<br>| 105  | 3-105 |     88 |<br>| 109  | 3-105 |     76 |<br>+------+-------+--------+<br><br>SELECT * FROM score WHERE c_no &#x3D; &#39;3-245&#39;;<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 103  | 3-245 |     86 |<br>| 105  | 3-245 |     75 |<br>| 109  | 3-245 |     68 |<br>+------+-------+--------+<br><br>-- ANY: 符合SQL语句中的任意条件。<br>-- 也就是说，在 3-105 成绩中，只要有一个大于从 3-245 筛选出来的任意行就符合条件，<br>-- 最后根据降序查询结果。<br>SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39; AND degree &gt; ANY(<br>    SELECT degree FROM score WHERE c_no &#x3D; &#39;3-245&#39;<br>) ORDER BY degree DESC;<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 103  | 3-105 |     92 |<br>| 102  | 3-105 |     91 |<br>| 101  | 3-105 |     90 |<br>| 104  | 3-105 |     89 |<br>| 105  | 3-105 |     88 |<br>| 109  | 3-105 |     76 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<h3 id="表示所有的-ALL"><a href="#表示所有的-ALL" class="headerlink" title="表示所有的 ALL"></a>表示所有的 ALL</h3><p><strong>查询课程 <code>3-105</code> 且成绩高于 <code>3-245</code> 的 <code>score</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 只需对上一道题稍作修改。<br>-- ALL: 符合SQL语句中的所有条件。<br>-- 也就是说，在 3-105 每一行成绩中，都要大于从 3-245 筛选出来全部行才算符合条件。<br>SELECT * FROM score WHERE c_no &#x3D; &#39;3-105&#39; AND degree &gt; ALL(<br>    SELECT degree FROM score WHERE c_no &#x3D; &#39;3-245&#39;<br>);<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 101  | 3-105 |     90 |<br>| 102  | 3-105 |     91 |<br>| 103  | 3-105 |     92 |<br>| 104  | 3-105 |     89 |<br>| 105  | 3-105 |     88 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<h3 id="复制表的数据作为条件查询"><a href="#复制表的数据作为条件查询" class="headerlink" title="复制表的数据作为条件查询"></a>复制表的数据作为条件查询</h3><p><strong>查询某课程成绩比该课程平均成绩低的 <code>score</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 查询平均分<br>SELECT c_no, AVG(degree) FROM score GROUP BY c_no;<br>+-------+-------------+<br>| c_no  | AVG(degree) |<br>+-------+-------------+<br>| 3-105 |     87.6667 |<br>| 3-245 |     76.3333 |<br>| 6-166 |     81.6667 |<br>+-------+-------------+<br><br>-- 查询 score 表<br>SELECT degree FROM score;<br>+--------+<br>| degree |<br>+--------+<br>|     90 |<br>|     91 |<br>|     92 |<br>|     86 |<br>|     85 |<br>|     89 |<br>|     88 |<br>|     75 |<br>|     79 |<br>|     76 |<br>|     68 |<br>|     81 |<br>+--------+<br><br>-- 将表 b 作用于表 a 中查询数据<br>-- score a (b): 将表声明为 a (b)，<br>-- 如此就能用 a.c_no &#x3D; b.c_no 作为条件执行查询了。<br>SELECT * FROM score a WHERE degree &lt; (<br>    (SELECT AVG(degree) FROM score b WHERE a.c_no &#x3D; b.c_no)<br>);<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 105  | 3-245 |     75 |<br>| 105  | 6-166 |     79 |<br>| 109  | 3-105 |     76 |<br>| 109  | 3-245 |     68 |<br>| 109  | 6-166 |     81 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<h3 id="子查询-4"><a href="#子查询-4" class="headerlink" title="子查询 - 4"></a>子查询 - 4</h3><p><strong>查询所有任课 ( 在 <code>course</code> 表里有课程 ) 教师的 <code>name</code> 和 <code>department</code></strong> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT name, department FROM teacher WHERE no IN (SELECT t_no FROM course);<br>+--------+-----------------+<br>| name   | department      |<br>+--------+-----------------+<br>| 李诚   | 计算机系        |<br>| 王萍   | 计算机系        |<br>| 刘冰   | 电子工程系      |<br>| 张旭   | 电子工程系      |<br>+--------+-----------------+<br></code></pre></td></tr></table></figure>

<h3 id="条件加组筛选"><a href="#条件加组筛选" class="headerlink" title="条件加组筛选"></a>条件加组筛选</h3><p><strong>查询 <code>student</code> 表中至少有 2 名男生的 <code>class</code> 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 查看学生表信息<br>SELECT * FROM student;<br>+-----+-----------+-----+------------+-------+<br>| no  | name      | sex | birthday   | class |<br>+-----+-----------+-----+------------+-------+<br>| 101 | 曾华      | 男  | 1977-09-01 | 95033 |<br>| 102 | 匡明      | 男  | 1975-10-02 | 95031 |<br>| 103 | 王丽      | 女  | 1976-01-23 | 95033 |<br>| 104 | 李军      | 男  | 1976-02-20 | 95033 |<br>| 105 | 王芳      | 女  | 1975-02-10 | 95031 |<br>| 106 | 陆军      | 男  | 1974-06-03 | 95031 |<br>| 107 | 王尼玛    | 男  | 1976-02-20 | 95033 |<br>| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |<br>| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |<br>| 110 | 张飞      | 男  | 1974-06-03 | 95038 |<br>+-----+-----------+-----+------------+-------+<br><br>-- 只查询性别为男，然后按 class 分组，并限制 class 行大于 1。<br>SELECT class FROM student WHERE sex &#x3D; &#39;男&#39; GROUP BY class HAVING COUNT(*) &gt; 1;<br>+-------+<br>| class |<br>+-------+<br>| 95033 |<br>| 95031 |<br>+-------+<br></code></pre></td></tr></table></figure>

<h3 id="NOTLIKE-模糊查询取反"><a href="#NOTLIKE-模糊查询取反" class="headerlink" title="NOTLIKE 模糊查询取反"></a>NOTLIKE 模糊查询取反</h3><p><strong>查询 <code>student</code> 表中不姓 “王” 的同学记录。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- NOT: 取反<br>-- LIKE: 模糊查询<br>mysql&gt; SELECT * FROM student WHERE name NOT LIKE &#39;王%&#39;;<br>+-----+-----------+-----+------------+-------+<br>| no  | name      | sex | birthday   | class |<br>+-----+-----------+-----+------------+-------+<br>| 101 | 曾华      | 男  | 1977-09-01 | 95033 |<br>| 102 | 匡明      | 男  | 1975-10-02 | 95031 |<br>| 104 | 李军      | 男  | 1976-02-20 | 95033 |<br>| 106 | 陆军      | 男  | 1974-06-03 | 95031 |<br>| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |<br>| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |<br>| 110 | 张飞      | 男  | 1974-06-03 | 95038 |<br>+-----+-----------+-----+------------+-------+<br></code></pre></td></tr></table></figure>

<h3 id="YEAR-与-NOW-函数"><a href="#YEAR-与-NOW-函数" class="headerlink" title="YEAR 与 NOW 函数"></a>YEAR 与 NOW 函数</h3><p><strong>查询 <code>student</code> 表中每个学生的姓名和年龄。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 使用函数 YEAR(NOW()) 计算出当前年份，减去出生年份后得出年龄。<br>SELECT name, YEAR(NOW()) - YEAR(birthday) as age FROM student;<br>+-----------+------+<br>| name      | age  |<br>+-----------+------+<br>| 曾华      |   42 |<br>| 匡明      |   44 |<br>| 王丽      |   43 |<br>| 李军      |   43 |<br>| 王芳      |   44 |<br>| 陆军      |   45 |<br>| 王尼玛    |   43 |<br>| 张全蛋    |   44 |<br>| 赵铁柱    |   45 |<br>| 张飞      |   45 |<br>+-----------+------+<br></code></pre></td></tr></table></figure>

<h3 id="MAX-与-MIN-函数"><a href="#MAX-与-MIN-函数" class="headerlink" title="MAX 与 MIN 函数"></a>MAX 与 MIN 函数</h3><p><strong>查询 <code>student</code> 表中最大和最小的 <code>birthday</code> 值。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT MAX(birthday), MIN(birthday) FROM student;<br>+---------------+---------------+<br>| MAX(birthday) | MIN(birthday) |<br>+---------------+---------------+<br>| 1977-09-01    | 1974-06-03    |<br>+---------------+---------------+<br></code></pre></td></tr></table></figure>

<h3 id="多段排序"><a href="#多段排序" class="headerlink" title="多段排序"></a>多段排序</h3><p><strong>以 <code>class</code> 和 <code>birthday</code> 从大到小的顺序查询 <code>student</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM student ORDER BY class DESC, birthday;<br>+-----+-----------+-----+------------+-------+<br>| no  | name      | sex | birthday   | class |<br>+-----+-----------+-----+------------+-------+<br>| 110 | 张飞      | 男  | 1974-06-03 | 95038 |<br>| 103 | 王丽      | 女  | 1976-01-23 | 95033 |<br>| 104 | 李军      | 男  | 1976-02-20 | 95033 |<br>| 107 | 王尼玛    | 男  | 1976-02-20 | 95033 |<br>| 101 | 曾华      | 男  | 1977-09-01 | 95033 |<br>| 106 | 陆军      | 男  | 1974-06-03 | 95031 |<br>| 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 |<br>| 105 | 王芳      | 女  | 1975-02-10 | 95031 |<br>| 108 | 张全蛋    | 男  | 1975-02-10 | 95031 |<br>| 102 | 匡明      | 男  | 1975-10-02 | 95031 |<br>+-----+-----------+-----+------------+-------+<br></code></pre></td></tr></table></figure>

<h3 id="子查询-5"><a href="#子查询-5" class="headerlink" title="子查询 - 5"></a>子查询 - 5</h3><p><strong>查询 “男” 教师及其所上的课程。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM course WHERE t_no in (SELECT no FROM teacher WHERE sex &#x3D; &#39;男&#39;);<br>+-------+--------------+------+<br>| no    | name         | t_no |<br>+-------+--------------+------+<br>| 3-245 | 操作系统     | 804  |<br>| 6-166 | 数字电路     | 856  |<br>+-------+--------------+------+<br></code></pre></td></tr></table></figure>

<h3 id="MAX-函数与子查询"><a href="#MAX-函数与子查询" class="headerlink" title="MAX 函数与子查询"></a>MAX 函数与子查询</h3><p><strong>查询最高分同学的 <code>score</code> 表。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 找出最高成绩（该查询只能有一个结果）<br>SELECT MAX(degree) FROM score;<br><br>-- 根据上面的条件筛选出所有最高成绩表，<br>-- 该查询可能有多个结果，假设 degree 值多次符合条件。<br>SELECT * FROM score WHERE degree &#x3D; (SELECT MAX(degree) FROM score);<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 103  | 3-105 |     92 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<h3 id="子查询-6"><a href="#子查询-6" class="headerlink" title="子查询 - 6"></a>子查询 - 6</h3><p><strong>查询和 “李军” 同性别的所有同学 <code>name</code> 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 首先将李军的性别作为条件取出来<br>SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;;<br>+-----+<br>| sex |<br>+-----+<br>| 男  |<br>+-----+<br><br>-- 根据性别查询 name 和 sex<br>SELECT name, sex FROM student WHERE sex &#x3D; (<br>    SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;<br>);<br>+-----------+-----+<br>| name      | sex |<br>+-----------+-----+<br>| 曾华      | 男  |<br>| 匡明      | 男  |<br>| 李军      | 男  |<br>| 陆军      | 男  |<br>| 王尼玛    | 男  |<br>| 张全蛋    | 男  |<br>| 赵铁柱    | 男  |<br>| 张飞      | 男  |<br>+-----------+-----+<br></code></pre></td></tr></table></figure>

<h3 id="子查询-7"><a href="#子查询-7" class="headerlink" title="子查询 - 7"></a>子查询 - 7</h3><p><strong>查询和 “李军” 同性别且同班的同学 <code>name</code> 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT name, sex, class FROM student WHERE sex &#x3D; (<br>    SELECT sex FROM student WHERE name &#x3D; &#39;李军&#39;<br>) AND class &#x3D; (<br>    SELECT class FROM student WHERE name &#x3D; &#39;李军&#39;<br>);<br>+-----------+-----+-------+<br>| name      | sex | class |<br>+-----------+-----+-------+<br>| 曾华      | 男  | 95033 |<br>| 李军      | 男  | 95033 |<br>| 王尼玛    | 男  | 95033 |<br>+-----------+-----+-------+<br></code></pre></td></tr></table></figure>

<h3 id="子查询-8"><a href="#子查询-8" class="headerlink" title="子查询 - 8"></a>子查询 - 8</h3><p><strong>查询所有选修 “计算机导论” 课程的 “男” 同学成绩表。</strong></p>
<p>需要的 “计算机导论” 和性别为 “男” 的编号可以在 <code>course</code> 和 <code>student</code> 表中找到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM score WHERE c_no &#x3D; (<br>    SELECT no FROM course WHERE name &#x3D; &#39;计算机导论&#39;<br>) AND s_no IN (<br>    SELECT no FROM student WHERE sex &#x3D; &#39;男&#39;<br>);<br>+------+-------+--------+<br>| s_no | c_no  | degree |<br>+------+-------+--------+<br>| 101  | 3-105 |     90 |<br>| 102  | 3-105 |     91 |<br>| 104  | 3-105 |     89 |<br>| 109  | 3-105 |     76 |<br>+------+-------+--------+<br></code></pre></td></tr></table></figure>

<h3 id="按等级查询"><a href="#按等级查询" class="headerlink" title="按等级查询"></a>按等级查询</h3><p>建立一个 <code>grade</code> 表代表学生的成绩等级，并插入数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE grade (<br>    low INT(3),<br>    upp INT(3),<br>    grade char(1)<br>);<br><br>INSERT INTO grade VALUES (90, 100, &#39;A&#39;);<br>INSERT INTO grade VALUES (80, 89, &#39;B&#39;);<br>INSERT INTO grade VALUES (70, 79, &#39;C&#39;);<br>INSERT INTO grade VALUES (60, 69, &#39;D&#39;);<br>INSERT INTO grade VALUES (0, 59, &#39;E&#39;);<br><br>SELECT * FROM grade;<br>+------+------+-------+<br>| low  | upp  | grade |<br>+------+------+-------+<br>|   90 |  100 | A     |<br>|   80 |   89 | B     |<br>|   70 |   79 | C     |<br>|   60 |   69 | D     |<br>|    0 |   59 | E     |<br>+------+------+-------+<br></code></pre></td></tr></table></figure>

<p><strong>查询所有学生的 <code>s_no</code> 、<code>c_no</code> 和 <code>grade</code> 列。</strong></p>
<p>思路是，使用区间 ( <code>BETWEEN</code> ) 查询，判断学生的成绩 ( <code>degree</code> )  在 <code>grade</code> 表的 <code>low</code> 和 <code>upp</code> 之间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT s_no, c_no, grade FROM score, grade <br>WHERE degree BETWEEN low AND upp;<br>+------+-------+-------+<br>| s_no | c_no  | grade |<br>+------+-------+-------+<br>| 101  | 3-105 | A     |<br>| 102  | 3-105 | A     |<br>| 103  | 3-105 | A     |<br>| 103  | 3-245 | B     |<br>| 103  | 6-166 | B     |<br>| 104  | 3-105 | B     |<br>| 105  | 3-105 | B     |<br>| 105  | 3-245 | C     |<br>| 105  | 6-166 | C     |<br>| 109  | 3-105 | C     |<br>| 109  | 3-245 | D     |<br>| 109  | 6-166 | B     |<br>+------+-------+-------+<br></code></pre></td></tr></table></figure>

<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>准备用于测试连接查询的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE DATABASE testJoin;<br><br>CREATE TABLE person (<br>    id INT,<br>    name VARCHAR(20),<br>    cardId INT<br>);<br><br>CREATE TABLE card (<br>    id INT,<br>    name VARCHAR(20)<br>);<br><br>INSERT INTO card VALUES (1, &#39;饭卡&#39;), (2, &#39;建行卡&#39;), (3, &#39;农行卡&#39;), (4, &#39;工商卡&#39;), (5, &#39;邮政卡&#39;);<br>SELECT * FROM card;<br>+------+-----------+<br>| id   | name      |<br>+------+-----------+<br>|    1 | 饭卡      |<br>|    2 | 建行卡    |<br>|    3 | 农行卡    |<br>|    4 | 工商卡    |<br>|    5 | 邮政卡    |<br>+------+-----------+<br><br>INSERT INTO person VALUES (1, &#39;张三&#39;, 1), (2, &#39;李四&#39;, 3), (3, &#39;王五&#39;, 6);<br>SELECT * FROM person;<br>+------+--------+--------+<br>| id   | name   | cardId |<br>+------+--------+--------+<br>|    1 | 张三   |      1 |<br>|    2 | 李四   |      3 |<br>|    3 | 王五   |      6 |<br>+------+--------+--------+<br></code></pre></td></tr></table></figure>

<p>分析两张表发现，<code>person</code> 表并没有为 <code>cardId</code> 字段设置一个在 <code>card</code> 表中对应的 <code>id</code> 外键。如果设置了的话，<code>person</code> 中 <code>cardId</code> 字段值为 <code>6</code> 的行就插不进去，因为该 <code>cardId</code> 值在 <code>card</code> 表中并没有。</p>
<h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>要查询这两张表中有关系的数据，可以使用 <code>INNER JOIN</code> ( 内连接 ) 将它们连接在一起。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- INNER JOIN: 表示为内连接，将两张表拼接在一起。<br>-- on: 表示要执行某个条件。<br>SELECT * FROM person INNER JOIN card on person.cardId &#x3D; card.id;<br>+------+--------+--------+------+-----------+<br>| id   | name   | cardId | id   | name      |<br>+------+--------+--------+------+-----------+<br>|    1 | 张三   |      1 |    1 | 饭卡      |<br>|    2 | 李四   |      3 |    3 | 农行卡    |<br>+------+--------+--------+------+-----------+<br><br>-- 将 INNER 关键字省略掉，结果也是一样的。<br>-- SELECT * FROM person JOIN card on person.cardId &#x3D; card.id;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code>card</code> 的整张表被连接到了右边。</p>
</blockquote>
<h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p>完整显示左边的表 ( <code>person</code> ) ，右边的表如果符合条件就显示，不符合则补 <code>NULL</code> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- LEFT JOIN 也叫做 LEFT OUTER JOIN，用这两种方式的查询结果是一样的。<br>SELECT * FROM person LEFT JOIN card on person.cardId &#x3D; card.id;<br>+------+--------+--------+------+-----------+<br>| id   | name   | cardId | id   | name      |<br>+------+--------+--------+------+-----------+<br>|    1 | 张三   |      1 |    1 | 饭卡      |<br>|    2 | 李四   |      3 |    3 | 农行卡    |<br>|    3 | 王五   |      6 | NULL | NULL      |<br>+------+--------+--------+------+-----------+<br></code></pre></td></tr></table></figure>

<h4 id="右外链接"><a href="#右外链接" class="headerlink" title="右外链接"></a>右外链接</h4><p>完整显示右边的表 ( <code>card</code> ) ，左边的表如果符合条件就显示，不符合则补 <code>NULL</code> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT * FROM person RIGHT JOIN card on person.cardId &#x3D; card.id;<br>+------+--------+--------+------+-----------+<br>| id   | name   | cardId | id   | name      |<br>+------+--------+--------+------+-----------+<br>|    1 | 张三   |      1 |    1 | 饭卡      |<br>|    2 | 李四   |      3 |    3 | 农行卡    |<br>| NULL | NULL   |   NULL |    2 | 建行卡    |<br>| NULL | NULL   |   NULL |    4 | 工商卡    |<br>| NULL | NULL   |   NULL |    5 | 邮政卡    |<br>+------+--------+--------+------+-----------+<br></code></pre></td></tr></table></figure>

<h4 id="全外链接"><a href="#全外链接" class="headerlink" title="全外链接"></a>全外链接</h4><p>完整显示两张表的全部数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- MySQL 不支持这种语法的全外连接<br>-- SELECT * FROM person FULL JOIN card on person.cardId &#x3D; card.id;<br>-- 出现错误：<br>-- ERROR 1054 (42S22): Unknown column &#39;person.cardId&#39; in &#39;on clause&#39;<br><br>-- MySQL全连接语法，使用 UNION 将两张表合并在一起。<br>SELECT * FROM person LEFT JOIN card on person.cardId &#x3D; card.id<br>UNION<br>SELECT * FROM person RIGHT JOIN card on person.cardId &#x3D; card.id;<br>+------+--------+--------+------+-----------+<br>| id   | name   | cardId | id   | name      |<br>+------+--------+--------+------+-----------+<br>|    1 | 张三   |      1 |    1 | 饭卡      |<br>|    2 | 李四   |      3 |    3 | 农行卡    |<br>|    3 | 王五   |      6 | NULL | NULL      |<br>| NULL | NULL   |   NULL |    2 | 建行卡    |<br>| NULL | NULL   |   NULL |    4 | 工商卡    |<br>| NULL | NULL   |   NULL |    5 | 邮政卡    |<br>+------+--------+--------+------+-----------+<br></code></pre></td></tr></table></figure>

<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>在 MySQL 中，事务其实是一个最小的不可分割的工作单元。事务能够<strong>保证一个业务的完整性</strong>。</p>
<p>比如我们的银行转账：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- a -&gt; -100<br>UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;<br><br>-- b -&gt; +100<br>UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;<br></code></pre></td></tr></table></figure>

<p>在实际项目中，假设只有一条 SQL 语句执行成功，而另外一条执行失败了，就会出现数据前后不一致。</p>
<p>因此，在执行多条有关联 SQL 语句时，<strong>事务</strong>可能会要求这些 SQL 语句要么同时执行成功，要么就都执行失败。</p>
<h3 id="如何控制事务-COMMIT-ROLLBACK"><a href="#如何控制事务-COMMIT-ROLLBACK" class="headerlink" title="如何控制事务 - COMMIT / ROLLBACK"></a>如何控制事务 - COMMIT / ROLLBACK</h3><p>在 MySQL 中，事务的<strong>自动提交</strong>状态默认是开启的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 查询事务的自动提交状态<br>SELECT @@AUTOCOMMIT;<br>+--------------+<br>| @@AUTOCOMMIT |<br>+--------------+<br>|            1 |<br>+--------------+<br></code></pre></td></tr></table></figure>

<p><strong>自动提交的作用</strong>：当我们执行一条 SQL 语句的时候，其产生的效果就会立即体现出来，且不能<strong>回滚</strong>。</p>
<p>什么是回滚？举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE DATABASE bank;<br><br>USE bank;<br><br>CREATE TABLE user (<br>    id INT PRIMARY KEY,<br>    name VARCHAR(20),<br>    money INT<br>);<br><br>INSERT INTO user VALUES (1, &#39;a&#39;, 1000);<br><br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |  1000 |<br>+----+------+-------+<br></code></pre></td></tr></table></figure>

<p>可以看到，在执行插入语句后数据立刻生效，原因是 MySQL 中的事务自动将它<strong>提交</strong>到了数据库中。那么所谓<strong>回滚</strong>的意思就是，撤销执行过的所有 SQL 语句，使其回滚到<strong>最后一次提交</strong>数据时的状态。</p>
<p>在 MySQL 中使用 <code>ROLLBACK</code> 执行回滚：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 回滚到最后一次提交<br>ROLLBACK;<br><br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |  1000 |<br>+----+------+-------+<br></code></pre></td></tr></table></figure>

<p>由于所有执行过的 SQL 语句都已经被提交过了，所以数据并没有发生回滚。那如何让数据可以发生回滚？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 关闭自动提交<br>SET AUTOCOMMIT &#x3D; 0;<br><br>-- 查询自动提交状态<br>SELECT @@AUTOCOMMIT;<br>+--------------+<br>| @@AUTOCOMMIT |<br>+--------------+<br>|            0 |<br>+--------------+<br></code></pre></td></tr></table></figure>

<p>将自动提交关闭后，测试数据回滚：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">INSERT INTO user VALUES (2, &#39;b&#39;, 1000);<br><br>-- 关闭 AUTOCOMMIT 后，数据的变化是在一张虚拟的临时数据表中展示，<br>-- 发生变化的数据并没有真正插入到数据表中。<br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |  1000 |<br>|  2 | b    |  1000 |<br>+----+------+-------+<br><br>-- 数据表中的真实数据其实还是：<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |  1000 |<br>+----+------+-------+<br><br>-- 由于数据还没有真正提交，可以使用回滚<br>ROLLBACK;<br><br>-- 再次查询<br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |  1000 |<br>+----+------+-------+<br></code></pre></td></tr></table></figure>

<p>那如何将虚拟的数据真正提交到数据库中？使用 <code>COMMIT</code> : </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">INSERT INTO user VALUES (2, &#39;b&#39;, 1000);<br>-- 手动提交数据（持久性），<br>-- 将数据真正提交到数据库中，执行后不能再回滚提交过的数据。<br>COMMIT;<br><br>-- 提交后测试回滚<br>ROLLBACK;<br><br>-- 再次查询（回滚无效了）<br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |  1000 |<br>|  2 | b    |  1000 |<br>+----+------+-------+<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>总结</strong></p>
<ol>
<li><p><strong>自动提交</strong></p>
<ul>
<li><p>查看自动提交状态：<code>SELECT @@AUTOCOMMIT</code> ；</p>
</li>
<li><p>设置自动提交状态：<code>SET AUTOCOMMIT = 0</code> 。</p>
</li>
</ul>
</li>
<li><p><strong>手动提交</strong></p>
<p><code>@@AUTOCOMMIT = 0</code> 时，使用 <code>COMMIT</code> 命令提交事务。</p>
</li>
<li><p><strong>事务回滚</strong></p>
<p><code>@@AUTOCOMMIT = 0</code> 时，使用 <code>ROLLBACK</code> 命令回滚事务。</p>
</li>
</ol>
</blockquote>
<p><strong>事务的实际应用</strong>，让我们再回到银行转账项目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 转账<br>UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;<br><br>-- 到账<br>UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;<br><br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |   900 |<br>|  2 | b    |  1100 |<br>+----+------+-------+<br></code></pre></td></tr></table></figure>

<p>这时假设在转账时发生了意外，就可以使用 <code>ROLLBACK</code> 回滚到最后一次提交的状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 假设转账发生了意外，需要回滚。<br>ROLLBACK;<br><br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |  1000 |<br>|  2 | b    |  1000 |<br>+----+------+-------+<br></code></pre></td></tr></table></figure>

<p>这时我们又回到了发生意外之前的状态，也就是说，事务给我们提供了一个可以反悔的机会。假设数据没有发生意外，这时可以手动将数据真正提交到数据表中：<code>COMMIT</code> 。</p>
<h3 id="手动开启事务-BEGIN-START-TRANSACTION"><a href="#手动开启事务-BEGIN-START-TRANSACTION" class="headerlink" title="手动开启事务 - BEGIN / START TRANSACTION"></a>手动开启事务 - BEGIN / START TRANSACTION</h3><p>事务的默认提交被开启 ( <code>@@AUTOCOMMIT = 1</code> ) 后，此时就不能使用事务回滚了。但是我们还可以手动开启一个事务处理事件，使其可以发生回滚：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 使用 BEGIN 或者 START TRANSACTION 手动开启一个事务<br>-- START TRANSACTION;<br>BEGIN;<br>UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;<br>UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;<br><br>-- 由于手动开启的事务没有开启自动提交，<br>-- 此时发生变化的数据仍然是被保存在一张临时表中。<br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |   900 |<br>|  2 | b    |  1100 |<br>+----+------+-------+<br><br>-- 测试回滚<br>ROLLBACK;<br><br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |  1000 |<br>|  2 | b    |  1000 |<br>+----+------+-------+<br></code></pre></td></tr></table></figure>

<p>仍然使用 <code>COMMIT</code> 提交数据，提交后无法再发生本次事务的回滚。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">BEGIN;<br>UPDATE user set money &#x3D; money - 100 WHERE name &#x3D; &#39;a&#39;;<br>UPDATE user set money &#x3D; money + 100 WHERE name &#x3D; &#39;b&#39;;<br><br>SELECT * FROM user;<br>+----+------+-------+<br>| id | name | money |<br>+----+------+-------+<br>|  1 | a    |   900 |<br>|  2 | b    |  1100 |<br>+----+------+-------+<br><br>-- 提交数据<br>COMMIT;<br><br>-- 测试回滚（无效，因为表的数据已经被提交）<br>ROLLBACK;<br></code></pre></td></tr></table></figure>

<h3 id="事务的-ACID-特征与使用"><a href="#事务的-ACID-特征与使用" class="headerlink" title="事务的 ACID 特征与使用"></a>事务的 ACID 特征与使用</h3><p><strong>事务的四大特征：</strong></p>
<ul>
<li><strong>A 原子性</strong>：事务是最小的单位，不可以再分割；</li>
<li><strong>C 一致性</strong>：要求同一事务中的 SQL 语句，必须保证同时成功或者失败；</li>
<li><strong>I 隔离性</strong>：事务1 和 事务2 之间是具有隔离性的；</li>
<li><strong>D 持久性</strong>：事务一旦结束 ( <code>COMMIT</code> ) ，就不可以再返回了 ( <code>ROLLBACK</code> ) 。</li>
</ul>
<h3 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h3><p><strong>事务的隔离性可分为四种 ( 性能从低到高 )</strong> ：</p>
<ol>
<li><p><strong>READ UNCOMMITTED ( 读取未提交 )</strong></p>
<p>如果有多个事务，那么任意事务都可以看见其他事务的<strong>未提交数据</strong>。</p>
</li>
<li><p><strong>READ COMMITTED ( 读取已提交 )</strong></p>
<p>只能读取到其他事务<strong>已经提交的数据</strong>。</p>
</li>
<li><p><strong>REPEATABLE READ ( 可被重复读 )</strong></p>
<p>如果有多个连接都开启了事务，那么事务之间不能共享数据记录，否则只能共享已提交的记录。</p>
</li>
<li><p><strong>SERIALIZABLE ( 串行化 )</strong></p>
<p>所有的事务都会按照<strong>固定顺序执行</strong>，执行完一个事务后再继续执行下一个事务的<strong>写入操作</strong>。</p>
</li>
</ol>
<p>查看当前数据库的默认隔离级别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- MySQL 8.x, GLOBAL 表示系统级别，不加表示会话级别。<br>SELECT @@GLOBAL.TRANSACTION_ISOLATION;<br>SELECT @@TRANSACTION_ISOLATION;<br>+--------------------------------+<br>| @@GLOBAL.TRANSACTION_ISOLATION |<br>+--------------------------------+<br>| REPEATABLE-READ                | -- MySQL的默认隔离级别，可以重复读。<br>+--------------------------------+<br><br>-- MySQL 5.x<br>SELECT @@GLOBAL.TX_ISOLATION;<br>SELECT @@TX_ISOLATION;<br></code></pre></td></tr></table></figure>

<p>修改隔离级别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 设置系统隔离级别，LEVEL 后面表示要设置的隔离级别 (READ UNCOMMITTED)。<br>SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;<br><br>-- 查询系统隔离级别，发现已经被修改。<br>SELECT @@GLOBAL.TRANSACTION_ISOLATION;<br>+--------------------------------+<br>| @@GLOBAL.TRANSACTION_ISOLATION |<br>+--------------------------------+<br>| READ-UNCOMMITTED               |<br>+--------------------------------+<br></code></pre></td></tr></table></figure>

<h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>测试 <strong>READ UNCOMMITTED ( 读取未提交 )</strong> 的隔离性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">INSERT INTO user VALUES (3, &#39;小明&#39;, 1000);<br>INSERT INTO user VALUES (4, &#39;淘宝店&#39;, 1000);<br><br>SELECT * FROM user;<br>+----+-----------+-------+<br>| id | name      | money |<br>+----+-----------+-------+<br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>+----+-----------+-------+<br><br>-- 开启一个事务操作数据<br>-- 假设小明在淘宝店买了一双800块钱的鞋子：<br>START TRANSACTION;<br>UPDATE user SET money &#x3D; money - 800 WHERE name &#x3D; &#39;小明&#39;;<br>UPDATE user SET money &#x3D; money + 800 WHERE name &#x3D; &#39;淘宝店&#39;;<br><br>-- 然后淘宝店在另一方查询结果，发现钱已到账。<br>SELECT * FROM user;<br>+----+-----------+-------+<br>| id | name      | money |<br>+----+-----------+-------+<br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |   200 |<br>|  4 | 淘宝店    |  1800 |<br>+----+-----------+-------+<br></code></pre></td></tr></table></figure>

<p>由于小明的转账是在新开启的事务上进行操作的，而该操作的结果是可以被其他事务（另一方的淘宝店）看见的，因此淘宝店的查询结果是正确的，淘宝店确认到账。但就在这时，如果小明在它所处的事务上又执行了 <code>ROLLBACK</code> 命令，会发生什么？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 小明所处的事务<br>ROLLBACK;<br><br>-- 此时无论对方是谁，如果再去查询结果就会发现：<br>SELECT * FROM user;<br>+----+-----------+-------+<br>| id | name      | money |<br>+----+-----------+-------+<br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>+----+-----------+-------+<br></code></pre></td></tr></table></figure>

<p>这就是所谓的<strong>脏读</strong>，一个事务读取到另外一个事务还未提交的数据。这在实际开发中是不允许出现的。</p>
<h4 id="读取已提交"><a href="#读取已提交" class="headerlink" title="读取已提交"></a>读取已提交</h4><p>把隔离级别设置为 <strong>READ COMMITTED</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;<br>SELECT @@GLOBAL.TRANSACTION_ISOLATION;<br>+--------------------------------+<br>| @@GLOBAL.TRANSACTION_ISOLATION |<br>+--------------------------------+<br>| READ-COMMITTED                 |<br>+--------------------------------+<br></code></pre></td></tr></table></figure>

<p>这样，再有新的事务连接进来时，它们就只能查询到已经提交过的事务数据了。但是对于当前事务来说，它们看到的还是未提交的数据，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 正在操作数据事务（当前事务）<br>START TRANSACTION;<br>UPDATE user SET money &#x3D; money - 800 WHERE name &#x3D; &#39;小明&#39;;<br>UPDATE user SET money &#x3D; money + 800 WHERE name &#x3D; &#39;淘宝店&#39;;<br><br>-- 虽然隔离级别被设置为了 READ COMMITTED，但在当前事务中，<br>-- 它看到的仍然是数据表中临时改变数据，而不是真正提交过的数据。<br>SELECT * FROM user;<br>+----+-----------+-------+<br>| id | name      | money |<br>+----+-----------+-------+<br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |   200 |<br>|  4 | 淘宝店    |  1800 |<br>+----+-----------+-------+<br><br><br>-- 假设此时在远程开启了一个新事务，连接到数据库。<br>$ mysql -u root -p12345612<br><br>-- 此时远程连接查询到的数据只能是已经提交过的<br>SELECT * FROM user;<br>+----+-----------+-------+<br>| id | name      | money |<br>+----+-----------+-------+<br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>+----+-----------+-------+<br></code></pre></td></tr></table></figure>

<p>但是这样还有问题，那就是假设一个事务在操作数据时，其他事务干扰了这个事务的数据。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 小张在查询数据的时候发现：<br>SELECT * FROM user;<br>+----+-----------+-------+<br>| id | name      | money |<br>+----+-----------+-------+<br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |   200 |<br>|  4 | 淘宝店    |  1800 |<br>+----+-----------+-------+<br><br>-- 在小张求表的 money 平均值之前，小王做了一个操作：<br>START TRANSACTION;<br>INSERT INTO user VALUES (5, &#39;c&#39;, 100);<br>COMMIT;<br><br>-- 此时表的真实数据是：<br>SELECT * FROM user;<br>+----+-----------+-------+<br>| id | name      | money |<br>+----+-----------+-------+<br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>|  5 | c         |   100 |<br>+----+-----------+-------+<br><br>-- 这时小张再求平均值的时候，就会出现计算不相符合的情况：<br>SELECT AVG(money) FROM user;<br>+------------+<br>| AVG(money) |<br>+------------+<br>|  820.0000  |<br>+------------+<br></code></pre></td></tr></table></figure>

<p>虽然 <strong>READ COMMITTED</strong> 让我们只能读取到其他事务已经提交的数据，但还是会出现问题，就是<strong>在读取同一个表的数据时，可能会发生前后不一致的情况。</strong>这被称为<strong>不可重复读现象 ( READ COMMITTED )</strong> 。</p>
<h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>将隔离级别设置为 <strong>REPEATABLE READ ( 可被重复读取 )</strong> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br>SELECT @@GLOBAL.TRANSACTION_ISOLATION;<br>+--------------------------------+<br>| @@GLOBAL.TRANSACTION_ISOLATION |<br>+--------------------------------+<br>| REPEATABLE-READ                |<br>+--------------------------------+<br></code></pre></td></tr></table></figure>

<p>测试 <strong>REPEATABLE READ</strong> ，假设在两个不同的连接上分别执行 <code>START TRANSACTION</code> :</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 小张 - 成都</span><br><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">1000</span>);<br><br><span class="hljs-comment">-- 小王 - 北京</span><br><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<br><br><span class="hljs-comment">-- 小张 - 成都</span><br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure>

<p>当前事务开启后，没提交之前，查询不到，提交后可以被查询到。但是，在提交之前其他事务被开启了，那么在这条事务线上，就不会查询到当前有操作事务的连接。相当于开辟出一条单独的线程。</p>
<p>无论小张是否执行过 <code>COMMIT</code> ，在小王这边，都不会查询到小张的事务记录，而是只会查询到自己所处事务的记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;<br>+<span class="hljs-comment">----+-----------+-------+</span><br>| id | name      | money |<br>+<span class="hljs-comment">----+-----------+-------+</span><br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>|  5 | c         |   100 |<br>+<span class="hljs-comment">----+-----------+-------+</span><br></code></pre></td></tr></table></figure>

<p>这是<strong>因为小王在此之前开启了一个新的事务 ( <code>START TRANSACTION</code> ) **，那么</strong>在他的这条新事务的线上，跟其他事务是没有联系的**，也就是说，此时如果其他事务正在操作数据，它是不知道的。</p>
<p>然而事实是，在真实的数据表中，小张已经插入了一条数据。但是小王此时并不知道，也插入了同一条数据，会发生什么呢？</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">1000</span>);<br><span class="hljs-comment">-- ERROR 1062 (23000): Duplicate entry &#x27;6&#x27; for key &#x27;PRIMARY&#x27;</span><br></code></pre></td></tr></table></figure>

<p>报错了，操作被告知已存在主键为 <code>6</code> 的字段。这种现象也被称为<strong>幻读，一个事务提交的数据，不能被其他事务读取到</strong>。</p>
<h4 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h4><p>顾名思义，就是所有事务的<strong>写入操作</strong>全都是串行化的。什么意思？把隔离级别修改成 <strong>SERIALIZABLE</strong> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;<br>SELECT @@GLOBAL.TRANSACTION_ISOLATION;<br>+--------------------------------+<br>| @@GLOBAL.TRANSACTION_ISOLATION |<br>+--------------------------------+<br>| SERIALIZABLE                   |<br>+--------------------------------+<br></code></pre></td></tr></table></figure>

<p>还是拿小张和小王来举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">-- 小张 - 成都<br>START TRANSACTION;<br><br>-- 小王 - 北京<br>START TRANSACTION;<br><br>-- 开启事务之前先查询表，准备操作数据。<br>SELECT * FROM user;<br>+----+-----------+-------+<br>| id | name      | money |<br>+----+-----------+-------+<br>|  1 | a         |   900 |<br>|  2 | b         |  1100 |<br>|  3 | 小明      |  1000 |<br>|  4 | 淘宝店    |  1000 |<br>|  5 | c         |   100 |<br>|  6 | d         |  1000 |<br>+----+-----------+-------+<br><br>-- 发现没有 7 号王小花，于是插入一条数据：<br>INSERT INTO user VALUES (7, &#39;王小花&#39;, 1000);<br></code></pre></td></tr></table></figure>

<p>此时会发生什么呢？由于现在的隔离级别是 <strong>SERIALIZABLE ( 串行化 )</strong> ，串行化的意思就是：假设把所有的事务都放在一个串行的队列中，那么所有的事务都会按照<strong>固定顺序执行</strong>，执行完一个事务后再继续执行下一个事务的<strong>写入操作</strong> ( <strong>这意味着队列中同时只能执行一个事务的写入操作</strong> ) 。</p>
<p>根据这个解释，小王在插入数据时，会出现等待状态，直到小张执行 <code>COMMIT</code> 结束它所处的事务，或者出现等待超时。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>3</title>
    <url>/2016/10/12/3/</url>
    <content><![CDATA[<h1 id="精尽-Spring-面试题"><a href="#精尽-Spring-面试题" class="headerlink" title="精尽 Spring 面试题"></a>精尽 Spring 面试题</h1><p>以下面试题，基于网络整理，和自己编辑。具体参考的文章，会在文末给出所有的链接。</p>
<p>如果胖友有自己的疑问，欢迎在星球提问，我们一起整理吊吊的 Spring 面试题的大保健。</p>
<p>而题目的难度，艿艿尽量按照从容易到困难的顺序，逐步下去。</p>
<blockquote>
<p>注意 1 ，这个面试题，暂时不包括 Spring MVC 部分。主要以 Spring IoC、Spring AOP、Spring Transaction 为主。</p>
<p>注意 2 ，T T Spring 怎么会有这么多问题，艿艿自己面试很多都不太问，跟背书一样。所以整理的过程，真的是痛苦万分。</p>
</blockquote>
<p>Spring 是一个很庞大的技术体系，可以说包容一切，所以本文我们按照下面的顺序，罗列各种面试题：</p>
<ul>
<li>Spring <strong>整体</strong>相关的面试</li>
<li>Spring <strong>IoC</strong> 相关的面试题</li>
<li>Spring <strong>AOP</strong> 相关的面试题</li>
<li>Spring <strong>Transaction</strong> 相关的面试题</li>
<li>Spring <strong>Data Access</strong> 相关的面试题</li>
</ul>
<h1 id="Spring-整体"><a href="#Spring-整体" class="headerlink" title="Spring 整体"></a>Spring 整体</h1><h2 id="什么是-Spring-Framework？"><a href="#什么是-Spring-Framework？" class="headerlink" title="什么是 Spring Framework？"></a>什么是 Spring Framework？</h2><p>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</p>
<ul>
<li><p>它是轻量级、松散耦合的。</p>
<blockquote>
<p>它的轻量级主要是相对于 EJB 。随着 Spring 的体系越来越庞大，大家被 Spring 的配置搞懵逼了，所以后来出了 Spring Boot 。</p>
</blockquote>
</li>
<li><p>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。</p>
</li>
<li><p>它可以集成其他框架，如 Spring MVC、Hibernate、MyBatis 等，所以又称为框架的框架( 粘合剂、脚手架 )。</p>
</li>
</ul>
<h2 id="Spring-Framework-中有多少个模块，它们分别是什么？"><a href="#Spring-Framework-中有多少个模块，它们分别是什么？" class="headerlink" title="Spring Framework 中有多少个模块，它们分别是什么？"></a>Spring Framework 中有多少个模块，它们分别是什么？</h2><p>如下是一张比较早期版本的 Spring Framework 的模块图：</p>
<blockquote>
<p>艿艿：因为它的配色比较好看，哈哈哈哈。所以，没自己画一个最新的。</p>
</blockquote>
<p><a href="http://static2.iocoder.cn/images/Spring/2018-12-24/01.jpg">![Spring Framework](D:\新建文件夹 (3)\01.jpg)</a>Spring Framework</p>
<p>我们按照一个一个分块来说。</p>
<p><strong>Spring 核心容器</strong></p>
<blockquote>
<p>对应图中，Core Container 。</p>
</blockquote>
<p>该层基本上是 Spring Framework 的核心。它包含以下模块：</p>
<ul>
<li><p>Spring Core</p>
</li>
<li><p>Spring Bean</p>
<blockquote>
<p>核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC）模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 </p>
</blockquote>
</li>
<li><p>Spring Context</p>
<blockquote>
<p>Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、事件机制、校验和调度功能。  </p>
</blockquote>
</li>
<li><p>SpEL (Spring Expression Language)</p>
<blockquote>
<p>Spring 表达式语言全称为 “Spring Expression Language”，缩写为 “SpEL” ，类似于 Struts2  中使用的 OGNL 表达式语言，能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与 Spring 功能完美整合，如能用来配置  Bean 定义。</p>
</blockquote>
</li>
</ul>
<p>或者说，这块就是 Spring IoC 。</p>
<p><strong>数据访问</strong></p>
<blockquote>
<p>对应图中，Data Access 。</p>
</blockquote>
<p>该层提供与数据库交互的支持。它包含以下模块：</p>
<ul>
<li><p>JDBC (Java DataBase Connectivity)</p>
<blockquote>
<p>Spring 对 JDBC 的封装模块，提供了对关系数据库的访问。</p>
</blockquote>
</li>
<li><p>ORM (Object Relational Mapping)</p>
<blockquote>
<p>Spring ORM 模块，提供了对 hibernate5 和 JPA 的集成。</p>
<ul>
<li>hibernate5 是一个 ORM 框架。</li>
<li>JPA 是一个 Java 持久化 API 。</li>
</ul>
</blockquote>
</li>
<li><p>OXM (Object XML Mappers)</p>
<blockquote>
<p>Spring 提供了一套类似 ORM 的映射机制，用来将 Java 对象和 XML 文件进行映射。这就是 Spring 的对象 XML 映射功能，有时候也成为 XML 的序列化和反序列化。</p>
<p>用的比较少，胖友了解下即可。</p>
</blockquote>
</li>
<li><p>Transaction</p>
<blockquote>
<p>Spring 简单而强大的事务管理功能，包括声明式事务和编程式事务。 </p>
</blockquote>
</li>
</ul>
<p><strong>Web</strong></p>
<p>该层提供了创建 Web 应用程序的支持。它包含以下模块：</p>
<ul>
<li><p>WebMVC</p>
<blockquote>
<p>MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。 </p>
</blockquote>
</li>
<li><p>WebFlux</p>
<blockquote>
<p>基于 Reactive 库的响应式的 Web 开发框架 </p>
<p>不了解的胖友，可以看看 <a href="https://www.ibm.com/developerworks/cn/java/spring5-webflux-reactive/index.html">《使用 Spring 5 的 WebFlux 开发反应式 Web 应用》</a></p>
</blockquote>
</li>
<li><p>WebSocket</p>
<blockquote>
<p>Spring 4.0 的一个最大更新是增加了对 Websocket 的支持。</p>
<p>Websocket 提供了一个在 Web 应用中实现高效、双向通讯，需考虑客户端(浏览器)和服务端之间高频和低延时消息交换的机制。</p>
<p>一般的应用场景有：在线交易、网页聊天、游戏、协作、数据可视化等。</p>
</blockquote>
</li>
<li><p><del>Portlet</del> 已经废弃</p>
</li>
</ul>
<p><strong>AOP</strong></p>
<p>该层支持面向切面编程。它包含以下模块：</p>
<ul>
<li><p>AOP</p>
<blockquote>
<p>通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。</p>
<p>Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。 </p>
</blockquote>
</li>
<li><p>Aspects </p>
<blockquote>
<p>该模块为与 AspectJ 的集成提供支持。</p>
</blockquote>
</li>
<li><p>Instrumentation</p>
<blockquote>
<p>该层为类检测和类加载器实现提供支持。</p>
<p>用的比较少，胖友了解下即可。</p>
</blockquote>
</li>
</ul>
<p><strong>其它</strong></p>
<ul>
<li><p>JMS (Java Messaging Service)</p>
<blockquote>
<p>提供了一个 JMS 集成框架，简化了 JMS API 的使用。</p>
<p>可能有胖友不太了解 JMS ，可以看看 <a href="https://www.cnblogs.com/chenpi/p/5559349.html">《JMS(Java消息服务)入门教程》</a> 。</p>
</blockquote>
</li>
<li><p>Test</p>
<blockquote>
<p>该模块为使用 JUnit 和 TestNG 进行测试提供支持。</p>
</blockquote>
</li>
<li><p>Messaging</p>
<blockquote>
<p>该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息。</p>
</blockquote>
</li>
</ul>
<h2 id="使用-Spring-框架能带来哪些好处？"><a href="#使用-Spring-框架能带来哪些好处？" class="headerlink" title="使用 Spring 框架能带来哪些好处？"></a>使用 Spring 框架能带来哪些好处？</h2><p>下面列举了一些使用 Spring 框架带来的主要好处：</p>
<blockquote>
<p>艿艿：注意，下文中加粗的内容，这是本句话的关键。</p>
</blockquote>
<ul>
<li><strong>DI</strong> ：**<a href="http://howtodoinjava.com/2013/03/19/inversion-of-control-ioc-and-dependency-injection-di-patterns-in-spring-framework-and-related-interview-questions/">Dependency Injection(DI)</a>** 方法，使得构造器和 JavaBean、properties 文件中的依赖关系一目了然。</li>
<li><strong>轻量级</strong>：与 EJB 容器相比较，IoC 容器更加趋向于<strong>轻量级</strong>。这样一来 IoC 容器在有限的内存和 CPU 资源的情况下，进行应用程序的开发和发布就变得十分有利。</li>
<li><strong>面向切面编程(AOP)**： Spring 支持面向</strong>切面编程**，同时把应用的业务逻辑与系统的服务分离开来。</li>
<li><strong>集成主流框架</strong>：Spring 并没有闭门造车，Spring <strong>集成</strong>了已有的技术栈，比如 ORM 框架、Logging 日期框架、J2EE、Quartz 和 JDK Timer ，以及其他视图技术。</li>
<li>模块化：Spring 框架是按照<strong>模块</strong>的形式来组织的。由包和类的命名，就可以看出其所属的模块，开发者仅仅需要选用他们需要的模块即可。</li>
<li><strong>便捷的测试</strong>：要 <a href="http://howtodoinjava.com/2013/04/19/how-to-unit-test-spring-security-authentication-with-junit/">测试一项用Spring开发的应用程序</a> 十分简单，因为<strong>测试</strong>相关的环境代码都已经囊括在框架中了。更加简单的是，利用 JavaBean 形式的 POJO 类，可以很方便的利用依赖注入来写入测试数据。</li>
<li><strong>Web 框架</strong>：Spring 的 <strong>Web 框架</strong>亦是一个精心设计的 Web MVC 框架，为开发者们在 Web 框架的选择上提供了一个除了主流框架比如 Struts 、过度设计的、不流行 Web 框架的以外的有力选项。</li>
<li><strong>事务管理</strong>：Spring 提供了一个便捷的<strong>事务管理</strong>接口，适用于小型的本地事物处理（比如在单 DB 的环境下）和复杂的共同事物处理（比如利用 JTA 的复杂 DB 环境）。</li>
<li><strong>异常处理</strong>：Spring 提供一个方便的 API ，将特定技术的异常(由JDBC, Hibernate, 或 JDO 抛出)转化为一致的、Unchecked 异常。</li>
</ul>
<p>当然，Spring 代码优点的同时，一定会带来相应的缺点：</p>
<ul>
<li><p>每个框架都有的问题，调试阶段不直观，后期的 bug 对应阶段，不容易判断问题所在。要花一定的时间去理解它。</p>
</li>
<li><p>把很多 JavaEE 的东西封装了，在满足快速开发高质量程序的同时，隐藏了实现细节。</p>
<blockquote>
<p>这就导致，很多工程师，离开了 Spring 之后，就不知道怎么工作了。从 Java 工程师，变成了 Spring 工程师。对于有追求的我们，还是需要知其然，知其所以然。</p>
</blockquote>
</li>
</ul>
<h2 id="Spring-框架中都用到了哪些设计模式？"><a href="#Spring-框架中都用到了哪些设计模式？" class="headerlink" title="Spring 框架中都用到了哪些设计模式？"></a>Spring 框架中都用到了哪些设计模式？</h2><p>Spring 框架中使用到了大量的设计模式，下面列举了比较有代表性的：</p>
<ul>
<li>代理模式 — 在 AOP 和 remoting 中被用的比较多。</li>
<li>单例模式 — 在 Spring 配置文件中定义的 Bean 默认为单例模式。</li>
<li>模板方法 — 用来解决代码重复的问题。比如 <a href="http://howtodoinjava.com/2015/02/20/spring-restful-client-resttemplate-example/">RestTemplate</a>、JmsTemplate、JdbcTemplate 。</li>
<li>前端控制器 — Spring提供了 DispatcherServlet 来对请求进行分发。</li>
<li>视图帮助(View Helper) — Spring 提供了一系列的 JSP 标签，高效宏来辅助将分散的代码整合在视图里。</li>
<li>依赖注入 — 贯穿于 BeanFactory / ApplicationContext 接口的核心理念。</li>
<li>工厂模式 — BeanFactory 用来创建对象的实例。</li>
</ul>
<p>当然，感兴趣的胖友，觉得不过瘾，可以看看艿艿基友知秋写的几篇文章：</p>
<ul>
<li><a href="http://www.iocoder.cn/Spring/DesignPattern-1">《Spring 框架中的设计模式(一)》</a></li>
<li><a href="http://www.iocoder.cn/Spring/DesignPattern-2">《Spring 框架中的设计模式(二)》</a></li>
<li><a href="http://www.iocoder.cn/Spring/DesignPattern-3">《Spring 框架中的设计模式(三)》</a></li>
<li><a href="http://www.iocoder.cn/Spring/DesignPattern-4">《Spring 框架中的设计模式(四)》</a></li>
<li><a href="http://www.iocoder.cn/Spring/DesignPattern-5">《Spring 框架中的设计模式(五)》</a></li>
</ul>
<h1 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="Spring IoC"></a>Spring IoC</h1><blockquote>
<p>下面，我们会将分成 IoC 和 Bean 两部分来分享 Spring 容器的内容。</p>
<ul>
<li>IoC ，侧重在于容器。</li>
<li>Bean ，侧重在于被容器管理的 Bean 。</li>
</ul>
</blockquote>
<h2 id="什么是-Spring-IoC-容器？"><a href="#什么是-Spring-IoC-容器？" class="headerlink" title="什么是 Spring IoC 容器？"></a>什么是 Spring IoC 容器？</h2><blockquote>
<p>注意，正确的拼写是 IoC 。</p>
</blockquote>
<p>Spring 框架的核心是 Spring IoC 容器。容器创建 Bean 对象，将它们装配在一起，配置它们并管理它们的完整生命周期。</p>
<ul>
<li>Spring 容器使用<strong>依赖注入</strong>来管理组成应用程序的 Bean 对象。</li>
<li>容器通过读取提供的<strong>配置元数据</strong> Bean Definition 来接收对象进行实例化，配置和组装的指令。</li>
<li>该配置元数据 Bean Definition 可以通过 XML，Java 注解或 Java Config 代码<strong>提供</strong>。</li>
</ul>
<blockquote>
<p>艿艿，注意上面三段段话的<strong>加粗</strong>部分的内容。</p>
</blockquote>
<p><a href="http://static2.iocoder.cn/images/Spring/2018-12-24/02.jpg">![Spring IoC](D:\新建文件夹 (3)\02.jpg)</a>Spring IoC</p>
<h2 id="什么是依赖注入？"><a href="#什么是依赖注入？" class="headerlink" title="什么是依赖注入？"></a>什么是依赖注入？</h2><p>在依赖注入中，你不必主动、手动创建对象，但必须描述如何创建它们。</p>
<ul>
<li>你不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。</li>
<li>然后，再由 IoC 容器将它们装配在一起。</li>
</ul>
<p>另外，依赖注入的英文缩写是 Dependency Injection ，简称 DI 。</p>
<h2 id="IoC-和-DI-有什么区别？"><a href="#IoC-和-DI-有什么区别？" class="headerlink" title="IoC 和 DI 有什么区别？"></a>IoC 和 DI 有什么区别？</h2><blockquote>
<p>艿艿的吐槽，最怕这种概念题。下面引用知乎上的一个讨论：<a href="https://www.zhihu.com/question/25392984">《IoC 和DI 有什么区别？》</a></p>
</blockquote>
<p>IoC 是个更宽泛的概念，DI 是更具体的。引用郑烨的一篇博客，引用郑烨的一篇博客，<a href="https://link.zhihu.com/?target=http://dreamhead.blogbus.com/logs/125334.html">我眼中的Spring</a></p>
<blockquote>
<p><strong>Dependency Injection</strong><br>原来，它叫 IoC 。<br>Martin Flower 发话了，是个框架都有 IoC ，这不足以新生容器反转的“如何定位插件的具体实现”，于是，它有了个新名字，Dependency Injection 。</p>
<p>其实，它就是一种将调用者与被调用者分离的思想，Uncle Bob 管它叫DIP（Dependency Inversion Principle），并把它归入OO设计原则。<br>同 Spring 相比，它更早进入我的大脑。一切都是那么朦胧，直至 Spring 出现。  </p>
<p>慢慢的，我知道了它还分为三种：</p>
<ul>
<li>Interface Injection（type 1）</li>
<li>Setter Injection（type 2）</li>
<li>Constructor Injection（type 3）。</li>
</ul>
<p>Martin Flower那篇为它更名的大作让我心目关于它的一切趋于完整。</p>
<p>在 Spring 中，它是一切的基础。Spring 的种种优势随之而来。<br>于我而言，它为我带来更多的是思维方式的转变，恐怕以后我再也无法写出那种一大块的全功能程序了。</p>
</blockquote>
<h2 id="可以通过多少种方式完成依赖注入？"><a href="#可以通过多少种方式完成依赖注入？" class="headerlink" title="可以通过多少种方式完成依赖注入？"></a>可以通过多少种方式完成依赖注入？</h2><p>通常，依赖注入可以通过<strong>三种</strong>方式完成，即：</p>
<blockquote>
<p>上面一个问题的三种方式的英文，下面是三种方式的中文。</p>
</blockquote>
<ul>
<li>接口注入</li>
<li>构造函数注入</li>
<li>setter 注入</li>
</ul>
<p>目前，在 Spring Framework 中，仅使用构造函数和 setter 注入这<strong>两种</strong>方式。</p>
<p>那么这两种方式各有什么优缺点呢？胖友可以简单阅读 <a href="https://my.oschina.net/itblog/blog/203746">《Spring两种依赖注入方式的比较》</a>，不用太较真。综述来说：</p>
<table>
<thead>
<tr>
<th>构造函数注入</th>
<th>setter 注入</th>
</tr>
</thead>
<tbody><tr>
<td>没有部分注入</td>
<td>有部分注入</td>
</tr>
<tr>
<td>不会覆盖 setter 属性</td>
<td>会覆盖 setter 属性</td>
</tr>
<tr>
<td>任意修改都会创建一个新实例</td>
<td>任意修改不会创建一个新实例</td>
</tr>
<tr>
<td>适用于设置很多属性</td>
<td>适用于设置少量属性</td>
</tr>
</tbody></table>
<ul>
<li>实际场景下，setting 注入使用的更多。</li>
</ul>
<h2 id="Spring-中有多少种-IoC-容器？"><a href="#Spring-中有多少种-IoC-容器？" class="headerlink" title="Spring 中有多少种 IoC 容器？"></a>Spring 中有多少种 IoC 容器？</h2><p>Spring 提供了两种( 不是“个” ) IoC 容器，分别是 BeanFactory、ApplicationContext 。</p>
<p><strong>BeanFactory</strong></p>
<blockquote>
<p>BeanFactory 在 <code>spring-beans</code> 项目提供。</p>
</blockquote>
<p>BeanFactory ，就像一个包含 Bean 集合的工厂类。它会在客户端要求时实例化 Bean 对象。</p>
<p><strong>ApplicationContext</strong></p>
<blockquote>
<p>ApplicationContext 在 <code>spring-context</code> 项目提供。</p>
</blockquote>
<p>ApplicationContext 接口扩展了 BeanFactory 接口，它在 BeanFactory 基础上提供了一些额外的功能。内置如下功能：</p>
<ul>
<li>MessageSource ：管理 message ，实现国际化等功能。</li>
<li>ApplicationEventPublisher ：事件发布。</li>
<li>ResourcePatternResolver ：多资源加载。</li>
<li>EnvironmentCapable ：系统 Environment（profile + Properties）相关。</li>
<li>Lifecycle ：管理生命周期。</li>
<li>Closable ：关闭，释放资源</li>
<li>InitializingBean：自定义初始化。</li>
<li>BeanNameAware：设置 beanName 的 Aware 接口。</li>
</ul>
<p>另外，ApplicationContext 会自动初始化非懒加载的 Bean 对象们。</p>
<p>详细的内容，感兴趣的胖友，可以看看 <a href="http://svip.iocoder.cn/Spring/ApplicationContext/">《【死磕 Spring】—— ApplicationContext 相关接口架构分析》</a> 一文。源码之前无秘密。简单总结下 BeanFactory 与 ApplicationContext 两者的差异：</p>
<blockquote>
<p>艿艿：可能很多胖友没看过源码，所以会比较难。</p>
</blockquote>
<table>
<thead>
<tr>
<th>BeanFactory</th>
<th>ApplicationContext</th>
</tr>
</thead>
<tbody><tr>
<td>它使用懒加载</td>
<td>它使用即时加载</td>
</tr>
<tr>
<td>它使用语法显式提供资源对象</td>
<td>它自己创建和管理资源对象</td>
</tr>
<tr>
<td>不支持国际化</td>
<td>支持国际化</td>
</tr>
<tr>
<td>不支持基于依赖的注解</td>
<td>支持基于依赖的注解</td>
</tr>
</tbody></table>
<p>另外，BeanFactory 也被称为<strong>低级</strong>容器，而 ApplicationContext 被称为<strong>高级</strong>容器。</p>
<h2 id="请介绍下常用的-BeanFactory-容器？"><a href="#请介绍下常用的-BeanFactory-容器？" class="headerlink" title="请介绍下常用的 BeanFactory 容器？"></a>请介绍下常用的 BeanFactory 容器？</h2><p>BeanFactory 最常用的是 XmlBeanFactory 。它可以根据 XML 文件中定义的内容，创建相应的 Bean。</p>
<h2 id="请介绍下常用的-ApplicationContext-容器？"><a href="#请介绍下常用的-ApplicationContext-容器？" class="headerlink" title="请介绍下常用的 ApplicationContext 容器？"></a>请介绍下常用的 ApplicationContext 容器？</h2><p>以下是三种较常见的 ApplicationContext 实现方式：</p>
<ul>
<li><p>1、ClassPathXmlApplicationContext ：从 ClassPath 的 XML 配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(“bean.xml”);<br></code></pre></td></tr></table></figure>
</li>
<li><p>2、FileSystemXmlApplicationContext ：由文件系统中的XML配置文件读取上下文。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">ApplicationContext context &#x3D; new FileSystemXmlApplicationContext(“bean.xml”);<br></code></pre></td></tr></table></figure>
</li>
<li><p>3、XmlWebApplicationContext ：由 Web 应用的XML文件读取上下文。例如我们在 Spring MVC 使用的情况。</p>
</li>
</ul>
<p>当然，目前我们更多的是使用 Spring Boot 为主，所以使用的是第四种 ApplicationContext 容器，ConfigServletWebServerApplicationContext 。</p>
<h2 id="列举一些-IoC-的一些好处？"><a href="#列举一些-IoC-的一些好处？" class="headerlink" title="列举一些 IoC 的一些好处？"></a>列举一些 IoC 的一些好处？</h2><ul>
<li>它将最小化应用程序中的代码量。</li>
<li>它以最小的影响和最少的侵入机制促进松耦合。</li>
<li>它支持即时的实例化和延迟加载 Bean 对象。</li>
<li>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</li>
</ul>
<h2 id="简述-Spring-IoC-的实现机制？"><a href="#简述-Spring-IoC-的实现机制？" class="headerlink" title="简述 Spring IoC 的实现机制？"></a>简述 Spring IoC 的实现机制？</h2><p>简单来说，Spring 中的 IoC 的实现原理，就是<strong>工厂模式</strong>加<strong>反射机制</strong>。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">interface Fruit &#123;<br><br>     public abstract void eat();<br>     <br>&#125;<br>class Apple implements Fruit &#123;<br><br>    public void eat()&#123;<br>        System.out.println(&quot;Apple&quot;);<br>    &#125;<br>    <br>&#125;<br>class Orange implements Fruit &#123;<br>    public void eat()&#123;<br>        System.out.println(&quot;Orange&quot;);<br>    &#125;<br>&#125;<br><br>class Factory &#123;<br><br>    public static Fruit getInstance(String className) &#123;<br>        Fruit f &#x3D; null;<br>        try &#123;<br>            f &#x3D; (Fruit) Class.forName(className).newInstance();<br>        &#125; catch (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        return f;<br>    &#125;<br>    <br>&#125;<br><br>class Client &#123;<br><br>    public static void main(String[] args) &#123;<br>        Fruit f &#x3D; Factory.getInstance(&quot;io.github.dunwu.spring.Apple&quot;);<br>        if(f !&#x3D; null)&#123;<br>            f.eat();<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Fruit 接口，有 Apple 和 Orange 两个实现类。</li>
<li>Factory 工厂，通过反射机制，创建 <code>className</code> 对应的 Fruit 对象。</li>
<li>Client 通过 Factory 工厂，获得对应的 Fruit 对象。</li>
<li>😈 实际情况下，Spring IoC 比这个复杂很多很多，例如单例 Bean 对象，Bean 的属性注入，相互依赖的 Bean 的处理，以及等等。</li>
</ul>
<p>在基友 <a href="http://www.iocoder.cn/Fight/Interview-poorly-asked-Spring-IOC-process-1/">《面试问烂的 Spring IoC 过程》</a> 的文章中，把 Spring IoC 相关的内容，讲的非常不错。</p>
<h2 id="Spring-框架中有哪些不同类型的事件？"><a href="#Spring-框架中有哪些不同类型的事件？" class="headerlink" title="Spring 框架中有哪些不同类型的事件？"></a>Spring 框架中有哪些不同类型的事件？</h2><p>Spring 的 ApplicationContext 提供了支持事件和代码中监听器的功能。</p>
<p>我们可以创建 Bean 用来监听在 ApplicationContext 中发布的事件。如果一个 Bean 实现了 ApplicationListener 接口，当一个ApplicationEvent 被发布以后，Bean 会自动被通知。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class AllApplicationEventListener implements ApplicationListener&lt;ApplicationEvent&gt; &#123;  <br>    <br>    @Override  <br>    public void onApplicationEvent(ApplicationEvent applicationEvent) &#123;  <br>        &#x2F;&#x2F; process event  <br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>Spring 提供了以下五种标准的事件：</p>
<ol>
<li>上下文更新事件（ContextRefreshedEvent）：该事件会在ApplicationContext 被初始化或者更新时发布。也可以在调用ConfigurableApplicationContext 接口中的 <code>#refresh()</code> 方法时被触发。</li>
<li>上下文开始事件（ContextStartedEvent）：当容器调用ConfigurableApplicationContext 的 <code>#start()</code> 方法开始/重新开始容器时触发该事件。</li>
<li>上下文停止事件（ContextStoppedEvent）：当容器调用 ConfigurableApplicationContext 的 <code>#stop()</code> 方法停止容器时触发该事件。</li>
<li>上下文关闭事件（ContextClosedEvent）：当ApplicationContext 被关闭时触发该事件。容器被关闭时，其管理的所有单例 Bean 都被销毁。</li>
<li>请求处理事件（RequestHandledEvent）：在 We b应用中，当一个HTTP 请求（request）结束触发该事件。</li>
</ol>
<hr>
<p>除了上面介绍的事件以外，还可以通过扩展 ApplicationEvent 类来开发<strong>自定义</strong>的事件。</p>
<p>① 示例自定义的事件的类，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class CustomApplicationEvent extends ApplicationEvent&#123;  <br><br>    public CustomApplicationEvent(Object source, final String msg) &#123;  <br>        super(source);<br>    &#125;  <br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>② 为了监听这个事件，还需要创建一个监听器。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class CustomEventListener implements ApplicationListener&lt;CustomApplicationEvent&gt; &#123;<br><br>    @Override  <br>    public void onApplicationEvent(CustomApplicationEvent applicationEvent) &#123;  <br>        &#x2F;&#x2F; handle event  <br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>③ 之后通过 ApplicationContext 接口的 <code>#publishEvent(Object event)</code> 方法，来发布自定义事件。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; 创建 CustomApplicationEvent 事件<br>CustomApplicationEvent customEvent &#x3D; new CustomApplicationEvent(applicationContext, &quot;Test message&quot;);<br>&#x2F;&#x2F; 发布事件<br>applicationContext.publishEvent(customEvent);<br></code></pre></td></tr></table></figure>

<h1 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h1><h2 id="什么是-Spring-Bean-？"><a href="#什么是-Spring-Bean-？" class="headerlink" title="什么是 Spring Bean ？"></a>什么是 Spring Bean ？</h2><ul>
<li>Bean 由 Spring IoC 容器实例化，配置，装配和管理。</li>
<li>Bean 是基于用户提供给 IoC 容器的配置元数据 Bean Definition 创建。</li>
</ul>
<p>这个问题，胖友可以在回过头看 <a href="http://svip.iocoder.cn/Spring/Interview/#">「什么是 Spring IoC 容器？」</a> 问题，相互对照。</p>
<h2 id="Spring-有哪些配置方式"><a href="#Spring-有哪些配置方式" class="headerlink" title="Spring 有哪些配置方式"></a>Spring 有哪些配置方式</h2><p>单纯从 Spring Framework 提供的方式，一共有三种：</p>
<ul>
<li><p>1、XML 配置文件。</p>
<p>Bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;bean id&#x3D;&quot;studentBean&quot; class&#x3D;&quot;org.edureka.firstSpring.StudentBean&quot;&gt;<br>    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;Edureka&quot;&gt;&lt;&#x2F;property&gt;<br>&lt;&#x2F;bean&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>2、注解配置。</p>
<p>您可以通过在相关的类，方法或字段声明上使用注解，将 Bean 配置为组件类本身，而不是使用 XML 来描述 Bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;beans&gt;<br>&lt;context:annotation-config&#x2F;&gt;<br>&lt;!-- bean definitions go here --&gt;<br>&lt;&#x2F;beans&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p>3、Java Config 配置。</p>
<p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p>
<ul>
<li><p><code>@Bean</code> 注解扮演与 <code>&lt;bean /&gt;</code> 元素相同的角色。</p>
</li>
<li><p><code>@Configuration</code> 类允许通过简单地调用同一个类中的其他 <code>@Bean</code> 方法来定义 Bean 间依赖关系。</p>
</li>
<li><p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Configuration<br>public class StudentConfig &#123;<br>    <br>    @Bean<br>    public StudentBean myStudent() &#123;<br>        return new StudentBean();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>是不是很熟悉 😈</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>目前主要使用 <strong>Java Config</strong> 配置为主。当然，三种配置方式是可以混合使用的。例如说：</p>
<ul>
<li>Dubbo 服务的配置，艿艿喜欢使用 XML 。</li>
<li>Spring MVC 请求的配置，艿艿喜欢使用 <code>@RequestMapping</code> 注解。</li>
<li>Spring MVC 拦截器的配置，艿艿喜欢 Java Config 配置。</li>
</ul>
<hr>
<p>另外，现在已经是 Spring Boot 的天下，所以更加是 <strong>Java Config</strong> 配置为主。</p>
<h2 id="Spring-支持几种-Bean-Scope-？"><a href="#Spring-支持几种-Bean-Scope-？" class="headerlink" title="Spring 支持几种 Bean Scope ？"></a>Spring 支持几种 Bean Scope ？</h2><blockquote>
<p>艿艿，这个是一个比较小众的题目，简单了解即可。</p>
</blockquote>
<p>Spring Bean 支持 5 种 Scope ，分别如下：</p>
<ul>
<li>Singleton - 每个 Spring IoC 容器仅有一个单 Bean 实例。<strong>默认</strong></li>
<li>Prototype - 每次请求都会产生一个新的实例。</li>
<li>Request - 每一次 HTTP 请求都会产生一个新的 Bean 实例，并且该 Bean 仅在当前 HTTP 请求内有效。</li>
<li>Session - 每一个的 Session 都会产生一个新的 Bean 实例，同时该 Bean 仅在当前 HTTP Session 内有效。</li>
<li>Application - 每一个 Web Application 都会产生一个新的 Bean ，同时该 Bean 仅在当前 Web Application 内有效。</li>
</ul>
<blockquote>
<p>另外，网络上很多文章说有 Global-session 级别，它是 Portlet 模块独有，目前已经废弃，在 Spring5 中是找不到的。</p>
</blockquote>
<p>仅当用户使用支持 Web 的 ApplicationContext 时，<strong>最后三个才可用</strong>。</p>
<p>再补充一点，开发者是可以<strong>自定义</strong> Bean Scope ，具体可参见 <a href="https://blog.csdn.net/elim168/article/details/75581670">《Spring（10）—— Bean 作用范围（二）—— 自定义 Scope》</a> 。</p>
<p>不错呢，还是那句话，这个题目简单了解下即可，实际常用的只有 Singleton 和 Prototype 两种级别，甚至说，只有 Singleton 级别。😈</p>
<h2 id="Spring-Bean-在容器的生命周期是什么样的？"><a href="#Spring-Bean-在容器的生命周期是什么样的？" class="headerlink" title="Spring Bean 在容器的生命周期是什么样的？"></a>Spring Bean 在容器的生命周期是什么样的？</h2><blockquote>
<p>艿艿说：这是一个比较高级的 Spring 的面试题，非常常见，并且答对比较加分。当然，如果实际真正弄懂，需要对 Spring Bean 的源码，有比较好的理解，所以 <a href="http://svip.iocoder.cn/categories/Spring/">《精尽 Spring 源码》</a> 系列，该读还是读吧。</p>
</blockquote>
<blockquote>
<p>艿艿：要注意下面每段话，艿艿进行加粗的地方。</p>
</blockquote>
<p>Spring Bean 的<strong>初始化</strong>流程如下：</p>
<ul>
<li><p>实例化 Bean 对象</p>
<ul>
<li><p>Spring 容器根据配置中的 Bean Definition(定义)中<strong>实例化</strong> Bean 对象。</p>
<blockquote>
<p>Bean Definition 可以通过 XML，Java 注解或 Java Config 代码提供。</p>
</blockquote>
</li>
<li><p>Spring 使用依赖注入<strong>填充</strong>所有属性，如 Bean 中所定义的配置。</p>
</li>
</ul>
</li>
<li><p>Aware 相关的属性，注入到 Bean 对象</p>
<ul>
<li>如果 Bean 实现 <strong>BeanNameAware</strong> 接口，则工厂通过传递 Bean 的 beanName 来调用 <code>#setBeanName(String name)</code> 方法。 </li>
<li>如果 Bean 实现 <strong>BeanFactoryAware</strong> 接口，工厂通过传递自身的实例来调用 <code>#setBeanFactory(BeanFactory beanFactory)</code> 方法。</li>
</ul>
</li>
<li><p>调用相应的方法，进一步初始化 Bean 对象</p>
<ul>
<li>如果存在与 Bean 关联的任何 <strong>BeanPostProcessor</strong> 们，则调用 <code>#preProcessBeforeInitialization(Object bean, String beanName)</code> 方法。 </li>
<li>如果 Bean 实现 <strong>InitializingBean</strong> 接口，则会调用 <code>#afterPropertiesSet()</code> 方法。</li>
<li>如果为 Bean 指定了 <strong>init</strong> 方法（例如 <code>&lt;bean /&gt;</code> 的 <code>init-method</code> 属性），那么将调用该方法。</li>
<li>如果存在与 Bean 关联的任何 <strong>BeanPostProcessor</strong> 们，则将调用 <code>#postProcessAfterInitialization(Object bean, String beanName)</code> 方法。</li>
</ul>
</li>
</ul>
<p>Spring Bean 的<strong>销毁</strong>流程如下：</p>
<ul>
<li>如果 Bean 实现 <strong>DisposableBean</strong> 接口，当 spring 容器关闭时，会调用 <code>#destroy()</code> 方法。</li>
<li>如果为 bean 指定了 <strong>destroy</strong> 方法（例如 <code>&lt;bean /&gt;</code> 的 <code>destroy-method</code> 属性），那么将调用该方法。</li>
</ul>
<p>整体如下图：<a href="http://static2.iocoder.cn/images/Spring/2018-12-24/03.jpg">![流程图](D:\新建文件夹 (3)\03.jpg)</a>流程图</p>
<p>无意中，艿艿又翻到一张有趣的整体图，如下图：</p>
<p><a href="http://static2.iocoder.cn/images/Spring/2018-12-24/08.png">![流程图](D:\新建文件夹 (3)\08.png)</a>流程图</p>
<h2 id="什么是-Spring-的内部-bean？"><a href="#什么是-Spring-的内部-bean？" class="headerlink" title="什么是 Spring 的内部 bean？"></a>什么是 Spring 的内部 bean？</h2><p>只有将 Bean <strong>仅</strong>用作另一个 Bean 的属性时，才能将 Bean 声明为内部 Bean。</p>
<ul>
<li>为了定义 Bean，Spring 提供基于 XML 的配置元数据在 <code>&lt;property&gt;</code>或 <code>&lt;constructor-arg&gt;</code> 中提供了 <code>&lt;bean&gt;</code>元素的使用。</li>
<li>内部 Bean 总是<strong>匿名</strong>的，并且它们总是作为<strong>原型 Prototype</strong> 。</li>
</ul>
<p>例如，假设我们有一个 Student 类，其中引用了 Person 类。这里我们将只创建一个 Person 类实例并在 Student 中使用它。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; Student.java<br><br>public class Student &#123;<br><br>    private Person person;<br>    <br>    &#x2F;&#x2F; ... Setters and Getters<br>&#125;<br><br>&#x2F;&#x2F; Person.java<br><br>public class Person &#123;<br><br>    private String name;<br>    private String address;<br>    <br>    &#x2F;&#x2F; ... Setters and Getters<br>&#125;<br>&lt;!-- bean.xml --&gt;<br><br>&lt;bean id&#x3D;“StudentBean&quot; class&#x3D;&quot;com.edureka.Student&quot;&gt;<br>    &lt;property name&#x3D;&quot;person&quot;&gt;<br>        &lt;!--This is inner bean --&gt;<br>        &lt;bean class&#x3D;&quot;com.edureka.Person&quot;&gt;<br>            &lt;property name&#x3D;&quot;name&quot; value&#x3D;“Scott&quot;&gt;&lt;&#x2F;property&gt;<br>            &lt;property name&#x3D;&quot;address&quot; value&#x3D;“Bangalore&quot;&gt;&lt;&#x2F;property&gt;<br>        &lt;&#x2F;bean&gt;<br>    &lt;&#x2F;property&gt;<br>&lt;&#x2F;bean&gt;<br></code></pre></td></tr></table></figure>

<h2 id="什么是-Spring-装配？"><a href="#什么是-Spring-装配？" class="headerlink" title="什么是 Spring 装配？"></a>什么是 Spring 装配？</h2><p>当 Bean 在 Spring 容器中组合在一起时，它被称为<strong>装配</strong>或 <strong>Bean 装配</strong>。Spring 容器需要知道需要什么 Bean 以及容器应该如何使用依赖注入来将 Bean 绑定在一起，同时装配 Bean 。</p>
<blockquote>
<p>装配，和上文提到的 DI 依赖注入，实际是一个东西。</p>
</blockquote>
<p><strong>自动装配有哪些方式？</strong></p>
<p>Spring 容器能够自动装配 Bean 。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 Bean 的协作者。</p>
<p>自动装配的不同模式：</p>
<ul>
<li>no - 这是默认设置，表示没有自动装配。应使用显式 Bean 引用进行装配。</li>
<li>byName - 它根据 Bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 Bean 。</li>
<li>【最常用】<strong>byType</strong> - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 Bean 类型匹配，则匹配并装配属性。</li>
<li>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li>
<li>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li>
</ul>
<p><strong>自动装配有什么局限？</strong></p>
<blockquote>
<p>艿艿：这个题目，了解下即可，也不是很准确。</p>
</blockquote>
<ul>
<li><p>覆盖的可能性 - 您始终可以使用 <code>&lt;constructor-arg&gt;</code> 和 <code>&lt;property&gt;</code> 设置指定依赖项，这将覆盖自动装配。</p>
</li>
<li><p>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。</p>
<blockquote>
<p>这种，严格来说，也不能称为局限。因为可以通过配置文件来解决。</p>
</blockquote>
</li>
<li><p>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。</p>
</li>
</ul>
<h2 id="解释什么叫延迟加载？"><a href="#解释什么叫延迟加载？" class="headerlink" title="解释什么叫延迟加载？"></a>解释什么叫延迟加载？</h2><p>默认情况下，容器启动之后会将所有作用域为<strong>单例</strong>的 Bean 都创建好，但是有的业务场景我们并不需要它提前都创建好。此时，我们可以在Bean 中设置 <code>lzay-init = &quot;true&quot;</code> 。</p>
<ul>
<li>这样，当容器启动之后，作用域为单例的 Bean ，就不在创建。</li>
<li>而是在获得该 Bean 时，才真正在创建加载。</li>
</ul>
<h2 id="Spring-框架中的单例-Bean-是线程安全的么？"><a href="#Spring-框架中的单例-Bean-是线程安全的么？" class="headerlink" title="Spring 框架中的单例 Bean 是线程安全的么？"></a>Spring 框架中的单例 Bean 是线程安全的么？</h2><p>Spring 框架并没有对<a href="http://howtodoinjava.com/2012/10/22/singleton-design-pattern-in-java/">单例</a> Bean 进行任何多线程的封装处理。</p>
<ul>
<li>关于单例 Bean 的<a href="http://howtodoinjava.com/2014/06/02/what-is-thread-safety/">线程安全</a>和并发问题，需要开发者自行去搞定。</li>
<li>并且，单例的线程安全问题，也不是 Spring 应该去关心的。Spring 应该做的是，提供根据配置，创建单例 Bean 或多例 Bean 的功能。</li>
</ul>
<p>当然，但实际上，大部分的 Spring Bean 并没有可变的状态(比如Serview 类和 DAO 类)，所以在某种程度上说 Spring 的单例 Bean 是线程安全的。</p>
<p>如果你的 Bean 有多种状态的话，就需要自行保证线程安全。最浅显的解决办法，就是将多态 Bean 的作用域( Scope )由 Singleton 变更为 Prototype 。</p>
<h2 id="Spring-Bean-怎么解决循环依赖的问题？"><a href="#Spring-Bean-怎么解决循环依赖的问题？" class="headerlink" title="Spring Bean 怎么解决循环依赖的问题？"></a>Spring Bean 怎么解决循环依赖的问题？</h2><blockquote>
<p>艿艿说：能回答出这个问题的，一般是比较厉害的。</p>
</blockquote>
<p>这是个比较复杂的问题，有能力的胖友，建议看下 <a href="http://svip.iocoder.cn/Spring/IoC-get-Bean-createBean-5/">《【死磕 Spring】—— IoC 之加载 Bean：创建 Bean（五）之循环依赖处理》</a></p>
<p>感觉，不通过源码，很难解释清楚这个问题。如果看不懂的胖友，可以在认真看完，在星球里，我们一起多交流下。好玩的。</p>
<h1 id="Spring-注解"><a href="#Spring-注解" class="headerlink" title="Spring 注解"></a>Spring 注解</h1><p>这块内容，实际写在 <a href="http://svip.iocoder.cn/Spring/Interview/#">「Spring Bean」</a> 中比较合适，考虑到后续的问题，都是关于注解的，所以单独起一个大的章节。</p>
<h2 id="什么是基于注解的容器配置？"><a href="#什么是基于注解的容器配置？" class="headerlink" title="什么是基于注解的容器配置？"></a>什么是基于注解的容器配置？</h2><p>不使用 XML 来描述 Bean 装配，开发人员通过在相关的类，方法或字段声明上使用<strong>注解</strong>将配置移动到组件类本身。它可以作为 XML 设置的替代方案。例如：</p>
<p>Spring 的 Java 配置是通过使用 <code>@Bean</code> 和 <code>@Configuration</code> 来实现。</p>
<ul>
<li><code>@Bean</code> 注解，扮演与 <code>&lt;bean /&gt;</code> 元素相同的角色。</li>
<li><code>@Configuration</code> 注解的类，允许通过简单地调用同一个类中的其他 <code>@Bean</code> 方法来定义 Bean 间依赖关系。</li>
</ul>
<p>示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Configuration<br>public class StudentConfig &#123;<br><br>    @Bean<br>    public StudentBean myStudent() &#123;<br>        return new StudentBean();<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="如何在-Spring-中启动注解装配？"><a href="#如何在-Spring-中启动注解装配？" class="headerlink" title="如何在 Spring 中启动注解装配？"></a>如何在 Spring 中启动注解装配？</h2><p>默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置 <code>&lt;context：annotation-config /&gt;</code> 元素在 Spring 配置文件中启用它。</p>
<p>当然，如果胖友是使用 Spring Boot ，默认情况下已经开启。</p>
<h2 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h2><ul>
<li><code>@Component</code> ：它将 Java 类标记为 Bean 。它是任何 Spring 管理组件的<strong>通用</strong>构造型。</li>
<li><code>@Controller</code> ：它将一个类标记为 Spring Web MVC <strong>控制器</strong>。</li>
<li><code>@Service</code> ：此注解是组件注解的特化。它不会对 <code>@Component</code> 注解提供任何其他行为。您可以在<strong>服务层</strong>类中使用 @Service 而不是 <code>@Component</code> ，因为它以更好的方式指定了意图。</li>
<li><code>@Repository</code> ：这个注解是具有类似用途和功能的 <code>@Component</code> 注解的特化。它为 <strong>DAO</strong> 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException 。</li>
</ul>
<h2 id="Required-注解有什么用？"><a href="#Required-注解有什么用？" class="headerlink" title="@Required 注解有什么用？"></a>@Required 注解有什么用？</h2><p><code>@Required</code> 注解，应用于 Bean 属性 setter 方法。  </p>
<ul>
<li>此注解仅指示必须在配置时使用 Bean 定义中的显式属性值或使用自动装配填充受影响的 Bean 属性。</li>
<li>如果尚未填充受影响的 Bean 属性，则容器将抛出 BeanInitializationException 异常。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class Employee &#123;<br><br>    private String name;<br>    <br>    @Required<br>    public void setName(String name)&#123;<br>        this.name&#x3D;name;<br>    &#125;<br>    <br>    public string getName()&#123;<br>        return name;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>T T 貌似平时很少用这个注解噢。</li>
</ul>
<h2 id="Autowired-注解有什么用？"><a href="#Autowired-注解有什么用？" class="headerlink" title="@Autowired 注解有什么用？"></a>@Autowired 注解有什么用？</h2><p><code>@Autowired</code> 注解，可以更准确地控制应该在何处以及如何进行自动装配。</p>
<ul>
<li>此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 Bean。</li>
<li>默认情况下，它是类型驱动的注入。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class EmpAccount &#123;<br>    <br>    @Autowired<br>    private Employee emp;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Qualifier-注解有什么用？"><a href="#Qualifier-注解有什么用？" class="headerlink" title="@Qualifier 注解有什么用？"></a>@Qualifier 注解有什么用？</h2><p>当你创建多个<strong>相同类型</strong>的 Bean ，并希望仅使用属性装配<strong>其中一个</strong> Bean 时，您可以使用 <code>@Qualifier</code> 注解和 <code>@Autowired</code> 通过指定 ID 应该装配哪个<strong>确切的</strong> Bean 来消除歧义。</p>
<p>例如，应用中有两个类型为 Employee 的 Bean ID 为 <code>&quot;emp1&quot;</code> 和 <code>&quot;emp2&quot;</code> ，此处，我们希望 EmployeeAccount Bean 注入 <code>&quot;emp1&quot;</code> 对应的 Bean 对象。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">public class EmployeeAccount &#123;<br><br>    @Autowired<br>    @Qualifier(emp1)<br>    private Employee emp;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><blockquote>
<p>Spring AOP 的面试题中，大多数都是概念题，主要是对切面的理解。概念点主要有：</p>
<ul>
<li>AOP</li>
<li>Aspect</li>
<li>JoinPoint</li>
<li>PointCut</li>
<li>Advice</li>
<li>Target</li>
<li>AOP Proxy</li>
<li>Weaving</li>
</ul>
</blockquote>
<ul>
<li>在阅读完 <a href="http://svip.iocoder.cn/Spring/Interview/#">「Spring AOP」</a> 的面试题后，在回过头思考下这些概念点，到底理解了多少。注意，不是背，理解！</li>
</ul>
<p>非常推荐阅读如下两篇文章：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000007469968">《彻底征服 Spring AOP 之理论篇》</a></li>
<li><a href="https://segmentfault.com/a/1190000007469982">《彻底征服 Spring AOP 之实战篇》</a></li>
</ul>
<h2 id="什么是-AOP-？"><a href="#什么是-AOP-？" class="headerlink" title="什么是 AOP ？"></a>什么是 AOP ？</h2><p>AOP(Aspect-Oriented Programming)，即<strong>面向切面编程</strong>, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成， 提供了与 OOP 不同的抽象软件结构的视角。</p>
<ul>
<li>在 OOP 中，以类( Class )作为基本单元</li>
<li>在 AOP 中，以**切面( Aspect )**作为基本单元。</li>
</ul>
<h2 id="什么是-Aspect-？"><a href="#什么是-Aspect-？" class="headerlink" title="什么是 Aspect ？"></a>什么是 Aspect ？</h2><p>Aspect 由 <strong>PointCut</strong> 和 <strong>Advice</strong> 组成。</p>
<ul>
<li>它既包含了横切逻辑的定义，也包括了连接点的定义。</li>
<li>Spring AOP 就是负责实施切面的框架，它将切面所定义的横切逻辑编织到切面所指定的连接点中。</li>
</ul>
<p>AOP 的工作重心在于如何将增强编织目标对象的连接点上, 这里包含两个工作:</p>
<ol>
<li>如何通过 PointCut 和 Advice 定位到特定的 <strong>JoinPoint</strong> 上。</li>
<li>如何在 Advice 中编写切面代码。</li>
</ol>
<p><strong>可以简单地认为, 使用 @Aspect 注解的类就是切面</strong></p>
<p><a href="http://static2.iocoder.cn/images/Spring/2018-12-24/04.jpg">![流程图](D:\新建文件夹 (3)\04.jpg)</a>流程图</p>
<h2 id="什么是-JoinPoint"><a href="#什么是-JoinPoint" class="headerlink" title="什么是 JoinPoint ?"></a>什么是 JoinPoint ?</h2><p>JoinPoint ，<strong>切点</strong>，程序运行中的一些时间点, 例如：</p>
<ul>
<li>一个方法的执行。</li>
<li>或者是一个异常的处理。</li>
</ul>
<p>在 Spring AOP 中，JoinPoint 总是方法的执行点。</p>
<h2 id="什么是-PointCut-？"><a href="#什么是-PointCut-？" class="headerlink" title="什么是 PointCut ？"></a>什么是 PointCut ？</h2><p>PointCut ，<strong>匹配</strong> JoinPoint 的谓词(a predicate that matches join points)。</p>
<blockquote>
<p>简单来说，PointCut 是匹配 JoinPoint 的条件。</p>
</blockquote>
<ul>
<li>Advice 是和特定的 PointCut 关联的，并且在 PointCut 相匹配的 JoinPoint 中执行。即 <code>Advice =&gt; PointCut =&gt; JoinPoint</code> 。</li>
<li>在 Spring 中, 所有的方法都可以认为是 JoinPoint ，但是我们并不希望在所有的方法上都添加 Advice 。<strong>而 PointCut 的作用</strong>，就是提供一组规则(使用 AspectJ PointCut expression language 来描述) 来匹配 JoinPoint ，给满足规则的 JoinPoint 添加 Advice 。</li>
</ul>
<p>😈 是不是觉得有点绕，实际场景下，其实也不会弄的这么清楚~~</p>
<h2 id="关于-JoinPoint-和-PointCut-的区别"><a href="#关于-JoinPoint-和-PointCut-的区别" class="headerlink" title="关于 JoinPoint 和 PointCut 的区别"></a>关于 JoinPoint 和 PointCut 的区别</h2><p>JoinPoint 和 PointCut 本质上就是<strong>两个不同纬度上</strong>的东西。</p>
<ul>
<li>在 Spring AOP 中，所有的方法执行都是 JoinPoint 。而 PointCut 是一个描述信息，它修饰的是 JoinPoint ，通过 PointCut ，我们就可以确定哪些 JoinPoint 可以被织入 Advice 。</li>
<li>Advice 是在 JoinPoint 上执行的，而 PointCut 规定了哪些 JoinPoint 可以执行哪些 Advice 。</li>
</ul>
<p>或者，我们在换一种说法：</p>
<ol>
<li>首先，Advice 通过 PointCut 查询需要被织入的 JoinPoint 。</li>
<li>然后，Advice 在查询到 JoinPoint 上执行逻辑。</li>
</ol>
<h2 id="什么是-Advice-？"><a href="#什么是-Advice-？" class="headerlink" title="什么是 Advice ？"></a>什么是 Advice ？</h2><p>Advice ，<strong>通知</strong>。</p>
<ul>
<li>特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice 。</li>
<li>Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的<strong>拦截器</strong>。</li>
</ul>
<p><strong>有哪些类型的 Advice？</strong></p>
<ul>
<li>Before - 这些类型的 Advice 在 JoinPoint 方法之前执行，并使用 <code>@Before</code> 注解标记进行配置。</li>
<li>After Returning - 这些类型的 Advice 在连接点方法正常执行后执行，并使用 <code>@AfterReturning</code> 注解标记进行配置。</li>
<li>After Throwing - 这些类型的 Advice 仅在 JoinPoint 方法通过抛出异常退出并使用 <code>@AfterThrowing</code> 注解标记配置时执行。</li>
<li>After Finally - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 <code>@After</code> 注解标记进行配置。</li>
<li>Around - 这些类型的 Advice 在连接点之前和之后执行，并使用 <code>@Around</code> 注解标记进行配置。</li>
</ul>
<p>😈 看起来，是不是和拦截器的执行时间，有几分相似。实际上，用于拦截效果的各种实现，大体都是类似的。</p>
<h2 id="什么是-Target-？"><a href="#什么是-Target-？" class="headerlink" title="什么是 Target ？"></a>什么是 Target ？</h2><p>Target ，织入 Advice 的<strong>目标对象</strong>。目标对象也被称为 <strong>Advised Object</strong> 。</p>
<ul>
<li>因为 Spring AOP 使用运行时代理的方式来实现 Aspect ，因此 Advised Object 总是一个代理对象(Proxied Object) 。</li>
<li><strong>注意, Advised Object 指的不是原来的对象，而是织入 Advice 后所产生的代理对象</strong>。</li>
<li>Advice + Target Object = Advised Object = Proxy 。</li>
</ul>
<h2 id="AOP-有哪些实现方式？"><a href="#AOP-有哪些实现方式？" class="headerlink" title="AOP 有哪些实现方式？"></a>AOP 有哪些实现方式？</h2><p>实现 AOP 的技术，主要分为两大类：</p>
<ul>
<li><p>① <strong>静态代理</strong> - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强。</p>
<ul>
<li><p>编译时编织（特殊编译器实现）</p>
</li>
<li><p>类加载时编织（特殊的类加载器实现）。</p>
<blockquote>
<p>例如，SkyWalking 基于 Java Agent 机制，配置上 ByteBuddy 库，实现类加载时编织时增强，从而实现链路追踪的透明埋点。</p>
<p>感兴趣的胖友，可以看看 <a href="http://www.kailing.pub/article/index/arcid/178.html">《SkyWalking 源码分析之 JavaAgent 工具 ByteBuddy 的应用》</a> 。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>② <strong>动态代理</strong> - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。目前 Spring 中使用了两种动态代理库：</p>
<ul>
<li>JDK 动态代理</li>
<li>CGLIB</li>
</ul>
</li>
</ul>
<p>那么 Spring 什么时候使用 JDK 动态代理，什么时候使用 CGLIB 呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; From 《Spring 源码深度解析》P172<br>&#x2F;&#x2F; Spring AOP 部分使用 JDK 动态代理或者 CGLIB 来为目标对象创建代理。（建议尽量使用 JDK 的动态代理）<br>&#x2F;&#x2F; 如果被代理的目标对象实现了至少一个接口，则会使用 JDK 动态代理。所有该目标类型实现的接口都讲被代理。<br>&#x2F;&#x2F; 若该目标对象没有实现任何接口，则创建一个 CGLIB 代理。<br>&#x2F;&#x2F; 如果你希望强制使用 CGLIB 代理，（例如希望代理目标对象的所有方法，而不只是实现自接口的方法）那也可以。但是需要考虑以下两个方法：<br>&#x2F;&#x2F;      1&gt; 无法通知(advise) Final 方法，因为它们不能被覆盖。<br>&#x2F;&#x2F;      2&gt; 你需要将 CGLIB 二进制发型包放在 classpath 下面。<br>&#x2F;&#x2F; 为什么 Spring 默认使用 JDK 的动态代理呢？笔者猜测原因如下：<br>&#x2F;&#x2F;      1&gt; 使用 JDK 原生支持，减少三方依赖<br>&#x2F;&#x2F;      2&gt; JDK8 开始后，JDK 代理的性能差距 CGLIB 的性能不会太多。可参见：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;haiq&#x2F;p&#x2F;4304615.html<br></code></pre></td></tr></table></figure>

<ul>
<li>实际上，Spring AOP 的代码量不大，与其在窗户外面不清不楚，不如捅破它！感兴趣的胖友，可以撸一撸 <a href="http://svip.iocoder.cn/Spring/aop-simple-intro/">《精尽 Spring 源码分析 —— AOP 源码简单导读》</a> 。</li>
</ul>
<p>或者，我们来换一个解答答案：</p>
<p>Spring AOP 中的动态代理主要有两种方式，</p>
<ul>
<li><p>JDK 动态代理</p>
<p>JDK 动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是 InvocationHandler 接口和 Proxy 类。</p>
</li>
<li><p>CGLIB 动态代理</p>
<p>如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类。当然，Spring 也支持配置，<strong>强制</strong>使用 CGLIB 动态代理。<br>CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 <code>final</code> ，那么它是无法使用 CGLIB 做动态代理的。  </p>
</li>
</ul>
<h2 id="Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？"></a>Spring AOP and AspectJ AOP 有什么区别？</h2><ul>
<li>代理方式不同<ul>
<li>Spring AOP 基于动态代理方式实现。</li>
<li>AspectJ AOP 基于静态代理方式实现。</li>
</ul>
</li>
<li>PointCut 支持力度不同<ul>
<li>Spring AOP <strong>仅</strong>支持方法级别的 PointCut 。</li>
<li>AspectJ AOP 提供了完全的 AOP 支持，它还支持属性级别的 PointCut 。</li>
</ul>
</li>
</ul>
<h2 id="什么是编织（Weaving）？"><a href="#什么是编织（Weaving）？" class="headerlink" title="什么是编织（Weaving）？"></a>什么是编织（Weaving）？</h2><p>Weaving ，<strong>编织</strong>。</p>
<ul>
<li>为了创建一个 Advice 对象而链接一个 Aspect 和其它应用类型或对象，称为编织（Weaving）。</li>
<li>在 Spring AOP 中，编织在运行时执行，即动态代理。请参考下图：<a href="http://static2.iocoder.cn/images/Spring/2018-12-24/05.jpg">![Proxy](D:\新建文件夹 (3)\05.jpg)</a>Proxy</li>
</ul>
<h2 id="Spring-如何使用-AOP-切面？"><a href="#Spring-如何使用-AOP-切面？" class="headerlink" title="Spring 如何使用 AOP 切面？"></a>Spring 如何使用 AOP 切面？</h2><p>在 Spring AOP 中，有两种方式配置 AOP 切面：</p>
<ul>
<li>基于 <strong>XML</strong> 方式的切面实现。</li>
<li>基于 <strong>注解</strong> 方式的切面实现。</li>
</ul>
<p>目前，主流喜欢使用 <strong>注解</strong> 方式。胖友可以看看 <a href="https://segmentfault.com/a/1190000007469982">《彻底征服 Spring AOP 之实战篇》</a> 。</p>
<h1 id="Spring-Transaction"><a href="#Spring-Transaction" class="headerlink" title="Spring Transaction"></a>Spring Transaction</h1><p>非常推荐阅读如下文章：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&mid=2247484702&idx=1&sn=c04261d63929db09ff6df7cadc7cca21&chksm=fa497aafcd3ef3b94082da7bca841b5b7b528eb2a52dbc4eb647b97be63a9a1cf38a9e71bf90&token=165108535&lang=zh_CN#rd">《可能是最漂亮的 Spring 事务管理详解》</a></li>
</ul>
<h2 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h2><p>事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。</p>
<p>这样可以防止出现脏数据，防止数据库数据出现问题。</p>
<h2 id="事务的特性指的是？"><a href="#事务的特性指的是？" class="headerlink" title="事务的特性指的是？"></a>事务的特性指的是？</h2><p>指的是 <strong>ACID</strong> ，如下图所示：</p>
<p><a href="http://static2.iocoder.cn/images/Spring/2018-12-24/06.png">![事务的特性](D:\新建文件夹 (3)\06.png)</a>事务的特性</p>
<ol>
<li><strong>原子性</strong> Atomicity  ：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>
<li><strong>一致性</strong> Consistency ：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7">约束</a>、<a href="https://zh.wikipedia.org/wiki/%E8%A7%A6%E5%8F%91%E5%99%A8_(%E6%95%B0%E6%8D%AE%E5%BA%93)">触发器</a>、<a href="https://zh.wikipedia.org/w/index.php?title=%E7%BA%A7%E8%81%94%E5%9B%9E%E6%BB%9A&action=edit&redlink=1">级联回滚</a>等。</li>
<li><strong>隔离性</strong> Isolation  ：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable  read）和串行化（Serializable）。</li>
<li><strong>持久性</strong> Durability ：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ol>
<h2 id="列举-Spring-支持的事务管理类型？"><a href="#列举-Spring-支持的事务管理类型？" class="headerlink" title="列举 Spring 支持的事务管理类型？"></a>列举 Spring 支持的事务管理类型？</h2><p>目前 Spring 提供两种类型的事务管理：</p>
<ul>
<li><strong>声明式</strong>事务：通过使用注解或基于 XML 的配置事务，从而事务管理与业务代码分离。</li>
<li><strong>编程式</strong>事务：通过编码的方式实现事务管理，需要在代码中显式的调用事务的获得、提交、回滚。它为您提供极大的灵活性，但维护起来非常困难。</li>
</ul>
<p>实际场景下，我们一般使用 Spring Boot + 注解的<strong>声明式</strong>事务。具体的示例，胖友可以看看 <a href="https://www.jianshu.com/p/cddeca2c9245">《Spring Boot 事务注解详解》</a> 。</p>
<p>另外，也推荐看看 <a href="https://blog.csdn.net/xktxoo/article/details/77919508">《Spring 事务管理 － 编程式事务、声明式事务》</a> 一文。</p>
<h2 id="Spring-事务如何和不同的数据持久层框架做集成？"><a href="#Spring-事务如何和不同的数据持久层框架做集成？" class="headerlink" title="Spring 事务如何和不同的数据持久层框架做集成？"></a>Spring 事务如何和不同的数据持久层框架做集成？</h2><p>① 首先，我们先明确下，这里数据持久层框架，指的是 Spring JDBC、Hibernate、Spring JPA、MyBatis 等等。</p>
<p>② 然后，Spring 事务的管理，是通过 <code>org.springframework.transaction.PlatformTransactionManager</code> 进行管理，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; PlatformTransactionManager.java<br><br>public interface PlatformTransactionManager &#123;<br><br>    &#x2F;&#x2F; 根据事务定义 TransactionDefinition ，获得 TransactionStatus 。 <br>    TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;<br><br>    &#x2F;&#x2F; 根据情况，提交事务<br>    void commit(TransactionStatus status) throws TransactionException;<br>    <br>    &#x2F;&#x2F; 根据情况，回滚事务<br>    void rollback(TransactionStatus status) throws TransactionException;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>PlatformTransactionManager 是负责事务管理的接口，一共有三个接口方法，分别负责事务的获得、提交、回滚。</p>
</li>
<li><pre><code>#getTransaction(TransactionDefinition definition)
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>   方法，根据事务定义 TransactionDefinition ，获得 TransactionStatus 。<br><br>  - 为什么不是创建事务呢？因为如果当前如果已经有事务，则不会进行创建，一般来说会跟当前线程进行绑定。如果不存在事务，则进行创建。<br>  - 为什么返回的是 TransactionStatus 对象？在 TransactionStatus 中，不仅仅包含事务属性，还包含事务的其它信息，例如是否只读、是否为新创建的事务等等。😈 下面，也会详细解析 TransactionStatus 。<br>  - 事务 TransactionDefinition 是什么？😈 下面，也会详细解析 TransactionStatus 。<br><br>- &#96;&#96;&#96;<br>  #commit(TransactionStatus status)<br></code></pre></td></tr></table></figure>

 方法，根据 TransactionStatus 情况，提交事务。

- 为什么根据 TransactionStatus 情况，进行提交？例如说，带

  <figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Transactional<br></code></pre></td></tr></table></figure>

   注解的的 A 方法，会调用 

  <figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Transactional<br></code></pre></td></tr></table></figure>

   注解的的 B 方法。

  - 在 B 方法结束调用后，会执行 `PlatformTransactionManager#commit(TransactionStatus status)` 方法，此处事务**是不能**、**也不会**提交的。
  - 而是在 A 方法结束调用后，执行 `PlatformTransactionManager#commit(TransactionStatus status)` 方法，提交事务。</code></pre>
</li>
<li><pre><code>#rollback(TransactionStatus status)
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>   方法，根据 TransactionStatus 情况，回滚事务。<br><br>  - 为什么根据 TransactionStatus 情况，进行回滚？原因同 &#96;#commit(TransactionStatus status)&#96; 方法。<br><br>③ 再之后，PlatformTransactionManager 有**抽象子**类 &#96;org.springframework.transaction.support.AbstractPlatformTransactionManager&#96; ，基于 [模板方法模式](https:&#x2F;&#x2F;blog.csdn.net&#x2F;carson_ho&#x2F;article&#x2F;details&#x2F;54910518) ，实现事务整体逻辑的骨架，而抽象 &#96;#doCommit(DefaultTransactionStatus status)&#96;、&#96;#doRollback(DefaultTransactionStatus status)&#96; 等等方法，交由子类类来实现。<br><br>&gt; 前方高能，即将进入关键的 ④ 步骤。<br><br>④ 最后，不同的数据持久层框架，会有其对应的 PlatformTransactionManager 实现类，如下图所示：[![事务的特性](D:\新建文件夹 (3)\07.png)](http:&#x2F;&#x2F;static2.iocoder.cn&#x2F;images&#x2F;Spring&#x2F;2018-12-24&#x2F;07.png)事务的特性<br><br>- 所有的实现类，都基于 AbstractPlatformTransactionManager 这个骨架类。<br>- HibernateTransactionManager ，和 Hibernate5 的事务管理做集成。<br>- DataSourceTransactionManager ，和 JDBC 的事务管理做集成。所以，它也适用于 MyBatis、Spring JDBC 等等。<br>- JpaTransactionManager ，和 JPA 的事务管理做集成。<br><br>如下，是一个比较常见的 XML 方式来配置的事务管理器，使用的是 DataSourceTransactionManager 。代码如下：<br><br></code></pre></td></tr></table></figure>
&lt;!-- 事务管理器 --&gt;
&lt;bean id=&quot;transactionManager&quot;
class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
  &lt;!-- 数据源 --&gt;
  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
&lt;/bean&gt;
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>- 正如上文所说，它适用于 MyBatis、Spring JDBC 等等。<br><br>------<br><br>😈 是不是很有趣，更多详细的解析，可见如下几篇文章：<br><br>- [《精尽 Spring 源码分析 —— Transaction 源码简单导读》](http:&#x2F;&#x2F;svip.iocoder.cn&#x2F;categories&#x2F;Spring&#x2F;)<br>- [《精尽 MyBatis 源码分析 —— 事务模块》](http:&#x2F;&#x2F;svip.iocoder.cn&#x2F;MyBatis&#x2F;transaction-package&#x2F;)<br>- [《精尽 MyBatis 源码解析 —— Spring 集成（四）之事务》](http:&#x2F;&#x2F;svip.iocoder.cn&#x2F;MyBatis&#x2F;Spring-Integration-4&#x2F;)<br><br>## 为什么在 Spring 事务中不能切换数据源？<br><br>做过 Spring 多数据源的胖友，都会有个惨痛的经历，为什么在开启事务的 Service 层的方法中，无法切换数据源呢？因为，在 Spring 的事务管理中，**所使用的数据库连接会和当前线程所绑定**，即使我们设置了另外一个数据源，使用的还是当前的数据源连接。<br><br>另外，多个数据源且需要事务的场景，本身会带来**多事务一致性**的问题，暂时没有特别好的解决方案。<br><br>所以一般一个应用，推荐除非了读写分离所带来的多数据源，其它情况下，建议只有一个数据源。并且，随着微服务日益身形，一个服务对应一个 DB 是比较常见的架构选择。<br><br>## @Transactional 注解有哪些属性？如何使用？<br><br>&#96;@Transactional&#96; 注解的**属性**如下：<br><br>| 属性                   | 类型                               | 描述                                   |<br>| ---------------------- | ---------------------------------- | -------------------------------------- |<br>| value                  | String                             | 可选的限定描述符，指定使用的事务管理器 |<br>| propagation            | enum: Propagation                  | 可选的事务传播行为设置                 |<br>| isolation              | enum: Isolation                    | 可选的事务隔离级别设置                 |<br>| readOnly               | boolean                            | 读写或只读事务，默认读写               |<br>| timeout                | int (in seconds granularity)       | 事务超时时间设置                       |<br>| rollbackFor            | Class对象数组，必须继承自Throwable | 导致事务回滚的异常类数组               |<br>| rollbackForClassName   | 类名数组，必须继承自Throwable      | 导致事务回滚的异常类名字数组           |<br>| noRollbackFor          | Class对象数组，必须继承自Throwable | 不会导致事务回滚的异常类数组           |<br>| noRollbackForClassName | 类名数组，必须继承自Throwable      | 不会导致事务回滚的异常类名字数组       |<br><br>- 一般情况下，我们直接使用 &#96;@Transactional&#96; 的所有属性默认值即可。<br><br>具体**用法**如下：<br><br>- &#96;@Transactional&#96; 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 &#96;public&#96; 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。<br>- 虽然 &#96;@Transactional&#96; 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， **&#96;@Transactional&#96; 注解应该只被应用到 &#96;public&#96; 方法上，这是由 Spring AOP 的本质决定的**。如果你在 &#96;protected&#96;、&#96;private&#96; 或者默认可见性的方法上使用 &#96;@Transactional&#96; 注解，这将被忽略，也不会抛出任何异常。**这一点，非常需要注意**。<br><br>------<br><br>下面，我们来简单说下**源码**相关的东西。<br><br>&#96;@Transactional&#96; 注解的属性，会解析成 &#96;org.springframework.transaction.TransactionDefinition&#96; 对象，即事务定义。TransactionDefinition 代码如下：<br><br></code></pre></td></tr></table></figure>
public interface TransactionDefinition &#123;

  int getPropagationBehavior(); // 事务的传播行为
  int getIsolationLevel(); // 事务的隔离级别
  int getTimeout(); // 事务的超时时间
  boolean isReadOnly(); // 事务是否只读
  @Nullable
  String getName(); // 事务的名字
</code></pre>
</li>
</ul>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>- 可能会胖友有以后，&#96;@Transactional&#96; 注解的 &#96;rollbackFor&#96;、&#96;rollbackForClassName&#96;、&#96;noRollbackFor&#96;、&#96;noRollbackForClassName&#96; 属性貌似没体现出来？它们提现在 TransactionDefinition 的实现类 RuleBasedTransactionAttribute 中。<br>- &#96;#getPropagationBehavior()&#96; 方法，返回事务的**传播行为**，该值是个枚举，在下面来说。<br>- &#96;#getIsolationLevel()&#96; 方法，返回事务的**隔离级别**，该值是个枚举，在下面来说。<br><br>## 什么是事务的隔离级别？分成哪些隔离级别？<br><br>关于这个问题，涉及的内容会比较多，胖友直接看如下两篇文章：<br><br>- [《数据库四大特性以及事务隔离级别》](https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;25419593)<br>- [《五分钟搞清楚 MySQL 事务隔离级别》](https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;4e3edbedb9a8)<br><br>另外，有一点非常重要，不同数据库对四个隔离级别的支持和实现略有不同。因为我们目前互联网主要使用 MySQL 为主，所以至少要搞懂 MySQL 对隔离级别的支持和实现情况。<br><br>在 TransactionDefinition 接口中，定义了“**四种**”的隔离级别枚举。代码如下：<br><br></code></pre></td></tr></table></figure>
<p>// TransactionDefinition.java</p>
<p>/**</p>
<ul>
<li>【Spring 独有】使用后端数据库默认的隔离级别</li>
<li></li>
<li>MySQL 默认采用的 REPEATABLE_READ隔离级别</li>
<li>Oracle 默认采用的 READ_COMMITTED隔离级别</li>
<li>/<br>int ISOLATION_DEFAULT = -1;</li>
</ul>
<p>/**</p>
<ul>
<li>最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</li>
<li>/<br>int ISOLATION_READ_UNCOMMITTED = Connection.TRANSACTION_READ_UNCOMMITTED;</li>
</ul>
<p>/**</p>
<ul>
<li>允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</li>
<li>/<br>int ISOLATION_READ_COMMITTED = Connection.TRANSACTION_READ_COMMITTED;<br>/**</li>
<li>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li>/<br>int ISOLATION_REPEATABLE_READ = Connection.TRANSACTION_REPEATABLE_READ;<br>/**</li>
<li>最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
<li></li>
<li>但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
<li>/<br>int ISOLATION_SERIALIZABLE = Connection.TRANSACTION_SERIALIZABLE;<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>## 什么是事务的传播级别？分成哪些传播级别？<br><br>事务的**传播行为**，指的是当前带有事务配置的方法，需要怎么处理事务。<br><br>- 例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。<br><br>- 有一点需要注意，事务的传播级别，并不是数据库事务规范中的名词，**而是 Spring 自身所定义的**。通过事务的传播级别，Spring 才知道如何处理事务，是创建一个新事务呢，还是继续使用当前的事务。<br><br>  &gt; 艿艿的自我吐槽：是不是有种背概念背的想哭<br><br>在 TransactionDefinition 接口中，定义了**三类七种**传播级别。代码如下：<br><br></code></pre></td></tr></table></figure>
// TransactionDefinition.java</li>
</ul>
<p>// ========== 支持当前事务的情况 ========== </p>
<p>/**</p>
<ul>
<li>如果当前存在事务，则使用该事务。</li>
<li>如果当前没有事务，则创建一个新的事务。</li>
<li>/<br>int PROPAGATION_REQUIRED = 0;<br>/**</li>
<li>如果当前存在事务，则使用该事务。</li>
<li>如果当前没有事务，则以非事务的方式继续运行。</li>
<li>/<br>int PROPAGATION_SUPPORTS = 1;<br>/**</li>
<li>如果当前存在事务，则使用该事务。</li>
<li>如果当前没有事务，则抛出异常。</li>
<li>/<br>int PROPAGATION_MANDATORY = 2;</li>
</ul>
<p>// ========== 不支持当前事务的情况 ========== </p>
<p>/**</p>
<ul>
<li>创建一个新的事务。</li>
<li>如果当前存在事务，则把当前事务挂起。</li>
<li>/<br>int PROPAGATION_REQUIRES_NEW = 3;<br>/**</li>
<li>以非事务方式运行。</li>
<li>如果当前存在事务，则把当前事务挂起。</li>
<li>/<br>int PROPAGATION_NOT_SUPPORTED = 4;<br>/**</li>
<li>以非事务方式运行。</li>
<li>如果当前存在事务，则抛出异常。</li>
<li>/<br>int PROPAGATION_NEVER = 5;</li>
</ul>
<p>// ========== 其他情况 ========== </p>
<p>/**</p>
<ul>
<li>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行。</li>
<li>如果当前没有事务，则等价于 {@link TransactionDefinition#PROPAGATION_REQUIRED}</li>
<li>/<br>int PROPAGATION_NESTED = 6;<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>- 分类之后，其实还是比较好记的。当然，绝大数场景，我们只用 &#96;PROPAGATION_REQUIRED&#96; 传播级别。<br><br>- 这里需要指出的是，前面的六种事务传播行为是 Spring 从 EJB 中引入的，他们共享相同的概念。而 <br><br></code></pre></td></tr></table></figure>
PROPAGATION_NESTED<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br>   是 Spring 所特有的。<br><br>  - 以 &#96;PROPAGATION_NESTED&#96;  启动的事务内嵌于外部事务中（如果存在外部事务的话），此时，内嵌事务并不是一个独立的事务，它依赖于外部事务的存在，只有通过外部的事务提交，才能引起内部事务的提交，嵌套的子事务不能单独提交。如果熟悉 JDBC  中的保存点（SavePoint）的概念，那嵌套事务就很容易理解了，其实嵌套的子事务就是保存点的一个应用，一个事务中可以包括多个保存点，每一个嵌套子事务。另外，外部事务的回滚也会导致嵌套子事务的回滚。<br>  - 😈 当然，虽然上面 &#96;PROPAGATION_NESTED&#96; 文字很长，实际我们基本没用过。或者说，去掉基本，我们根本没用过。<br><br>## 什么是事务的超时属性？<br><br>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。<br><br>在 TransactionDefinition 中以 &#96;int&#96; 的值来表示超时时间，其单位是秒。<br><br>当然，这个属性，貌似我们基本也没用过。<br><br>## 什么是事务的只读属性？<br><br>事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。<br><br>- 所谓事务性资源就是指那些被事务管理的资源，比如数据源、JMS 资源，以及自定义的事务性资源等等。<br>- 如果确定只对事务性资源进行只读操作，那么我们可以将事务标志为只读的，以提高事务处理的性能。感兴趣的胖友，可以看看 [《不使用事务和使用只读事务的区别 》](https:&#x2F;&#x2F;my.oschina.net&#x2F;uniquejava&#x2F;blog&#x2F;80954) 。<br><br>在 TransactionDefinition 中以 &#96;boolean&#96; 类型来表示该事务是否只读。<br><br>## 什么是事务的回滚规则？<br><br>回滚规则，定义了哪些异常会导致事务回滚而哪些不会。<br><br>- 默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的）。 <br>- 但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。<br><br>注意，事务的回滚规则，并不是数据库事务规范中的名词，**而是 Spring 自身所定义的**。<br><br>## 简单介绍 TransactionStatus ？<br><br>&gt; 艿艿：这个可能不是一个面试题，主要满足下大家的好奇心。<br><br>TransactionStatus 接口，记录事务的状态，不仅仅包含事务本身，还包含事务的其它信息。代码如下：<br><br></code></pre></td></tr></table></figure>
// TransactionStatus.java</li>
</ul>
<p>public interface TransactionStatus extends SavepointManager, Flushable {</p>
<pre><code>/**
 * 是否是新创建的事务
 */
boolean isNewTransaction();

/**
 * 是否有 Savepoint
 *
 * 在 &#123;@link TransactionDefinition#PROPAGATION_NESTED&#125; 传播级别使用。
 */
boolean hasSavepoint();

/**
 * 设置为只回滚
 */
void setRollbackOnly();
/**
 * 是否为只回滚
 */
boolean isRollbackOnly();

/**
 * 执行 flush 操作
 */
@Override
void flush();

/**
 * 是否事务已经完成
 */
boolean isCompleted();</code></pre>
<p>}</p>
<p>```</p>
<ul>
<li>为什么没有事务对象呢？在 TransactionStatus 的实现类 DefaultTransactionStatus 中，有个 <code>Object transaction</code> 属性，表示事务对象。</li>
<li><code>#isNewTransaction()</code> 方法，表示是否是新创建的事务。有什么用呢？答案结合 <a href="http://svip.iocoder.cn/Spring/Interview/#">「Spring 事务如何和不同的数据持久层框架做集成？」</a> 问题，我们对 <code>#commit(TransactionStatus status)</code> 方法的解释。通过该方法，我们可以判断，当前事务是否当前方法所创建的，只有创建事务的方法，<strong>才能且应该真正的提交事务</strong>。</li>
</ul>
<h2 id="使用-Spring-事务有什么优点？"><a href="#使用-Spring-事务有什么优点？" class="headerlink" title="使用 Spring 事务有什么优点？"></a>使用 Spring 事务有什么优点？</h2><ol>
<li>通过 PlatformTransactionManager ，为不同的数据层持久框架提供统一的 API ，无需关心到底是原生 JDBC、Spring JDBC、JPA、Hibernate 还是 MyBatis 。</li>
<li>通过使用声明式事务，使业务代码和事务管理的逻辑分离，更加清晰。</li>
</ol>
<p>从倾向上来说，艿艿比较喜欢<strong>注解</strong> + 声明式事务。</p>
<h1 id="Spring-Data-Access"><a href="#Spring-Data-Access" class="headerlink" title="Spring Data Access"></a>Spring Data Access</h1><blockquote>
<p>艿艿：这块的问题，感觉面试问的不多，至少我很少问。哈哈哈。就当做下了解，万一问了呢。</p>
</blockquote>
<h2 id="Spring-支持哪些-ORM-框架？"><a href="#Spring-支持哪些-ORM-框架？" class="headerlink" title="Spring 支持哪些 ORM 框架？"></a>Spring 支持哪些 ORM 框架？</h2><ul>
<li>Hibernate</li>
<li>JPA</li>
<li>MyBatis</li>
<li><a href="https://docs.spring.io/spring/docs/3.0.0.M4/reference/html/ch13s04.html">JDO</a></li>
<li><a href="https://db.apache.org/ojb/docu/howtos/howto-use-spring.html">OJB</a></li>
</ul>
<p>可能会有胖友说，不是应该还有 Spring JDBC 吗。注意，Spring JDBC 不是 ORM 框架。</p>
<h2 id="在-Spring-框架中如何更有效地使用-JDBC-？"><a href="#在-Spring-框架中如何更有效地使用-JDBC-？" class="headerlink" title="在 Spring 框架中如何更有效地使用 JDBC ？"></a>在 Spring 框架中如何更有效地使用 JDBC ？</h2><p>Spring 提供了 Spring JDBC 框架，方便我们使用 JDBC 。</p>
<p>对于开发者，只需要使用 JdbcTemplate 类，它提供了很多便利的方法解决诸如把数据库数据转变成基本数据类型或对象，执行写好的或可调用的数据库操作语句，提供自定义的数据错误处理。</p>
<p>没有使用过的胖友，可以看看 <a href="https://www.tianmaying.com/tutorial/spring-jdbc-data-accessing">《Spring JDBC 访问关系型数据库》</a> 文章。</p>
<h2 id="Spring-数据数据访问层有哪些异常？"><a href="#Spring-数据数据访问层有哪些异常？" class="headerlink" title="Spring 数据数据访问层有哪些异常？"></a>Spring 数据数据访问层有哪些异常？</h2><p>通过使用 Spring 数据数据访问层，它统一了各个数据持久层框架的不同异常，统一进行提供 <code>org.springframework.dao.DataAccessException</code> 异常及其子类。如下图所示：</p>
<p><a href="http://static2.iocoder.cn/images/Spring/2018-12-24/09.jpg">![流程图](D:\新建文件夹 (3)\09.jpg)</a>流程图</p>
<h2 id="使用-Spring-访问-Hibernate-的方法有哪些？"><a href="#使用-Spring-访问-Hibernate-的方法有哪些？" class="headerlink" title="使用 Spring 访问 Hibernate 的方法有哪些？"></a>使用 Spring 访问 Hibernate 的方法有哪些？</h2><blockquote>
<p>艿艿：这个问题很灵异，因为艿艿已经好久不使用 Hibernate 了，所以答案是直接复制的。</p>
</blockquote>
<p>我们可以通过两种方式使用 Spring 访问 Hibernate：</p>
<ul>
<li>使用 Hibernate 模板和回调进行控制反转。</li>
<li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点。</li>
</ul>
<blockquote>
<p>艿艿：不过我记得，12 年我用过 Spring JPA 的方式，操作 Hibernate 。具体可参考 <a href="http://www.iocoder.cn/Spring-Boot/battcn/v2-orm-jpa/">《一起来学 SpringBoot 2.x | 第六篇：整合 Spring Data JPA》</a> 。 </p>
</blockquote>
<p>当然，我们可以再来看一道 <a href="https://www.cnblogs.com/xiaoheike/p/5150553.html">《JPA 规范与 ORM 框架之间的关系是怎样的呢？》</a> 。这个问题，我倒是问过面试的候选人，哈哈哈哈。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>整理 Spring 面试题的过程中，又把 Spring 的知识点又复习了一遍。我突然有点想念，那本被我翻烂的 <a href="https://book.douban.com/subject/26767354/">《Spring 实战》</a> 。😈 我要买一本原版的！！！</p>
<p>参考与推荐如下文章：</p>
<ul>
<li>Java 架构 <a href="https://yq.aliyun.com/articles/669702">《Spring 面试题》</a></li>
<li>永顺 <a href="https://segmentfault.com/a/1190000007469968">《彻底征服 Spring AOP 之理论篇》</a></li>
<li>陌上桑花开花 <a href="https://blog.csdn.net/u014079773/article/details/52453002">《Java 面试题集（七）– Spring常见面试问题》</a></li>
<li>一人浅醉 <a href="https://www.cnblogs.com/yepei/p/4716112.html">《Spring 的 @Transactional 注解详细用法》</a></li>
<li>dalaoyang <a href="https://juejin.im/post/5b065000f265da0de45235e6">《Spring 面试题》</a></li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
